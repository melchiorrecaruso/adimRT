{
  ADimRT library built on 17-10-24.

  Number of base units: 160
  Number of factored units: 69
  Number of operators: 0 (0 external, 0 internal)
}

unit ADimRT;

{$H+}{$J-}
{$modeswitch typehelpers}
{$modeswitch advancedrecords}
{$WARN 5024 OFF} // Suppress warning for unused routine parameter.
{$WARN 5033 OFF} // Suppress warning for unassigned function's return value.
{$MACRO ON}

interface

uses
  DateUtils, Sysutils;

type
  { Prefix }

  TPrefix = (pQuetta, pRonna, pYotta, pZetta, pExa, pPeta, pTera, pGiga, pMega, pKilo, pHecto, pDeca,
    pNone, pDeci, pCenti, pMilli, pMicro, pNano, pPico, pFemto, pAtto, pZepto, pYocto, pRonto, pQuecto);

  { Prefixes }

  TPrefixes = array of TPrefix;

  { Exponents }

  TExponents = array of longint;

type
{ TQuantity }

  {$IFOPT D+}
  TQuantity = record
  private
    FUnitOfMeasurement: longint;
    FValue: double;
  public
    class operator + (const ASelf: TQuantity): TQuantity;
    class operator - (const ASelf: TQuantity): TQuantity;
    class operator + (const ALeft, ARight: TQuantity): TQuantity;
    class operator - (const ALeft, ARight: TQuantity): TQuantity;
    class operator * (const ALeft, ARight: TQuantity): TQuantity;
    class operator / (const ALeft, ARight: TQuantity): TQuantity;
    class operator * (const ALeft: double; const ARight: TQuantity): TQuantity;
    class operator / (const ALeft: double; const ARight: TQuantity): TQuantity;
    class operator * (const ALeft: TQuantity; const ARight: double): TQuantity;
    class operator / (const ALeft: TQuantity; const ARight: double): TQuantity;

    class operator = (const ALeft, ARight: TQuantity): boolean;
    class operator < (const ALeft, ARight: TQuantity): boolean;
    class operator > (const ALeft, ARight: TQuantity): boolean;
    class operator <=(const ALeft, ARight: TQuantity): boolean;
    class operator >=(const ALeft, ARight: TQuantity): boolean;
    class operator <>(const ALeft, ARight: TQuantity): boolean;
    class operator :=(const ASelf: double): TQuantity;
    class operator :=(const ASelf: TQuantity): double;
  end;
  {$ELSE}
  TQuantity = double;
  {$ENDIF}

{ TUnit }

  generic TUnit<U> = record
    type TSelf = specialize TUnit<U>;
  public
    function ToFloat(const AQuantity: TQuantity): double;
    function ToFloat(const AQuantity; const APrefixes: TPrefixes): double;
    function ToString(const AQuantity: TQuantity): string;
    function ToString(const AQuantity: TQuantity; const APrefixes: TPrefixes): string;
    function ToString(const AQuantity: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
    function ToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
    function ToVerboseString(const AQuantity: TQuantity): string;
    function ToVerboseString(const AQuantity: TQuantity; const APrefixes: TPrefixes): string;
    function ToVerboseString(const AQuantity: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
    function ToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
    class operator *(const AValue: double; const ASelf: TSelf): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TSelf): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TSelf): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TSelf): TQuantity; inline;
  {$ENDIF}
  end;

{ TFactoredUnit }

  generic TFactoredUnit<U> = record
    type TSelf = specialize TFactoredUnit<U>;
  public
    function ToFloat(const AQuantity: TQuantity): double;
    function ToFloat(const AQuantity; const APrefixes: TPrefixes): double;
    function ToString(const AQuantity: TQuantity): string;
    function ToString(const AQuantity: TQuantity; const APrefixes: TPrefixes): string;
    function ToString(const AQuantity: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
    function ToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
    function ToVerboseString(const AQuantity: TQuantity): string;
    function ToVerboseString(const AQuantity: TQuantity; const APrefixes: TPrefixes): string;
    function ToVerboseString(const AQuantity: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
    function ToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
    class operator *(const AValue: double; const ASelf: TSelf): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TSelf): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TSelf): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TSelf): TQuantity; inline;
  {$ENDIF}
  end;

type
  { TScalar }

  TScalar = record
    const FUnitOfMeasurement = 0;
    const FSymbol            = '';
    const FName              = '';
    const FPluralName        = '';
    const FPrefixes          : TPrefixes  = ();
    const FExponents         : TExponents = ();
  end;
  TScalarUnit = specialize TUnit<TScalar>;

type
  { TRadian }

  TRadian = record
    const FUnitOfMeasurement = 0;
    const FSymbol            = 'rad';
    const FName              = 'radian';
    const FPluralName        = 'radians';
    const FPrefixes          : TPrefixes  = ();
    const FExponents         : TExponents = ();
  end;
  TRadianUnit = specialize TUnit<TRadian>;

var
  rad        : TRadianUnit;

type
  { TDegree }

  TDegree = record
    const FUnitOfMeasurement = 0;
    const FSymbol            = 'deg';
    const FName              = 'degree';
    const FPluralName        = 'degrees';
    const FPrefixes          : TPrefixes  = ();
    const FExponents         : TExponents = ();
    const FFactor = Pi/180;
  end;
  TDegreeUnit = specialize TUnit<TDegree>;

const
  deg        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 0; FValue: Pi/180); {$ELSE} (Pi/180); {$ENDIF}

type
  { TSteradian }

  TSteradian = record
    const FUnitOfMeasurement = 0;
    const FSymbol            = 'sr';
    const FName              = 'steradian';
    const FPluralName        = 'steradians';
    const FPrefixes          : TPrefixes  = ();
    const FExponents         : TExponents = ();
  end;
  TSteradianUnit = specialize TUnit<TSteradian>;

var
  sr         : TSteradianUnit;

type
  { TSquareDegree }

  TSquareDegree = record
    const FUnitOfMeasurement = 0;
    const FSymbol            = 'deg2';
    const FName              = 'square degree';
    const FPluralName        = 'square degrees';
    const FPrefixes          : TPrefixes  = ();
    const FExponents         : TExponents = ();
    const FFactor = Pi*Pi/32400;
  end;
  TSquareDegreeUnit = specialize TUnit<TSquareDegree>;

const
  deg2       : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 0; FValue: Pi*Pi/32400); {$ELSE} (Pi*Pi/32400); {$ENDIF}

type
  { TSecond }

  TSecond = record
    const FUnitOfMeasurement = 1;
    const FSymbol            = '%ss';
    const FName              = '%ssecond';
    const FPluralName        = '%sseconds';
    const FPrefixes          : TPrefixes  = (pNone);
    const FExponents         : TExponents = (1);
  end;
  TSecondUnit = specialize TUnit<TSecond>;

var
  s          : TSecondUnit;

const
  ds         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 1; FValue: 1E-01); {$ELSE} (1E-01); {$ENDIF}
  cs         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 1; FValue: 1E-02); {$ELSE} (1E-02); {$ENDIF}
  ms         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 1; FValue: 1E-03); {$ELSE} (1E-03); {$ENDIF}
  mis        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 1; FValue: 1E-06); {$ELSE} (1E-06); {$ENDIF}
  ns         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 1; FValue: 1E-09); {$ELSE} (1E-09); {$ENDIF}
  ps         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 1; FValue: 1E-12); {$ELSE} (1E-12); {$ENDIF}

type
  { TDay }

  TDay = record
    const FUnitOfMeasurement = 0;
    const FSymbol            = 'd';
    const FName              = 'day';
    const FPluralName        = 'days';
    const FPrefixes          : TPrefixes  = ();
    const FExponents         : TExponents = ();
    const FFactor = 86400;
  end;
  TDayUnit = specialize TUnit<TDay>;

const
  day        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 0; FValue: 86400); {$ELSE} (86400); {$ENDIF}

type
  { THour }

  THour = record
    const FUnitOfMeasurement = 0;
    const FSymbol            = 'h';
    const FName              = 'hour';
    const FPluralName        = 'hours';
    const FPrefixes          : TPrefixes  = ();
    const FExponents         : TExponents = ();
    const FFactor = 3600;
  end;
  THourUnit = specialize TUnit<THour>;

const
  hr         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 0; FValue: 3600); {$ELSE} (3600); {$ENDIF}

type
  { TMinute }

  TMinute = record
    const FUnitOfMeasurement = 0;
    const FSymbol            = 'min';
    const FName              = 'minute';
    const FPluralName        = 'minutes';
    const FPrefixes          : TPrefixes  = ();
    const FExponents         : TExponents = ();
    const FFactor = 60;
  end;
  TMinuteUnit = specialize TUnit<TMinute>;

const
  minute     : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 0; FValue: 60); {$ELSE} (60); {$ENDIF}

type
  { TSquareSecond }

  TSquareSecond = record
    const FUnitOfMeasurement = 2;
    const FSymbol            = '%ss2';
    const FName              = 'square %ssecond';
    const FPluralName        = 'square %sseconds';
    const FPrefixes          : TPrefixes  = (pNone);
    const FExponents         : TExponents = (2);
  end;
  TSquareSecondUnit = specialize TUnit<TSquareSecond>;

var
  s2         : TSquareSecondUnit;

const
  ds2        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 2; FValue: 1E-02); {$ELSE} (1E-02); {$ENDIF}
  cs2        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 2; FValue: 1E-04); {$ELSE} (1E-04); {$ENDIF}
  ms2        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 2; FValue: 1E-06); {$ELSE} (1E-06); {$ENDIF}
  mis2       : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 2; FValue: 1E-12); {$ELSE} (1E-12); {$ENDIF}
  ns2        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 2; FValue: 1E-18); {$ELSE} (1E-18); {$ENDIF}
  ps2        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 2; FValue: 1E-24); {$ELSE} (1E-24); {$ENDIF}

type
  { TSquareDay }

  TSquareDay = record
    const FUnitOfMeasurement = 0;
    const FSymbol            = 'd2';
    const FName              = 'square day';
    const FPluralName        = 'square days';
    const FPrefixes          : TPrefixes  = ();
    const FExponents         : TExponents = ();
    const FFactor = 7464960000;
  end;
  TSquareDayUnit = specialize TUnit<TSquareDay>;

const
  day2       : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 0; FValue: 7464960000); {$ELSE} (7464960000); {$ENDIF}

type
  { TSquareHour }

  TSquareHour = record
    const FUnitOfMeasurement = 0;
    const FSymbol            = 'h2';
    const FName              = 'square hour';
    const FPluralName        = 'square hours';
    const FPrefixes          : TPrefixes  = ();
    const FExponents         : TExponents = ();
    const FFactor = 12960000;
  end;
  TSquareHourUnit = specialize TUnit<TSquareHour>;

const
  hr2        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 0; FValue: 12960000); {$ELSE} (12960000); {$ENDIF}

type
  { TSquareMinute }

  TSquareMinute = record
    const FUnitOfMeasurement = 0;
    const FSymbol            = 'min2';
    const FName              = 'square minute';
    const FPluralName        = 'square minutes';
    const FPrefixes          : TPrefixes  = ();
    const FExponents         : TExponents = ();
    const FFactor = 3600;
  end;
  TSquareMinuteUnit = specialize TUnit<TSquareMinute>;

const
  minute2    : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 0; FValue: 3600); {$ELSE} (3600); {$ENDIF}

type
  { TCubicSecond }

  TCubicSecond = record
    const FUnitOfMeasurement = 3;
    const FSymbol            = '%ss3';
    const FName              = 'cubic %ssecond';
    const FPluralName        = 'cubic %sseconds';
    const FPrefixes          : TPrefixes  = (pNone);
    const FExponents         : TExponents = (3);
  end;
  TCubicSecondUnit = specialize TUnit<TCubicSecond>;

var
  s3         : TCubicSecondUnit;

const
  ds3        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 3; FValue: 1E-03); {$ELSE} (1E-03); {$ENDIF}
  cs3        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 3; FValue: 1E-06); {$ELSE} (1E-06); {$ENDIF}
  ms3        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 3; FValue: 1E-09); {$ELSE} (1E-09); {$ENDIF}
  mis3       : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 3; FValue: 1E-18); {$ELSE} (1E-18); {$ENDIF}
  ns3        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 3; FValue: 1E-27); {$ELSE} (1E-27); {$ENDIF}
  ps3        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 3; FValue: 1E-36); {$ELSE} (1E-36); {$ENDIF}

type
  { TQuarticSecond }

  TQuarticSecond = record
    const FUnitOfMeasurement = 4;
    const FSymbol            = '%ss4';
    const FName              = 'quartic %ssecond';
    const FPluralName        = 'quartic %sseconds';
    const FPrefixes          : TPrefixes  = (pNone);
    const FExponents         : TExponents = (4);
  end;
  TQuarticSecondUnit = specialize TUnit<TQuarticSecond>;

var
  s4         : TQuarticSecondUnit;

const
  ds4        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 4; FValue: 1E-04); {$ELSE} (1E-04); {$ENDIF}
  cs4        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 4; FValue: 1E-08); {$ELSE} (1E-08); {$ENDIF}
  ms4        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 4; FValue: 1E-12); {$ELSE} (1E-12); {$ENDIF}
  mis4       : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 4; FValue: 1E-24); {$ELSE} (1E-24); {$ENDIF}
  ns4        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 4; FValue: 1E-36); {$ELSE} (1E-36); {$ENDIF}
  ps4        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 4; FValue: 1E-48); {$ELSE} (1E-48); {$ENDIF}

type
  { TQuinticSecond }

  TQuinticSecond = record
    const FUnitOfMeasurement = 5;
    const FSymbol            = '%ss5';
    const FName              = 'quintic %ssecond';
    const FPluralName        = 'quintic %sseconds';
    const FPrefixes          : TPrefixes  = (pNone);
    const FExponents         : TExponents = (5);
  end;
  TQuinticSecondUnit = specialize TUnit<TQuinticSecond>;

var
  s5         : TQuinticSecondUnit;

const
  ds5        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 5; FValue: 1E-05); {$ELSE} (1E-05); {$ENDIF}
  cs5        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 5; FValue: 1E-10); {$ELSE} (1E-10); {$ENDIF}
  ms5        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 5; FValue: 1E-15); {$ELSE} (1E-15); {$ENDIF}
  mis5       : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 5; FValue: 1E-30); {$ELSE} (1E-30); {$ENDIF}
  ns5        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 5; FValue: 1E-45); {$ELSE} (1E-45); {$ENDIF}
  ps5        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 5; FValue: 1E-60); {$ELSE} (1E-60); {$ENDIF}

type
  { TSexticSecond }

  TSexticSecond = record
    const FUnitOfMeasurement = 6;
    const FSymbol            = '%ss6';
    const FName              = 'sextic %ssecond';
    const FPluralName        = 'sextic %sseconds';
    const FPrefixes          : TPrefixes  = (pNone);
    const FExponents         : TExponents = (6);
  end;
  TSexticSecondUnit = specialize TUnit<TSexticSecond>;

var
  s6         : TSexticSecondUnit;

const
  ds6        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 6; FValue: 1E-06); {$ELSE} (1E-06); {$ENDIF}
  cs6        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 6; FValue: 1E-12); {$ELSE} (1E-12); {$ENDIF}
  ms6        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 6; FValue: 1E-18); {$ELSE} (1E-18); {$ENDIF}
  mis6       : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 6; FValue: 1E-36); {$ELSE} (1E-36); {$ENDIF}
  ns6        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 6; FValue: 1E-54); {$ELSE} (1E-54); {$ENDIF}
  ps6        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 6; FValue: 1E-72); {$ELSE} (1E-72); {$ENDIF}

type
  { TMeter }

  TMeter = record
    const FUnitOfMeasurement = 7;
    const FSymbol            = '%sm';
    const FName              = '%smeter';
    const FPluralName        = '%smeters';
    const FPrefixes          : TPrefixes  = (pNone);
    const FExponents         : TExponents = (1);
  end;
  TMeterUnit = specialize TUnit<TMeter>;

var
  m          : TMeterUnit;

const
  km         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 7; FValue: 1E+03); {$ELSE} (1E+03); {$ENDIF}
  dm         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 7; FValue: 1E-01); {$ELSE} (1E-01); {$ENDIF}
  cm         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 7; FValue: 1E-02); {$ELSE} (1E-02); {$ENDIF}
  mm         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 7; FValue: 1E-03); {$ELSE} (1E-03); {$ENDIF}
  mim        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 7; FValue: 1E-06); {$ELSE} (1E-06); {$ENDIF}
  nm         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 7; FValue: 1E-09); {$ELSE} (1E-09); {$ENDIF}
  pm         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 7; FValue: 1E-12); {$ELSE} (1E-12); {$ENDIF}

type
  { TAstronomical }

  TAstronomical = record
    const FUnitOfMeasurement = 0;
    const FSymbol            = 'au';
    const FName              = 'astronomical unit';
    const FPluralName        = 'astronomical units';
    const FPrefixes          : TPrefixes  = ();
    const FExponents         : TExponents = ();
    const FFactor = 149597870691;
  end;
  TAstronomicalUnit = specialize TUnit<TAstronomical>;

const
  au         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 0; FValue: 149597870691); {$ELSE} (149597870691); {$ENDIF}

type
  { TInch }

  TInch = record
    const FUnitOfMeasurement = 0;
    const FSymbol            = 'in';
    const FName              = 'inch';
    const FPluralName        = 'inches';
    const FPrefixes          : TPrefixes  = ();
    const FExponents         : TExponents = ();
    const FFactor = 0.0254;
  end;
  TInchUnit = specialize TUnit<TInch>;

const
  inch       : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 0; FValue: 0.0254); {$ELSE} (0.0254); {$ENDIF}

type
  { TFoot }

  TFoot = record
    const FUnitOfMeasurement = 0;
    const FSymbol            = 'ft';
    const FName              = 'foot';
    const FPluralName        = 'feet';
    const FPrefixes          : TPrefixes  = ();
    const FExponents         : TExponents = ();
    const FFactor = 0.3048;
  end;
  TFootUnit = specialize TUnit<TFoot>;

const
  ft         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 0; FValue: 0.3048); {$ELSE} (0.3048); {$ENDIF}

type
  { TYard }

  TYard = record
    const FUnitOfMeasurement = 0;
    const FSymbol            = 'yd';
    const FName              = 'yard';
    const FPluralName        = 'yards';
    const FPrefixes          : TPrefixes  = ();
    const FExponents         : TExponents = ();
    const FFactor = 0.9144;
  end;
  TYardUnit = specialize TUnit<TYard>;

const
  yd         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 0; FValue: 0.9144); {$ELSE} (0.9144); {$ENDIF}

type
  { TMile }

  TMile = record
    const FUnitOfMeasurement = 0;
    const FSymbol            = 'mi';
    const FName              = 'mile';
    const FPluralName        = 'miles';
    const FPrefixes          : TPrefixes  = ();
    const FExponents         : TExponents = ();
    const FFactor = 1609.344;
  end;
  TMileUnit = specialize TUnit<TMile>;

const
  mi         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 0; FValue: 1609.344); {$ELSE} (1609.344); {$ENDIF}

type
  { TNauticalMile }

  TNauticalMile = record
    const FUnitOfMeasurement = 0;
    const FSymbol            = 'nmi';
    const FName              = 'nautical mile';
    const FPluralName        = 'nautical miles';
    const FPrefixes          : TPrefixes  = ();
    const FExponents         : TExponents = ();
    const FFactor = 1852;
  end;
  TNauticalMileUnit = specialize TUnit<TNauticalMile>;

const
  nmi        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 0; FValue: 1852); {$ELSE} (1852); {$ENDIF}

type
  { TAngstrom }

  TAngstrom = record
    const FUnitOfMeasurement = 0;
    const FSymbol            = '%sÅ';
    const FName              = '%sangstrom';
    const FPluralName        = '%sangstroms';
    const FPrefixes          : TPrefixes  = (pNone);
    const FExponents         : TExponents = (1);
    const FFactor = 1E-10;
  end;
  TAngstromUnit = specialize TUnit<TAngstrom>;

const
  angstrom   : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 0; FValue: 1E-10); {$ELSE} (1E-10); {$ENDIF}

type
  { TSquareRootMeter }

  TSquareRootMeter = record
    const FUnitOfMeasurement = 8;
    const FSymbol            = '√%sm';
    const FName              = 'square root %smeter';
    const FPluralName        = 'square root %smeters';
    const FPrefixes          : TPrefixes  = (pNone);
    const FExponents         : TExponents = (1);
  end;
  TSquareRootMeterUnit = specialize TUnit<TSquareRootMeter>;

type
  { TSquareMeter }

  TSquareMeter = record
    const FUnitOfMeasurement = 9;
    const FSymbol            = '%sm2';
    const FName              = 'square %smeter';
    const FPluralName        = 'square %smeters';
    const FPrefixes          : TPrefixes  = (pNone);
    const FExponents         : TExponents = (2);
  end;
  TSquareMeterUnit = specialize TUnit<TSquareMeter>;

var
  m2         : TSquareMeterUnit;

const
  km2        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 9; FValue: 1E+06); {$ELSE} (1E+06); {$ENDIF}
  dm2        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 9; FValue: 1E-02); {$ELSE} (1E-02); {$ENDIF}
  cm2        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 9; FValue: 1E-04); {$ELSE} (1E-04); {$ENDIF}
  mm2        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 9; FValue: 1E-06); {$ELSE} (1E-06); {$ENDIF}
  mim2       : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 9; FValue: 1E-12); {$ELSE} (1E-12); {$ENDIF}
  nm2        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 9; FValue: 1E-18); {$ELSE} (1E-18); {$ENDIF}
  pm2        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 9; FValue: 1E-24); {$ELSE} (1E-24); {$ENDIF}

type
  { TSquareInch }

  TSquareInch = record
    const FUnitOfMeasurement = 0;
    const FSymbol            = 'in2';
    const FName              = 'square inch';
    const FPluralName        = 'square inches';
    const FPrefixes          : TPrefixes  = ();
    const FExponents         : TExponents = ();
    const FFactor = 0.00064516;
  end;
  TSquareInchUnit = specialize TUnit<TSquareInch>;

const
  inch2      : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 0; FValue: 0.00064516); {$ELSE} (0.00064516); {$ENDIF}

type
  { TSquareFoot }

  TSquareFoot = record
    const FUnitOfMeasurement = 0;
    const FSymbol            = 'ft2';
    const FName              = 'square foot';
    const FPluralName        = 'square feet';
    const FPrefixes          : TPrefixes  = ();
    const FExponents         : TExponents = ();
    const FFactor = 0.09290304;
  end;
  TSquareFootUnit = specialize TUnit<TSquareFoot>;

const
  ft2        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 0; FValue: 0.09290304); {$ELSE} (0.09290304); {$ENDIF}

type
  { TSquareYard }

  TSquareYard = record
    const FUnitOfMeasurement = 0;
    const FSymbol            = 'yd2';
    const FName              = 'square yard';
    const FPluralName        = 'square yards';
    const FPrefixes          : TPrefixes  = ();
    const FExponents         : TExponents = ();
    const FFactor = 0.83612736;
  end;
  TSquareYardUnit = specialize TUnit<TSquareYard>;

const
  yd2        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 0; FValue: 0.83612736); {$ELSE} (0.83612736); {$ENDIF}

type
  { TSquareMile }

  TSquareMile = record
    const FUnitOfMeasurement = 0;
    const FSymbol            = 'mi2';
    const FName              = 'square mile';
    const FPluralName        = 'square miles';
    const FPrefixes          : TPrefixes  = ();
    const FExponents         : TExponents = ();
    const FFactor = 2589988.110336;
  end;
  TSquareMileUnit = specialize TUnit<TSquareMile>;

const
  mi2        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 0; FValue: 2589988.110336); {$ELSE} (2589988.110336); {$ENDIF}

type
  { TCubicMeter }

  TCubicMeter = record
    const FUnitOfMeasurement = 10;
    const FSymbol            = '%sm3';
    const FName              = 'cubic %smeter';
    const FPluralName        = 'cubic %smeters';
    const FPrefixes          : TPrefixes  = (pNone);
    const FExponents         : TExponents = (3);
  end;
  TCubicMeterUnit = specialize TUnit<TCubicMeter>;

var
  m3         : TCubicMeterUnit;

const
  km3        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 10; FValue: 1E+09); {$ELSE} (1E+09); {$ENDIF}
  dm3        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 10; FValue: 1E-03); {$ELSE} (1E-03); {$ENDIF}
  cm3        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 10; FValue: 1E-06); {$ELSE} (1E-06); {$ENDIF}
  mm3        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 10; FValue: 1E-09); {$ELSE} (1E-09); {$ENDIF}
  mim3       : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 10; FValue: 1E-18); {$ELSE} (1E-18); {$ENDIF}
  nm3        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 10; FValue: 1E-27); {$ELSE} (1E-27); {$ENDIF}
  pm3        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 10; FValue: 1E-36); {$ELSE} (1E-36); {$ENDIF}

type
  { TCubicInch }

  TCubicInch = record
    const FUnitOfMeasurement = 0;
    const FSymbol            = 'in3';
    const FName              = 'cubic inch';
    const FPluralName        = 'cubic inches';
    const FPrefixes          : TPrefixes  = ();
    const FExponents         : TExponents = ();
    const FFactor = 0.000016387064;
  end;
  TCubicInchUnit = specialize TUnit<TCubicInch>;

const
  inch3      : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 0; FValue: 0.000016387064); {$ELSE} (0.000016387064); {$ENDIF}

type
  { TCubicFoot }

  TCubicFoot = record
    const FUnitOfMeasurement = 0;
    const FSymbol            = 'ft3';
    const FName              = 'cubic foot';
    const FPluralName        = 'cubic feet';
    const FPrefixes          : TPrefixes  = ();
    const FExponents         : TExponents = ();
    const FFactor = 0.028316846592;
  end;
  TCubicFootUnit = specialize TUnit<TCubicFoot>;

const
  ft3        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 0; FValue: 0.028316846592); {$ELSE} (0.028316846592); {$ENDIF}

type
  { TCubicYard }

  TCubicYard = record
    const FUnitOfMeasurement = 0;
    const FSymbol            = 'yd3';
    const FName              = 'cubic yard';
    const FPluralName        = 'cubic yards';
    const FPrefixes          : TPrefixes  = ();
    const FExponents         : TExponents = ();
    const FFactor = 0.764554857984;
  end;
  TCubicYardUnit = specialize TUnit<TCubicYard>;

const
  yd3        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 0; FValue: 0.764554857984); {$ELSE} (0.764554857984); {$ENDIF}

type
  { TLitre }

  TLitre = record
    const FUnitOfMeasurement = 0;
    const FSymbol            = '%sL';
    const FName              = '%slitre';
    const FPluralName        = '%slitres';
    const FPrefixes          : TPrefixes  = (pNone);
    const FExponents         : TExponents = (1);
    const FFactor = 1E-03;
  end;
  TLitreUnit = specialize TUnit<TLitre>;

const
  L          : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 0; FValue: 1E-03); {$ELSE} (1E-03); {$ENDIF}

const
  dL         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 0; FValue: 1E-03 * 1E-01); {$ELSE} (1E-03 * 1E-01); {$ENDIF}
  cL         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 0; FValue: 1E-03 * 1E-02); {$ELSE} (1E-03 * 1E-02); {$ENDIF}
  mL         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 0; FValue: 1E-03 * 1E-03); {$ELSE} (1E-03 * 1E-03); {$ENDIF}

type
  { TGallon }

  TGallon = record
    const FUnitOfMeasurement = 0;
    const FSymbol            = 'gal';
    const FName              = 'gallon';
    const FPluralName        = 'gallons';
    const FPrefixes          : TPrefixes  = ();
    const FExponents         : TExponents = ();
    const FFactor = 0.0037854119678;
  end;
  TGallonUnit = specialize TUnit<TGallon>;

const
  gal        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 0; FValue: 0.0037854119678); {$ELSE} (0.0037854119678); {$ENDIF}

type
  { TQuarticMeter }

  TQuarticMeter = record
    const FUnitOfMeasurement = 11;
    const FSymbol            = '%sm4';
    const FName              = 'quartic %smeter';
    const FPluralName        = 'quartic %smeters';
    const FPrefixes          : TPrefixes  = (pNone);
    const FExponents         : TExponents = (4);
  end;
  TQuarticMeterUnit = specialize TUnit<TQuarticMeter>;

var
  m4         : TQuarticMeterUnit;

const
  km4        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 11; FValue: 1E+12); {$ELSE} (1E+12); {$ENDIF}
  dm4        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 11; FValue: 1E-04); {$ELSE} (1E-04); {$ENDIF}
  cm4        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 11; FValue: 1E-08); {$ELSE} (1E-08); {$ENDIF}
  mm4        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 11; FValue: 1E-12); {$ELSE} (1E-12); {$ENDIF}
  mim4       : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 11; FValue: 1E-24); {$ELSE} (1E-24); {$ENDIF}
  nm4        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 11; FValue: 1E-36); {$ELSE} (1E-36); {$ENDIF}
  pm4        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 11; FValue: 1E-48); {$ELSE} (1E-48); {$ENDIF}

type
  { TQuinticMeter }

  TQuinticMeter = record
    const FUnitOfMeasurement = 12;
    const FSymbol            = '%sm5';
    const FName              = 'quintic %smeter';
    const FPluralName        = 'quintic %smeters';
    const FPrefixes          : TPrefixes  = (pNone);
    const FExponents         : TExponents = (5);
  end;
  TQuinticMeterUnit = specialize TUnit<TQuinticMeter>;

var
  m5         : TQuinticMeterUnit;

const
  km5        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 12; FValue: 1E+15); {$ELSE} (1E+15); {$ENDIF}
  dm5        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 12; FValue: 1E-05); {$ELSE} (1E-05); {$ENDIF}
  cm5        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 12; FValue: 1E-10); {$ELSE} (1E-10); {$ENDIF}
  mm5        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 12; FValue: 1E-15); {$ELSE} (1E-15); {$ENDIF}
  mim5       : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 12; FValue: 1E-30); {$ELSE} (1E-30); {$ENDIF}
  nm5        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 12; FValue: 1E-45); {$ELSE} (1E-45); {$ENDIF}
  pm5        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 12; FValue: 1E-60); {$ELSE} (1E-60); {$ENDIF}

type
  { TSexticMeter }

  TSexticMeter = record
    const FUnitOfMeasurement = 13;
    const FSymbol            = '%sm6';
    const FName              = 'sextic %smeter';
    const FPluralName        = 'sextic %smeters';
    const FPrefixes          : TPrefixes  = (pNone);
    const FExponents         : TExponents = (6);
  end;
  TSexticMeterUnit = specialize TUnit<TSexticMeter>;

var
  m6         : TSexticMeterUnit;

const
  km6        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 13; FValue: 1E+18); {$ELSE} (1E+18); {$ENDIF}
  dm6        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 13; FValue: 1E-06); {$ELSE} (1E-06); {$ENDIF}
  cm6        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 13; FValue: 1E-12); {$ELSE} (1E-12); {$ENDIF}
  mm6        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 13; FValue: 1E-18); {$ELSE} (1E-18); {$ENDIF}
  mim6       : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 13; FValue: 1E-36); {$ELSE} (1E-36); {$ENDIF}
  nm6        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 13; FValue: 1E-54); {$ELSE} (1E-54); {$ENDIF}
  pm6        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 13; FValue: 1E-72); {$ELSE} (1E-72); {$ENDIF}

type
  { TKilogram }

  TKilogram = record
    const FUnitOfMeasurement = 14;
    const FSymbol            = '%sg';
    const FName              = '%sgram';
    const FPluralName        = '%sgrams';
    const FPrefixes          : TPrefixes  = (pKilo);
    const FExponents         : TExponents = (1);
  end;
  TKilogramUnit = specialize TUnit<TKilogram>;

var
  kg         : TKilogramUnit;

const
  hg         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 14; FValue: 1E-01); {$ELSE} (1E-01); {$ENDIF}
  dag        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 14; FValue: 1E-02); {$ELSE} (1E-02); {$ENDIF}
  g          : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 14; FValue: 1E-03); {$ELSE} (1E-03); {$ENDIF}
  dg         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 14; FValue: 1E-04); {$ELSE} (1E-04); {$ENDIF}
  cg         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 14; FValue: 1E-05); {$ELSE} (1E-05); {$ENDIF}
  mg         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 14; FValue: 1E-06); {$ELSE} (1E-06); {$ENDIF}
  mig        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 14; FValue: 1E-09); {$ELSE} (1E-09); {$ENDIF}
  ng         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 14; FValue: 1E-12); {$ELSE} (1E-12); {$ENDIF}
  pg         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 14; FValue: 1E-15); {$ELSE} (1E-15); {$ENDIF}

type
  { TTonne }

  TTonne = record
    const FUnitOfMeasurement = 0;
    const FSymbol            = '%st';
    const FName              = '%stonne';
    const FPluralName        = '%stonnes';
    const FPrefixes          : TPrefixes  = (pNone);
    const FExponents         : TExponents = (1);
    const FFactor = 1E+03;
  end;
  TTonneUnit = specialize TUnit<TTonne>;

const
  tonne      : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 0; FValue: 1E+03); {$ELSE} (1E+03); {$ENDIF}

const
  gigatonne  : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 0; FValue: 1E+03 * 1E+09); {$ELSE} (1E+03 * 1E+09); {$ENDIF}
  megatonne  : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 0; FValue: 1E+03 * 1E+06); {$ELSE} (1E+03 * 1E+06); {$ENDIF}
  kilotonne  : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 0; FValue: 1E+03 * 1E+03); {$ELSE} (1E+03 * 1E+03); {$ENDIF}

type
  { TPound }

  TPound = record
    const FUnitOfMeasurement = 0;
    const FSymbol            = 'lb';
    const FName              = 'pound';
    const FPluralName        = 'pounds';
    const FPrefixes          : TPrefixes  = ();
    const FExponents         : TExponents = ();
    const FFactor = 0.45359237;
  end;
  TPoundUnit = specialize TUnit<TPound>;

const
  lb         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 0; FValue: 0.45359237); {$ELSE} (0.45359237); {$ENDIF}

type
  { TOunce }

  TOunce = record
    const FUnitOfMeasurement = 0;
    const FSymbol            = 'oz';
    const FName              = 'ounce';
    const FPluralName        = 'ounces';
    const FPrefixes          : TPrefixes  = ();
    const FExponents         : TExponents = ();
    const FFactor = 0.028349523125;
  end;
  TOunceUnit = specialize TUnit<TOunce>;

const
  oz         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 0; FValue: 0.028349523125); {$ELSE} (0.028349523125); {$ENDIF}

type
  { TStone }

  TStone = record
    const FUnitOfMeasurement = 0;
    const FSymbol            = 'st';
    const FName              = 'stone';
    const FPluralName        = 'stones';
    const FPrefixes          : TPrefixes  = ();
    const FExponents         : TExponents = ();
    const FFactor = 6.35029318;
  end;
  TStoneUnit = specialize TUnit<TStone>;

const
  st         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 0; FValue: 6.35029318); {$ELSE} (6.35029318); {$ENDIF}

type
  { TTon }

  TTon = record
    const FUnitOfMeasurement = 0;
    const FSymbol            = 'ton';
    const FName              = 'ton';
    const FPluralName        = 'tons';
    const FPrefixes          : TPrefixes  = ();
    const FExponents         : TExponents = ();
    const FFactor = 907.18474;
  end;
  TTonUnit = specialize TUnit<TTon>;

const
  ton        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 0; FValue: 907.18474); {$ELSE} (907.18474); {$ENDIF}

type
  { TElectronvoltPerSquareSpeedOfLight }

  TElectronvoltPerSquareSpeedOfLight = record
    const FUnitOfMeasurement = 0;
    const FSymbol            = '%seV/c2';
    const FName              = '%selectronvolt per squared speed of light';
    const FPluralName        = '%selectronvolts per squared speed of light';
    const FPrefixes          : TPrefixes  = (pNone);
    const FExponents         : TExponents = (1);
    const FFactor = 1.7826619216279E-36;
  end;
  TElectronvoltPerSquareSpeedOfLightUnit = specialize TUnit<TElectronvoltPerSquareSpeedOfLight>;

type
  { TSquareKilogram }

  TSquareKilogram = record
    const FUnitOfMeasurement = 15;
    const FSymbol            = '%sg2';
    const FName              = 'square %sgram';
    const FPluralName        = 'square %sgrams';
    const FPrefixes          : TPrefixes  = (pKilo);
    const FExponents         : TExponents = (2);
  end;
  TSquareKilogramUnit = specialize TUnit<TSquareKilogram>;

var
  kg2        : TSquareKilogramUnit;

const
  hg2        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 15; FValue: 1E-02); {$ELSE} (1E-02); {$ENDIF}
  dag2       : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 15; FValue: 1E-04); {$ELSE} (1E-04); {$ENDIF}
  g2         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 15; FValue: 1E-06); {$ELSE} (1E-06); {$ENDIF}
  dg2        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 15; FValue: 1E-08); {$ELSE} (1E-08); {$ENDIF}
  cg2        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 15; FValue: 1E-10); {$ELSE} (1E-10); {$ENDIF}
  mg2        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 15; FValue: 1E-12); {$ELSE} (1E-12); {$ENDIF}
  mig2       : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 15; FValue: 1E-18); {$ELSE} (1E-18); {$ENDIF}
  ng2        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 15; FValue: 1E-24); {$ELSE} (1E-24); {$ENDIF}
  pg2        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 15; FValue: 1E-30); {$ELSE} (1E-30); {$ENDIF}

type
  { TAmpere }

  TAmpere = record
    const FUnitOfMeasurement = 16;
    const FSymbol            = '%sA';
    const FName              = '%sampere';
    const FPluralName        = '%samperes';
    const FPrefixes          : TPrefixes  = (pNone);
    const FExponents         : TExponents = (1);
  end;
  TAmpereUnit = specialize TUnit<TAmpere>;

var
  A          : TAmpereUnit;

const
  kA         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 16; FValue: 1E+03); {$ELSE} (1E+03); {$ENDIF}
  hA         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 16; FValue: 1E+02); {$ELSE} (1E+02); {$ENDIF}
  daA        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 16; FValue: 1E+01); {$ELSE} (1E+01); {$ENDIF}
  dA         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 16; FValue: 1E-01); {$ELSE} (1E-01); {$ENDIF}
  cA         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 16; FValue: 1E-02); {$ELSE} (1E-02); {$ENDIF}
  mA         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 16; FValue: 1E-03); {$ELSE} (1E-03); {$ENDIF}
  miA        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 16; FValue: 1E-06); {$ELSE} (1E-06); {$ENDIF}
  nA         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 16; FValue: 1E-09); {$ELSE} (1E-09); {$ENDIF}
  picoA      : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 16; FValue: 1E-12); {$ELSE} (1E-12); {$ENDIF}

type
  { TSquareAmpere }

  TSquareAmpere = record
    const FUnitOfMeasurement = 17;
    const FSymbol            = '%sA2';
    const FName              = 'square %sampere';
    const FPluralName        = 'square %samperes';
    const FPrefixes          : TPrefixes  = (pNone);
    const FExponents         : TExponents = (2);
  end;
  TSquareAmpereUnit = specialize TUnit<TSquareAmpere>;

var
  A2         : TSquareAmpereUnit;

const
  kA2        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 17; FValue: 1E+06); {$ELSE} (1E+06); {$ENDIF}
  hA2        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 17; FValue: 1E+04); {$ELSE} (1E+04); {$ENDIF}
  daA2       : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 17; FValue: 1E+02); {$ELSE} (1E+02); {$ENDIF}
  dA2        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 17; FValue: 1E-02); {$ELSE} (1E-02); {$ENDIF}
  cA2        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 17; FValue: 1E-04); {$ELSE} (1E-04); {$ENDIF}
  mA2        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 17; FValue: 1E-06); {$ELSE} (1E-06); {$ENDIF}
  miA2       : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 17; FValue: 1E-12); {$ELSE} (1E-12); {$ENDIF}
  nA2        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 17; FValue: 1E-18); {$ELSE} (1E-18); {$ENDIF}
  picoA2     : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 17; FValue: 1E-24); {$ELSE} (1E-24); {$ENDIF}

type
  { TKelvin }

  TKelvin = record
    const FUnitOfMeasurement = 18;
    const FSymbol            = '%sK';
    const FName              = '%skelvin';
    const FPluralName        = '%skelvins';
    const FPrefixes          : TPrefixes  = (pNone);
    const FExponents         : TExponents = (1);
  end;
  TKelvinUnit = specialize TUnit<TKelvin>;

var
  K          : TKelvinUnit;

type
  { TSquareKelvin }

  TSquareKelvin = record
    const FUnitOfMeasurement = 19;
    const FSymbol            = '%sK2';
    const FName              = 'square %skelvin';
    const FPluralName        = 'square %skelvins';
    const FPrefixes          : TPrefixes  = (pNone);
    const FExponents         : TExponents = (2);
  end;
  TSquareKelvinUnit = specialize TUnit<TSquareKelvin>;

var
  K2         : TSquareKelvinUnit;

type
  { TCubicKelvin }

  TCubicKelvin = record
    const FUnitOfMeasurement = 20;
    const FSymbol            = '%sK3';
    const FName              = 'cubic %skelvin';
    const FPluralName        = 'cubic %skelvins';
    const FPrefixes          : TPrefixes  = (pNone);
    const FExponents         : TExponents = (3);
  end;
  TCubicKelvinUnit = specialize TUnit<TCubicKelvin>;

var
  K3         : TCubicKelvinUnit;

type
  { TQuarticKelvin }

  TQuarticKelvin = record
    const FUnitOfMeasurement = 21;
    const FSymbol            = '%sK4';
    const FName              = 'quartic %skelvin';
    const FPluralName        = 'quartic %skelvins';
    const FPrefixes          : TPrefixes  = (pNone);
    const FExponents         : TExponents = (4);
  end;
  TQuarticKelvinUnit = specialize TUnit<TQuarticKelvin>;

var
  K4         : TQuarticKelvinUnit;

type
  { TMole }

  TMole = record
    const FUnitOfMeasurement = 22;
    const FSymbol            = '%smol';
    const FName              = '%smole';
    const FPluralName        = '%smoles';
    const FPrefixes          : TPrefixes  = (pNone);
    const FExponents         : TExponents = (1);
  end;
  TMoleUnit = specialize TUnit<TMole>;

var
  mol        : TMoleUnit;

const
  kmol       : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 22; FValue: 1E+03); {$ELSE} (1E+03); {$ENDIF}
  hmol       : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 22; FValue: 1E+02); {$ELSE} (1E+02); {$ENDIF}
  damol      : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 22; FValue: 1E+01); {$ELSE} (1E+01); {$ENDIF}

type
  { TCandela }

  TCandela = record
    const FUnitOfMeasurement = 23;
    const FSymbol            = '%scd';
    const FName              = '%scandela';
    const FPluralName        = '%scandelas';
    const FPrefixes          : TPrefixes  = (pNone);
    const FExponents         : TExponents = (1);
  end;
  TCandelaUnit = specialize TUnit<TCandela>;

var
  cd         : TCandelaUnit;

type
  { THertz }

  THertz = record
    const FUnitOfMeasurement = 24;
    const FSymbol            = '%sHz';
    const FName              = '%shertz';
    const FPluralName        = '%shertz';
    const FPrefixes          : TPrefixes  = (pNone);
    const FExponents         : TExponents = (1);
  end;
  THertzUnit = specialize TUnit<THertz>;

var
  Hz         : THertzUnit;

const
  THz        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 24; FValue: 1E+12); {$ELSE} (1E+12); {$ENDIF}
  GHz        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 24; FValue: 1E+09); {$ELSE} (1E+09); {$ENDIF}
  MHz        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 24; FValue: 1E+06); {$ELSE} (1E+06); {$ENDIF}
  kHz        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 24; FValue: 1E+03); {$ELSE} (1E+03); {$ENDIF}

type
  { TReciprocalSecond }

  TReciprocalSecond = record
    const FUnitOfMeasurement = 24;
    const FSymbol            = '1/%ss';
    const FName              = 'reciprocal %ssecond';
    const FPluralName        = 'reciprocal %sseconds';
    const FPrefixes          : TPrefixes  = (pNone);
    const FExponents         : TExponents = (-1);
  end;
  TReciprocalSecondUnit = specialize TUnit<TReciprocalSecond>;

type
  { TRadianPerSecond }

  TRadianPerSecond = record
    const FUnitOfMeasurement = 24;
    const FSymbol            = 'rad/%ss';
    const FName              = 'radian per %ssecond';
    const FPluralName        = 'radians per %ssecond';
    const FPrefixes          : TPrefixes  = (pNone);
    const FExponents         : TExponents = (-1);
  end;
  TRadianPerSecondUnit = specialize TUnit<TRadianPerSecond>;

type
  { TSquareHertz }

  TSquareHertz = record
    const FUnitOfMeasurement = 25;
    const FSymbol            = '%sHz2';
    const FName              = 'square %shertz';
    const FPluralName        = 'square %shertz';
    const FPrefixes          : TPrefixes  = (pNone);
    const FExponents         : TExponents = (2);
  end;
  TSquareHertzUnit = specialize TUnit<TSquareHertz>;

var
  Hz2        : TSquareHertzUnit;

const
  THz2       : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 25; FValue: 1E+24); {$ELSE} (1E+24); {$ENDIF}
  GHz2       : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 25; FValue: 1E+18); {$ELSE} (1E+18); {$ENDIF}
  MHz2       : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 25; FValue: 1E+12); {$ELSE} (1E+12); {$ENDIF}
  kHz2       : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 25; FValue: 1E+06); {$ELSE} (1E+06); {$ENDIF}

type
  { TReciprocalSquareSecond }

  TReciprocalSquareSecond = record
    const FUnitOfMeasurement = 25;
    const FSymbol            = '1/%ss2';
    const FName              = 'reciprocal square %ssecond';
    const FPluralName        = 'reciprocal square %sseconds';
    const FPrefixes          : TPrefixes  = (pNone);
    const FExponents         : TExponents = (-2);
  end;
  TReciprocalSquareSecondUnit = specialize TUnit<TReciprocalSquareSecond>;

type
  { TRadianPerSquareSecond }

  TRadianPerSquareSecond = record
    const FUnitOfMeasurement = 25;
    const FSymbol            = 'rad/%ss2';
    const FName              = 'radian per square %ssecond';
    const FPluralName        = 'radians per square %ssecond';
    const FPrefixes          : TPrefixes  = (pNone);
    const FExponents         : TExponents = (-2);
  end;
  TRadianPerSquareSecondUnit = specialize TUnit<TRadianPerSquareSecond>;

type
  { TSteradianPerSquareSecond }

  TSteradianPerSquareSecond = record
    const FUnitOfMeasurement = 26;
    const FSymbol            = 'sr/%ss2';
    const FName              = 'steradian per square %ssecond';
    const FPluralName        = 'steradians per square %ssecond';
    const FPrefixes          : TPrefixes  = (pNone);
    const FExponents         : TExponents = (-2);
  end;
  TSteradianPerSquareSecondUnit = specialize TUnit<TSteradianPerSquareSecond>;

type
  { TMeterPerSecond }

  TMeterPerSecond = record
    const FUnitOfMeasurement = 27;
    const FSymbol            = '%sm/%ss';
    const FName              = '%smeter per %ssecond';
    const FPluralName        = '%smeters per %ssecond';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (1, -1);
  end;
  TMeterPerSecondUnit = specialize TUnit<TMeterPerSecond>;

type
  { TMeterPerHour }

  TMeterPerHour = record
    const FUnitOfMeasurement = 0;
    const FSymbol            = '%sm/h';
    const FName              = '%smeter per hour';
    const FPluralName        = '%smeters per hour';
    const FPrefixes          : TPrefixes  = (pNone);
    const FExponents         : TExponents = (1);
    const FFactor = 1/3600;
  end;
  TMeterPerHourUnit = specialize TUnit<TMeterPerHour>;

type
  { TMilePerHour }

  TMilePerHour = record
    const FUnitOfMeasurement = 0;
    const FSymbol            = 'mi/h';
    const FName              = 'mile per hour';
    const FPluralName        = 'miles per hour';
    const FPrefixes          : TPrefixes  = ();
    const FExponents         : TExponents = ();
    const FFactor = 0.44704;
  end;
  TMilePerHourUnit = specialize TUnit<TMilePerHour>;

type
  { TNauticalMilePerHour }

  TNauticalMilePerHour = record
    const FUnitOfMeasurement = 0;
    const FSymbol            = 'nmi/h';
    const FName              = 'nautical mile per hour';
    const FPluralName        = 'nautical miles per hour';
    const FPrefixes          : TPrefixes  = ();
    const FExponents         : TExponents = ();
    const FFactor = 463/900;
  end;
  TNauticalMilePerHourUnit = specialize TUnit<TNauticalMilePerHour>;

type
  { TMeterPerSquareSecond }

  TMeterPerSquareSecond = record
    const FUnitOfMeasurement = 28;
    const FSymbol            = '%sm/%ss2';
    const FName              = '%smeter per %ssecond squared';
    const FPluralName        = '%smeters per %ssecond squared';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (1, -2);
  end;
  TMeterPerSquareSecondUnit = specialize TUnit<TMeterPerSquareSecond>;

type
  { TMeterPerSecondPerSecond }

  TMeterPerSecondPerSecond = record
    const FUnitOfMeasurement = 28;
    const FSymbol            = '%sm/%ss/%ss';
    const FName              = '%smeter per %ssecond per %ssecond';
    const FPluralName        = '%smeters per %ssecond per %ssecond';
    const FPrefixes          : TPrefixes  = (pNone, pNone, pNone);
    const FExponents         : TExponents = (1, -1, -1);
  end;
  TMeterPerSecondPerSecondUnit = specialize TUnit<TMeterPerSecondPerSecond>;

type
  { TMeterPerHourPerSecond }

  TMeterPerHourPerSecond = record
    const FUnitOfMeasurement = 0;
    const FSymbol            = '%sm/h/%ss';
    const FName              = '%smeter per hour per %ssecond';
    const FPluralName        = '%smeters per hour per %ssecond';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (1, -1);
    const FFactor = 1/3600;
  end;
  TMeterPerHourPerSecondUnit = specialize TUnit<TMeterPerHourPerSecond>;

type
  { TMeterPerCubicSecond }

  TMeterPerCubicSecond = record
    const FUnitOfMeasurement = 29;
    const FSymbol            = '%sm/%ss3';
    const FName              = '%smeter per cubic %ssecond';
    const FPluralName        = '%smeters per cubic %ssecond';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (1, -3);
  end;
  TMeterPerCubicSecondUnit = specialize TUnit<TMeterPerCubicSecond>;

type
  { TMeterPerQuarticSecond }

  TMeterPerQuarticSecond = record
    const FUnitOfMeasurement = 30;
    const FSymbol            = '%sm/%ss4';
    const FName              = '%smeter per quartic %ssecond';
    const FPluralName        = '%smeters per quartic %ssecond';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (1, -4);
  end;
  TMeterPerQuarticSecondUnit = specialize TUnit<TMeterPerQuarticSecond>;

type
  { TMeterPerQuinticSecond }

  TMeterPerQuinticSecond = record
    const FUnitOfMeasurement = 31;
    const FSymbol            = '%sm/%ss5';
    const FName              = '%smeter per quintic %ssecond';
    const FPluralName        = '%smeters per quintic %ssecond';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (1, -5);
  end;
  TMeterPerQuinticSecondUnit = specialize TUnit<TMeterPerQuinticSecond>;

type
  { TMeterPerSexticSecond }

  TMeterPerSexticSecond = record
    const FUnitOfMeasurement = 32;
    const FSymbol            = '%sm/%ss6';
    const FName              = '%smeter per sextic %ssecond';
    const FPluralName        = '%smeters per sextic %ssecond';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (1, -6);
  end;
  TMeterPerSexticSecondUnit = specialize TUnit<TMeterPerSexticSecond>;

type
  { TSquareMeterPerSquareSecond }

  TSquareMeterPerSquareSecond = record
    const FUnitOfMeasurement = 33;
    const FSymbol            = '%sm2/%ss2';
    const FName              = 'square %smeter per square %ssecond';
    const FPluralName        = 'square %smeters per square %ssecond';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (2, -2);
  end;
  TSquareMeterPerSquareSecondUnit = specialize TUnit<TSquareMeterPerSquareSecond>;

type
  { TJoulePerKilogram }

  TJoulePerKilogram = record
    const FUnitOfMeasurement = 33;
    const FSymbol            = '%sJ/%sg';
    const FName              = '%sjoule per %sgram';
    const FPluralName        = '%sjoules per %sgram';
    const FPrefixes          : TPrefixes  = (pNone, pKilo);
    const FExponents         : TExponents = (1, -1);
  end;
  TJoulePerKilogramUnit = specialize TUnit<TJoulePerKilogram>;

type
  { TGray }

  TGray = record
    const FUnitOfMeasurement = 33;
    const FSymbol            = '%sGy';
    const FName              = '%sgray';
    const FPluralName        = '%sgrays';
    const FPrefixes          : TPrefixes  = (pNone);
    const FExponents         : TExponents = (1);
  end;
  TGrayUnit = specialize TUnit<TGray>;

var
  Gy         : TGrayUnit;

const
  kGy        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 33; FValue: 1E+03); {$ELSE} (1E+03); {$ENDIF}
  mGy        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 33; FValue: 1E-03); {$ELSE} (1E-03); {$ENDIF}
  miGy       : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 33; FValue: 1E-06); {$ELSE} (1E-06); {$ENDIF}
  nGy        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 33; FValue: 1E-09); {$ELSE} (1E-09); {$ENDIF}

type
  { TSievert }

  TSievert = record
    const FUnitOfMeasurement = 33;
    const FSymbol            = '%sSv';
    const FName              = '%ssievert';
    const FPluralName        = '%ssieverts';
    const FPrefixes          : TPrefixes  = (pNone);
    const FExponents         : TExponents = (1);
  end;
  TSievertUnit = specialize TUnit<TSievert>;

var
  Sv         : TSievertUnit;

const
  kSv        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 33; FValue: 1E+03); {$ELSE} (1E+03); {$ENDIF}
  mSv        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 33; FValue: 1E-03); {$ELSE} (1E-03); {$ENDIF}
  miSv       : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 33; FValue: 1E-06); {$ELSE} (1E-06); {$ENDIF}
  nSv        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 33; FValue: 1E-09); {$ELSE} (1E-09); {$ENDIF}

type
  { TMeterSecond }

  TMeterSecond = record
    const FUnitOfMeasurement = 34;
    const FSymbol            = '%sm.%ss';
    const FName              = '%smeter %ssecond';
    const FPluralName        = '%smeter %sseconds';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (1, 1);
  end;
  TMeterSecondUnit = specialize TUnit<TMeterSecond>;

type
  { TKilogramMeter }

  TKilogramMeter = record
    const FUnitOfMeasurement = 35;
    const FSymbol            = '%sg.%sm';
    const FName              = '%sgram %smeter';
    const FPluralName        = '%sgram %smeters';
    const FPrefixes          : TPrefixes  = (pKilo, pNone);
    const FExponents         : TExponents = (1, 1);
  end;
  TKilogramMeterUnit = specialize TUnit<TKilogramMeter>;

type
  { TKilogramPerSecond }

  TKilogramPerSecond = record
    const FUnitOfMeasurement = 36;
    const FSymbol            = '%sg/%ss';
    const FName              = '%sgram per %ssecond';
    const FPluralName        = '%sgrams per %ssecond';
    const FPrefixes          : TPrefixes  = (pKilo, pNone);
    const FExponents         : TExponents = (1, -1);
  end;
  TKilogramPerSecondUnit = specialize TUnit<TKilogramPerSecond>;

type
  { TJoulePerSquareMeterPerHertz }

  TJoulePerSquareMeterPerHertz = record
    const FUnitOfMeasurement = 36;
    const FSymbol            = '%sJ/%sm2/%sHz';
    const FName              = '%sjoule per square %smeter per %shertz';
    const FPluralName        = '%sjoules per square %smeter per %shertz';
    const FPrefixes          : TPrefixes  = (pNone, pNone, pNone);
    const FExponents         : TExponents = (1, -2, -1);
  end;
  TJoulePerSquareMeterPerHertzUnit = specialize TUnit<TJoulePerSquareMeterPerHertz>;

type
  { TKilogramMeterPerSecond }

  TKilogramMeterPerSecond = record
    const FUnitOfMeasurement = 37;
    const FSymbol            = '%sg.%sm/%ss';
    const FName              = '%sgram %smeter per %ssecond';
    const FPluralName        = '%sgram %smeters per %ssecond';
    const FPrefixes          : TPrefixes  = (pKilo, pNone, pNone);
    const FExponents         : TExponents = (1, 1, -1);
  end;
  TKilogramMeterPerSecondUnit = specialize TUnit<TKilogramMeterPerSecond>;

type
  { TNewtonSecond }

  TNewtonSecond = record
    const FUnitOfMeasurement = 37;
    const FSymbol            = '%sN.%ss';
    const FName              = '%snewton %ssecond';
    const FPluralName        = '%snewton %sseconds';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (1, 1);
  end;
  TNewtonSecondUnit = specialize TUnit<TNewtonSecond>;

type
  { TSquareKilogramSquareMeterPerSquareSecond }

  TSquareKilogramSquareMeterPerSquareSecond = record
    const FUnitOfMeasurement = 38;
    const FSymbol            = '%sg2.%sm2/%ss2';
    const FName              = 'square%sgram square%smeter per square%ssecond';
    const FPluralName        = 'square%sgram square%smeters per square%ssecond';
    const FPrefixes          : TPrefixes  = (pKilo, pNone, pNone);
    const FExponents         : TExponents = (2, 2, -2);
  end;
  TSquareKilogramSquareMeterPerSquareSecondUnit = specialize TUnit<TSquareKilogramSquareMeterPerSquareSecond>;

type
  { TReciprocalSquareRootMeter }

  TReciprocalSquareRootMeter = record
    const FUnitOfMeasurement = 39;
    const FSymbol            = '1/√%sm';
    const FName              = 'reciprocal square root %smeter';
    const FPluralName        = 'reciprocal square root %smeters';
    const FPrefixes          : TPrefixes  = (pNone);
    const FExponents         : TExponents = (-1);
  end;
  TReciprocalSquareRootMeterUnit = specialize TUnit<TReciprocalSquareRootMeter>;

type
  { TReciprocalMeter }

  TReciprocalMeter = record
    const FUnitOfMeasurement = 40;
    const FSymbol            = '1/%sm';
    const FName              = 'reciprocal %smeter';
    const FPluralName        = 'reciprocal %smeters';
    const FPrefixes          : TPrefixes  = (pNone);
    const FExponents         : TExponents = (-1);
  end;
  TReciprocalMeterUnit = specialize TUnit<TReciprocalMeter>;

type
  { TDioptre }

  TDioptre = record
    const FUnitOfMeasurement = 40;
    const FSymbol            = 'dpt';
    const FName              = '%sdioptre';
    const FPluralName        = '%sdioptres';
    const FPrefixes          : TPrefixes  = ();
    const FExponents         : TExponents = ();
  end;
  TDioptreUnit = specialize TUnit<TDioptre>;

type
  { TReciprocalSquareRootCubicMeter }

  TReciprocalSquareRootCubicMeter = record
    const FUnitOfMeasurement = 41;
    const FSymbol            = '1/√%sm3';
    const FName              = 'reciprocal square root cubic %smeter';
    const FPluralName        = 'reciprocal square root cubic %smeters';
    const FPrefixes          : TPrefixes  = (pNone);
    const FExponents         : TExponents = (-3);
  end;
  TReciprocalSquareRootCubicMeterUnit = specialize TUnit<TReciprocalSquareRootCubicMeter>;

type
  { TReciprocalSquareMeter }

  TReciprocalSquareMeter = record
    const FUnitOfMeasurement = 42;
    const FSymbol            = '1/%sm2';
    const FName              = 'reciprocal square %smeter';
    const FPluralName        = 'reciprocal square %smeters';
    const FPrefixes          : TPrefixes  = (pNone);
    const FExponents         : TExponents = (-2);
  end;
  TReciprocalSquareMeterUnit = specialize TUnit<TReciprocalSquareMeter>;

type
  { TReciprocalCubicMeter }

  TReciprocalCubicMeter = record
    const FUnitOfMeasurement = 43;
    const FSymbol            = '1/%sm3';
    const FName              = 'reciprocal cubic %smeter';
    const FPluralName        = 'reciprocal cubic %smeters';
    const FPrefixes          : TPrefixes  = (pNone);
    const FExponents         : TExponents = (-3);
  end;
  TReciprocalCubicMeterUnit = specialize TUnit<TReciprocalCubicMeter>;

type
  { TReciprocalQuarticMeter }

  TReciprocalQuarticMeter = record
    const FUnitOfMeasurement = 44;
    const FSymbol            = '1/%sm4';
    const FName              = 'reciprocal quartic %smeter';
    const FPluralName        = 'reciprocal quartic %smeters';
    const FPrefixes          : TPrefixes  = (pNone);
    const FExponents         : TExponents = (-4);
  end;
  TReciprocalQuarticMeterUnit = specialize TUnit<TReciprocalQuarticMeter>;

type
  { TKilogramSquareMeter }

  TKilogramSquareMeter = record
    const FUnitOfMeasurement = 45;
    const FSymbol            = '%sg.%sm2';
    const FName              = '%sgram square %smeter';
    const FPluralName        = '%sgram square %smeters';
    const FPrefixes          : TPrefixes  = (pKilo, pNone);
    const FExponents         : TExponents = (1, 2);
  end;
  TKilogramSquareMeterUnit = specialize TUnit<TKilogramSquareMeter>;

type
  { TKilogramSquareMeterPerSecond }

  TKilogramSquareMeterPerSecond = record
    const FUnitOfMeasurement = 46;
    const FSymbol            = '%sg.%sm2/%ss';
    const FName              = '%sgram square %smeter per %ssecond';
    const FPluralName        = '%sgram square %smeters per %ssecond';
    const FPrefixes          : TPrefixes  = (pKilo, pNone, pNone);
    const FExponents         : TExponents = (1, 2, -1);
  end;
  TKilogramSquareMeterPerSecondUnit = specialize TUnit<TKilogramSquareMeterPerSecond>;

type
  { TNewtonMeterSecond }

  TNewtonMeterSecond = record
    const FUnitOfMeasurement = 46;
    const FSymbol            = '%sN.%sm.%ss';
    const FName              = '%snewton %smeter %ssecond';
    const FPluralName        = '%snewton %smeter %sseconds';
    const FPrefixes          : TPrefixes  = (pNone, pNone, pNone);
    const FExponents         : TExponents = (1, 1, 1);
  end;
  TNewtonMeterSecondUnit = specialize TUnit<TNewtonMeterSecond>;

type
  { TSecondPerMeter }

  TSecondPerMeter = record
    const FUnitOfMeasurement = 47;
    const FSymbol            = '%ss/%sm';
    const FName              = '%ssecond per %smeter';
    const FPluralName        = '%sseconds per %smeter';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (1, -1);
  end;
  TSecondPerMeterUnit = specialize TUnit<TSecondPerMeter>;

type
  { TKilogramPerMeter }

  TKilogramPerMeter = record
    const FUnitOfMeasurement = 48;
    const FSymbol            = '%sg/%sm';
    const FName              = '%sgram per %smeter';
    const FPluralName        = '%sgrams per %smeter';
    const FPrefixes          : TPrefixes  = (pKilo, pNone);
    const FExponents         : TExponents = (1, -1);
  end;
  TKilogramPerMeterUnit = specialize TUnit<TKilogramPerMeter>;

type
  { TKilogramPerSquareMeter }

  TKilogramPerSquareMeter = record
    const FUnitOfMeasurement = 49;
    const FSymbol            = '%sg/%sm2';
    const FName              = '%sgram per square %smeter';
    const FPluralName        = '%sgrams per square %smeter';
    const FPrefixes          : TPrefixes  = (pKilo, pNone);
    const FExponents         : TExponents = (1, -2);
  end;
  TKilogramPerSquareMeterUnit = specialize TUnit<TKilogramPerSquareMeter>;

type
  { TKilogramPerCubicMeter }

  TKilogramPerCubicMeter = record
    const FUnitOfMeasurement = 50;
    const FSymbol            = '%sg/%sm3';
    const FName              = '%sgram per cubic %smeter';
    const FPluralName        = '%sgrams per cubic %smeter';
    const FPrefixes          : TPrefixes  = (pKilo, pNone);
    const FExponents         : TExponents = (1, -3);
  end;
  TKilogramPerCubicMeterUnit = specialize TUnit<TKilogramPerCubicMeter>;

type
  { TPoundPerCubicInch }

  TPoundPerCubicInch = record
    const FUnitOfMeasurement = 0;
    const FSymbol            = 'lb/in3';
    const FName              = 'pound per cubic inch';
    const FPluralName        = 'pounds per cubic inch';
    const FPrefixes          : TPrefixes  = ();
    const FExponents         : TExponents = ();
    const FFactor = 27679.9047102031;
  end;
  TPoundPerCubicInchUnit = specialize TUnit<TPoundPerCubicInch>;

type
  { TNewton }

  TNewton = record
    const FUnitOfMeasurement = 51;
    const FSymbol            = '%sN';
    const FName              = '%snewton';
    const FPluralName        = '%snewtons';
    const FPrefixes          : TPrefixes  = (pNone);
    const FExponents         : TExponents = (1);
  end;
  TNewtonUnit = specialize TUnit<TNewton>;

var
  N          : TNewtonUnit;

const
  GN         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 51; FValue: 1E+09); {$ELSE} (1E+09); {$ENDIF}
  MN         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 51; FValue: 1E+06); {$ELSE} (1E+06); {$ENDIF}
  kN         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 51; FValue: 1E+03); {$ELSE} (1E+03); {$ENDIF}
  hN         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 51; FValue: 1E+02); {$ELSE} (1E+02); {$ENDIF}
  daN        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 51; FValue: 1E+01); {$ELSE} (1E+01); {$ENDIF}

type
  { TPoundForce }

  TPoundForce = record
    const FUnitOfMeasurement = 0;
    const FSymbol            = 'lbf';
    const FName              = 'pound-force';
    const FPluralName        = 'pounds-force';
    const FPrefixes          : TPrefixes  = ();
    const FExponents         : TExponents = ();
    const FFactor = 4.4482216152605;
  end;
  TPoundForceUnit = specialize TUnit<TPoundForce>;

const
  lbf        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 0; FValue: 4.4482216152605); {$ELSE} (4.4482216152605); {$ENDIF}

type
  { TKilogramMeterPerSquareSecond }

  TKilogramMeterPerSquareSecond = record
    const FUnitOfMeasurement = 51;
    const FSymbol            = '%sg.%sm/%ss2';
    const FName              = '%sgram %smeter per square %ssecond';
    const FPluralName        = '%sgram %smeters per square %ssecond';
    const FPrefixes          : TPrefixes  = (pKilo, pNone, pNone);
    const FExponents         : TExponents = (1, 1, -2);
  end;
  TKilogramMeterPerSquareSecondUnit = specialize TUnit<TKilogramMeterPerSquareSecond>;

type
  { TNewtonRadian }

  TNewtonRadian = record
    const FUnitOfMeasurement = 52;
    const FSymbol            = '%sN.%srad';
    const FName              = '%snewton %sradian';
    const FPluralName        = '%snewton %sradians';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (1, 1);
  end;
  TNewtonRadianUnit = specialize TUnit<TNewtonRadian>;

type
  { TSquareNewton }

  TSquareNewton = record
    const FUnitOfMeasurement = 53;
    const FSymbol            = '%sN2';
    const FName              = 'square %snewton';
    const FPluralName        = 'square %snewtons';
    const FPrefixes          : TPrefixes  = (pNone);
    const FExponents         : TExponents = (2);
  end;
  TSquareNewtonUnit = specialize TUnit<TSquareNewton>;

var
  N2         : TSquareNewtonUnit;

const
  GN2        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 53; FValue: 1E+18); {$ELSE} (1E+18); {$ENDIF}
  MN2        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 53; FValue: 1E+12); {$ELSE} (1E+12); {$ENDIF}
  kN2        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 53; FValue: 1E+06); {$ELSE} (1E+06); {$ENDIF}
  hN2        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 53; FValue: 1E+04); {$ELSE} (1E+04); {$ENDIF}
  daN2       : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 53; FValue: 1E+02); {$ELSE} (1E+02); {$ENDIF}

type
  { TSquareKilogramSquareMeterPerQuarticSecond }

  TSquareKilogramSquareMeterPerQuarticSecond = record
    const FUnitOfMeasurement = 53;
    const FSymbol            = '%sg2.%sm2/%ss4';
    const FName              = 'square %sgram square %smeter per quartic %ssecond';
    const FPluralName        = 'square %sgram square %smeters per quartic %ssecond';
    const FPrefixes          : TPrefixes  = (pKilo, pNone, pNone);
    const FExponents         : TExponents = (2, 2, -4);
  end;
  TSquareKilogramSquareMeterPerQuarticSecondUnit = specialize TUnit<TSquareKilogramSquareMeterPerQuarticSecond>;

type
  { TPascal }

  TPascal = record
    const FUnitOfMeasurement = 54;
    const FSymbol            = '%sPa';
    const FName              = '%spascal';
    const FPluralName        = '%spascals';
    const FPrefixes          : TPrefixes  = (pNone);
    const FExponents         : TExponents = (1);
  end;
  TPascalUnit = specialize TUnit<TPascal>;

var
  Pa         : TPascalUnit;

const
  TPa        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 54; FValue: 1E+12); {$ELSE} (1E+12); {$ENDIF}
  GPa        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 54; FValue: 1E+09); {$ELSE} (1E+09); {$ENDIF}
  MPa        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 54; FValue: 1E+06); {$ELSE} (1E+06); {$ENDIF}
  kPa        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 54; FValue: 1E+03); {$ELSE} (1E+03); {$ENDIF}

type
  { TNewtonPerSquareMeter }

  TNewtonPerSquareMeter = record
    const FUnitOfMeasurement = 54;
    const FSymbol            = '%sN/%sm2';
    const FName              = '%snewton per square %smeter';
    const FPluralName        = '%snewtons per square %smeter';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (1, -2);
  end;
  TNewtonPerSquareMeterUnit = specialize TUnit<TNewtonPerSquareMeter>;

type
  { TBar }

  TBar = record
    const FUnitOfMeasurement = 0;
    const FSymbol            = '%sbar';
    const FName              = '%sbar';
    const FPluralName        = '%sbars';
    const FPrefixes          : TPrefixes  = (pNone);
    const FExponents         : TExponents = (1);
    const FFactor = 1E+05;
  end;
  TBarUnit = specialize TUnit<TBar>;

const
  bar        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 0; FValue: 1E+05); {$ELSE} (1E+05); {$ENDIF}

const
  kbar       : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 0; FValue: 1E+05 * 1E+03); {$ELSE} (1E+05 * 1E+03); {$ENDIF}
  mbar       : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 0; FValue: 1E+05 * 1E-03); {$ELSE} (1E+05 * 1E-03); {$ENDIF}

type
  { TPoundPerSquareInch }

  TPoundPerSquareInch = record
    const FUnitOfMeasurement = 0;
    const FSymbol            = '%spsi';
    const FName              = '%spound per square inch';
    const FPluralName        = '%spounds per square inch';
    const FPrefixes          : TPrefixes  = (pNone);
    const FExponents         : TExponents = (1);
    const FFactor = 6894.75729316836;
  end;
  TPoundPerSquareInchUnit = specialize TUnit<TPoundPerSquareInch>;

const
  psi        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 0; FValue: 6894.75729316836); {$ELSE} (6894.75729316836); {$ENDIF}

const
  kpsi       : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 0; FValue: 6894.75729316836 * 1E+03); {$ELSE} (6894.75729316836 * 1E+03); {$ENDIF}

type
  { TJoulePerCubicMeter }

  TJoulePerCubicMeter = record
    const FUnitOfMeasurement = 54;
    const FSymbol            = '%sJ/%sm3';
    const FName              = '%sjoule per cubic %smeter';
    const FPluralName        = '%sjoules per cubic %smeter';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (1, -3);
  end;
  TJoulePerCubicMeterUnit = specialize TUnit<TJoulePerCubicMeter>;

type
  { TKilogramPerMeterPerSquareSecond }

  TKilogramPerMeterPerSquareSecond = record
    const FUnitOfMeasurement = 54;
    const FSymbol            = '%sg/%sm/%ss2';
    const FName              = '%sgram per %smeter per square %ssecond';
    const FPluralName        = '%sgrams per %smeter per square %ssecond';
    const FPrefixes          : TPrefixes  = (pKilo, pNone, pNone);
    const FExponents         : TExponents = (1, -1, -2);
  end;
  TKilogramPerMeterPerSquareSecondUnit = specialize TUnit<TKilogramPerMeterPerSquareSecond>;

type
  { TJoule }

  TJoule = record
    const FUnitOfMeasurement = 55;
    const FSymbol            = '%sJ';
    const FName              = '%sjoule';
    const FPluralName        = '%sjoules';
    const FPrefixes          : TPrefixes  = (pNone);
    const FExponents         : TExponents = (1);
  end;
  TJouleUnit = specialize TUnit<TJoule>;

var
  J          : TJouleUnit;

const
  TJ         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 55; FValue: 1E+12); {$ELSE} (1E+12); {$ENDIF}
  GJ         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 55; FValue: 1E+09); {$ELSE} (1E+09); {$ENDIF}
  MJ         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 55; FValue: 1E+06); {$ELSE} (1E+06); {$ENDIF}
  kJ         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 55; FValue: 1E+03); {$ELSE} (1E+03); {$ENDIF}

type
  { TWattHour }

  TWattHour = record
    const FUnitOfMeasurement = 0;
    const FSymbol            = '%sW.h';
    const FName              = '%swatt hour';
    const FPluralName        = '%swatt hours';
    const FPrefixes          : TPrefixes  = (pNone);
    const FExponents         : TExponents = (1);
    const FFactor = 3600;
  end;
  TWattHourUnit = specialize TUnit<TWattHour>;

type
  { TWattSecond }

  TWattSecond = record
    const FUnitOfMeasurement = 55;
    const FSymbol            = '%sW.%ss';
    const FName              = '%swatt %ssecond';
    const FPluralName        = '%swatt %sseconds';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (1, 1);
  end;
  TWattSecondUnit = specialize TUnit<TWattSecond>;

type
  { TWattPerHertz }

  TWattPerHertz = record
    const FUnitOfMeasurement = 55;
    const FSymbol            = '%sW/%shz';
    const FName              = '%swatt per %shertz';
    const FPluralName        = '%swatts per %shertz';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (1, -1);
  end;
  TWattPerHertzUnit = specialize TUnit<TWattPerHertz>;

type
  { TElectronvolt }

  TElectronvolt = record
    const FUnitOfMeasurement = 0;
    const FSymbol            = '%seV';
    const FName              = '%selectronvolt';
    const FPluralName        = '%selectronvolts';
    const FPrefixes          : TPrefixes  = (pNone);
    const FExponents         : TExponents = (1);
    const FFactor = 1.602176634E-019;
  end;
  TElectronvoltUnit = specialize TUnit<TElectronvolt>;

const
  eV         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 0; FValue: 1.602176634E-019); {$ELSE} (1.602176634E-019); {$ENDIF}

const
  TeV        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 0; FValue: 1.602176634E-019 * 1E+12); {$ELSE} (1.602176634E-019 * 1E+12); {$ENDIF}
  GeV        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 0; FValue: 1.602176634E-019 * 1E+09); {$ELSE} (1.602176634E-019 * 1E+09); {$ENDIF}
  MeV        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 0; FValue: 1.602176634E-019 * 1E+06); {$ELSE} (1.602176634E-019 * 1E+06); {$ENDIF}
  keV        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 0; FValue: 1.602176634E-019 * 1E+03); {$ELSE} (1.602176634E-019 * 1E+03); {$ENDIF}

type
  { TNewtonMeter }

  TNewtonMeter = record
    const FUnitOfMeasurement = 55;
    const FSymbol            = '%sN.%sm';
    const FName              = '%snewton %smeter';
    const FPluralName        = '%snewton %smeters';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (1, 1);
  end;
  TNewtonMeterUnit = specialize TUnit<TNewtonMeter>;

type
  { TPoundForceInch }

  TPoundForceInch = record
    const FUnitOfMeasurement = 0;
    const FSymbol            = 'lbf.in';
    const FName              = 'pound-force inch';
    const FPluralName        = 'pound-force inches';
    const FPrefixes          : TPrefixes  = ();
    const FExponents         : TExponents = ();
    const FFactor = 0.112984829027617;
  end;
  TPoundForceInchUnit = specialize TUnit<TPoundForceInch>;

type
  { TRydberg }

  TRydberg = record
    const FUnitOfMeasurement = 0;
    const FSymbol            = '%sRy';
    const FName              = '%srydberg';
    const FPluralName        = '%srydbergs';
    const FPrefixes          : TPrefixes  = (pNone);
    const FExponents         : TExponents = (1);
    const FFactor = 2.1798723611035E-18;
  end;
  TRydbergUnit = specialize TUnit<TRydberg>;

const
  Ry         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 0; FValue: 2.1798723611035E-18); {$ELSE} (2.1798723611035E-18); {$ENDIF}

type
  { TCalorie }

  TCalorie = record
    const FUnitOfMeasurement = 0;
    const FSymbol            = '%scal';
    const FName              = '%scalorie';
    const FPluralName        = '%scalories';
    const FPrefixes          : TPrefixes  = (pNone);
    const FExponents         : TExponents = (1);
    const FFactor = 4.184;
  end;
  TCalorieUnit = specialize TUnit<TCalorie>;

const
  cal        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 0; FValue: 4.184); {$ELSE} (4.184); {$ENDIF}

const
  Mcal       : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 0; FValue: 4.184 * 1E+06); {$ELSE} (4.184 * 1E+06); {$ENDIF}
  kcal       : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 0; FValue: 4.184 * 1E+03); {$ELSE} (4.184 * 1E+03); {$ENDIF}

type
  { TKilogramSquareMeterPerSquareSecond }

  TKilogramSquareMeterPerSquareSecond = record
    const FUnitOfMeasurement = 55;
    const FSymbol            = '%sg.%sm2/%ss2';
    const FName              = '%sgram square %smeter per square %ssecond';
    const FPluralName        = '%sgram square %smeters per square %ssecond';
    const FPrefixes          : TPrefixes  = (pKilo, pNone, pNone);
    const FExponents         : TExponents = (1, 2, -2);
  end;
  TKilogramSquareMeterPerSquareSecondUnit = specialize TUnit<TKilogramSquareMeterPerSquareSecond>;

type
  { TJoulePerRadian }

  TJoulePerRadian = record
    const FUnitOfMeasurement = 56;
    const FSymbol            = '%sJ/rad';
    const FName              = '%sjoule per radian';
    const FPluralName        = '%sjoules per radian';
    const FPrefixes          : TPrefixes  = (pNone);
    const FExponents         : TExponents = (1);
  end;
  TJoulePerRadianUnit = specialize TUnit<TJoulePerRadian>;

type
  { TJoulePerDegree }

  TJoulePerDegree = record
    const FUnitOfMeasurement = 0;
    const FSymbol            = '%sJ/deg';
    const FName              = '%sjoule per degree';
    const FPluralName        = '%sjoules per degree';
    const FPrefixes          : TPrefixes  = (pNone);
    const FExponents         : TExponents = (1);
    const FFactor = 180/Pi;
  end;
  TJoulePerDegreeUnit = specialize TUnit<TJoulePerDegree>;

type
  { TNewtonMeterPerRadian }

  TNewtonMeterPerRadian = record
    const FUnitOfMeasurement = 56;
    const FSymbol            = '%sN.%sm/rad';
    const FName              = '%snewton %smeter per radian';
    const FPluralName        = '%snewton %smeters per radian';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (1, 1);
  end;
  TNewtonMeterPerRadianUnit = specialize TUnit<TNewtonMeterPerRadian>;

type
  { TNewtonMeterPerDegree }

  TNewtonMeterPerDegree = record
    const FUnitOfMeasurement = 0;
    const FSymbol            = '%sN.%sm/deg';
    const FName              = '%snewton %smeter per degree';
    const FPluralName        = '%snewton %smeters per degree';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (1, 1);
    const FFactor = 180/Pi;
  end;
  TNewtonMeterPerDegreeUnit = specialize TUnit<TNewtonMeterPerDegree>;

type
  { TKilogramSquareMeterPerSquareSecondPerRadian }

  TKilogramSquareMeterPerSquareSecondPerRadian = record
    const FUnitOfMeasurement = 56;
    const FSymbol            = '%sg.%sm2/%ss2/rad';
    const FName              = '%sgram square %smeter per square %ssecond per radian';
    const FPluralName        = '%sgram square %smeters per square %ssecond per radian';
    const FPrefixes          : TPrefixes  = (pKilo, pNone, pNone);
    const FExponents         : TExponents = (1, 2, -2);
  end;
  TKilogramSquareMeterPerSquareSecondPerRadianUnit = specialize TUnit<TKilogramSquareMeterPerSquareSecondPerRadian>;

type
  { TWatt }

  TWatt = record
    const FUnitOfMeasurement = 57;
    const FSymbol            = '%sW';
    const FName              = '%swatt';
    const FPluralName        = '%swatts';
    const FPrefixes          : TPrefixes  = (pNone);
    const FExponents         : TExponents = (1);
  end;
  TWattUnit = specialize TUnit<TWatt>;

var
  W          : TWattUnit;

const
  TW         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 57; FValue: 1E+12); {$ELSE} (1E+12); {$ENDIF}
  GW         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 57; FValue: 1E+09); {$ELSE} (1E+09); {$ENDIF}
  MW         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 57; FValue: 1E+06); {$ELSE} (1E+06); {$ENDIF}
  kW         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 57; FValue: 1E+03); {$ELSE} (1E+03); {$ENDIF}
  milliW     : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 57; FValue: 1E-03); {$ELSE} (1E-03); {$ENDIF}

type
  { TKilogramSquareMeterPerCubicSecond }

  TKilogramSquareMeterPerCubicSecond = record
    const FUnitOfMeasurement = 57;
    const FSymbol            = '%sg.%sm2/%ss3';
    const FName              = '%sgram square %smeter per cubic %ssecond';
    const FPluralName        = '%sgram square %smeters per cubic %ssecond';
    const FPrefixes          : TPrefixes  = (pKilo, pNone, pNone);
    const FExponents         : TExponents = (1, 2, -3);
  end;
  TKilogramSquareMeterPerCubicSecondUnit = specialize TUnit<TKilogramSquareMeterPerCubicSecond>;

type
  { TCoulomb }

  TCoulomb = record
    const FUnitOfMeasurement = 58;
    const FSymbol            = '%sC';
    const FName              = '%scoulomb';
    const FPluralName        = '%scoulombs';
    const FPrefixes          : TPrefixes  = (pNone);
    const FExponents         : TExponents = (1);
  end;
  TCoulombUnit = specialize TUnit<TCoulomb>;

var
  C          : TCoulombUnit;

const
  kC         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 58; FValue: 1E+03); {$ELSE} (1E+03); {$ENDIF}
  hC         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 58; FValue: 1E+02); {$ELSE} (1E+02); {$ENDIF}
  daC        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 58; FValue: 1E+01); {$ELSE} (1E+01); {$ENDIF}
  dC         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 58; FValue: 1E-01); {$ELSE} (1E-01); {$ENDIF}
  cC         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 58; FValue: 1E-02); {$ELSE} (1E-02); {$ENDIF}
  mC         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 58; FValue: 1E-03); {$ELSE} (1E-03); {$ENDIF}
  miC        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 58; FValue: 1E-06); {$ELSE} (1E-06); {$ENDIF}
  nC         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 58; FValue: 1E-09); {$ELSE} (1E-09); {$ENDIF}
  pC         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 58; FValue: 1E-12); {$ELSE} (1E-12); {$ENDIF}

type
  { TAmpereHour }

  TAmpereHour = record
    const FUnitOfMeasurement = 0;
    const FSymbol            = '%sA.h';
    const FName              = '%sampere hour';
    const FPluralName        = '%sampere hours';
    const FPrefixes          : TPrefixes  = (pNone);
    const FExponents         : TExponents = (1);
    const FFactor = 3600;
  end;
  TAmpereHourUnit = specialize TUnit<TAmpereHour>;

type
  { TAmpereSecond }

  TAmpereSecond = record
    const FUnitOfMeasurement = 58;
    const FSymbol            = '%sA.%ss';
    const FName              = '%sampere %ssecond';
    const FPluralName        = '%sampere %sseconds';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (1, 1);
  end;
  TAmpereSecondUnit = specialize TUnit<TAmpereSecond>;

type
  { TSquareCoulomb }

  TSquareCoulomb = record
    const FUnitOfMeasurement = 59;
    const FSymbol            = '%sC2';
    const FName              = 'square %scoulomb';
    const FPluralName        = 'square %scoulombs';
    const FPrefixes          : TPrefixes  = (pNone);
    const FExponents         : TExponents = (2);
  end;
  TSquareCoulombUnit = specialize TUnit<TSquareCoulomb>;

var
  C2         : TSquareCoulombUnit;

const
  kC2        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 59; FValue: 1E+06); {$ELSE} (1E+06); {$ENDIF}
  hC2        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 59; FValue: 1E+04); {$ELSE} (1E+04); {$ENDIF}
  daC2       : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 59; FValue: 1E+02); {$ELSE} (1E+02); {$ENDIF}
  dC2        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 59; FValue: 1E-02); {$ELSE} (1E-02); {$ENDIF}
  cC2        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 59; FValue: 1E-04); {$ELSE} (1E-04); {$ENDIF}
  mC2        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 59; FValue: 1E-06); {$ELSE} (1E-06); {$ENDIF}
  miC2       : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 59; FValue: 1E-12); {$ELSE} (1E-12); {$ENDIF}
  nC2        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 59; FValue: 1E-18); {$ELSE} (1E-18); {$ENDIF}
  pC2        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 59; FValue: 1E-24); {$ELSE} (1E-24); {$ENDIF}

type
  { TSquareAmpereSquareSecond }

  TSquareAmpereSquareSecond = record
    const FUnitOfMeasurement = 59;
    const FSymbol            = '%sA2.%ss2';
    const FName              = 'square %sampere square %ssecond';
    const FPluralName        = 'square %sampere square %sseconds';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (2, 2);
  end;
  TSquareAmpereSquareSecondUnit = specialize TUnit<TSquareAmpereSquareSecond>;

type
  { TCoulombMeter }

  TCoulombMeter = record
    const FUnitOfMeasurement = 60;
    const FSymbol            = '%sC.%sm';
    const FName              = '%scoulomb %smeter';
    const FPluralName        = '%scoulomb %smeters';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (1, 1);
  end;
  TCoulombMeterUnit = specialize TUnit<TCoulombMeter>;

type
  { TVolt }

  TVolt = record
    const FUnitOfMeasurement = 61;
    const FSymbol            = '%sV';
    const FName              = '%svolt';
    const FPluralName        = '%svolts';
    const FPrefixes          : TPrefixes  = (pNone);
    const FExponents         : TExponents = (1);
  end;
  TVoltUnit = specialize TUnit<TVolt>;

var
  V          : TVoltUnit;

const
  kV         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 61; FValue: 1E+03); {$ELSE} (1E+03); {$ENDIF}
  mV         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 61; FValue: 1E-03); {$ELSE} (1E-03); {$ENDIF}

type
  { TJoulePerCoulomb }

  TJoulePerCoulomb = record
    const FUnitOfMeasurement = 61;
    const FSymbol            = '%sJ/%sC';
    const FName              = '%sJoule per %scoulomb';
    const FPluralName        = '%sJoules per %scoulomb';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (1, -1);
  end;
  TJoulePerCoulombUnit = specialize TUnit<TJoulePerCoulomb>;

type
  { TKilogramSquareMeterPerAmperePerCubicSecond }

  TKilogramSquareMeterPerAmperePerCubicSecond = record
    const FUnitOfMeasurement = 61;
    const FSymbol            = '%sg.%sm2/%sA/%ss3';
    const FName              = '%sgram square %smeter per %sampere per cubic %ssecond';
    const FPluralName        = '%sgram square %smeters per %sampere per cubic %ssecond';
    const FPrefixes          : TPrefixes  = (pKilo, pNone, pNone, pNone);
    const FExponents         : TExponents = (1, 2, -1, -3);
  end;
  TKilogramSquareMeterPerAmperePerCubicSecondUnit = specialize TUnit<TKilogramSquareMeterPerAmperePerCubicSecond>;

type
  { TSquareVolt }

  TSquareVolt = record
    const FUnitOfMeasurement = 62;
    const FSymbol            = '%sV2';
    const FName              = 'square %svolt';
    const FPluralName        = 'square %svolts';
    const FPrefixes          : TPrefixes  = (pNone);
    const FExponents         : TExponents = (2);
  end;
  TSquareVoltUnit = specialize TUnit<TSquareVolt>;

var
  V2         : TSquareVoltUnit;

const
  kV2        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 62; FValue: 1E+06); {$ELSE} (1E+06); {$ENDIF}
  mV2        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 62; FValue: 1E-06); {$ELSE} (1E-06); {$ENDIF}

type
  { TSquareKilogramQuarticMeterPerSquareAmperePerSexticSecond }

  TSquareKilogramQuarticMeterPerSquareAmperePerSexticSecond = record
    const FUnitOfMeasurement = 62;
    const FSymbol            = '%sg2.%sm3/%sA2/%ss6';
    const FName              = 'square %sgram quartic %smeter per square %sampere per sextic %ssecond';
    const FPluralName        = 'square %sgram quartic %smeters per square %sampere per sextic %ssecond';
    const FPrefixes          : TPrefixes  = (pKilo, pNone, pNone, pNone);
    const FExponents         : TExponents = (2, 3, -2, -6);
  end;
  TSquareKilogramQuarticMeterPerSquareAmperePerSexticSecondUnit = specialize TUnit<TSquareKilogramQuarticMeterPerSquareAmperePerSexticSecond>;

type
  { TFarad }

  TFarad = record
    const FUnitOfMeasurement = 63;
    const FSymbol            = '%sF';
    const FName              = '%sfarad';
    const FPluralName        = '%sfarads';
    const FPrefixes          : TPrefixes  = (pNone);
    const FExponents         : TExponents = (1);
  end;
  TFaradUnit = specialize TUnit<TFarad>;

var
  F          : TFaradUnit;

const
  mF         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 63; FValue: 1E-03); {$ELSE} (1E-03); {$ENDIF}
  miF        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 63; FValue: 1E-06); {$ELSE} (1E-06); {$ENDIF}
  nF         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 63; FValue: 1E-09); {$ELSE} (1E-09); {$ENDIF}
  pF         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 63; FValue: 1E-12); {$ELSE} (1E-12); {$ENDIF}

type
  { TCoulombPerVolt }

  TCoulombPerVolt = record
    const FUnitOfMeasurement = 63;
    const FSymbol            = '%sC/%sV';
    const FName              = '%scoulomb per %svolt';
    const FPluralName        = '%scoulombs per %svolt';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (1, -1);
  end;
  TCoulombPerVoltUnit = specialize TUnit<TCoulombPerVolt>;

type
  { TSquareAmpereQuarticSecondPerKilogramPerSquareMeter }

  TSquareAmpereQuarticSecondPerKilogramPerSquareMeter = record
    const FUnitOfMeasurement = 63;
    const FSymbol            = '%sA2.%ss4/%sg/%sm2';
    const FName              = 'square %sampere quartic %ssecond per %sgram per square %smeter';
    const FPluralName        = 'square %sampere quartic %sseconds per %sgram per square %smeter';
    const FPrefixes          : TPrefixes  = (pNone, pNone, pKilo, pNone);
    const FExponents         : TExponents = (2, 4, -1, -2);
  end;
  TSquareAmpereQuarticSecondPerKilogramPerSquareMeterUnit = specialize TUnit<TSquareAmpereQuarticSecondPerKilogramPerSquareMeter>;

type
  { TOhm }

  TOhm = record
    const FUnitOfMeasurement = 64;
    const FSymbol            = '%sΩ';
    const FName              = '%sohm';
    const FPluralName        = '%sohms';
    const FPrefixes          : TPrefixes  = (pNone);
    const FExponents         : TExponents = (1);
  end;
  TOhmUnit = specialize TUnit<TOhm>;

var
  ohm        : TOhmUnit;

const
  Gohm       : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 64; FValue: 1E+09); {$ELSE} (1E+09); {$ENDIF}
  megaohm    : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 64; FValue: 1E+06); {$ELSE} (1E+06); {$ENDIF}
  kohm       : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 64; FValue: 1E+03); {$ELSE} (1E+03); {$ENDIF}
  mohm       : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 64; FValue: 1E-03); {$ELSE} (1E-03); {$ENDIF}
  miohm      : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 64; FValue: 1E-06); {$ELSE} (1E-06); {$ENDIF}
  nohm       : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 64; FValue: 1E-09); {$ELSE} (1E-09); {$ENDIF}

type
  { TKilogramSquareMeterPerSquareAmperePerCubicSecond }

  TKilogramSquareMeterPerSquareAmperePerCubicSecond = record
    const FUnitOfMeasurement = 64;
    const FSymbol            = '%sg.%sm2/%sA/%ss3';
    const FName              = '%sgram square %smeter per square %sampere per cubic %ssecond';
    const FPluralName        = '%sgram square %smeters per square %sampere per cubic %ssecond';
    const FPrefixes          : TPrefixes  = (pKilo, pNone, pNone, pNone);
    const FExponents         : TExponents = (1, 2, -1, -3);
  end;
  TKilogramSquareMeterPerSquareAmperePerCubicSecondUnit = specialize TUnit<TKilogramSquareMeterPerSquareAmperePerCubicSecond>;

type
  { TSiemens }

  TSiemens = record
    const FUnitOfMeasurement = 65;
    const FSymbol            = '%sS';
    const FName              = '%ssiemens';
    const FPluralName        = '%ssiemens';
    const FPrefixes          : TPrefixes  = (pNone);
    const FExponents         : TExponents = (1);
  end;
  TSiemensUnit = specialize TUnit<TSiemens>;

var
  siemens    : TSiemensUnit;

const
  millisiemens : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 65; FValue: 1E-03); {$ELSE} (1E-03); {$ENDIF}
  microsiemens : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 65; FValue: 1E-06); {$ELSE} (1E-06); {$ENDIF}
   nanosiemens : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 65; FValue: 1E-09); {$ELSE} (1E-09); {$ENDIF}

type
  { TSquareAmpereCubicSecondPerKilogramPerSquareMeter }

  TSquareAmpereCubicSecondPerKilogramPerSquareMeter = record
    const FUnitOfMeasurement = 65;
    const FSymbol            = '%sA2.%ss3/%sg/%sm2';
    const FName              = 'square %sampere cubic %ssecond per %sgram per square %smeter';
    const FPluralName        = 'square %sampere cubic %sseconds per %sgram per square %smeter';
    const FPrefixes          : TPrefixes  = (pNone, pNone, pKilo, pNone);
    const FExponents         : TExponents = (2, 3, -1, -2);
  end;
  TSquareAmpereCubicSecondPerKilogramPerSquareMeterUnit = specialize TUnit<TSquareAmpereCubicSecondPerKilogramPerSquareMeter>;

type
  { TSiemensPerMeter }

  TSiemensPerMeter = record
    const FUnitOfMeasurement = 66;
    const FSymbol            = '%sS/%sm';
    const FName              = '%ssiemens per %smeter';
    const FPluralName        = '%ssiemens per %smeter';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (1, -1);
  end;
  TSiemensPerMeterUnit = specialize TUnit<TSiemensPerMeter>;

type
  { TTesla }

  TTesla = record
    const FUnitOfMeasurement = 67;
    const FSymbol            = '%sT';
    const FName              = '%stesla';
    const FPluralName        = '%steslas';
    const FPrefixes          : TPrefixes  = (pNone);
    const FExponents         : TExponents = (1);
  end;
  TTeslaUnit = specialize TUnit<TTesla>;

var
  T          : TTeslaUnit;

const
  mT         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 67; FValue: 1E-03); {$ELSE} (1E-03); {$ENDIF}
  miT        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 67; FValue: 1E-06); {$ELSE} (1E-06); {$ENDIF}
  nT         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 67; FValue: 1E-09); {$ELSE} (1E-09); {$ENDIF}

type
  { TWeberPerSquareMeter }

  TWeberPerSquareMeter = record
    const FUnitOfMeasurement = 67;
    const FSymbol            = '%sWb/%m2';
    const FName              = '%sweber per square %smeter';
    const FPluralName        = '%swebers per square %smeter';
    const FPrefixes          : TPrefixes  = (pNone);
    const FExponents         : TExponents = (1);
  end;
  TWeberPerSquareMeterUnit = specialize TUnit<TWeberPerSquareMeter>;

type
  { TKilogramPerAmperePerSquareSecond }

  TKilogramPerAmperePerSquareSecond = record
    const FUnitOfMeasurement = 67;
    const FSymbol            = '%sg/%sA/%ss2';
    const FName              = '%sgram per %sampere per square %ssecond';
    const FPluralName        = '%sgrams per %sampere per square %ssecond';
    const FPrefixes          : TPrefixes  = (pKilo, pNone, pNone);
    const FExponents         : TExponents = (1, -1, -2);
  end;
  TKilogramPerAmperePerSquareSecondUnit = specialize TUnit<TKilogramPerAmperePerSquareSecond>;

type
  { TWeber }

  TWeber = record
    const FUnitOfMeasurement = 68;
    const FSymbol            = '%sWb';
    const FName              = '%sweber';
    const FPluralName        = '%swebers';
    const FPrefixes          : TPrefixes  = (pNone);
    const FExponents         : TExponents = (1);
  end;
  TWeberUnit = specialize TUnit<TWeber>;

var
  Wb         : TWeberUnit;

type
  { TKilogramSquareMeterPerAmperePerSquareSecond }

  TKilogramSquareMeterPerAmperePerSquareSecond = record
    const FUnitOfMeasurement = 68;
    const FSymbol            = '%sg.%sm2/%sA/%ss2';
    const FName              = '%sgram square %smeter per %sampere per square %ssecond';
    const FPluralName        = '%sgram square %smeters per %sampere per square %ssecond';
    const FPrefixes          : TPrefixes  = (pKilo, pNone, pNone, pNone);
    const FExponents         : TExponents = (1, 2, -1, -2);
  end;
  TKilogramSquareMeterPerAmperePerSquareSecondUnit = specialize TUnit<TKilogramSquareMeterPerAmperePerSquareSecond>;

type
  { THenry }

  THenry = record
    const FUnitOfMeasurement = 69;
    const FSymbol            = '%sH';
    const FName              = '%shenry';
    const FPluralName        = '%shenries';
    const FPrefixes          : TPrefixes  = (pNone);
    const FExponents         : TExponents = (1);
  end;
  THenryUnit = specialize TUnit<THenry>;

var
  H          : THenryUnit;

const
  mH         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 69; FValue: 1E-03); {$ELSE} (1E-03); {$ENDIF}
  miH        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 69; FValue: 1E-06); {$ELSE} (1E-06); {$ENDIF}
  nH         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 69; FValue: 1E-09); {$ELSE} (1E-09); {$ENDIF}

type
  { TKilogramSquareMeterPerSquareAmperePerSquareSecond }

  TKilogramSquareMeterPerSquareAmperePerSquareSecond = record
    const FUnitOfMeasurement = 69;
    const FSymbol            = '%sg.%sm2/%sA2/%ss2';
    const FName              = '%sgram square %smeter per square %sampere per square %ssecond';
    const FPluralName        = '%sgram square %smeters per square %sampere per square %ssecond';
    const FPrefixes          : TPrefixes  = (pKilo, pNone, pNone, pNone);
    const FExponents         : TExponents = (1, 2, -2, -2);
  end;
  TKilogramSquareMeterPerSquareAmperePerSquareSecondUnit = specialize TUnit<TKilogramSquareMeterPerSquareAmperePerSquareSecond>;

type
  { TReciprocalHenry }

  TReciprocalHenry = record
    const FUnitOfMeasurement = 70;
    const FSymbol            = '1/%sH';
    const FName              = 'reciprocal %shenry';
    const FPluralName        = 'reciprocal %shenries';
    const FPrefixes          : TPrefixes  = (pNone);
    const FExponents         : TExponents = (-1);
  end;
  TReciprocalHenryUnit = specialize TUnit<TReciprocalHenry>;

type
  { TLumen }

  TLumen = record
    const FUnitOfMeasurement = 71;
    const FSymbol            = '%slm';
    const FName              = '%slumen';
    const FPluralName        = '%slumens';
    const FPrefixes          : TPrefixes  = (pNone);
    const FExponents         : TExponents = (1);
  end;
  TLumenUnit = specialize TUnit<TLumen>;

var
  lm         : TLumenUnit;

type
  { TCandelaSteradian }

  TCandelaSteradian = record
    const FUnitOfMeasurement = 71;
    const FSymbol            = '%scd.%ssr';
    const FName              = '%scandela %ssteradian';
    const FPluralName        = '%scandela %ssteradians';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (1, 1);
  end;
  TCandelaSteradianUnit = specialize TUnit<TCandelaSteradian>;

type
  { TLumenSecond }

  TLumenSecond = record
    const FUnitOfMeasurement = 72;
    const FSymbol            = '%slm.%ss';
    const FName              = '%slumen %ssecond';
    const FPluralName        = '%slumen %sseconds';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (1, 1);
  end;
  TLumenSecondUnit = specialize TUnit<TLumenSecond>;

type
  { TLumenSecondPerCubicMeter }

  TLumenSecondPerCubicMeter = record
    const FUnitOfMeasurement = 73;
    const FSymbol            = '%slm.%ss/%sm3';
    const FName              = '%slumen %ssecond per cubic meter';
    const FPluralName        = '%slumen %sseconds per cubic meter';
    const FPrefixes          : TPrefixes  = (pNone, pNone, pNone);
    const FExponents         : TExponents = (1, 1, -3);
  end;
  TLumenSecondPerCubicMeterUnit = specialize TUnit<TLumenSecondPerCubicMeter>;

type
  { TLux }

  TLux = record
    const FUnitOfMeasurement = 74;
    const FSymbol            = '%slx';
    const FName              = '%slux';
    const FPluralName        = '%slux';
    const FPrefixes          : TPrefixes  = (pNone);
    const FExponents         : TExponents = (1);
  end;
  TLuxUnit = specialize TUnit<TLux>;

var
  lx         : TLuxUnit;

type
  { TCandelaSteradianPerSquareMeter }

  TCandelaSteradianPerSquareMeter = record
    const FUnitOfMeasurement = 74;
    const FSymbol            = '%scd.%ssr/%sm2';
    const FName              = '%scandela %ssteradian per square %smeter';
    const FPluralName        = '%scandela %ssteradians per square %smeter';
    const FPrefixes          : TPrefixes  = (pNone, pNone, pNone);
    const FExponents         : TExponents = (1, 1, -2);
  end;
  TCandelaSteradianPerSquareMeterUnit = specialize TUnit<TCandelaSteradianPerSquareMeter>;

type
  { TLuxSecond }

  TLuxSecond = record
    const FUnitOfMeasurement = 75;
    const FSymbol            = '%slx.%ss';
    const FName              = '%slux %ssecond';
    const FPluralName        = '%slux %sseconds';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (1, 1);
  end;
  TLuxSecondUnit = specialize TUnit<TLuxSecond>;

type
  { TBequerel }

  TBequerel = record
    const FUnitOfMeasurement = 24;
    const FSymbol            = '%sBq';
    const FName              = '%sbequerel';
    const FPluralName        = '%sbequerels';
    const FPrefixes          : TPrefixes  = (pNone);
    const FExponents         : TExponents = (1);
  end;
  TBequerelUnit = specialize TUnit<TBequerel>;

var
  Bq         : TBequerelUnit;

const
  kBq        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 24; FValue: 1E+03); {$ELSE} (1E+03); {$ENDIF}
  mBq        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 24; FValue: 1E-03); {$ELSE} (1E-03); {$ENDIF}
  miBq       : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 24; FValue: 1E-06); {$ELSE} (1E-06); {$ENDIF}
  nBq        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 24; FValue: 1E-09); {$ELSE} (1E-09); {$ENDIF}
  pBq        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 24; FValue: 1E-12); {$ELSE} (1E-12); {$ENDIF}

type
  { TKatal }

  TKatal = record
    const FUnitOfMeasurement = 76;
    const FSymbol            = '%skat';
    const FName              = '%skatal';
    const FPluralName        = '%skatals';
    const FPrefixes          : TPrefixes  = (pNone);
    const FExponents         : TExponents = (1);
  end;
  TKatalUnit = specialize TUnit<TKatal>;

var
  kat        : TKatalUnit;

type
  { TMolePerSecond }

  TMolePerSecond = record
    const FUnitOfMeasurement = 76;
    const FSymbol            = '%smol/%ss';
    const FName              = '%smole per %ssecond';
    const FPluralName        = '%smoles per %ssecond';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (1, -1);
  end;
  TMolePerSecondUnit = specialize TUnit<TMolePerSecond>;

type
  { TNewtonPerCubicMeter }

  TNewtonPerCubicMeter = record
    const FUnitOfMeasurement = 77;
    const FSymbol            = '%sN/%sm3';
    const FName              = '%snewton per cubic %smeter';
    const FPluralName        = '%snewtons per cubic %smeter';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (1, -3);
  end;
  TNewtonPerCubicMeterUnit = specialize TUnit<TNewtonPerCubicMeter>;

type
  { TPascalPerMeter }

  TPascalPerMeter = record
    const FUnitOfMeasurement = 77;
    const FSymbol            = '%sPa/%sm';
    const FName              = '%spascal per %smeter';
    const FPluralName        = '%spascals per %smeter';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (1, -1);
  end;
  TPascalPerMeterUnit = specialize TUnit<TPascalPerMeter>;

type
  { TKilogramPerSquareMeterPerSquareSecond }

  TKilogramPerSquareMeterPerSquareSecond = record
    const FUnitOfMeasurement = 77;
    const FSymbol            = '%sg/%sm2/%ss2';
    const FName              = '%sgram per square %smeter per square %ssecond';
    const FPluralName        = '%sgrams per square %smeter per square %ssecond';
    const FPrefixes          : TPrefixes  = (pKilo, pNone, pNone);
    const FExponents         : TExponents = (1, -2, -2);
  end;
  TKilogramPerSquareMeterPerSquareSecondUnit = specialize TUnit<TKilogramPerSquareMeterPerSquareSecond>;

type
  { TNewtonPerMeter }

  TNewtonPerMeter = record
    const FUnitOfMeasurement = 78;
    const FSymbol            = '%sN/%sm';
    const FName              = '%snewton per %smeter';
    const FPluralName        = '%snewtons per %smeter';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (1, -1);
  end;
  TNewtonPerMeterUnit = specialize TUnit<TNewtonPerMeter>;

type
  { TJoulePerSquareMeter }

  TJoulePerSquareMeter = record
    const FUnitOfMeasurement = 78;
    const FSymbol            = '%sJ/%sm2';
    const FName              = '%sjoule per square %smeter';
    const FPluralName        = '%sjoules per square %smeter';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (1, -2);
  end;
  TJoulePerSquareMeterUnit = specialize TUnit<TJoulePerSquareMeter>;

type
  { TWattPerSquareMeterPerHertz }

  TWattPerSquareMeterPerHertz = record
    const FUnitOfMeasurement = 78;
    const FSymbol            = '%sW/%sm2/%sHz';
    const FName              = '%swatt per square %smeter per %shertz';
    const FPluralName        = '%swatts per square %smeter per %shertz';
    const FPrefixes          : TPrefixes  = (pNone, pNone, pNone);
    const FExponents         : TExponents = (1, -2, -1);
  end;
  TWattPerSquareMeterPerHertzUnit = specialize TUnit<TWattPerSquareMeterPerHertz>;

type
  { TPoundForcePerInch }

  TPoundForcePerInch = record
    const FUnitOfMeasurement = 0;
    const FSymbol            = 'lbf/in';
    const FName              = 'pound-force per inch';
    const FPluralName        = 'pounds-force per inch';
    const FPrefixes          : TPrefixes  = ();
    const FExponents         : TExponents = ();
    const FFactor = 175.126835246476;
  end;
  TPoundForcePerInchUnit = specialize TUnit<TPoundForcePerInch>;

type
  { TKilogramPerSquareSecond }

  TKilogramPerSquareSecond = record
    const FUnitOfMeasurement = 78;
    const FSymbol            = '%sg/%ss2';
    const FName              = '%sgram per square %ssecond';
    const FPluralName        = '%sgrams per square %ssecond';
    const FPrefixes          : TPrefixes  = (pKilo, pNone);
    const FExponents         : TExponents = (1, -2);
  end;
  TKilogramPerSquareSecondUnit = specialize TUnit<TKilogramPerSquareSecond>;

type
  { TCubicMeterPerSecond }

  TCubicMeterPerSecond = record
    const FUnitOfMeasurement = 79;
    const FSymbol            = '%sm3/%ss';
    const FName              = 'cubic %smeter per %ssecond';
    const FPluralName        = 'cubic %smeters per %ssecond';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (3, -1);
  end;
  TCubicMeterPerSecondUnit = specialize TUnit<TCubicMeterPerSecond>;

type
  { TPoiseuille }

  TPoiseuille = record
    const FUnitOfMeasurement = 80;
    const FSymbol            = '%sPl';
    const FName              = '%spoiseuille';
    const FPluralName        = '%spoiseuilles';
    const FPrefixes          : TPrefixes  = (pNone);
    const FExponents         : TExponents = (1);
  end;
  TPoiseuilleUnit = specialize TUnit<TPoiseuille>;

var
  Pl         : TPoiseuilleUnit;

const
  cPl        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 80; FValue: 1E-02); {$ELSE} (1E-02); {$ENDIF}
  mPl        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 80; FValue: 1E-03); {$ELSE} (1E-03); {$ENDIF}
  miPl       : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 80; FValue: 1E-06); {$ELSE} (1E-06); {$ENDIF}

type
  { TPascalSecond }

  TPascalSecond = record
    const FUnitOfMeasurement = 80;
    const FSymbol            = '%sPa.%ss';
    const FName              = '%spascal %ssecond';
    const FPluralName        = '%spascal %sseconds';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (1, 1);
  end;
  TPascalSecondUnit = specialize TUnit<TPascalSecond>;

type
  { TKilogramPerMeterPerSecond }

  TKilogramPerMeterPerSecond = record
    const FUnitOfMeasurement = 80;
    const FSymbol            = '%sg/%sm/%ss';
    const FName              = '%sgram per %smeter per %ssecond';
    const FPluralName        = '%sgrams per %smeter per %ssecond';
    const FPrefixes          : TPrefixes  = (pKilo, pNone, pNone);
    const FExponents         : TExponents = (1, -1, -1);
  end;
  TKilogramPerMeterPerSecondUnit = specialize TUnit<TKilogramPerMeterPerSecond>;

type
  { TSquareMeterPerSecond }

  TSquareMeterPerSecond = record
    const FUnitOfMeasurement = 81;
    const FSymbol            = '%sm2/%ss';
    const FName              = 'square %smeter per %ssecond';
    const FPluralName        = 'square %smeters per %ssecond';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (2, -1);
  end;
  TSquareMeterPerSecondUnit = specialize TUnit<TSquareMeterPerSecond>;

type
  { TKilogramPerQuarticMeter }

  TKilogramPerQuarticMeter = record
    const FUnitOfMeasurement = 82;
    const FSymbol            = '%sg/%sm4';
    const FName              = '%sgram per quartic %smeter';
    const FPluralName        = '%sgrams per quartic %smeter';
    const FPrefixes          : TPrefixes  = (pKilo, pNone);
    const FExponents         : TExponents = (1, -4);
  end;
  TKilogramPerQuarticMeterUnit = specialize TUnit<TKilogramPerQuarticMeter>;

type
  { TQuarticMeterSecond }

  TQuarticMeterSecond = record
    const FUnitOfMeasurement = 83;
    const FSymbol            = '%sm4.%ss';
    const FName              = 'quartic %smeter %ssecond';
    const FPluralName        = 'quartic %smeter %sseconds';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (4, 1);
  end;
  TQuarticMeterSecondUnit = specialize TUnit<TQuarticMeterSecond>;

type
  { TKilogramPerQuarticMeterPerSecond }

  TKilogramPerQuarticMeterPerSecond = record
    const FUnitOfMeasurement = 84;
    const FSymbol            = '%sg/%sm4/%ss';
    const FName              = '%sgram per quartic %smeter per %ssecond';
    const FPluralName        = '%sgrams per quartic %smeter per %ssecond';
    const FPrefixes          : TPrefixes  = (pKilo, pNone, pNone);
    const FExponents         : TExponents = (1, -4, -1);
  end;
  TKilogramPerQuarticMeterPerSecondUnit = specialize TUnit<TKilogramPerQuarticMeterPerSecond>;

type
  { TCubicMeterPerKilogram }

  TCubicMeterPerKilogram = record
    const FUnitOfMeasurement = 85;
    const FSymbol            = '%sm3/%sg';
    const FName              = 'cubic %smeter per %sgram';
    const FPluralName        = 'cubic %smeters per %sgram';
    const FPrefixes          : TPrefixes  = (pNone, pKilo);
    const FExponents         : TExponents = (3, -1);
  end;
  TCubicMeterPerKilogramUnit = specialize TUnit<TCubicMeterPerKilogram>;

type
  { TKilogramSquareSecond }

  TKilogramSquareSecond = record
    const FUnitOfMeasurement = 86;
    const FSymbol            = '%sg.%ss2';
    const FName              = '%sgram square %ssecond';
    const FPluralName        = '%sgram square %sseconds';
    const FPrefixes          : TPrefixes  = (pKilo, pNone);
    const FExponents         : TExponents = (1, 2);
  end;
  TKilogramSquareSecondUnit = specialize TUnit<TKilogramSquareSecond>;

type
  { TCubicMeterPerSquareSecond }

  TCubicMeterPerSquareSecond = record
    const FUnitOfMeasurement = 87;
    const FSymbol            = '%sm3/%ss2';
    const FName              = 'cubic %smeter per square %ssecond';
    const FPluralName        = 'cubic %smeters per square %ssecond';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (3, -2);
  end;
  TCubicMeterPerSquareSecondUnit = specialize TUnit<TCubicMeterPerSquareSecond>;

type
  { TNewtonSquareMeter }

  TNewtonSquareMeter = record
    const FUnitOfMeasurement = 88;
    const FSymbol            = '%sN.%sm2';
    const FName              = '%snewton square %smeter';
    const FPluralName        = '%snewton square %smeters';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (1, 2);
  end;
  TNewtonSquareMeterUnit = specialize TUnit<TNewtonSquareMeter>;

type
  { TKilogramCubicMeterPerSquareSecond }

  TKilogramCubicMeterPerSquareSecond = record
    const FUnitOfMeasurement = 88;
    const FSymbol            = '%sg.%sm3/%ss2';
    const FName              = '%sgram cubic %smeter per square %ssecond';
    const FPluralName        = '%sgram cubic %smeters per square %ssecond';
    const FPrefixes          : TPrefixes  = (pKilo, pNone, pNone);
    const FExponents         : TExponents = (1, 3, -2);
  end;
  TKilogramCubicMeterPerSquareSecondUnit = specialize TUnit<TKilogramCubicMeterPerSquareSecond>;

type
  { TNewtonCubicMeter }

  TNewtonCubicMeter = record
    const FUnitOfMeasurement = 89;
    const FSymbol            = '%sN.%sm3';
    const FName              = '%snewton cubic %smeter';
    const FPluralName        = '%snewton cubic %smeters';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (1, 3);
  end;
  TNewtonCubicMeterUnit = specialize TUnit<TNewtonCubicMeter>;

type
  { TKilogramQuarticMeterPerSquareSecond }

  TKilogramQuarticMeterPerSquareSecond = record
    const FUnitOfMeasurement = 89;
    const FSymbol            = '%sg.%sm4/%ss2';
    const FName              = '%sgram quartic %smeter per square %ssecond';
    const FPluralName        = '%sgram quartic %smeters per square %ssecond';
    const FPrefixes          : TPrefixes  = (pKilo, pNone, pNone);
    const FExponents         : TExponents = (1, 4, -2);
  end;
  TKilogramQuarticMeterPerSquareSecondUnit = specialize TUnit<TKilogramQuarticMeterPerSquareSecond>;

type
  { TNewtonPerSquareKilogram }

  TNewtonPerSquareKilogram = record
    const FUnitOfMeasurement = 90;
    const FSymbol            = '%sN/%sg2';
    const FName              = '%snewton per square %sgram';
    const FPluralName        = '%snewtons per square %sgram';
    const FPrefixes          : TPrefixes  = (pNone, pKilo);
    const FExponents         : TExponents = (1, -2);
  end;
  TNewtonPerSquareKilogramUnit = specialize TUnit<TNewtonPerSquareKilogram>;

type
  { TMeterPerKilogramPerSquareSecond }

  TMeterPerKilogramPerSquareSecond = record
    const FUnitOfMeasurement = 90;
    const FSymbol            = '%sm/%sg/%ss2';
    const FName              = '%smeter per %sgram per square %ssecond';
    const FPluralName        = '%smeters per %sgram per square %ssecond';
    const FPrefixes          : TPrefixes  = (pNone, pKilo, pNone);
    const FExponents         : TExponents = (1, -1, -2);
  end;
  TMeterPerKilogramPerSquareSecondUnit = specialize TUnit<TMeterPerKilogramPerSquareSecond>;

type
  { TSquareKilogramPerMeter }

  TSquareKilogramPerMeter = record
    const FUnitOfMeasurement = 91;
    const FSymbol            = '%sg2/%sm';
    const FName              = 'square %sgram per %smeter';
    const FPluralName        = 'square %sgrams per %smeter';
    const FPrefixes          : TPrefixes  = (pKilo, pNone);
    const FExponents         : TExponents = (2, -1);
  end;
  TSquareKilogramPerMeterUnit = specialize TUnit<TSquareKilogramPerMeter>;

type
  { TSquareKilogramPerSquareMeter }

  TSquareKilogramPerSquareMeter = record
    const FUnitOfMeasurement = 92;
    const FSymbol            = '%sg2/%sm2';
    const FName              = 'square %sgram per square %smeter';
    const FPluralName        = 'square %sgrams per square %smeter';
    const FPrefixes          : TPrefixes  = (pKilo, pNone);
    const FExponents         : TExponents = (2, -2);
  end;
  TSquareKilogramPerSquareMeterUnit = specialize TUnit<TSquareKilogramPerSquareMeter>;

type
  { TSquareMeterPerSquareKilogram }

  TSquareMeterPerSquareKilogram = record
    const FUnitOfMeasurement = 93;
    const FSymbol            = '%sm2/%sg2';
    const FName              = 'square %smeter per square %sgram';
    const FPluralName        = 'square %smeters per square %sgram';
    const FPrefixes          : TPrefixes  = (pNone, pKilo);
    const FExponents         : TExponents = (2, -2);
  end;
  TSquareMeterPerSquareKilogramUnit = specialize TUnit<TSquareMeterPerSquareKilogram>;

type
  { TNewtonSquareMeterPerSquareKilogram }

  TNewtonSquareMeterPerSquareKilogram = record
    const FUnitOfMeasurement = 94;
    const FSymbol            = '%sN.%sm2/%sg2';
    const FName              = '%snewton square %smeter per square %sgram';
    const FPluralName        = '%snewton square %smeters per square %sgram';
    const FPrefixes          : TPrefixes  = (pNone, pNone, pKilo);
    const FExponents         : TExponents = (1, 2, -2);
  end;
  TNewtonSquareMeterPerSquareKilogramUnit = specialize TUnit<TNewtonSquareMeterPerSquareKilogram>;

type
  { TCubicMeterPerKilogramPerSquareSecond }

  TCubicMeterPerKilogramPerSquareSecond = record
    const FUnitOfMeasurement = 94;
    const FSymbol            = '%sm3/%sg/%ss2';
    const FName              = 'cubic %smeter per %sgram per square %ssecond';
    const FPluralName        = 'cubic %smeters per %sgram per square %ssecond';
    const FPrefixes          : TPrefixes  = (pNone, pKilo, pNone);
    const FExponents         : TExponents = (3, -1, -2);
  end;
  TCubicMeterPerKilogramPerSquareSecondUnit = specialize TUnit<TCubicMeterPerKilogramPerSquareSecond>;

type
  { TReciprocalKelvin }

  TReciprocalKelvin = record
    const FUnitOfMeasurement = 95;
    const FSymbol            = '1/%sK';
    const FName              = 'reciprocal %skelvin';
    const FPluralName        = 'reciprocal %skelvin';
    const FPrefixes          : TPrefixes  = (pNone);
    const FExponents         : TExponents = (-1);
  end;
  TReciprocalKelvinUnit = specialize TUnit<TReciprocalKelvin>;

type
  { TKilogramKelvin }

  TKilogramKelvin = record
    const FUnitOfMeasurement = 96;
    const FSymbol            = '%sg.%sK';
    const FName              = '%sgram %skelvin';
    const FPluralName        = '%sgram %skelvins';
    const FPrefixes          : TPrefixes  = (pKilo, pNone);
    const FExponents         : TExponents = (1, 1);
  end;
  TKilogramKelvinUnit = specialize TUnit<TKilogramKelvin>;

type
  { TJoulePerKelvin }

  TJoulePerKelvin = record
    const FUnitOfMeasurement = 97;
    const FSymbol            = '%sJ/%sK';
    const FName              = '%sjoule per %skelvin';
    const FPluralName        = '%sjoules per %skelvin';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (1, -1);
  end;
  TJoulePerKelvinUnit = specialize TUnit<TJoulePerKelvin>;

type
  { TKilogramSquareMeterPerSquareSecondPerKelvin }

  TKilogramSquareMeterPerSquareSecondPerKelvin = record
    const FUnitOfMeasurement = 97;
    const FSymbol            = '%sg.%sm2/%ss2/%sK';
    const FName              = '%sgram square %smeter per square %ssecond per %skelvin';
    const FPluralName        = '%sgram square %smeters per square %ssecond per %skelvin';
    const FPrefixes          : TPrefixes  = (pKilo, pNone, pNone, pNone);
    const FExponents         : TExponents = (1, 2, -2, -1);
  end;
  TKilogramSquareMeterPerSquareSecondPerKelvinUnit = specialize TUnit<TKilogramSquareMeterPerSquareSecondPerKelvin>;

type
  { TJoulePerKilogramPerKelvin }

  TJoulePerKilogramPerKelvin = record
    const FUnitOfMeasurement = 98;
    const FSymbol            = '%sJ/%sg/%sK';
    const FName              = '%sjoule per %sgram per %skelvin';
    const FPluralName        = '%sjoules per %sgram per %skelvin';
    const FPrefixes          : TPrefixes  = (pNone, pKilo, pNone);
    const FExponents         : TExponents = (1, -1, -1);
  end;
  TJoulePerKilogramPerKelvinUnit = specialize TUnit<TJoulePerKilogramPerKelvin>;

type
  { TSquareMeterPerSquareSecondPerKelvin }

  TSquareMeterPerSquareSecondPerKelvin = record
    const FUnitOfMeasurement = 98;
    const FSymbol            = '%sm2/%ss2/%sK';
    const FName              = 'square %smeter per square %ssecond per %skelvin';
    const FPluralName        = 'square %smeters per square %ssecond per %skelvin';
    const FPrefixes          : TPrefixes  = (pNone, pNone, pNone);
    const FExponents         : TExponents = (2, -2, -1);
  end;
  TSquareMeterPerSquareSecondPerKelvinUnit = specialize TUnit<TSquareMeterPerSquareSecondPerKelvin>;

type
  { TMeterKelvin }

  TMeterKelvin = record
    const FUnitOfMeasurement = 99;
    const FSymbol            = '%sm.%sK';
    const FName              = '%smeter %skelvin';
    const FPluralName        = '%smeter %skelvins';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (1, 1);
  end;
  TMeterKelvinUnit = specialize TUnit<TMeterKelvin>;

type
  { TKelvinPerMeter }

  TKelvinPerMeter = record
    const FUnitOfMeasurement = 100;
    const FSymbol            = '%sK/%sm';
    const FName              = '%skelvin per %smeter';
    const FPluralName        = '%skelvins per %smeter';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (1, -1);
  end;
  TKelvinPerMeterUnit = specialize TUnit<TKelvinPerMeter>;

type
  { TWattPerMeter }

  TWattPerMeter = record
    const FUnitOfMeasurement = 101;
    const FSymbol            = '%sW/%sm';
    const FName              = '%swatt per %smeter';
    const FPluralName        = '%swatts per %smeter';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (1, -1);
  end;
  TWattPerMeterUnit = specialize TUnit<TWattPerMeter>;

type
  { TKilogramMeterPerCubicSecond }

  TKilogramMeterPerCubicSecond = record
    const FUnitOfMeasurement = 101;
    const FSymbol            = '%sg.%sm/%ss3';
    const FName              = '%sgram %smeter per cubic %ssecond';
    const FPluralName        = '%sgram %smeters per cubic %ssecond';
    const FPrefixes          : TPrefixes  = (pKilo, pNone, pNone);
    const FExponents         : TExponents = (1, 1, -3);
  end;
  TKilogramMeterPerCubicSecondUnit = specialize TUnit<TKilogramMeterPerCubicSecond>;

type
  { TWattPerSquareMeter }

  TWattPerSquareMeter = record
    const FUnitOfMeasurement = 102;
    const FSymbol            = '%sW/%sm2';
    const FName              = '%swatt per square %smeter';
    const FPluralName        = '%swatts per square %smeter';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (1, -2);
  end;
  TWattPerSquareMeterUnit = specialize TUnit<TWattPerSquareMeter>;

type
  { TKilogramPerCubicSecond }

  TKilogramPerCubicSecond = record
    const FUnitOfMeasurement = 102;
    const FSymbol            = '%sg/%ss3';
    const FName              = '%sgram per cubic %ssecond';
    const FPluralName        = '%sgrams per cubic %ssecond';
    const FPrefixes          : TPrefixes  = (pKilo, pNone);
    const FExponents         : TExponents = (1, -3);
  end;
  TKilogramPerCubicSecondUnit = specialize TUnit<TKilogramPerCubicSecond>;

type
  { TWattPerCubicMeter }

  TWattPerCubicMeter = record
    const FUnitOfMeasurement = 103;
    const FSymbol            = '%sW/%sm3';
    const FName              = '%swatt per cubic %smeter';
    const FPluralName        = '%swatts per cubic %smeter';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (1, -3);
  end;
  TWattPerCubicMeterUnit = specialize TUnit<TWattPerCubicMeter>;

type
  { TWattPerKelvin }

  TWattPerKelvin = record
    const FUnitOfMeasurement = 104;
    const FSymbol            = '%sW/%sK';
    const FName              = '%swatt per %skelvin';
    const FPluralName        = '%swatts per %skelvin';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (1, -1);
  end;
  TWattPerKelvinUnit = specialize TUnit<TWattPerKelvin>;

type
  { TKilogramSquareMeterPerCubicSecondPerKelvin }

  TKilogramSquareMeterPerCubicSecondPerKelvin = record
    const FUnitOfMeasurement = 104;
    const FSymbol            = '%sg.%sm2/%ss3/%sK';
    const FName              = '%sgram square %smeter per cubic %ssecond per %skelvin';
    const FPluralName        = '%sgram square %smeters per cubic %ssecond per %skelvin';
    const FPrefixes          : TPrefixes  = (pKilo, pNone, pNone, pNone);
    const FExponents         : TExponents = (1, 2, -3, -1);
  end;
  TKilogramSquareMeterPerCubicSecondPerKelvinUnit = specialize TUnit<TKilogramSquareMeterPerCubicSecondPerKelvin>;

type
  { TWattPerMeterPerKelvin }

  TWattPerMeterPerKelvin = record
    const FUnitOfMeasurement = 105;
    const FSymbol            = '%sW/%sm/%sK';
    const FName              = '%swatt per %smeter per %skelvin';
    const FPluralName        = '%swatts per %smeter per %skelvin';
    const FPrefixes          : TPrefixes  = (pNone, pNone, pNone);
    const FExponents         : TExponents = (1, -1, -1);
  end;
  TWattPerMeterPerKelvinUnit = specialize TUnit<TWattPerMeterPerKelvin>;

type
  { TKilogramMeterPerCubicSecondPerKelvin }

  TKilogramMeterPerCubicSecondPerKelvin = record
    const FUnitOfMeasurement = 105;
    const FSymbol            = '%sg.%sm/%ss3/%sK';
    const FName              = '%sgram %smeter per cubic %ssecond per %skelvin';
    const FPluralName        = '%sgram %smeters per cubic %ssecond per %skelvin';
    const FPrefixes          : TPrefixes  = (pKilo, pNone, pNone, pNone);
    const FExponents         : TExponents = (1, 1, -3, -1);
  end;
  TKilogramMeterPerCubicSecondPerKelvinUnit = specialize TUnit<TKilogramMeterPerCubicSecondPerKelvin>;

type
  { TKelvinPerWatt }

  TKelvinPerWatt = record
    const FUnitOfMeasurement = 106;
    const FSymbol            = '%sK/%sW';
    const FName              = '%skelvin per %swatt';
    const FPluralName        = '%skelvins per %swatt';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (1, -1);
  end;
  TKelvinPerWattUnit = specialize TUnit<TKelvinPerWatt>;

type
  { TMeterPerWatt }

  TMeterPerWatt = record
    const FUnitOfMeasurement = 107;
    const FSymbol            = '%sm/%sW';
    const FName              = '%smeter per %swatt';
    const FPluralName        = '%smeters per %swatts';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (1, -1);
  end;
  TMeterPerWattUnit = specialize TUnit<TMeterPerWatt>;

type
  { TMeterKelvinPerWatt }

  TMeterKelvinPerWatt = record
    const FUnitOfMeasurement = 108;
    const FSymbol            = '%sK.%sm/%sW';
    const FName              = '%skelvin %smeter per %swatt';
    const FPluralName        = '%skelvin %smeters per %swatt';
    const FPrefixes          : TPrefixes  = (pNone, pNone, pNone);
    const FExponents         : TExponents = (1, 1, -1);
  end;
  TMeterKelvinPerWattUnit = specialize TUnit<TMeterKelvinPerWatt>;

type
  { TSquareMeterKelvin }

  TSquareMeterKelvin = record
    const FUnitOfMeasurement = 109;
    const FSymbol            = '%sm2.%sK';
    const FName              = 'square %smeter %skelvin';
    const FPluralName        = 'square %smeter %skelvins';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (2, 1);
  end;
  TSquareMeterKelvinUnit = specialize TUnit<TSquareMeterKelvin>;

type
  { TWattPerSquareMeterPerKelvin }

  TWattPerSquareMeterPerKelvin = record
    const FUnitOfMeasurement = 110;
    const FSymbol            = '%sW/%sm2/%sK';
    const FName              = '%swatt per square %smeter per %skelvin';
    const FPluralName        = '%swatts per square %smeter per %skelvin';
    const FPrefixes          : TPrefixes  = (pNone, pNone, pNone);
    const FExponents         : TExponents = (1, -2, -1);
  end;
  TWattPerSquareMeterPerKelvinUnit = specialize TUnit<TWattPerSquareMeterPerKelvin>;

type
  { TKilogramPerCubicSecondPerKelvin }

  TKilogramPerCubicSecondPerKelvin = record
    const FUnitOfMeasurement = 110;
    const FSymbol            = '%sg/%ss3/%sK';
    const FName              = '%sgram per cubic %ssecond per %skelvin';
    const FPluralName        = '%sgrams per cubic %ssecond per %skelvin';
    const FPrefixes          : TPrefixes  = (pKilo, pNone, pNone);
    const FExponents         : TExponents = (1, -3, -1);
  end;
  TKilogramPerCubicSecondPerKelvinUnit = specialize TUnit<TKilogramPerCubicSecondPerKelvin>;

type
  { TSquareMeterQuarticKelvin }

  TSquareMeterQuarticKelvin = record
    const FUnitOfMeasurement = 111;
    const FSymbol            = '%sm2.%sK4';
    const FName              = 'square %smeter quartic %skelvin';
    const FPluralName        = 'square %smeter quartic %skelvins';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (2, 4);
  end;
  TSquareMeterQuarticKelvinUnit = specialize TUnit<TSquareMeterQuarticKelvin>;

type
  { TWattPerQuarticKelvin }

  TWattPerQuarticKelvin = record
    const FUnitOfMeasurement = 112;
    const FSymbol            = '%sW/%sK4';
    const FName              = '%swatt per quartic %skelvin';
    const FPluralName        = '%swatts per quartic %skelvin';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (1, -4);
  end;
  TWattPerQuarticKelvinUnit = specialize TUnit<TWattPerQuarticKelvin>;

type
  { TWattPerSquareMeterPerQuarticKelvin }

  TWattPerSquareMeterPerQuarticKelvin = record
    const FUnitOfMeasurement = 113;
    const FSymbol            = '%sW/%sm2/%sK4';
    const FName              = '%swatt per square %smeter per quartic %skelvin';
    const FPluralName        = '%swatts per square %smeter per quartic %skelvin';
    const FPrefixes          : TPrefixes  = (pNone, pNone, pNone);
    const FExponents         : TExponents = (1, -2, -4);
  end;
  TWattPerSquareMeterPerQuarticKelvinUnit = specialize TUnit<TWattPerSquareMeterPerQuarticKelvin>;

type
  { TJoulePerMole }

  TJoulePerMole = record
    const FUnitOfMeasurement = 114;
    const FSymbol            = '%sJ/%smol';
    const FName              = '%sjoule per %smole';
    const FPluralName        = '%sjoules per %smole';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (1, -1);
  end;
  TJoulePerMoleUnit = specialize TUnit<TJoulePerMole>;

type
  { TMoleKelvin }

  TMoleKelvin = record
    const FUnitOfMeasurement = 115;
    const FSymbol            = '%smol.%sK';
    const FName              = '%smole %skelvin';
    const FPluralName        = '%smole %skelvins';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (1, 1);
  end;
  TMoleKelvinUnit = specialize TUnit<TMoleKelvin>;

type
  { TJoulePerMolePerKelvin }

  TJoulePerMolePerKelvin = record
    const FUnitOfMeasurement = 116;
    const FSymbol            = '%sJ/%smol/%sK';
    const FName              = '%sjoule per %smole per %skelvin';
    const FPluralName        = '%sjoules per %smole per %skelvin';
    const FPrefixes          : TPrefixes  = (pNone, pNone, pNone);
    const FExponents         : TExponents = (1, -1, -1);
  end;
  TJoulePerMolePerKelvinUnit = specialize TUnit<TJoulePerMolePerKelvin>;

type
  { TOhmMeter }

  TOhmMeter = record
    const FUnitOfMeasurement = 117;
    const FSymbol            = '%sΩ.%sm';
    const FName              = '%sohm %smeter';
    const FPluralName        = '%sohm %smeters';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (1, 1);
  end;
  TOhmMeterUnit = specialize TUnit<TOhmMeter>;

type
  { TVoltPerMeter }

  TVoltPerMeter = record
    const FUnitOfMeasurement = 118;
    const FSymbol            = '%sV/%sm';
    const FName              = '%svolt per %smeter';
    const FPluralName        = '%svolts per %smeter';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (1, -1);
  end;
  TVoltPerMeterUnit = specialize TUnit<TVoltPerMeter>;

type
  { TNewtonPerCoulomb }

  TNewtonPerCoulomb = record
    const FUnitOfMeasurement = 118;
    const FSymbol            = '%sN/%sC';
    const FName              = '%snewton per %scoulomb';
    const FPluralName        = '%snewtons per %scoulomb';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (1, -1);
  end;
  TNewtonPerCoulombUnit = specialize TUnit<TNewtonPerCoulomb>;

type
  { TCoulombPerMeter }

  TCoulombPerMeter = record
    const FUnitOfMeasurement = 119;
    const FSymbol            = '%sC/%sm';
    const FName              = '%scoulomb per %smeter';
    const FPluralName        = '%scoulombs per %smeter';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (1, -1);
  end;
  TCoulombPerMeterUnit = specialize TUnit<TCoulombPerMeter>;

type
  { TSquareCoulombPerMeter }

  TSquareCoulombPerMeter = record
    const FUnitOfMeasurement = 120;
    const FSymbol            = '%sC2/%sm';
    const FName              = 'square %scoulomb per %smeter';
    const FPluralName        = 'square %scoulombs per %smeter';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (2, -1);
  end;
  TSquareCoulombPerMeterUnit = specialize TUnit<TSquareCoulombPerMeter>;

type
  { TCoulombPerSquareMeter }

  TCoulombPerSquareMeter = record
    const FUnitOfMeasurement = 121;
    const FSymbol            = '%sC/%sm2';
    const FName              = '%scoulomb per square %smeter';
    const FPluralName        = '%scoulombs per square %smeter';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (1, -2);
  end;
  TCoulombPerSquareMeterUnit = specialize TUnit<TCoulombPerSquareMeter>;

type
  { TSquareMeterPerSquareCoulomb }

  TSquareMeterPerSquareCoulomb = record
    const FUnitOfMeasurement = 122;
    const FSymbol            = '%sm2/%sC2';
    const FName              = 'square %smeter per square %scoulomb';
    const FPluralName        = 'square %smeters per square %scoulomb';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (2, -2);
  end;
  TSquareMeterPerSquareCoulombUnit = specialize TUnit<TSquareMeterPerSquareCoulomb>;

type
  { TNewtonPerSquareCoulomb }

  TNewtonPerSquareCoulomb = record
    const FUnitOfMeasurement = 123;
    const FSymbol            = '%sN/%sC2';
    const FName              = '%snewton per square %scoulomb';
    const FPluralName        = '%snewtons per square %scoulomb';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (1, -2);
  end;
  TNewtonPerSquareCoulombUnit = specialize TUnit<TNewtonPerSquareCoulomb>;

type
  { TNewtonSquareMeterPerSquareCoulomb }

  TNewtonSquareMeterPerSquareCoulomb = record
    const FUnitOfMeasurement = 124;
    const FSymbol            = '%sN.%sm2/%sC2';
    const FName              = '%snewton square %smeter per square %scoulomb';
    const FPluralName        = '%snewton square %smeters per square %scoulomb';
    const FPrefixes          : TPrefixes  = (pNone, pNone, pNone);
    const FExponents         : TExponents = (1, 2, -2);
  end;
  TNewtonSquareMeterPerSquareCoulombUnit = specialize TUnit<TNewtonSquareMeterPerSquareCoulomb>;

type
  { TVoltMeter }

  TVoltMeter = record
    const FUnitOfMeasurement = 125;
    const FSymbol            = '%sV.%sm';
    const FName              = '%svolt %smeter';
    const FPluralName        = '%svolt %smeters';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (1, 1);
  end;
  TVoltMeterUnit = specialize TUnit<TVoltMeter>;

type
  { TNewtonSquareMeterPerCoulomb }

  TNewtonSquareMeterPerCoulomb = record
    const FUnitOfMeasurement = 125;
    const FSymbol            = '%sN.%sm2/%sC';
    const FName              = '%snewton square %smeter per %scoulomb';
    const FPluralName        = '%snewton square %smeters per %scoulomb';
    const FPrefixes          : TPrefixes  = (pNone, pNone, pNone);
    const FExponents         : TExponents = (1, 2, -1);
  end;
  TNewtonSquareMeterPerCoulombUnit = specialize TUnit<TNewtonSquareMeterPerCoulomb>;

type
  { TVoltMeterPerSecond }

  TVoltMeterPerSecond = record
    const FUnitOfMeasurement = 126;
    const FSymbol            = '%sV.%sm/%ss';
    const FName              = '%svolt %smeter per %ssecond';
    const FPluralName        = '%svolt %smeters per %ssecond';
    const FPrefixes          : TPrefixes  = (pNone, pNone, pNone);
    const FExponents         : TExponents = (1, 1, -1);
  end;
  TVoltMeterPerSecondUnit = specialize TUnit<TVoltMeterPerSecond>;

type
  { TFaradPerMeter }

  TFaradPerMeter = record
    const FUnitOfMeasurement = 127;
    const FSymbol            = '%sF/%sm';
    const FName              = '%sfarad per %smeter';
    const FPluralName        = '%sfarads per %smeter';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (1, -1);
  end;
  TFaradPerMeterUnit = specialize TUnit<TFaradPerMeter>;

type
  { TAmperePerMeter }

  TAmperePerMeter = record
    const FUnitOfMeasurement = 128;
    const FSymbol            = '%sA/%sm';
    const FName              = '%sampere per %smeter';
    const FPluralName        = '%samperes per %smeter';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (1, -1);
  end;
  TAmperePerMeterUnit = specialize TUnit<TAmperePerMeter>;

type
  { TMeterPerAmpere }

  TMeterPerAmpere = record
    const FUnitOfMeasurement = 129;
    const FSymbol            = '%sm/%sA';
    const FName              = '%smeter per %sampere';
    const FPluralName        = '%smeters per %sampere';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (1, -1);
  end;
  TMeterPerAmpereUnit = specialize TUnit<TMeterPerAmpere>;

type
  { TTeslaMeter }

  TTeslaMeter = record
    const FUnitOfMeasurement = 130;
    const FSymbol            = '%sT.%sm';
    const FName              = '%stesla %smeter';
    const FPluralName        = '%stesla %smeters';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (1, 1);
  end;
  TTeslaMeterUnit = specialize TUnit<TTeslaMeter>;

type
  { TNewtonPerAmpere }

  TNewtonPerAmpere = record
    const FUnitOfMeasurement = 130;
    const FSymbol            = '%sN/%sA';
    const FName              = '%snewton per %sampere';
    const FPluralName        = '%snewtons per %sampere';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (1, -1);
  end;
  TNewtonPerAmpereUnit = specialize TUnit<TNewtonPerAmpere>;

type
  { TTeslaPerAmpere }

  TTeslaPerAmpere = record
    const FUnitOfMeasurement = 131;
    const FSymbol            = '%sT/%sA';
    const FName              = '%stesla per %sampere';
    const FPluralName        = '%steslas per %sampere';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (1, -1);
  end;
  TTeslaPerAmpereUnit = specialize TUnit<TTeslaPerAmpere>;

type
  { THenryPerMeter }

  THenryPerMeter = record
    const FUnitOfMeasurement = 132;
    const FSymbol            = '%sH/%sm';
    const FName              = '%shenry per %smeter';
    const FPluralName        = '%shenries per %smeter';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (1, -1);
  end;
  THenryPerMeterUnit = specialize TUnit<THenryPerMeter>;

type
  { TTeslaMeterPerAmpere }

  TTeslaMeterPerAmpere = record
    const FUnitOfMeasurement = 132;
    const FSymbol            = '%sT.%sm/%sA';
    const FName              = '%stesla %smeter per %sampere';
    const FPluralName        = '%stesla %smeters per %sampere';
    const FPrefixes          : TPrefixes  = (pNone, pNone, pNone);
    const FExponents         : TExponents = (1, 1, -1);
  end;
  TTeslaMeterPerAmpereUnit = specialize TUnit<TTeslaMeterPerAmpere>;

type
  { TNewtonPerSquareAmpere }

  TNewtonPerSquareAmpere = record
    const FUnitOfMeasurement = 132;
    const FSymbol            = '%sN/%sA2';
    const FName              = '%snewton per square %sampere';
    const FPluralName        = '%snewtons per square %sampere';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (1, -2);
  end;
  TNewtonPerSquareAmpereUnit = specialize TUnit<TNewtonPerSquareAmpere>;

type
  { TRadianPerMeter }

  TRadianPerMeter = record
    const FUnitOfMeasurement = 133;
    const FSymbol            = 'rad/%sm';
    const FName              = 'radian per %smeter';
    const FPluralName        = 'radians per %smeter';
    const FPrefixes          : TPrefixes  = (pNone);
    const FExponents         : TExponents = (-1);
  end;
  TRadianPerMeterUnit = specialize TUnit<TRadianPerMeter>;

type
  { TSquareKilogramPerSquareSecond }

  TSquareKilogramPerSquareSecond = record
    const FUnitOfMeasurement = 134;
    const FSymbol            = '%sg2/%ss2';
    const FName              = 'square %sgram per square %ssecond';
    const FPluralName        = 'square %sgrams per square %ssecond';
    const FPrefixes          : TPrefixes  = (pKilo, pNone);
    const FExponents         : TExponents = (2, -2);
  end;
  TSquareKilogramPerSquareSecondUnit = specialize TUnit<TSquareKilogramPerSquareSecond>;

type
  { TSquareSecondPerSquareMeter }

  TSquareSecondPerSquareMeter = record
    const FUnitOfMeasurement = 135;
    const FSymbol            = '%ss2/%sm2';
    const FName              = 'square %ssecond per square %smeter';
    const FPluralName        = 'square %sseconds per square %smeter';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (2, -2);
  end;
  TSquareSecondPerSquareMeterUnit = specialize TUnit<TSquareSecondPerSquareMeter>;

type
  { TSquareJoule }

  TSquareJoule = record
    const FUnitOfMeasurement = 136;
    const FSymbol            = '%sJ2';
    const FName              = 'square %sjoule';
    const FPluralName        = 'square %sjoules';
    const FPrefixes          : TPrefixes  = (pNone);
    const FExponents         : TExponents = (2);
  end;
  TSquareJouleUnit = specialize TUnit<TSquareJoule>;

var
  J2         : TSquareJouleUnit;

const
  TJ2        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 136; FValue: 1E+24); {$ELSE} (1E+24); {$ENDIF}
  GJ2        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 136; FValue: 1E+18); {$ELSE} (1E+18); {$ENDIF}
  MJ2        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 136; FValue: 1E+12); {$ELSE} (1E+12); {$ENDIF}
  kJ2        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 136; FValue: 1E+06); {$ELSE} (1E+06); {$ENDIF}

type
  { TJouleSecond }

  TJouleSecond = record
    const FUnitOfMeasurement = 46;
    const FSymbol            = '%sJ.%ss';
    const FName              = '%sjoule %ssecond';
    const FPluralName        = '%sjoule %sseconds';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (1, 1);
  end;
  TJouleSecondUnit = specialize TUnit<TJouleSecond>;

type
  { TJoulePerHertz }

  TJoulePerHertz = record
    const FUnitOfMeasurement = 46;
    const FSymbol            = '%sJ/%sHz';
    const FName              = '%sjoule per %shertz';
    const FPluralName        = '%sjoules per %shertz';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (1, -1);
  end;
  TJoulePerHertzUnit = specialize TUnit<TJoulePerHertz>;

type
  { TElectronvoltSecond }

  TElectronvoltSecond = record
    const FUnitOfMeasurement = 0;
    const FSymbol            = '%seV.%ss';
    const FName              = '%selectronvolt %ssecond';
    const FPluralName        = '%selectronvolt %sseconds';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (1, 1);
    const FFactor = 1.60217742320523E-019;
  end;
  TElectronvoltSecondUnit = specialize TUnit<TElectronvoltSecond>;

type
  { TElectronvoltMeterPerSpeedOfLight }

  TElectronvoltMeterPerSpeedOfLight = record
    const FUnitOfMeasurement = 0;
    const FSymbol            = '%seV.%sm/c';
    const FName              = '%selectronvolt %smeter per speed of  light';
    const FPluralName        = '%selectronvolt %smeters per speed of  light';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (1, 1);
    const FFactor = 1.7826619216279E-36;
  end;
  TElectronvoltMeterPerSpeedOfLightUnit = specialize TUnit<TElectronvoltMeterPerSpeedOfLight>;

type
  { TSquareJouleSquareSecond }

  TSquareJouleSquareSecond = record
    const FUnitOfMeasurement = 137;
    const FSymbol            = '%sJ2.%ss2';
    const FName              = 'square %sjoule square %ssecond';
    const FPluralName        = 'square %sjoule square %sseconds';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (2, 2);
  end;
  TSquareJouleSquareSecondUnit = specialize TUnit<TSquareJouleSquareSecond>;

type
  { TCoulombPerKilogram }

  TCoulombPerKilogram = record
    const FUnitOfMeasurement = 138;
    const FSymbol            = '%sC/%sg';
    const FName              = '%scoulomb per %sgram';
    const FPluralName        = '%scoulombs per %sgram';
    const FPrefixes          : TPrefixes  = (pNone, pKilo);
    const FExponents         : TExponents = (1, -1);
  end;
  TCoulombPerKilogramUnit = specialize TUnit<TCoulombPerKilogram>;

type
  { TSquareMeterAmpere }

  TSquareMeterAmpere = record
    const FUnitOfMeasurement = 139;
    const FSymbol            = '%sm2.%sA';
    const FName              = 'square %smeter %sampere';
    const FPluralName        = 'square %smeter %samperes';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (2, 1);
  end;
  TSquareMeterAmpereUnit = specialize TUnit<TSquareMeterAmpere>;

type
  { TJoulePerTesla }

  TJoulePerTesla = record
    const FUnitOfMeasurement = 139;
    const FSymbol            = '%sJ/%sT';
    const FName              = '%sjoule per %stesla';
    const FPluralName        = '%sjoules per %stesla';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (1, -1);
  end;
  TJoulePerTeslaUnit = specialize TUnit<TJoulePerTesla>;

type
  { TLumenPerWatt }

  TLumenPerWatt = record
    const FUnitOfMeasurement = 140;
    const FSymbol            = '%slm/%sW';
    const FName              = '%slumen per %swatt';
    const FPluralName        = '%slumens per %swatt';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (1, -1);
  end;
  TLumenPerWattUnit = specialize TUnit<TLumenPerWatt>;

type
  { TReciprocalMole }

  TReciprocalMole = record
    const FUnitOfMeasurement = 141;
    const FSymbol            = '1/%smol';
    const FName              = 'reciprocal %smole';
    const FPluralName        = 'reciprocal %smoles';
    const FPrefixes          : TPrefixes  = (pNone);
    const FExponents         : TExponents = (-1);
  end;
  TReciprocalMoleUnit = specialize TUnit<TReciprocalMole>;

type
  { TAmperePerSquareMeter }

  TAmperePerSquareMeter = record
    const FUnitOfMeasurement = 142;
    const FSymbol            = '%sA/%sm2';
    const FName              = '%sampere per square %smeter';
    const FPluralName        = '%samperes per square %smeter';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (1, -2);
  end;
  TAmperePerSquareMeterUnit = specialize TUnit<TAmperePerSquareMeter>;

type
  { TMolePerCubicMeter }

  TMolePerCubicMeter = record
    const FUnitOfMeasurement = 143;
    const FSymbol            = '%smol/%sm3';
    const FName              = '%smole per cubic %smeter';
    const FPluralName        = '%smoles per cubic %smeter';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (1, -3);
  end;
  TMolePerCubicMeterUnit = specialize TUnit<TMolePerCubicMeter>;

type
  { TCandelaPerSquareMeter }

  TCandelaPerSquareMeter = record
    const FUnitOfMeasurement = 144;
    const FSymbol            = '%scd/%sm2';
    const FName              = '%scandela per square %smeter';
    const FPluralName        = '%scandelas per square %smeter';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (1, -2);
  end;
  TCandelaPerSquareMeterUnit = specialize TUnit<TCandelaPerSquareMeter>;

type
  { TCoulombPerCubicMeter }

  TCoulombPerCubicMeter = record
    const FUnitOfMeasurement = 145;
    const FSymbol            = '%sC/%sm3';
    const FName              = '%scoulomb per cubic %smeter';
    const FPluralName        = '%scoulombs per cubic %smeter';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (1, -3);
  end;
  TCoulombPerCubicMeterUnit = specialize TUnit<TCoulombPerCubicMeter>;

type
  { TGrayPerSecond }

  TGrayPerSecond = record
    const FUnitOfMeasurement = 146;
    const FSymbol            = '%sGy/%ss';
    const FName              = '%sgray per %ssecond';
    const FPluralName        = '%sgrays per %ssecond';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (1, -1);
  end;
  TGrayPerSecondUnit = specialize TUnit<TGrayPerSecond>;

type
  { TSteradianHertz }

  TSteradianHertz = record
    const FUnitOfMeasurement = 147;
    const FSymbol            = 'sr.%sHz';
    const FName              = 'steradian %shertz';
    const FPluralName        = 'steradian %shertz';
    const FPrefixes          : TPrefixes  = (pNone);
    const FExponents         : TExponents = (1);
  end;
  TSteradianHertzUnit = specialize TUnit<TSteradianHertz>;

type
  { TMeterSteradian }

  TMeterSteradian = record
    const FUnitOfMeasurement = 148;
    const FSymbol            = '%sm.sr';
    const FName              = '%smeter steradian';
    const FPluralName        = '%smeter steradians';
    const FPrefixes          : TPrefixes  = (pNone);
    const FExponents         : TExponents = (1);
  end;
  TMeterSteradianUnit = specialize TUnit<TMeterSteradian>;

type
  { TSquareMeterSteradian }

  TSquareMeterSteradian = record
    const FUnitOfMeasurement = 149;
    const FSymbol            = '%sm2.sr';
    const FName              = 'square %smeter steradian';
    const FPluralName        = 'square %smeter steradians';
    const FPrefixes          : TPrefixes  = (pNone);
    const FExponents         : TExponents = (2);
  end;
  TSquareMeterSteradianUnit = specialize TUnit<TSquareMeterSteradian>;

type
  { TCubicMeterSteradian }

  TCubicMeterSteradian = record
    const FUnitOfMeasurement = 150;
    const FSymbol            = '%sm3.sr';
    const FName              = 'cubic %smeter steradian';
    const FPluralName        = 'cubic %smeter steradians';
    const FPrefixes          : TPrefixes  = (pNone);
    const FExponents         : TExponents = (3);
  end;
  TCubicMeterSteradianUnit = specialize TUnit<TCubicMeterSteradian>;

type
  { TSquareMeterSteradianHertz }

  TSquareMeterSteradianHertz = record
    const FUnitOfMeasurement = 151;
    const FSymbol            = '%sm2.sr.%shertz';
    const FName              = 'square %smeter steradian %shertz';
    const FPluralName        = 'square %smeter steradian %shertz';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (2, 1);
  end;
  TSquareMeterSteradianHertzUnit = specialize TUnit<TSquareMeterSteradianHertz>;

type
  { TWattPerSteradian }

  TWattPerSteradian = record
    const FUnitOfMeasurement = 152;
    const FSymbol            = '%sW/sr';
    const FName              = '%swatt per steradian';
    const FPluralName        = '%swatts per steradian';
    const FPrefixes          : TPrefixes  = (pNone);
    const FExponents         : TExponents = (1);
  end;
  TWattPerSteradianUnit = specialize TUnit<TWattPerSteradian>;

type
  { TWattPerSteradianPerHertz }

  TWattPerSteradianPerHertz = record
    const FUnitOfMeasurement = 153;
    const FSymbol            = '%sW/sr/%sHz';
    const FName              = '%swatt per steradian per %shertz';
    const FPluralName        = '%swatts per steradian per %shertz';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (1, -1);
  end;
  TWattPerSteradianPerHertzUnit = specialize TUnit<TWattPerSteradianPerHertz>;

type
  { TWattPerMeterPerSteradian }

  TWattPerMeterPerSteradian = record
    const FUnitOfMeasurement = 154;
    const FSymbol            = '%sW/sr/%sm';
    const FName              = '%swatt per steradian per %smeter';
    const FPluralName        = '%swatts per steradian per %smeter';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (1, -1);
  end;
  TWattPerMeterPerSteradianUnit = specialize TUnit<TWattPerMeterPerSteradian>;

type
  { TWattPerSquareMeterPerSteradian }

  TWattPerSquareMeterPerSteradian = record
    const FUnitOfMeasurement = 155;
    const FSymbol            = '%sW/%sm2/sr';
    const FName              = '%swatt per square %smeter per steradian';
    const FPluralName        = '%swatts per square %smeter per steradian';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (1, -2);
  end;
  TWattPerSquareMeterPerSteradianUnit = specialize TUnit<TWattPerSquareMeterPerSteradian>;

type
  { TWattPerCubicMeterPerSteradian }

  TWattPerCubicMeterPerSteradian = record
    const FUnitOfMeasurement = 156;
    const FSymbol            = '%sW/%sm3/sr';
    const FName              = '%swatt per cubic %smeter per steradian';
    const FPluralName        = '%swatts per cubic %smeter per steradian';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (1, -3);
  end;
  TWattPerCubicMeterPerSteradianUnit = specialize TUnit<TWattPerCubicMeterPerSteradian>;

type
  { TWattPerSquareMeterPerSteradianPerHertz }

  TWattPerSquareMeterPerSteradianPerHertz = record
    const FUnitOfMeasurement = 157;
    const FSymbol            = '%sW/%sm2/sr/%sHz';
    const FName              = '%swatt per square %smeter per steradian per %shertz';
    const FPluralName        = '%swatts per square %smeter per steradian per %shertz';
    const FPrefixes          : TPrefixes  = (pNone, pNone, pNone);
    const FExponents         : TExponents = (1, -2, -1);
  end;
  TWattPerSquareMeterPerSteradianPerHertzUnit = specialize TUnit<TWattPerSquareMeterPerSteradianPerHertz>;

type
  { TKatalPerCubicMeter }

  TKatalPerCubicMeter = record
    const FUnitOfMeasurement = 158;
    const FSymbol            = '%skat/%sm3';
    const FName              = '%skatal per cubic %smeter';
    const FPluralName        = '%skatals per cubic %smeter';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (1, -3);
  end;
  TKatalPerCubicMeterUnit = specialize TUnit<TKatalPerCubicMeter>;

type
  { TCoulombPerMole }

  TCoulombPerMole = record
    const FUnitOfMeasurement = 159;
    const FSymbol            = '%sC/%smol';
    const FName              = '%scoulomb per %smole';
    const FPluralName        = '%scoulombs per %smole';
    const FPrefixes          : TPrefixes  = (pNone, pNone);
    const FExponents         : TExponents = (1, -1);
  end;
  TCoulombPerMoleUnit = specialize TUnit<TCoulombPerMole>;

const
  AvogadroConstant               : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 141; FValue:       6.02214076E+23); {$ELSE} (      6.02214076E+23); {$ENDIF}
  BohrMagneton                   : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 139; FValue:     9.2740100657E-24); {$ELSE} (    9.2740100657E-24); {$ENDIF}
  BohrRadius                     : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 7; FValue:    5.29177210903E-11); {$ELSE} (   5.29177210903E-11); {$ENDIF}
  BoltzmannConstant              : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 97; FValue:         1.380649E-23); {$ELSE} (        1.380649E-23); {$ENDIF}
  ComptonWaveLength              : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 7; FValue:    2.42631023867E-12); {$ELSE} (   2.42631023867E-12); {$ENDIF}
  CoulombConstant                : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 124; FValue:      8.9875517923E+9); {$ELSE} (     8.9875517923E+9); {$ENDIF}
  DeuteronMass                   : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 14; FValue:     3.3435837768E-27); {$ELSE} (    3.3435837768E-27); {$ENDIF}
  ElectricPermittivity           : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 127; FValue:     8.8541878128E-12); {$ELSE} (    8.8541878128E-12); {$ENDIF}
  ElectronMass                   : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 14; FValue:     9.1093837015E-31); {$ELSE} (    9.1093837015E-31); {$ENDIF}
  ElectronCharge                 : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 58; FValue:      1.602176634E-19); {$ELSE} (     1.602176634E-19); {$ENDIF}
  MagneticPermeability           : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 132; FValue:     1.25663706212E-6); {$ELSE} (    1.25663706212E-6); {$ENDIF}
  MolarGasConstant               : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 116; FValue:          8.314462618); {$ELSE} (         8.314462618); {$ENDIF}
  NeutronMass                    : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 14; FValue:    1.67492750056E-27); {$ELSE} (   1.67492750056E-27); {$ENDIF}
  NewtonianConstantOfGravitation : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 94; FValue:          6.67430E-11); {$ELSE} (         6.67430E-11); {$ENDIF}
  PlanckConstant                 : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 46; FValue:       6.62607015E-34); {$ELSE} (      6.62607015E-34); {$ENDIF}
  ProtonMass                     : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 14; FValue:    1.67262192595E-27); {$ELSE} (   1.67262192595E-27); {$ENDIF}
  RydbergConstant                : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 40; FValue:      10973731.568157); {$ELSE} (     10973731.568157); {$ENDIF}
  SpeedOfLight                   : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 27; FValue:            299792458); {$ELSE} (           299792458); {$ENDIF}
  SquaredSpeedOfLight            : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 33; FValue: 8.98755178736818E+16); {$ELSE} (8.98755178736818E+16); {$ENDIF}
  StandardAccelerationOfGravity  : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 28; FValue:              9.80665); {$ELSE} (             9.80665); {$ENDIF}
  ReducedPlanckConstant          : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 46; FValue:  6.62607015E-34/2/pi); {$ELSE} ( 6.62607015E-34/2/pi); {$ENDIF}
  UnifiedAtomicMassUnit          : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: 14; FValue:    1.66053906892E-27); {$ELSE} (   1.66053906892E-27); {$ENDIF}

const
  PrefixTable: array[pQuetta..pQuecto] of
    record  Symbol, Name: string; Exponent: longint end = (
    (Symbol: 'Q';   Name: 'quetta';  Exponent: +30),
    (Symbol: 'R';   Name: 'ronna';   Exponent: +27),
    (Symbol: 'Y';   Name: 'yotta';   Exponent: +24),
    (Symbol: 'Z';   Name: 'zetta';   Exponent: +21),
    (Symbol: 'E';   Name: 'exa';     Exponent: +18),
    (Symbol: 'P';   Name: 'peta';    Exponent: +15),
    (Symbol: 'T';   Name: 'tera';    Exponent: +12),
    (Symbol: 'G';   Name: 'giga';    Exponent: +09),
    (Symbol: 'M';   Name: 'mega';    Exponent: +06),
    (Symbol: 'k';   Name: 'kilo';    Exponent: +03),
    (Symbol: 'h';   Name: 'hecto';   Exponent: +02),
    (Symbol: 'da';  Name: 'deca';    Exponent: +01),
    (Symbol: '';    Name: '';        Exponent:  00),
    (Symbol: 'd';   Name: 'deci';    Exponent: -01),
    (Symbol: 'c';   Name: 'centi';   Exponent: -02),
    (Symbol: 'm';   Name: 'milli';   Exponent: -03),
    (Symbol: 'μ';   Name: 'micro';   Exponent: -06),
    (Symbol: 'n';   Name: 'nano';    Exponent: -09),
    (Symbol: 'p';   Name: 'pico';    Exponent: -12),
    (Symbol: 'f';   Name: 'femto';   Exponent: -15),
    (Symbol: 'a';   Name: 'atto';    Exponent: -18),
    (Symbol: 'z';   Name: 'zepto';   Exponent: -21),
    (Symbol: 'y';   Name: 'yocto';   Exponent: -24),
    (Symbol: 'r';   Name: 'ronto';   Exponent: -27),
    (Symbol: 'q';   Name: 'quecto';  Exponent: -30)
  );

{ Helpers }

function ScalarToString(const AValue: TQuantity): string;
function ScalarToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ScalarToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ScalarToVerboseString(const AValue: TQuantity): string;
function ScalarToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ScalarToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ScalarToFloat(const AValue: TQuantity): double;
function ScalarToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function RadianToString(const AValue: TQuantity): string;
function RadianToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function RadianToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function RadianToVerboseString(const AValue: TQuantity): string;
function RadianToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function RadianToFloat(const AValue: TQuantity): double;
function RadianToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function DegreeToString(const AValue: TQuantity): string;
function DegreeToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function cDegreeToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function DegreeToVerboseString(const AValue: TQuantity): string;
function DegreeToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function DegreeToFloat(const AValue: TQuantity): double;
function DegreeToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function SteradianToString(const AValue: TQuantity): string;
function SteradianToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SteradianToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SteradianToVerboseString(const AValue: TQuantity): string;
function SteradianToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SteradianToFloat(const AValue: TQuantity): double;
function SteradianToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function SquareDegreeToString(const AValue: TQuantity): string;
function SquareDegreeToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function cSquareDegreeToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareDegreeToVerboseString(const AValue: TQuantity): string;
function SquareDegreeToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareDegreeToFloat(const AValue: TQuantity): double;
function SquareDegreeToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function SecondToString(const AValue: TQuantity): string;
function SecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SecondToVerboseString(const AValue: TQuantity): string;
function SecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SecondToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SecondToFloat(const AValue: TQuantity): double;
function SecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function DayToString(const AValue: TQuantity): string;
function DayToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function cDayToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function DayToVerboseString(const AValue: TQuantity): string;
function DayToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function DayToFloat(const AValue: TQuantity): double;
function DayToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function HourToString(const AValue: TQuantity): string;
function HourToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function cHourToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function HourToVerboseString(const AValue: TQuantity): string;
function HourToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function HourToFloat(const AValue: TQuantity): double;
function HourToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function MinuteToString(const AValue: TQuantity): string;
function MinuteToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function cMinuteToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MinuteToVerboseString(const AValue: TQuantity): string;
function MinuteToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MinuteToFloat(const AValue: TQuantity): double;
function MinuteToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function SquareSecondToString(const AValue: TQuantity): string;
function SquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareSecondToVerboseString(const AValue: TQuantity): string;
function SquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareSecondToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareSecondToFloat(const AValue: TQuantity): double;
function SquareSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function SquareDayToString(const AValue: TQuantity): string;
function SquareDayToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function cSquareDayToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareDayToVerboseString(const AValue: TQuantity): string;
function SquareDayToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareDayToFloat(const AValue: TQuantity): double;
function SquareDayToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function SquareHourToString(const AValue: TQuantity): string;
function SquareHourToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function cSquareHourToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareHourToVerboseString(const AValue: TQuantity): string;
function SquareHourToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareHourToFloat(const AValue: TQuantity): double;
function SquareHourToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function SquareMinuteToString(const AValue: TQuantity): string;
function SquareMinuteToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function cSquareMinuteToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareMinuteToVerboseString(const AValue: TQuantity): string;
function SquareMinuteToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareMinuteToFloat(const AValue: TQuantity): double;
function SquareMinuteToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function CubicSecondToString(const AValue: TQuantity): string;
function CubicSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CubicSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CubicSecondToVerboseString(const AValue: TQuantity): string;
function CubicSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CubicSecondToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CubicSecondToFloat(const AValue: TQuantity): double;
function CubicSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function QuarticSecondToString(const AValue: TQuantity): string;
function QuarticSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function QuarticSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function QuarticSecondToVerboseString(const AValue: TQuantity): string;
function QuarticSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function QuarticSecondToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function QuarticSecondToFloat(const AValue: TQuantity): double;
function QuarticSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function QuinticSecondToString(const AValue: TQuantity): string;
function QuinticSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function QuinticSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function QuinticSecondToVerboseString(const AValue: TQuantity): string;
function QuinticSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function QuinticSecondToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function QuinticSecondToFloat(const AValue: TQuantity): double;
function QuinticSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function SexticSecondToString(const AValue: TQuantity): string;
function SexticSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SexticSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SexticSecondToVerboseString(const AValue: TQuantity): string;
function SexticSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SexticSecondToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SexticSecondToFloat(const AValue: TQuantity): double;
function SexticSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function MeterToString(const AValue: TQuantity): string;
function MeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterToVerboseString(const AValue: TQuantity): string;
function MeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterToFloat(const AValue: TQuantity): double;
function MeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function AstronomicalToString(const AValue: TQuantity): string;
function AstronomicalToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function cAstronomicalToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function AstronomicalToVerboseString(const AValue: TQuantity): string;
function AstronomicalToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function AstronomicalToFloat(const AValue: TQuantity): double;
function AstronomicalToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function InchToString(const AValue: TQuantity): string;
function InchToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function cInchToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function InchToVerboseString(const AValue: TQuantity): string;
function InchToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function InchToFloat(const AValue: TQuantity): double;
function InchToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function FootToString(const AValue: TQuantity): string;
function FootToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function cFootToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function FootToVerboseString(const AValue: TQuantity): string;
function FootToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function FootToFloat(const AValue: TQuantity): double;
function FootToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function YardToString(const AValue: TQuantity): string;
function YardToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function cYardToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function YardToVerboseString(const AValue: TQuantity): string;
function YardToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function YardToFloat(const AValue: TQuantity): double;
function YardToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function MileToString(const AValue: TQuantity): string;
function MileToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function cMileToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MileToVerboseString(const AValue: TQuantity): string;
function MileToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MileToFloat(const AValue: TQuantity): double;
function MileToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function NauticalMileToString(const AValue: TQuantity): string;
function NauticalMileToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function cNauticalMileToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NauticalMileToVerboseString(const AValue: TQuantity): string;
function NauticalMileToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NauticalMileToFloat(const AValue: TQuantity): double;
function NauticalMileToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function AngstromToString(const AValue: TQuantity): string;
function AngstromToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function cAngstromToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function AngstromToVerboseString(const AValue: TQuantity): string;
function AngstromToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function AngstromToFloat(const AValue: TQuantity): double;
function AngstromToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function SquareRootMeterToString(const AValue: TQuantity): string;
function SquareRootMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareRootMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareRootMeterToVerboseString(const AValue: TQuantity): string;
function SquareRootMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareRootMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareRootMeterToFloat(const AValue: TQuantity): double;
function SquareRootMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function SquareMeterToString(const AValue: TQuantity): string;
function SquareMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareMeterToVerboseString(const AValue: TQuantity): string;
function SquareMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareMeterToFloat(const AValue: TQuantity): double;
function SquareMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function SquareInchToString(const AValue: TQuantity): string;
function SquareInchToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function cSquareInchToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareInchToVerboseString(const AValue: TQuantity): string;
function SquareInchToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareInchToFloat(const AValue: TQuantity): double;
function SquareInchToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function SquareFootToString(const AValue: TQuantity): string;
function SquareFootToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function cSquareFootToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareFootToVerboseString(const AValue: TQuantity): string;
function SquareFootToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareFootToFloat(const AValue: TQuantity): double;
function SquareFootToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function SquareYardToString(const AValue: TQuantity): string;
function SquareYardToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function cSquareYardToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareYardToVerboseString(const AValue: TQuantity): string;
function SquareYardToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareYardToFloat(const AValue: TQuantity): double;
function SquareYardToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function SquareMileToString(const AValue: TQuantity): string;
function SquareMileToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function cSquareMileToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareMileToVerboseString(const AValue: TQuantity): string;
function SquareMileToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareMileToFloat(const AValue: TQuantity): double;
function SquareMileToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function CubicMeterToString(const AValue: TQuantity): string;
function CubicMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CubicMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CubicMeterToVerboseString(const AValue: TQuantity): string;
function CubicMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CubicMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CubicMeterToFloat(const AValue: TQuantity): double;
function CubicMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function CubicInchToString(const AValue: TQuantity): string;
function CubicInchToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function cCubicInchToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CubicInchToVerboseString(const AValue: TQuantity): string;
function CubicInchToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CubicInchToFloat(const AValue: TQuantity): double;
function CubicInchToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function CubicFootToString(const AValue: TQuantity): string;
function CubicFootToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function cCubicFootToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CubicFootToVerboseString(const AValue: TQuantity): string;
function CubicFootToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CubicFootToFloat(const AValue: TQuantity): double;
function CubicFootToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function CubicYardToString(const AValue: TQuantity): string;
function CubicYardToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function cCubicYardToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CubicYardToVerboseString(const AValue: TQuantity): string;
function CubicYardToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CubicYardToFloat(const AValue: TQuantity): double;
function CubicYardToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function LitreToString(const AValue: TQuantity): string;
function LitreToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function cLitreToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function LitreToVerboseString(const AValue: TQuantity): string;
function LitreToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function LitreToFloat(const AValue: TQuantity): double;
function LitreToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function GallonToString(const AValue: TQuantity): string;
function GallonToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function cGallonToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function GallonToVerboseString(const AValue: TQuantity): string;
function GallonToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function GallonToFloat(const AValue: TQuantity): double;
function GallonToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function QuarticMeterToString(const AValue: TQuantity): string;
function QuarticMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function QuarticMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function QuarticMeterToVerboseString(const AValue: TQuantity): string;
function QuarticMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function QuarticMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function QuarticMeterToFloat(const AValue: TQuantity): double;
function QuarticMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function QuinticMeterToString(const AValue: TQuantity): string;
function QuinticMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function QuinticMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function QuinticMeterToVerboseString(const AValue: TQuantity): string;
function QuinticMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function QuinticMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function QuinticMeterToFloat(const AValue: TQuantity): double;
function QuinticMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function SexticMeterToString(const AValue: TQuantity): string;
function SexticMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SexticMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SexticMeterToVerboseString(const AValue: TQuantity): string;
function SexticMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SexticMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SexticMeterToFloat(const AValue: TQuantity): double;
function SexticMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function KilogramToString(const AValue: TQuantity): string;
function KilogramToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramToVerboseString(const AValue: TQuantity): string;
function KilogramToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramToFloat(const AValue: TQuantity): double;
function KilogramToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function TonneToString(const AValue: TQuantity): string;
function TonneToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function cTonneToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function TonneToVerboseString(const AValue: TQuantity): string;
function TonneToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function TonneToFloat(const AValue: TQuantity): double;
function TonneToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function PoundToString(const AValue: TQuantity): string;
function PoundToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function cPoundToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function PoundToVerboseString(const AValue: TQuantity): string;
function PoundToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function PoundToFloat(const AValue: TQuantity): double;
function PoundToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function OunceToString(const AValue: TQuantity): string;
function OunceToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function cOunceToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function OunceToVerboseString(const AValue: TQuantity): string;
function OunceToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function OunceToFloat(const AValue: TQuantity): double;
function OunceToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function StoneToString(const AValue: TQuantity): string;
function StoneToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function cStoneToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function StoneToVerboseString(const AValue: TQuantity): string;
function StoneToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function StoneToFloat(const AValue: TQuantity): double;
function StoneToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function TonToString(const AValue: TQuantity): string;
function TonToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function cTonToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function TonToVerboseString(const AValue: TQuantity): string;
function TonToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function TonToFloat(const AValue: TQuantity): double;
function TonToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function ElectronvoltPerSquareSpeedOfLightToString(const AValue: TQuantity): string;
function ElectronvoltPerSquareSpeedOfLightToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function cElectronvoltPerSquareSpeedOfLightToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ElectronvoltPerSquareSpeedOfLightToVerboseString(const AValue: TQuantity): string;
function ElectronvoltPerSquareSpeedOfLightToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ElectronvoltPerSquareSpeedOfLightToFloat(const AValue: TQuantity): double;
function ElectronvoltPerSquareSpeedOfLightToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function SquareKilogramToString(const AValue: TQuantity): string;
function SquareKilogramToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareKilogramToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareKilogramToVerboseString(const AValue: TQuantity): string;
function SquareKilogramToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareKilogramToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareKilogramToFloat(const AValue: TQuantity): double;
function SquareKilogramToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function AmpereToString(const AValue: TQuantity): string;
function AmpereToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function AmpereToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function AmpereToVerboseString(const AValue: TQuantity): string;
function AmpereToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function AmpereToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function AmpereToFloat(const AValue: TQuantity): double;
function AmpereToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function SquareAmpereToString(const AValue: TQuantity): string;
function SquareAmpereToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareAmpereToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareAmpereToVerboseString(const AValue: TQuantity): string;
function SquareAmpereToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareAmpereToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareAmpereToFloat(const AValue: TQuantity): double;
function SquareAmpereToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function KelvinToString(const AValue: TQuantity): string;
function KelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KelvinToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KelvinToVerboseString(const AValue: TQuantity): string;
function KelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KelvinToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KelvinToFloat(const AValue: TQuantity): double;
function KelvinToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function SquareKelvinToString(const AValue: TQuantity): string;
function SquareKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareKelvinToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareKelvinToVerboseString(const AValue: TQuantity): string;
function SquareKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareKelvinToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareKelvinToFloat(const AValue: TQuantity): double;
function SquareKelvinToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function CubicKelvinToString(const AValue: TQuantity): string;
function CubicKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CubicKelvinToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CubicKelvinToVerboseString(const AValue: TQuantity): string;
function CubicKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CubicKelvinToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CubicKelvinToFloat(const AValue: TQuantity): double;
function CubicKelvinToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function QuarticKelvinToString(const AValue: TQuantity): string;
function QuarticKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function QuarticKelvinToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function QuarticKelvinToVerboseString(const AValue: TQuantity): string;
function QuarticKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function QuarticKelvinToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function QuarticKelvinToFloat(const AValue: TQuantity): double;
function QuarticKelvinToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function MoleToString(const AValue: TQuantity): string;
function MoleToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MoleToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MoleToVerboseString(const AValue: TQuantity): string;
function MoleToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MoleToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MoleToFloat(const AValue: TQuantity): double;
function MoleToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function CandelaToString(const AValue: TQuantity): string;
function CandelaToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CandelaToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CandelaToVerboseString(const AValue: TQuantity): string;
function CandelaToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CandelaToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CandelaToFloat(const AValue: TQuantity): double;
function CandelaToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function HertzToString(const AValue: TQuantity): string;
function HertzToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function HertzToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function HertzToVerboseString(const AValue: TQuantity): string;
function HertzToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function HertzToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function HertzToFloat(const AValue: TQuantity): double;
function HertzToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function ReciprocalSecondToString(const AValue: TQuantity): string;
function ReciprocalSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ReciprocalSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ReciprocalSecondToVerboseString(const AValue: TQuantity): string;
function ReciprocalSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ReciprocalSecondToFloat(const AValue: TQuantity): double;
function ReciprocalSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function RadianPerSecondToString(const AValue: TQuantity): string;
function RadianPerSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function RadianPerSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function RadianPerSecondToVerboseString(const AValue: TQuantity): string;
function RadianPerSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function RadianPerSecondToFloat(const AValue: TQuantity): double;
function RadianPerSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function SquareHertzToString(const AValue: TQuantity): string;
function SquareHertzToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareHertzToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareHertzToVerboseString(const AValue: TQuantity): string;
function SquareHertzToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareHertzToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareHertzToFloat(const AValue: TQuantity): double;
function SquareHertzToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function ReciprocalSquareSecondToString(const AValue: TQuantity): string;
function ReciprocalSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ReciprocalSquareSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ReciprocalSquareSecondToVerboseString(const AValue: TQuantity): string;
function ReciprocalSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ReciprocalSquareSecondToFloat(const AValue: TQuantity): double;
function ReciprocalSquareSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function RadianPerSquareSecondToString(const AValue: TQuantity): string;
function RadianPerSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function RadianPerSquareSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function RadianPerSquareSecondToVerboseString(const AValue: TQuantity): string;
function RadianPerSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function RadianPerSquareSecondToFloat(const AValue: TQuantity): double;
function RadianPerSquareSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function SteradianPerSquareSecondToString(const AValue: TQuantity): string;
function SteradianPerSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SteradianPerSquareSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SteradianPerSquareSecondToVerboseString(const AValue: TQuantity): string;
function SteradianPerSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SteradianPerSquareSecondToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SteradianPerSquareSecondToFloat(const AValue: TQuantity): double;
function SteradianPerSquareSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function MeterPerSecondToString(const AValue: TQuantity): string;
function MeterPerSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterPerSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterPerSecondToVerboseString(const AValue: TQuantity): string;
function MeterPerSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterPerSecondToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterPerSecondToFloat(const AValue: TQuantity): double;
function MeterPerSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function MeterPerHourToString(const AValue: TQuantity): string;
function MeterPerHourToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function cMeterPerHourToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterPerHourToVerboseString(const AValue: TQuantity): string;
function MeterPerHourToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterPerHourToFloat(const AValue: TQuantity): double;
function MeterPerHourToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function MilePerHourToString(const AValue: TQuantity): string;
function MilePerHourToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function cMilePerHourToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MilePerHourToVerboseString(const AValue: TQuantity): string;
function MilePerHourToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MilePerHourToFloat(const AValue: TQuantity): double;
function MilePerHourToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function NauticalMilePerHourToString(const AValue: TQuantity): string;
function NauticalMilePerHourToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function cNauticalMilePerHourToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NauticalMilePerHourToVerboseString(const AValue: TQuantity): string;
function NauticalMilePerHourToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NauticalMilePerHourToFloat(const AValue: TQuantity): double;
function NauticalMilePerHourToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function MeterPerSquareSecondToString(const AValue: TQuantity): string;
function MeterPerSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterPerSquareSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterPerSquareSecondToVerboseString(const AValue: TQuantity): string;
function MeterPerSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterPerSquareSecondToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterPerSquareSecondToFloat(const AValue: TQuantity): double;
function MeterPerSquareSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function MeterPerSecondPerSecondToString(const AValue: TQuantity): string;
function MeterPerSecondPerSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterPerSecondPerSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterPerSecondPerSecondToVerboseString(const AValue: TQuantity): string;
function MeterPerSecondPerSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterPerSecondPerSecondToFloat(const AValue: TQuantity): double;
function MeterPerSecondPerSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function MeterPerHourPerSecondToString(const AValue: TQuantity): string;
function MeterPerHourPerSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function cMeterPerHourPerSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterPerHourPerSecondToVerboseString(const AValue: TQuantity): string;
function MeterPerHourPerSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterPerHourPerSecondToFloat(const AValue: TQuantity): double;
function MeterPerHourPerSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function MeterPerCubicSecondToString(const AValue: TQuantity): string;
function MeterPerCubicSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterPerCubicSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterPerCubicSecondToVerboseString(const AValue: TQuantity): string;
function MeterPerCubicSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterPerCubicSecondToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterPerCubicSecondToFloat(const AValue: TQuantity): double;
function MeterPerCubicSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function MeterPerQuarticSecondToString(const AValue: TQuantity): string;
function MeterPerQuarticSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterPerQuarticSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterPerQuarticSecondToVerboseString(const AValue: TQuantity): string;
function MeterPerQuarticSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterPerQuarticSecondToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterPerQuarticSecondToFloat(const AValue: TQuantity): double;
function MeterPerQuarticSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function MeterPerQuinticSecondToString(const AValue: TQuantity): string;
function MeterPerQuinticSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterPerQuinticSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterPerQuinticSecondToVerboseString(const AValue: TQuantity): string;
function MeterPerQuinticSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterPerQuinticSecondToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterPerQuinticSecondToFloat(const AValue: TQuantity): double;
function MeterPerQuinticSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function MeterPerSexticSecondToString(const AValue: TQuantity): string;
function MeterPerSexticSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterPerSexticSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterPerSexticSecondToVerboseString(const AValue: TQuantity): string;
function MeterPerSexticSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterPerSexticSecondToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterPerSexticSecondToFloat(const AValue: TQuantity): double;
function MeterPerSexticSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function SquareMeterPerSquareSecondToString(const AValue: TQuantity): string;
function SquareMeterPerSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareMeterPerSquareSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareMeterPerSquareSecondToVerboseString(const AValue: TQuantity): string;
function SquareMeterPerSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareMeterPerSquareSecondToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareMeterPerSquareSecondToFloat(const AValue: TQuantity): double;
function SquareMeterPerSquareSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function JoulePerKilogramToString(const AValue: TQuantity): string;
function JoulePerKilogramToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function JoulePerKilogramToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function JoulePerKilogramToVerboseString(const AValue: TQuantity): string;
function JoulePerKilogramToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function JoulePerKilogramToFloat(const AValue: TQuantity): double;
function JoulePerKilogramToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function GrayToString(const AValue: TQuantity): string;
function GrayToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function GrayToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function GrayToVerboseString(const AValue: TQuantity): string;
function GrayToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function GrayToFloat(const AValue: TQuantity): double;
function GrayToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function SievertToString(const AValue: TQuantity): string;
function SievertToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SievertToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SievertToVerboseString(const AValue: TQuantity): string;
function SievertToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SievertToFloat(const AValue: TQuantity): double;
function SievertToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function MeterSecondToString(const AValue: TQuantity): string;
function MeterSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterSecondToVerboseString(const AValue: TQuantity): string;
function MeterSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterSecondToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterSecondToFloat(const AValue: TQuantity): double;
function MeterSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function KilogramMeterToString(const AValue: TQuantity): string;
function KilogramMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramMeterToVerboseString(const AValue: TQuantity): string;
function KilogramMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramMeterToFloat(const AValue: TQuantity): double;
function KilogramMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function KilogramPerSecondToString(const AValue: TQuantity): string;
function KilogramPerSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramPerSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramPerSecondToVerboseString(const AValue: TQuantity): string;
function KilogramPerSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramPerSecondToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramPerSecondToFloat(const AValue: TQuantity): double;
function KilogramPerSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function JoulePerSquareMeterPerHertzToString(const AValue: TQuantity): string;
function JoulePerSquareMeterPerHertzToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function JoulePerSquareMeterPerHertzToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function JoulePerSquareMeterPerHertzToVerboseString(const AValue: TQuantity): string;
function JoulePerSquareMeterPerHertzToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function JoulePerSquareMeterPerHertzToFloat(const AValue: TQuantity): double;
function JoulePerSquareMeterPerHertzToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function KilogramMeterPerSecondToString(const AValue: TQuantity): string;
function KilogramMeterPerSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramMeterPerSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramMeterPerSecondToVerboseString(const AValue: TQuantity): string;
function KilogramMeterPerSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramMeterPerSecondToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramMeterPerSecondToFloat(const AValue: TQuantity): double;
function KilogramMeterPerSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function NewtonSecondToString(const AValue: TQuantity): string;
function NewtonSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonSecondToVerboseString(const AValue: TQuantity): string;
function NewtonSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonSecondToFloat(const AValue: TQuantity): double;
function NewtonSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function SquareKilogramSquareMeterPerSquareSecondToString(const AValue: TQuantity): string;
function SquareKilogramSquareMeterPerSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareKilogramSquareMeterPerSquareSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareKilogramSquareMeterPerSquareSecondToVerboseString(const AValue: TQuantity): string;
function SquareKilogramSquareMeterPerSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareKilogramSquareMeterPerSquareSecondToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareKilogramSquareMeterPerSquareSecondToFloat(const AValue: TQuantity): double;
function SquareKilogramSquareMeterPerSquareSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function ReciprocalSquareRootMeterToString(const AValue: TQuantity): string;
function ReciprocalSquareRootMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ReciprocalSquareRootMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ReciprocalSquareRootMeterToVerboseString(const AValue: TQuantity): string;
function ReciprocalSquareRootMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ReciprocalSquareRootMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ReciprocalSquareRootMeterToFloat(const AValue: TQuantity): double;
function ReciprocalSquareRootMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function ReciprocalMeterToString(const AValue: TQuantity): string;
function ReciprocalMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ReciprocalMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ReciprocalMeterToVerboseString(const AValue: TQuantity): string;
function ReciprocalMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ReciprocalMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ReciprocalMeterToFloat(const AValue: TQuantity): double;
function ReciprocalMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function DioptreToString(const AValue: TQuantity): string;
function DioptreToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function DioptreToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function DioptreToVerboseString(const AValue: TQuantity): string;
function DioptreToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function DioptreToFloat(const AValue: TQuantity): double;
function DioptreToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function ReciprocalSquareRootCubicMeterToString(const AValue: TQuantity): string;
function ReciprocalSquareRootCubicMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ReciprocalSquareRootCubicMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ReciprocalSquareRootCubicMeterToVerboseString(const AValue: TQuantity): string;
function ReciprocalSquareRootCubicMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ReciprocalSquareRootCubicMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ReciprocalSquareRootCubicMeterToFloat(const AValue: TQuantity): double;
function ReciprocalSquareRootCubicMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function ReciprocalSquareMeterToString(const AValue: TQuantity): string;
function ReciprocalSquareMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ReciprocalSquareMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ReciprocalSquareMeterToVerboseString(const AValue: TQuantity): string;
function ReciprocalSquareMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ReciprocalSquareMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ReciprocalSquareMeterToFloat(const AValue: TQuantity): double;
function ReciprocalSquareMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function ReciprocalCubicMeterToString(const AValue: TQuantity): string;
function ReciprocalCubicMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ReciprocalCubicMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ReciprocalCubicMeterToVerboseString(const AValue: TQuantity): string;
function ReciprocalCubicMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ReciprocalCubicMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ReciprocalCubicMeterToFloat(const AValue: TQuantity): double;
function ReciprocalCubicMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function ReciprocalQuarticMeterToString(const AValue: TQuantity): string;
function ReciprocalQuarticMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ReciprocalQuarticMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ReciprocalQuarticMeterToVerboseString(const AValue: TQuantity): string;
function ReciprocalQuarticMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ReciprocalQuarticMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ReciprocalQuarticMeterToFloat(const AValue: TQuantity): double;
function ReciprocalQuarticMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function KilogramSquareMeterToString(const AValue: TQuantity): string;
function KilogramSquareMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramSquareMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramSquareMeterToVerboseString(const AValue: TQuantity): string;
function KilogramSquareMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramSquareMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramSquareMeterToFloat(const AValue: TQuantity): double;
function KilogramSquareMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function KilogramSquareMeterPerSecondToString(const AValue: TQuantity): string;
function KilogramSquareMeterPerSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramSquareMeterPerSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramSquareMeterPerSecondToVerboseString(const AValue: TQuantity): string;
function KilogramSquareMeterPerSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramSquareMeterPerSecondToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramSquareMeterPerSecondToFloat(const AValue: TQuantity): double;
function KilogramSquareMeterPerSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function NewtonMeterSecondToString(const AValue: TQuantity): string;
function NewtonMeterSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonMeterSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonMeterSecondToVerboseString(const AValue: TQuantity): string;
function NewtonMeterSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonMeterSecondToFloat(const AValue: TQuantity): double;
function NewtonMeterSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function SecondPerMeterToString(const AValue: TQuantity): string;
function SecondPerMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SecondPerMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SecondPerMeterToVerboseString(const AValue: TQuantity): string;
function SecondPerMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SecondPerMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SecondPerMeterToFloat(const AValue: TQuantity): double;
function SecondPerMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function KilogramPerMeterToString(const AValue: TQuantity): string;
function KilogramPerMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramPerMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramPerMeterToVerboseString(const AValue: TQuantity): string;
function KilogramPerMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramPerMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramPerMeterToFloat(const AValue: TQuantity): double;
function KilogramPerMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function KilogramPerSquareMeterToString(const AValue: TQuantity): string;
function KilogramPerSquareMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramPerSquareMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramPerSquareMeterToVerboseString(const AValue: TQuantity): string;
function KilogramPerSquareMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramPerSquareMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramPerSquareMeterToFloat(const AValue: TQuantity): double;
function KilogramPerSquareMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function KilogramPerCubicMeterToString(const AValue: TQuantity): string;
function KilogramPerCubicMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramPerCubicMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramPerCubicMeterToVerboseString(const AValue: TQuantity): string;
function KilogramPerCubicMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramPerCubicMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramPerCubicMeterToFloat(const AValue: TQuantity): double;
function KilogramPerCubicMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function PoundPerCubicInchToString(const AValue: TQuantity): string;
function PoundPerCubicInchToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function cPoundPerCubicInchToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function PoundPerCubicInchToVerboseString(const AValue: TQuantity): string;
function PoundPerCubicInchToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function PoundPerCubicInchToFloat(const AValue: TQuantity): double;
function PoundPerCubicInchToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function NewtonToString(const AValue: TQuantity): string;
function NewtonToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonToVerboseString(const AValue: TQuantity): string;
function NewtonToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonToFloat(const AValue: TQuantity): double;
function NewtonToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function PoundForceToString(const AValue: TQuantity): string;
function PoundForceToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function cPoundForceToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function PoundForceToVerboseString(const AValue: TQuantity): string;
function PoundForceToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function PoundForceToFloat(const AValue: TQuantity): double;
function PoundForceToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function KilogramMeterPerSquareSecondToString(const AValue: TQuantity): string;
function KilogramMeterPerSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramMeterPerSquareSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramMeterPerSquareSecondToVerboseString(const AValue: TQuantity): string;
function KilogramMeterPerSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramMeterPerSquareSecondToFloat(const AValue: TQuantity): double;
function KilogramMeterPerSquareSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function NewtonRadianToString(const AValue: TQuantity): string;
function NewtonRadianToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonRadianToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonRadianToVerboseString(const AValue: TQuantity): string;
function NewtonRadianToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonRadianToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonRadianToFloat(const AValue: TQuantity): double;
function NewtonRadianToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function SquareNewtonToString(const AValue: TQuantity): string;
function SquareNewtonToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareNewtonToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareNewtonToVerboseString(const AValue: TQuantity): string;
function SquareNewtonToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareNewtonToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareNewtonToFloat(const AValue: TQuantity): double;
function SquareNewtonToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function SquareKilogramSquareMeterPerQuarticSecondToString(const AValue: TQuantity): string;
function SquareKilogramSquareMeterPerQuarticSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareKilogramSquareMeterPerQuarticSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareKilogramSquareMeterPerQuarticSecondToVerboseString(const AValue: TQuantity): string;
function SquareKilogramSquareMeterPerQuarticSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareKilogramSquareMeterPerQuarticSecondToFloat(const AValue: TQuantity): double;
function SquareKilogramSquareMeterPerQuarticSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function PascalToString(const AValue: TQuantity): string;
function PascalToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function PascalToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function PascalToVerboseString(const AValue: TQuantity): string;
function PascalToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function PascalToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function PascalToFloat(const AValue: TQuantity): double;
function PascalToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function NewtonPerSquareMeterToString(const AValue: TQuantity): string;
function NewtonPerSquareMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonPerSquareMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonPerSquareMeterToVerboseString(const AValue: TQuantity): string;
function NewtonPerSquareMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonPerSquareMeterToFloat(const AValue: TQuantity): double;
function NewtonPerSquareMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function BarToString(const AValue: TQuantity): string;
function BarToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function cBarToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function BarToVerboseString(const AValue: TQuantity): string;
function BarToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function BarToFloat(const AValue: TQuantity): double;
function BarToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function PoundPerSquareInchToString(const AValue: TQuantity): string;
function PoundPerSquareInchToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function cPoundPerSquareInchToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function PoundPerSquareInchToVerboseString(const AValue: TQuantity): string;
function PoundPerSquareInchToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function PoundPerSquareInchToFloat(const AValue: TQuantity): double;
function PoundPerSquareInchToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function JoulePerCubicMeterToString(const AValue: TQuantity): string;
function JoulePerCubicMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function JoulePerCubicMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function JoulePerCubicMeterToVerboseString(const AValue: TQuantity): string;
function JoulePerCubicMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function JoulePerCubicMeterToFloat(const AValue: TQuantity): double;
function JoulePerCubicMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function KilogramPerMeterPerSquareSecondToString(const AValue: TQuantity): string;
function KilogramPerMeterPerSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramPerMeterPerSquareSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramPerMeterPerSquareSecondToVerboseString(const AValue: TQuantity): string;
function KilogramPerMeterPerSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramPerMeterPerSquareSecondToFloat(const AValue: TQuantity): double;
function KilogramPerMeterPerSquareSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function JouleToString(const AValue: TQuantity): string;
function JouleToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function JouleToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function JouleToVerboseString(const AValue: TQuantity): string;
function JouleToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function JouleToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function JouleToFloat(const AValue: TQuantity): double;
function JouleToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function WattHourToString(const AValue: TQuantity): string;
function WattHourToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function cWattHourToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattHourToVerboseString(const AValue: TQuantity): string;
function WattHourToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattHourToFloat(const AValue: TQuantity): double;
function WattHourToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function WattSecondToString(const AValue: TQuantity): string;
function WattSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattSecondToVerboseString(const AValue: TQuantity): string;
function WattSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattSecondToFloat(const AValue: TQuantity): double;
function WattSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function WattPerHertzToString(const AValue: TQuantity): string;
function WattPerHertzToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerHertzToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerHertzToVerboseString(const AValue: TQuantity): string;
function WattPerHertzToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerHertzToFloat(const AValue: TQuantity): double;
function WattPerHertzToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function ElectronvoltToString(const AValue: TQuantity): string;
function ElectronvoltToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function cElectronvoltToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ElectronvoltToVerboseString(const AValue: TQuantity): string;
function ElectronvoltToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ElectronvoltToFloat(const AValue: TQuantity): double;
function ElectronvoltToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function NewtonMeterToString(const AValue: TQuantity): string;
function NewtonMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonMeterToVerboseString(const AValue: TQuantity): string;
function NewtonMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonMeterToFloat(const AValue: TQuantity): double;
function NewtonMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function PoundForceInchToString(const AValue: TQuantity): string;
function PoundForceInchToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function cPoundForceInchToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function PoundForceInchToVerboseString(const AValue: TQuantity): string;
function PoundForceInchToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function PoundForceInchToFloat(const AValue: TQuantity): double;
function PoundForceInchToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function RydbergToString(const AValue: TQuantity): string;
function RydbergToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function cRydbergToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function RydbergToVerboseString(const AValue: TQuantity): string;
function RydbergToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function RydbergToFloat(const AValue: TQuantity): double;
function RydbergToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function CalorieToString(const AValue: TQuantity): string;
function CalorieToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function cCalorieToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CalorieToVerboseString(const AValue: TQuantity): string;
function CalorieToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CalorieToFloat(const AValue: TQuantity): double;
function CalorieToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function KilogramSquareMeterPerSquareSecondToString(const AValue: TQuantity): string;
function KilogramSquareMeterPerSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramSquareMeterPerSquareSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramSquareMeterPerSquareSecondToVerboseString(const AValue: TQuantity): string;
function KilogramSquareMeterPerSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramSquareMeterPerSquareSecondToFloat(const AValue: TQuantity): double;
function KilogramSquareMeterPerSquareSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function JoulePerRadianToString(const AValue: TQuantity): string;
function JoulePerRadianToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function JoulePerRadianToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function JoulePerRadianToVerboseString(const AValue: TQuantity): string;
function JoulePerRadianToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function JoulePerRadianToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function JoulePerRadianToFloat(const AValue: TQuantity): double;
function JoulePerRadianToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function JoulePerDegreeToString(const AValue: TQuantity): string;
function JoulePerDegreeToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function cJoulePerDegreeToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function JoulePerDegreeToVerboseString(const AValue: TQuantity): string;
function JoulePerDegreeToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function JoulePerDegreeToFloat(const AValue: TQuantity): double;
function JoulePerDegreeToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function NewtonMeterPerRadianToString(const AValue: TQuantity): string;
function NewtonMeterPerRadianToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonMeterPerRadianToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonMeterPerRadianToVerboseString(const AValue: TQuantity): string;
function NewtonMeterPerRadianToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonMeterPerRadianToFloat(const AValue: TQuantity): double;
function NewtonMeterPerRadianToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function NewtonMeterPerDegreeToString(const AValue: TQuantity): string;
function NewtonMeterPerDegreeToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function cNewtonMeterPerDegreeToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonMeterPerDegreeToVerboseString(const AValue: TQuantity): string;
function NewtonMeterPerDegreeToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonMeterPerDegreeToFloat(const AValue: TQuantity): double;
function NewtonMeterPerDegreeToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function KilogramSquareMeterPerSquareSecondPerRadianToString(const AValue: TQuantity): string;
function KilogramSquareMeterPerSquareSecondPerRadianToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramSquareMeterPerSquareSecondPerRadianToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramSquareMeterPerSquareSecondPerRadianToVerboseString(const AValue: TQuantity): string;
function KilogramSquareMeterPerSquareSecondPerRadianToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramSquareMeterPerSquareSecondPerRadianToFloat(const AValue: TQuantity): double;
function KilogramSquareMeterPerSquareSecondPerRadianToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function WattToString(const AValue: TQuantity): string;
function WattToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattToVerboseString(const AValue: TQuantity): string;
function WattToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattToFloat(const AValue: TQuantity): double;
function WattToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function KilogramSquareMeterPerCubicSecondToString(const AValue: TQuantity): string;
function KilogramSquareMeterPerCubicSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramSquareMeterPerCubicSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramSquareMeterPerCubicSecondToVerboseString(const AValue: TQuantity): string;
function KilogramSquareMeterPerCubicSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramSquareMeterPerCubicSecondToFloat(const AValue: TQuantity): double;
function KilogramSquareMeterPerCubicSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function CoulombToString(const AValue: TQuantity): string;
function CoulombToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CoulombToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CoulombToVerboseString(const AValue: TQuantity): string;
function CoulombToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CoulombToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CoulombToFloat(const AValue: TQuantity): double;
function CoulombToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function AmpereHourToString(const AValue: TQuantity): string;
function AmpereHourToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function cAmpereHourToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function AmpereHourToVerboseString(const AValue: TQuantity): string;
function AmpereHourToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function AmpereHourToFloat(const AValue: TQuantity): double;
function AmpereHourToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function AmpereSecondToString(const AValue: TQuantity): string;
function AmpereSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function AmpereSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function AmpereSecondToVerboseString(const AValue: TQuantity): string;
function AmpereSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function AmpereSecondToFloat(const AValue: TQuantity): double;
function AmpereSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function SquareCoulombToString(const AValue: TQuantity): string;
function SquareCoulombToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareCoulombToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareCoulombToVerboseString(const AValue: TQuantity): string;
function SquareCoulombToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareCoulombToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareCoulombToFloat(const AValue: TQuantity): double;
function SquareCoulombToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function SquareAmpereSquareSecondToString(const AValue: TQuantity): string;
function SquareAmpereSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareAmpereSquareSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareAmpereSquareSecondToVerboseString(const AValue: TQuantity): string;
function SquareAmpereSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareAmpereSquareSecondToFloat(const AValue: TQuantity): double;
function SquareAmpereSquareSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function CoulombMeterToString(const AValue: TQuantity): string;
function CoulombMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CoulombMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CoulombMeterToVerboseString(const AValue: TQuantity): string;
function CoulombMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CoulombMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CoulombMeterToFloat(const AValue: TQuantity): double;
function CoulombMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function VoltToString(const AValue: TQuantity): string;
function VoltToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function VoltToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function VoltToVerboseString(const AValue: TQuantity): string;
function VoltToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function VoltToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function VoltToFloat(const AValue: TQuantity): double;
function VoltToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function JoulePerCoulombToString(const AValue: TQuantity): string;
function JoulePerCoulombToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function JoulePerCoulombToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function JoulePerCoulombToVerboseString(const AValue: TQuantity): string;
function JoulePerCoulombToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function JoulePerCoulombToFloat(const AValue: TQuantity): double;
function JoulePerCoulombToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function KilogramSquareMeterPerAmperePerCubicSecondToString(const AValue: TQuantity): string;
function KilogramSquareMeterPerAmperePerCubicSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramSquareMeterPerAmperePerCubicSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramSquareMeterPerAmperePerCubicSecondToVerboseString(const AValue: TQuantity): string;
function KilogramSquareMeterPerAmperePerCubicSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramSquareMeterPerAmperePerCubicSecondToFloat(const AValue: TQuantity): double;
function KilogramSquareMeterPerAmperePerCubicSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function SquareVoltToString(const AValue: TQuantity): string;
function SquareVoltToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareVoltToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareVoltToVerboseString(const AValue: TQuantity): string;
function SquareVoltToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareVoltToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareVoltToFloat(const AValue: TQuantity): double;
function SquareVoltToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function SquareKilogramQuarticMeterPerSquareAmperePerSexticSecondToString(const AValue: TQuantity): string;
function SquareKilogramQuarticMeterPerSquareAmperePerSexticSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareKilogramQuarticMeterPerSquareAmperePerSexticSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareKilogramQuarticMeterPerSquareAmperePerSexticSecondToVerboseString(const AValue: TQuantity): string;
function SquareKilogramQuarticMeterPerSquareAmperePerSexticSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareKilogramQuarticMeterPerSquareAmperePerSexticSecondToFloat(const AValue: TQuantity): double;
function SquareKilogramQuarticMeterPerSquareAmperePerSexticSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function FaradToString(const AValue: TQuantity): string;
function FaradToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function FaradToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function FaradToVerboseString(const AValue: TQuantity): string;
function FaradToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function FaradToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function FaradToFloat(const AValue: TQuantity): double;
function FaradToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function CoulombPerVoltToString(const AValue: TQuantity): string;
function CoulombPerVoltToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CoulombPerVoltToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CoulombPerVoltToVerboseString(const AValue: TQuantity): string;
function CoulombPerVoltToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CoulombPerVoltToFloat(const AValue: TQuantity): double;
function CoulombPerVoltToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function SquareAmpereQuarticSecondPerKilogramPerSquareMeterToString(const AValue: TQuantity): string;
function SquareAmpereQuarticSecondPerKilogramPerSquareMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareAmpereQuarticSecondPerKilogramPerSquareMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareAmpereQuarticSecondPerKilogramPerSquareMeterToVerboseString(const AValue: TQuantity): string;
function SquareAmpereQuarticSecondPerKilogramPerSquareMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareAmpereQuarticSecondPerKilogramPerSquareMeterToFloat(const AValue: TQuantity): double;
function SquareAmpereQuarticSecondPerKilogramPerSquareMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function OhmToString(const AValue: TQuantity): string;
function OhmToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function OhmToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function OhmToVerboseString(const AValue: TQuantity): string;
function OhmToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function OhmToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function OhmToFloat(const AValue: TQuantity): double;
function OhmToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function KilogramSquareMeterPerSquareAmperePerCubicSecondToString(const AValue: TQuantity): string;
function KilogramSquareMeterPerSquareAmperePerCubicSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramSquareMeterPerSquareAmperePerCubicSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramSquareMeterPerSquareAmperePerCubicSecondToVerboseString(const AValue: TQuantity): string;
function KilogramSquareMeterPerSquareAmperePerCubicSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramSquareMeterPerSquareAmperePerCubicSecondToFloat(const AValue: TQuantity): double;
function KilogramSquareMeterPerSquareAmperePerCubicSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function SiemensToString(const AValue: TQuantity): string;
function SiemensToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SiemensToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SiemensToVerboseString(const AValue: TQuantity): string;
function SiemensToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SiemensToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SiemensToFloat(const AValue: TQuantity): double;
function SiemensToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function SquareAmpereCubicSecondPerKilogramPerSquareMeterToString(const AValue: TQuantity): string;
function SquareAmpereCubicSecondPerKilogramPerSquareMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareAmpereCubicSecondPerKilogramPerSquareMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareAmpereCubicSecondPerKilogramPerSquareMeterToVerboseString(const AValue: TQuantity): string;
function SquareAmpereCubicSecondPerKilogramPerSquareMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareAmpereCubicSecondPerKilogramPerSquareMeterToFloat(const AValue: TQuantity): double;
function SquareAmpereCubicSecondPerKilogramPerSquareMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function SiemensPerMeterToString(const AValue: TQuantity): string;
function SiemensPerMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SiemensPerMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SiemensPerMeterToVerboseString(const AValue: TQuantity): string;
function SiemensPerMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SiemensPerMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SiemensPerMeterToFloat(const AValue: TQuantity): double;
function SiemensPerMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function TeslaToString(const AValue: TQuantity): string;
function TeslaToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function TeslaToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function TeslaToVerboseString(const AValue: TQuantity): string;
function TeslaToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function TeslaToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function TeslaToFloat(const AValue: TQuantity): double;
function TeslaToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function WeberPerSquareMeterToString(const AValue: TQuantity): string;
function WeberPerSquareMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WeberPerSquareMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WeberPerSquareMeterToVerboseString(const AValue: TQuantity): string;
function WeberPerSquareMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WeberPerSquareMeterToFloat(const AValue: TQuantity): double;
function WeberPerSquareMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function KilogramPerAmperePerSquareSecondToString(const AValue: TQuantity): string;
function KilogramPerAmperePerSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramPerAmperePerSquareSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramPerAmperePerSquareSecondToVerboseString(const AValue: TQuantity): string;
function KilogramPerAmperePerSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramPerAmperePerSquareSecondToFloat(const AValue: TQuantity): double;
function KilogramPerAmperePerSquareSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function WeberToString(const AValue: TQuantity): string;
function WeberToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WeberToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WeberToVerboseString(const AValue: TQuantity): string;
function WeberToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WeberToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WeberToFloat(const AValue: TQuantity): double;
function WeberToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function KilogramSquareMeterPerAmperePerSquareSecondToString(const AValue: TQuantity): string;
function KilogramSquareMeterPerAmperePerSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramSquareMeterPerAmperePerSquareSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramSquareMeterPerAmperePerSquareSecondToVerboseString(const AValue: TQuantity): string;
function KilogramSquareMeterPerAmperePerSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramSquareMeterPerAmperePerSquareSecondToFloat(const AValue: TQuantity): double;
function KilogramSquareMeterPerAmperePerSquareSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function HenryToString(const AValue: TQuantity): string;
function HenryToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function HenryToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function HenryToVerboseString(const AValue: TQuantity): string;
function HenryToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function HenryToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function HenryToFloat(const AValue: TQuantity): double;
function HenryToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function KilogramSquareMeterPerSquareAmperePerSquareSecondToString(const AValue: TQuantity): string;
function KilogramSquareMeterPerSquareAmperePerSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramSquareMeterPerSquareAmperePerSquareSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramSquareMeterPerSquareAmperePerSquareSecondToVerboseString(const AValue: TQuantity): string;
function KilogramSquareMeterPerSquareAmperePerSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramSquareMeterPerSquareAmperePerSquareSecondToFloat(const AValue: TQuantity): double;
function KilogramSquareMeterPerSquareAmperePerSquareSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function ReciprocalHenryToString(const AValue: TQuantity): string;
function ReciprocalHenryToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ReciprocalHenryToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ReciprocalHenryToVerboseString(const AValue: TQuantity): string;
function ReciprocalHenryToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ReciprocalHenryToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ReciprocalHenryToFloat(const AValue: TQuantity): double;
function ReciprocalHenryToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function LumenToString(const AValue: TQuantity): string;
function LumenToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function LumenToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function LumenToVerboseString(const AValue: TQuantity): string;
function LumenToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function LumenToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function LumenToFloat(const AValue: TQuantity): double;
function LumenToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function CandelaSteradianToString(const AValue: TQuantity): string;
function CandelaSteradianToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CandelaSteradianToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CandelaSteradianToVerboseString(const AValue: TQuantity): string;
function CandelaSteradianToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CandelaSteradianToFloat(const AValue: TQuantity): double;
function CandelaSteradianToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function LumenSecondToString(const AValue: TQuantity): string;
function LumenSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function LumenSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function LumenSecondToVerboseString(const AValue: TQuantity): string;
function LumenSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function LumenSecondToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function LumenSecondToFloat(const AValue: TQuantity): double;
function LumenSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function LumenSecondPerCubicMeterToString(const AValue: TQuantity): string;
function LumenSecondPerCubicMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function LumenSecondPerCubicMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function LumenSecondPerCubicMeterToVerboseString(const AValue: TQuantity): string;
function LumenSecondPerCubicMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function LumenSecondPerCubicMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function LumenSecondPerCubicMeterToFloat(const AValue: TQuantity): double;
function LumenSecondPerCubicMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function LuxToString(const AValue: TQuantity): string;
function LuxToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function LuxToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function LuxToVerboseString(const AValue: TQuantity): string;
function LuxToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function LuxToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function LuxToFloat(const AValue: TQuantity): double;
function LuxToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function CandelaSteradianPerSquareMeterToString(const AValue: TQuantity): string;
function CandelaSteradianPerSquareMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CandelaSteradianPerSquareMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CandelaSteradianPerSquareMeterToVerboseString(const AValue: TQuantity): string;
function CandelaSteradianPerSquareMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CandelaSteradianPerSquareMeterToFloat(const AValue: TQuantity): double;
function CandelaSteradianPerSquareMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function LuxSecondToString(const AValue: TQuantity): string;
function LuxSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function LuxSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function LuxSecondToVerboseString(const AValue: TQuantity): string;
function LuxSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function LuxSecondToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function LuxSecondToFloat(const AValue: TQuantity): double;
function LuxSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function BequerelToString(const AValue: TQuantity): string;
function BequerelToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function BequerelToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function BequerelToVerboseString(const AValue: TQuantity): string;
function BequerelToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function BequerelToFloat(const AValue: TQuantity): double;
function BequerelToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function KatalToString(const AValue: TQuantity): string;
function KatalToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KatalToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KatalToVerboseString(const AValue: TQuantity): string;
function KatalToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KatalToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KatalToFloat(const AValue: TQuantity): double;
function KatalToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function MolePerSecondToString(const AValue: TQuantity): string;
function MolePerSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MolePerSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MolePerSecondToVerboseString(const AValue: TQuantity): string;
function MolePerSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MolePerSecondToFloat(const AValue: TQuantity): double;
function MolePerSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function NewtonPerCubicMeterToString(const AValue: TQuantity): string;
function NewtonPerCubicMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonPerCubicMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonPerCubicMeterToVerboseString(const AValue: TQuantity): string;
function NewtonPerCubicMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonPerCubicMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonPerCubicMeterToFloat(const AValue: TQuantity): double;
function NewtonPerCubicMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function PascalPerMeterToString(const AValue: TQuantity): string;
function PascalPerMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function PascalPerMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function PascalPerMeterToVerboseString(const AValue: TQuantity): string;
function PascalPerMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function PascalPerMeterToFloat(const AValue: TQuantity): double;
function PascalPerMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function KilogramPerSquareMeterPerSquareSecondToString(const AValue: TQuantity): string;
function KilogramPerSquareMeterPerSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramPerSquareMeterPerSquareSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramPerSquareMeterPerSquareSecondToVerboseString(const AValue: TQuantity): string;
function KilogramPerSquareMeterPerSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramPerSquareMeterPerSquareSecondToFloat(const AValue: TQuantity): double;
function KilogramPerSquareMeterPerSquareSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function NewtonPerMeterToString(const AValue: TQuantity): string;
function NewtonPerMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonPerMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonPerMeterToVerboseString(const AValue: TQuantity): string;
function NewtonPerMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonPerMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonPerMeterToFloat(const AValue: TQuantity): double;
function NewtonPerMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function JoulePerSquareMeterToString(const AValue: TQuantity): string;
function JoulePerSquareMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function JoulePerSquareMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function JoulePerSquareMeterToVerboseString(const AValue: TQuantity): string;
function JoulePerSquareMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function JoulePerSquareMeterToFloat(const AValue: TQuantity): double;
function JoulePerSquareMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function WattPerSquareMeterPerHertzToString(const AValue: TQuantity): string;
function WattPerSquareMeterPerHertzToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerSquareMeterPerHertzToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerSquareMeterPerHertzToVerboseString(const AValue: TQuantity): string;
function WattPerSquareMeterPerHertzToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerSquareMeterPerHertzToFloat(const AValue: TQuantity): double;
function WattPerSquareMeterPerHertzToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function PoundForcePerInchToString(const AValue: TQuantity): string;
function PoundForcePerInchToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function cPoundForcePerInchToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function PoundForcePerInchToVerboseString(const AValue: TQuantity): string;
function PoundForcePerInchToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function PoundForcePerInchToFloat(const AValue: TQuantity): double;
function PoundForcePerInchToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function KilogramPerSquareSecondToString(const AValue: TQuantity): string;
function KilogramPerSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramPerSquareSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramPerSquareSecondToVerboseString(const AValue: TQuantity): string;
function KilogramPerSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramPerSquareSecondToFloat(const AValue: TQuantity): double;
function KilogramPerSquareSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function CubicMeterPerSecondToString(const AValue: TQuantity): string;
function CubicMeterPerSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CubicMeterPerSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CubicMeterPerSecondToVerboseString(const AValue: TQuantity): string;
function CubicMeterPerSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CubicMeterPerSecondToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CubicMeterPerSecondToFloat(const AValue: TQuantity): double;
function CubicMeterPerSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function PoiseuilleToString(const AValue: TQuantity): string;
function PoiseuilleToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function PoiseuilleToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function PoiseuilleToVerboseString(const AValue: TQuantity): string;
function PoiseuilleToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function PoiseuilleToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function PoiseuilleToFloat(const AValue: TQuantity): double;
function PoiseuilleToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function PascalSecondToString(const AValue: TQuantity): string;
function PascalSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function PascalSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function PascalSecondToVerboseString(const AValue: TQuantity): string;
function PascalSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function PascalSecondToFloat(const AValue: TQuantity): double;
function PascalSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function KilogramPerMeterPerSecondToString(const AValue: TQuantity): string;
function KilogramPerMeterPerSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramPerMeterPerSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramPerMeterPerSecondToVerboseString(const AValue: TQuantity): string;
function KilogramPerMeterPerSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramPerMeterPerSecondToFloat(const AValue: TQuantity): double;
function KilogramPerMeterPerSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function SquareMeterPerSecondToString(const AValue: TQuantity): string;
function SquareMeterPerSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareMeterPerSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareMeterPerSecondToVerboseString(const AValue: TQuantity): string;
function SquareMeterPerSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareMeterPerSecondToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareMeterPerSecondToFloat(const AValue: TQuantity): double;
function SquareMeterPerSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function KilogramPerQuarticMeterToString(const AValue: TQuantity): string;
function KilogramPerQuarticMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramPerQuarticMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramPerQuarticMeterToVerboseString(const AValue: TQuantity): string;
function KilogramPerQuarticMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramPerQuarticMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramPerQuarticMeterToFloat(const AValue: TQuantity): double;
function KilogramPerQuarticMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function QuarticMeterSecondToString(const AValue: TQuantity): string;
function QuarticMeterSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function QuarticMeterSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function QuarticMeterSecondToVerboseString(const AValue: TQuantity): string;
function QuarticMeterSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function QuarticMeterSecondToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function QuarticMeterSecondToFloat(const AValue: TQuantity): double;
function QuarticMeterSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function KilogramPerQuarticMeterPerSecondToString(const AValue: TQuantity): string;
function KilogramPerQuarticMeterPerSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramPerQuarticMeterPerSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramPerQuarticMeterPerSecondToVerboseString(const AValue: TQuantity): string;
function KilogramPerQuarticMeterPerSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramPerQuarticMeterPerSecondToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramPerQuarticMeterPerSecondToFloat(const AValue: TQuantity): double;
function KilogramPerQuarticMeterPerSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function CubicMeterPerKilogramToString(const AValue: TQuantity): string;
function CubicMeterPerKilogramToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CubicMeterPerKilogramToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CubicMeterPerKilogramToVerboseString(const AValue: TQuantity): string;
function CubicMeterPerKilogramToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CubicMeterPerKilogramToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CubicMeterPerKilogramToFloat(const AValue: TQuantity): double;
function CubicMeterPerKilogramToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function KilogramSquareSecondToString(const AValue: TQuantity): string;
function KilogramSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramSquareSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramSquareSecondToVerboseString(const AValue: TQuantity): string;
function KilogramSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramSquareSecondToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramSquareSecondToFloat(const AValue: TQuantity): double;
function KilogramSquareSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function CubicMeterPerSquareSecondToString(const AValue: TQuantity): string;
function CubicMeterPerSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CubicMeterPerSquareSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CubicMeterPerSquareSecondToVerboseString(const AValue: TQuantity): string;
function CubicMeterPerSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CubicMeterPerSquareSecondToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CubicMeterPerSquareSecondToFloat(const AValue: TQuantity): double;
function CubicMeterPerSquareSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function NewtonSquareMeterToString(const AValue: TQuantity): string;
function NewtonSquareMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonSquareMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonSquareMeterToVerboseString(const AValue: TQuantity): string;
function NewtonSquareMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonSquareMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonSquareMeterToFloat(const AValue: TQuantity): double;
function NewtonSquareMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function KilogramCubicMeterPerSquareSecondToString(const AValue: TQuantity): string;
function KilogramCubicMeterPerSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramCubicMeterPerSquareSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramCubicMeterPerSquareSecondToVerboseString(const AValue: TQuantity): string;
function KilogramCubicMeterPerSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramCubicMeterPerSquareSecondToFloat(const AValue: TQuantity): double;
function KilogramCubicMeterPerSquareSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function NewtonCubicMeterToString(const AValue: TQuantity): string;
function NewtonCubicMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonCubicMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonCubicMeterToVerboseString(const AValue: TQuantity): string;
function NewtonCubicMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonCubicMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonCubicMeterToFloat(const AValue: TQuantity): double;
function NewtonCubicMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function KilogramQuarticMeterPerSquareSecondToString(const AValue: TQuantity): string;
function KilogramQuarticMeterPerSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramQuarticMeterPerSquareSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramQuarticMeterPerSquareSecondToVerboseString(const AValue: TQuantity): string;
function KilogramQuarticMeterPerSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramQuarticMeterPerSquareSecondToFloat(const AValue: TQuantity): double;
function KilogramQuarticMeterPerSquareSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function NewtonPerSquareKilogramToString(const AValue: TQuantity): string;
function NewtonPerSquareKilogramToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonPerSquareKilogramToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonPerSquareKilogramToVerboseString(const AValue: TQuantity): string;
function NewtonPerSquareKilogramToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonPerSquareKilogramToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonPerSquareKilogramToFloat(const AValue: TQuantity): double;
function NewtonPerSquareKilogramToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function MeterPerKilogramPerSquareSecondToString(const AValue: TQuantity): string;
function MeterPerKilogramPerSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterPerKilogramPerSquareSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterPerKilogramPerSquareSecondToVerboseString(const AValue: TQuantity): string;
function MeterPerKilogramPerSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterPerKilogramPerSquareSecondToFloat(const AValue: TQuantity): double;
function MeterPerKilogramPerSquareSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function SquareKilogramPerMeterToString(const AValue: TQuantity): string;
function SquareKilogramPerMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareKilogramPerMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareKilogramPerMeterToVerboseString(const AValue: TQuantity): string;
function SquareKilogramPerMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareKilogramPerMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareKilogramPerMeterToFloat(const AValue: TQuantity): double;
function SquareKilogramPerMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function SquareKilogramPerSquareMeterToString(const AValue: TQuantity): string;
function SquareKilogramPerSquareMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareKilogramPerSquareMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareKilogramPerSquareMeterToVerboseString(const AValue: TQuantity): string;
function SquareKilogramPerSquareMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareKilogramPerSquareMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareKilogramPerSquareMeterToFloat(const AValue: TQuantity): double;
function SquareKilogramPerSquareMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function SquareMeterPerSquareKilogramToString(const AValue: TQuantity): string;
function SquareMeterPerSquareKilogramToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareMeterPerSquareKilogramToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareMeterPerSquareKilogramToVerboseString(const AValue: TQuantity): string;
function SquareMeterPerSquareKilogramToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareMeterPerSquareKilogramToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareMeterPerSquareKilogramToFloat(const AValue: TQuantity): double;
function SquareMeterPerSquareKilogramToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function NewtonSquareMeterPerSquareKilogramToString(const AValue: TQuantity): string;
function NewtonSquareMeterPerSquareKilogramToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonSquareMeterPerSquareKilogramToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonSquareMeterPerSquareKilogramToVerboseString(const AValue: TQuantity): string;
function NewtonSquareMeterPerSquareKilogramToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonSquareMeterPerSquareKilogramToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonSquareMeterPerSquareKilogramToFloat(const AValue: TQuantity): double;
function NewtonSquareMeterPerSquareKilogramToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function CubicMeterPerKilogramPerSquareSecondToString(const AValue: TQuantity): string;
function CubicMeterPerKilogramPerSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CubicMeterPerKilogramPerSquareSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CubicMeterPerKilogramPerSquareSecondToVerboseString(const AValue: TQuantity): string;
function CubicMeterPerKilogramPerSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CubicMeterPerKilogramPerSquareSecondToFloat(const AValue: TQuantity): double;
function CubicMeterPerKilogramPerSquareSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function ReciprocalKelvinToString(const AValue: TQuantity): string;
function ReciprocalKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ReciprocalKelvinToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ReciprocalKelvinToVerboseString(const AValue: TQuantity): string;
function ReciprocalKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ReciprocalKelvinToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ReciprocalKelvinToFloat(const AValue: TQuantity): double;
function ReciprocalKelvinToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function KilogramKelvinToString(const AValue: TQuantity): string;
function KilogramKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramKelvinToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramKelvinToVerboseString(const AValue: TQuantity): string;
function KilogramKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramKelvinToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramKelvinToFloat(const AValue: TQuantity): double;
function KilogramKelvinToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function JoulePerKelvinToString(const AValue: TQuantity): string;
function JoulePerKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function JoulePerKelvinToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function JoulePerKelvinToVerboseString(const AValue: TQuantity): string;
function JoulePerKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function JoulePerKelvinToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function JoulePerKelvinToFloat(const AValue: TQuantity): double;
function JoulePerKelvinToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function KilogramSquareMeterPerSquareSecondPerKelvinToString(const AValue: TQuantity): string;
function KilogramSquareMeterPerSquareSecondPerKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramSquareMeterPerSquareSecondPerKelvinToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramSquareMeterPerSquareSecondPerKelvinToVerboseString(const AValue: TQuantity): string;
function KilogramSquareMeterPerSquareSecondPerKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramSquareMeterPerSquareSecondPerKelvinToFloat(const AValue: TQuantity): double;
function KilogramSquareMeterPerSquareSecondPerKelvinToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function JoulePerKilogramPerKelvinToString(const AValue: TQuantity): string;
function JoulePerKilogramPerKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function JoulePerKilogramPerKelvinToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function JoulePerKilogramPerKelvinToVerboseString(const AValue: TQuantity): string;
function JoulePerKilogramPerKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function JoulePerKilogramPerKelvinToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function JoulePerKilogramPerKelvinToFloat(const AValue: TQuantity): double;
function JoulePerKilogramPerKelvinToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function SquareMeterPerSquareSecondPerKelvinToString(const AValue: TQuantity): string;
function SquareMeterPerSquareSecondPerKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareMeterPerSquareSecondPerKelvinToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareMeterPerSquareSecondPerKelvinToVerboseString(const AValue: TQuantity): string;
function SquareMeterPerSquareSecondPerKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareMeterPerSquareSecondPerKelvinToFloat(const AValue: TQuantity): double;
function SquareMeterPerSquareSecondPerKelvinToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function MeterKelvinToString(const AValue: TQuantity): string;
function MeterKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterKelvinToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterKelvinToVerboseString(const AValue: TQuantity): string;
function MeterKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterKelvinToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterKelvinToFloat(const AValue: TQuantity): double;
function MeterKelvinToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function KelvinPerMeterToString(const AValue: TQuantity): string;
function KelvinPerMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KelvinPerMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KelvinPerMeterToVerboseString(const AValue: TQuantity): string;
function KelvinPerMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KelvinPerMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KelvinPerMeterToFloat(const AValue: TQuantity): double;
function KelvinPerMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function WattPerMeterToString(const AValue: TQuantity): string;
function WattPerMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerMeterToVerboseString(const AValue: TQuantity): string;
function WattPerMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerMeterToFloat(const AValue: TQuantity): double;
function WattPerMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function KilogramMeterPerCubicSecondToString(const AValue: TQuantity): string;
function KilogramMeterPerCubicSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramMeterPerCubicSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramMeterPerCubicSecondToVerboseString(const AValue: TQuantity): string;
function KilogramMeterPerCubicSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramMeterPerCubicSecondToFloat(const AValue: TQuantity): double;
function KilogramMeterPerCubicSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function WattPerSquareMeterToString(const AValue: TQuantity): string;
function WattPerSquareMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerSquareMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerSquareMeterToVerboseString(const AValue: TQuantity): string;
function WattPerSquareMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerSquareMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerSquareMeterToFloat(const AValue: TQuantity): double;
function WattPerSquareMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function KilogramPerCubicSecondToString(const AValue: TQuantity): string;
function KilogramPerCubicSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramPerCubicSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramPerCubicSecondToVerboseString(const AValue: TQuantity): string;
function KilogramPerCubicSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramPerCubicSecondToFloat(const AValue: TQuantity): double;
function KilogramPerCubicSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function WattPerCubicMeterToString(const AValue: TQuantity): string;
function WattPerCubicMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerCubicMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerCubicMeterToVerboseString(const AValue: TQuantity): string;
function WattPerCubicMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerCubicMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerCubicMeterToFloat(const AValue: TQuantity): double;
function WattPerCubicMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function WattPerKelvinToString(const AValue: TQuantity): string;
function WattPerKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerKelvinToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerKelvinToVerboseString(const AValue: TQuantity): string;
function WattPerKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerKelvinToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerKelvinToFloat(const AValue: TQuantity): double;
function WattPerKelvinToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function KilogramSquareMeterPerCubicSecondPerKelvinToString(const AValue: TQuantity): string;
function KilogramSquareMeterPerCubicSecondPerKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramSquareMeterPerCubicSecondPerKelvinToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramSquareMeterPerCubicSecondPerKelvinToVerboseString(const AValue: TQuantity): string;
function KilogramSquareMeterPerCubicSecondPerKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramSquareMeterPerCubicSecondPerKelvinToFloat(const AValue: TQuantity): double;
function KilogramSquareMeterPerCubicSecondPerKelvinToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function WattPerMeterPerKelvinToString(const AValue: TQuantity): string;
function WattPerMeterPerKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerMeterPerKelvinToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerMeterPerKelvinToVerboseString(const AValue: TQuantity): string;
function WattPerMeterPerKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerMeterPerKelvinToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerMeterPerKelvinToFloat(const AValue: TQuantity): double;
function WattPerMeterPerKelvinToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function KilogramMeterPerCubicSecondPerKelvinToString(const AValue: TQuantity): string;
function KilogramMeterPerCubicSecondPerKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramMeterPerCubicSecondPerKelvinToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramMeterPerCubicSecondPerKelvinToVerboseString(const AValue: TQuantity): string;
function KilogramMeterPerCubicSecondPerKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramMeterPerCubicSecondPerKelvinToFloat(const AValue: TQuantity): double;
function KilogramMeterPerCubicSecondPerKelvinToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function KelvinPerWattToString(const AValue: TQuantity): string;
function KelvinPerWattToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KelvinPerWattToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KelvinPerWattToVerboseString(const AValue: TQuantity): string;
function KelvinPerWattToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KelvinPerWattToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KelvinPerWattToFloat(const AValue: TQuantity): double;
function KelvinPerWattToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function MeterPerWattToString(const AValue: TQuantity): string;
function MeterPerWattToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterPerWattToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterPerWattToVerboseString(const AValue: TQuantity): string;
function MeterPerWattToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterPerWattToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterPerWattToFloat(const AValue: TQuantity): double;
function MeterPerWattToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function MeterKelvinPerWattToString(const AValue: TQuantity): string;
function MeterKelvinPerWattToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterKelvinPerWattToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterKelvinPerWattToVerboseString(const AValue: TQuantity): string;
function MeterKelvinPerWattToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterKelvinPerWattToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterKelvinPerWattToFloat(const AValue: TQuantity): double;
function MeterKelvinPerWattToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function SquareMeterKelvinToString(const AValue: TQuantity): string;
function SquareMeterKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareMeterKelvinToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareMeterKelvinToVerboseString(const AValue: TQuantity): string;
function SquareMeterKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareMeterKelvinToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareMeterKelvinToFloat(const AValue: TQuantity): double;
function SquareMeterKelvinToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function WattPerSquareMeterPerKelvinToString(const AValue: TQuantity): string;
function WattPerSquareMeterPerKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerSquareMeterPerKelvinToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerSquareMeterPerKelvinToVerboseString(const AValue: TQuantity): string;
function WattPerSquareMeterPerKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerSquareMeterPerKelvinToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerSquareMeterPerKelvinToFloat(const AValue: TQuantity): double;
function WattPerSquareMeterPerKelvinToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function KilogramPerCubicSecondPerKelvinToString(const AValue: TQuantity): string;
function KilogramPerCubicSecondPerKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramPerCubicSecondPerKelvinToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramPerCubicSecondPerKelvinToVerboseString(const AValue: TQuantity): string;
function KilogramPerCubicSecondPerKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramPerCubicSecondPerKelvinToFloat(const AValue: TQuantity): double;
function KilogramPerCubicSecondPerKelvinToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function SquareMeterQuarticKelvinToString(const AValue: TQuantity): string;
function SquareMeterQuarticKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareMeterQuarticKelvinToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareMeterQuarticKelvinToVerboseString(const AValue: TQuantity): string;
function SquareMeterQuarticKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareMeterQuarticKelvinToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareMeterQuarticKelvinToFloat(const AValue: TQuantity): double;
function SquareMeterQuarticKelvinToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function WattPerQuarticKelvinToString(const AValue: TQuantity): string;
function WattPerQuarticKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerQuarticKelvinToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerQuarticKelvinToVerboseString(const AValue: TQuantity): string;
function WattPerQuarticKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerQuarticKelvinToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerQuarticKelvinToFloat(const AValue: TQuantity): double;
function WattPerQuarticKelvinToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function WattPerSquareMeterPerQuarticKelvinToString(const AValue: TQuantity): string;
function WattPerSquareMeterPerQuarticKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerSquareMeterPerQuarticKelvinToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerSquareMeterPerQuarticKelvinToVerboseString(const AValue: TQuantity): string;
function WattPerSquareMeterPerQuarticKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerSquareMeterPerQuarticKelvinToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerSquareMeterPerQuarticKelvinToFloat(const AValue: TQuantity): double;
function WattPerSquareMeterPerQuarticKelvinToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function JoulePerMoleToString(const AValue: TQuantity): string;
function JoulePerMoleToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function JoulePerMoleToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function JoulePerMoleToVerboseString(const AValue: TQuantity): string;
function JoulePerMoleToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function JoulePerMoleToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function JoulePerMoleToFloat(const AValue: TQuantity): double;
function JoulePerMoleToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function MoleKelvinToString(const AValue: TQuantity): string;
function MoleKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MoleKelvinToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MoleKelvinToVerboseString(const AValue: TQuantity): string;
function MoleKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MoleKelvinToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MoleKelvinToFloat(const AValue: TQuantity): double;
function MoleKelvinToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function JoulePerMolePerKelvinToString(const AValue: TQuantity): string;
function JoulePerMolePerKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function JoulePerMolePerKelvinToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function JoulePerMolePerKelvinToVerboseString(const AValue: TQuantity): string;
function JoulePerMolePerKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function JoulePerMolePerKelvinToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function JoulePerMolePerKelvinToFloat(const AValue: TQuantity): double;
function JoulePerMolePerKelvinToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function OhmMeterToString(const AValue: TQuantity): string;
function OhmMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function OhmMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function OhmMeterToVerboseString(const AValue: TQuantity): string;
function OhmMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function OhmMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function OhmMeterToFloat(const AValue: TQuantity): double;
function OhmMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function VoltPerMeterToString(const AValue: TQuantity): string;
function VoltPerMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function VoltPerMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function VoltPerMeterToVerboseString(const AValue: TQuantity): string;
function VoltPerMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function VoltPerMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function VoltPerMeterToFloat(const AValue: TQuantity): double;
function VoltPerMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function NewtonPerCoulombToString(const AValue: TQuantity): string;
function NewtonPerCoulombToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonPerCoulombToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonPerCoulombToVerboseString(const AValue: TQuantity): string;
function NewtonPerCoulombToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonPerCoulombToFloat(const AValue: TQuantity): double;
function NewtonPerCoulombToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function CoulombPerMeterToString(const AValue: TQuantity): string;
function CoulombPerMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CoulombPerMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CoulombPerMeterToVerboseString(const AValue: TQuantity): string;
function CoulombPerMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CoulombPerMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CoulombPerMeterToFloat(const AValue: TQuantity): double;
function CoulombPerMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function SquareCoulombPerMeterToString(const AValue: TQuantity): string;
function SquareCoulombPerMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareCoulombPerMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareCoulombPerMeterToVerboseString(const AValue: TQuantity): string;
function SquareCoulombPerMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareCoulombPerMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareCoulombPerMeterToFloat(const AValue: TQuantity): double;
function SquareCoulombPerMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function CoulombPerSquareMeterToString(const AValue: TQuantity): string;
function CoulombPerSquareMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CoulombPerSquareMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CoulombPerSquareMeterToVerboseString(const AValue: TQuantity): string;
function CoulombPerSquareMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CoulombPerSquareMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CoulombPerSquareMeterToFloat(const AValue: TQuantity): double;
function CoulombPerSquareMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function SquareMeterPerSquareCoulombToString(const AValue: TQuantity): string;
function SquareMeterPerSquareCoulombToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareMeterPerSquareCoulombToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareMeterPerSquareCoulombToVerboseString(const AValue: TQuantity): string;
function SquareMeterPerSquareCoulombToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareMeterPerSquareCoulombToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareMeterPerSquareCoulombToFloat(const AValue: TQuantity): double;
function SquareMeterPerSquareCoulombToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function NewtonPerSquareCoulombToString(const AValue: TQuantity): string;
function NewtonPerSquareCoulombToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonPerSquareCoulombToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonPerSquareCoulombToVerboseString(const AValue: TQuantity): string;
function NewtonPerSquareCoulombToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonPerSquareCoulombToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonPerSquareCoulombToFloat(const AValue: TQuantity): double;
function NewtonPerSquareCoulombToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function NewtonSquareMeterPerSquareCoulombToString(const AValue: TQuantity): string;
function NewtonSquareMeterPerSquareCoulombToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonSquareMeterPerSquareCoulombToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonSquareMeterPerSquareCoulombToVerboseString(const AValue: TQuantity): string;
function NewtonSquareMeterPerSquareCoulombToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonSquareMeterPerSquareCoulombToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonSquareMeterPerSquareCoulombToFloat(const AValue: TQuantity): double;
function NewtonSquareMeterPerSquareCoulombToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function VoltMeterToString(const AValue: TQuantity): string;
function VoltMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function VoltMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function VoltMeterToVerboseString(const AValue: TQuantity): string;
function VoltMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function VoltMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function VoltMeterToFloat(const AValue: TQuantity): double;
function VoltMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function NewtonSquareMeterPerCoulombToString(const AValue: TQuantity): string;
function NewtonSquareMeterPerCoulombToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonSquareMeterPerCoulombToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonSquareMeterPerCoulombToVerboseString(const AValue: TQuantity): string;
function NewtonSquareMeterPerCoulombToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonSquareMeterPerCoulombToFloat(const AValue: TQuantity): double;
function NewtonSquareMeterPerCoulombToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function VoltMeterPerSecondToString(const AValue: TQuantity): string;
function VoltMeterPerSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function VoltMeterPerSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function VoltMeterPerSecondToVerboseString(const AValue: TQuantity): string;
function VoltMeterPerSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function VoltMeterPerSecondToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function VoltMeterPerSecondToFloat(const AValue: TQuantity): double;
function VoltMeterPerSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function FaradPerMeterToString(const AValue: TQuantity): string;
function FaradPerMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function FaradPerMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function FaradPerMeterToVerboseString(const AValue: TQuantity): string;
function FaradPerMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function FaradPerMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function FaradPerMeterToFloat(const AValue: TQuantity): double;
function FaradPerMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function AmperePerMeterToString(const AValue: TQuantity): string;
function AmperePerMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function AmperePerMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function AmperePerMeterToVerboseString(const AValue: TQuantity): string;
function AmperePerMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function AmperePerMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function AmperePerMeterToFloat(const AValue: TQuantity): double;
function AmperePerMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function MeterPerAmpereToString(const AValue: TQuantity): string;
function MeterPerAmpereToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterPerAmpereToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterPerAmpereToVerboseString(const AValue: TQuantity): string;
function MeterPerAmpereToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterPerAmpereToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterPerAmpereToFloat(const AValue: TQuantity): double;
function MeterPerAmpereToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function TeslaMeterToString(const AValue: TQuantity): string;
function TeslaMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function TeslaMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function TeslaMeterToVerboseString(const AValue: TQuantity): string;
function TeslaMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function TeslaMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function TeslaMeterToFloat(const AValue: TQuantity): double;
function TeslaMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function NewtonPerAmpereToString(const AValue: TQuantity): string;
function NewtonPerAmpereToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonPerAmpereToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonPerAmpereToVerboseString(const AValue: TQuantity): string;
function NewtonPerAmpereToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonPerAmpereToFloat(const AValue: TQuantity): double;
function NewtonPerAmpereToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function TeslaPerAmpereToString(const AValue: TQuantity): string;
function TeslaPerAmpereToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function TeslaPerAmpereToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function TeslaPerAmpereToVerboseString(const AValue: TQuantity): string;
function TeslaPerAmpereToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function TeslaPerAmpereToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function TeslaPerAmpereToFloat(const AValue: TQuantity): double;
function TeslaPerAmpereToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function HenryPerMeterToString(const AValue: TQuantity): string;
function HenryPerMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function HenryPerMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function HenryPerMeterToVerboseString(const AValue: TQuantity): string;
function HenryPerMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function HenryPerMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function HenryPerMeterToFloat(const AValue: TQuantity): double;
function HenryPerMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function TeslaMeterPerAmpereToString(const AValue: TQuantity): string;
function TeslaMeterPerAmpereToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function TeslaMeterPerAmpereToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function TeslaMeterPerAmpereToVerboseString(const AValue: TQuantity): string;
function TeslaMeterPerAmpereToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function TeslaMeterPerAmpereToFloat(const AValue: TQuantity): double;
function TeslaMeterPerAmpereToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function NewtonPerSquareAmpereToString(const AValue: TQuantity): string;
function NewtonPerSquareAmpereToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonPerSquareAmpereToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonPerSquareAmpereToVerboseString(const AValue: TQuantity): string;
function NewtonPerSquareAmpereToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonPerSquareAmpereToFloat(const AValue: TQuantity): double;
function NewtonPerSquareAmpereToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function RadianPerMeterToString(const AValue: TQuantity): string;
function RadianPerMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function RadianPerMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function RadianPerMeterToVerboseString(const AValue: TQuantity): string;
function RadianPerMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function RadianPerMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function RadianPerMeterToFloat(const AValue: TQuantity): double;
function RadianPerMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function SquareKilogramPerSquareSecondToString(const AValue: TQuantity): string;
function SquareKilogramPerSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareKilogramPerSquareSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareKilogramPerSquareSecondToVerboseString(const AValue: TQuantity): string;
function SquareKilogramPerSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareKilogramPerSquareSecondToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareKilogramPerSquareSecondToFloat(const AValue: TQuantity): double;
function SquareKilogramPerSquareSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function SquareSecondPerSquareMeterToString(const AValue: TQuantity): string;
function SquareSecondPerSquareMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareSecondPerSquareMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareSecondPerSquareMeterToVerboseString(const AValue: TQuantity): string;
function SquareSecondPerSquareMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareSecondPerSquareMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareSecondPerSquareMeterToFloat(const AValue: TQuantity): double;
function SquareSecondPerSquareMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function SquareJouleToString(const AValue: TQuantity): string;
function SquareJouleToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareJouleToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareJouleToVerboseString(const AValue: TQuantity): string;
function SquareJouleToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareJouleToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareJouleToFloat(const AValue: TQuantity): double;
function SquareJouleToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function JouleSecondToString(const AValue: TQuantity): string;
function JouleSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function JouleSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function JouleSecondToVerboseString(const AValue: TQuantity): string;
function JouleSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function JouleSecondToFloat(const AValue: TQuantity): double;
function JouleSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function JoulePerHertzToString(const AValue: TQuantity): string;
function JoulePerHertzToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function JoulePerHertzToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function JoulePerHertzToVerboseString(const AValue: TQuantity): string;
function JoulePerHertzToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function JoulePerHertzToFloat(const AValue: TQuantity): double;
function JoulePerHertzToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function ElectronvoltSecondToString(const AValue: TQuantity): string;
function ElectronvoltSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function cElectronvoltSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ElectronvoltSecondToVerboseString(const AValue: TQuantity): string;
function ElectronvoltSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ElectronvoltSecondToFloat(const AValue: TQuantity): double;
function ElectronvoltSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function ElectronvoltMeterPerSpeedOfLightToString(const AValue: TQuantity): string;
function ElectronvoltMeterPerSpeedOfLightToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function cElectronvoltMeterPerSpeedOfLightToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ElectronvoltMeterPerSpeedOfLightToVerboseString(const AValue: TQuantity): string;
function ElectronvoltMeterPerSpeedOfLightToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ElectronvoltMeterPerSpeedOfLightToFloat(const AValue: TQuantity): double;
function ElectronvoltMeterPerSpeedOfLightToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function SquareJouleSquareSecondToString(const AValue: TQuantity): string;
function SquareJouleSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareJouleSquareSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareJouleSquareSecondToVerboseString(const AValue: TQuantity): string;
function SquareJouleSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareJouleSquareSecondToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareJouleSquareSecondToFloat(const AValue: TQuantity): double;
function SquareJouleSquareSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function CoulombPerKilogramToString(const AValue: TQuantity): string;
function CoulombPerKilogramToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CoulombPerKilogramToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CoulombPerKilogramToVerboseString(const AValue: TQuantity): string;
function CoulombPerKilogramToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CoulombPerKilogramToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CoulombPerKilogramToFloat(const AValue: TQuantity): double;
function CoulombPerKilogramToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function SquareMeterAmpereToString(const AValue: TQuantity): string;
function SquareMeterAmpereToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareMeterAmpereToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareMeterAmpereToVerboseString(const AValue: TQuantity): string;
function SquareMeterAmpereToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareMeterAmpereToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareMeterAmpereToFloat(const AValue: TQuantity): double;
function SquareMeterAmpereToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function JoulePerTeslaToString(const AValue: TQuantity): string;
function JoulePerTeslaToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function JoulePerTeslaToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function JoulePerTeslaToVerboseString(const AValue: TQuantity): string;
function JoulePerTeslaToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function JoulePerTeslaToFloat(const AValue: TQuantity): double;
function JoulePerTeslaToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function LumenPerWattToString(const AValue: TQuantity): string;
function LumenPerWattToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function LumenPerWattToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function LumenPerWattToVerboseString(const AValue: TQuantity): string;
function LumenPerWattToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function LumenPerWattToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function LumenPerWattToFloat(const AValue: TQuantity): double;
function LumenPerWattToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function ReciprocalMoleToString(const AValue: TQuantity): string;
function ReciprocalMoleToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ReciprocalMoleToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ReciprocalMoleToVerboseString(const AValue: TQuantity): string;
function ReciprocalMoleToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ReciprocalMoleToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ReciprocalMoleToFloat(const AValue: TQuantity): double;
function ReciprocalMoleToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function AmperePerSquareMeterToString(const AValue: TQuantity): string;
function AmperePerSquareMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function AmperePerSquareMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function AmperePerSquareMeterToVerboseString(const AValue: TQuantity): string;
function AmperePerSquareMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function AmperePerSquareMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function AmperePerSquareMeterToFloat(const AValue: TQuantity): double;
function AmperePerSquareMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function MolePerCubicMeterToString(const AValue: TQuantity): string;
function MolePerCubicMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MolePerCubicMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MolePerCubicMeterToVerboseString(const AValue: TQuantity): string;
function MolePerCubicMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MolePerCubicMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MolePerCubicMeterToFloat(const AValue: TQuantity): double;
function MolePerCubicMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function CandelaPerSquareMeterToString(const AValue: TQuantity): string;
function CandelaPerSquareMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CandelaPerSquareMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CandelaPerSquareMeterToVerboseString(const AValue: TQuantity): string;
function CandelaPerSquareMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CandelaPerSquareMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CandelaPerSquareMeterToFloat(const AValue: TQuantity): double;
function CandelaPerSquareMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function CoulombPerCubicMeterToString(const AValue: TQuantity): string;
function CoulombPerCubicMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CoulombPerCubicMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CoulombPerCubicMeterToVerboseString(const AValue: TQuantity): string;
function CoulombPerCubicMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CoulombPerCubicMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CoulombPerCubicMeterToFloat(const AValue: TQuantity): double;
function CoulombPerCubicMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function GrayPerSecondToString(const AValue: TQuantity): string;
function GrayPerSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function GrayPerSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function GrayPerSecondToVerboseString(const AValue: TQuantity): string;
function GrayPerSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function GrayPerSecondToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function GrayPerSecondToFloat(const AValue: TQuantity): double;
function GrayPerSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function SteradianHertzToString(const AValue: TQuantity): string;
function SteradianHertzToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SteradianHertzToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SteradianHertzToVerboseString(const AValue: TQuantity): string;
function SteradianHertzToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SteradianHertzToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SteradianHertzToFloat(const AValue: TQuantity): double;
function SteradianHertzToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function MeterSteradianToString(const AValue: TQuantity): string;
function MeterSteradianToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterSteradianToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterSteradianToVerboseString(const AValue: TQuantity): string;
function MeterSteradianToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterSteradianToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterSteradianToFloat(const AValue: TQuantity): double;
function MeterSteradianToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function SquareMeterSteradianToString(const AValue: TQuantity): string;
function SquareMeterSteradianToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareMeterSteradianToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareMeterSteradianToVerboseString(const AValue: TQuantity): string;
function SquareMeterSteradianToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareMeterSteradianToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareMeterSteradianToFloat(const AValue: TQuantity): double;
function SquareMeterSteradianToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function CubicMeterSteradianToString(const AValue: TQuantity): string;
function CubicMeterSteradianToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CubicMeterSteradianToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CubicMeterSteradianToVerboseString(const AValue: TQuantity): string;
function CubicMeterSteradianToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CubicMeterSteradianToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CubicMeterSteradianToFloat(const AValue: TQuantity): double;
function CubicMeterSteradianToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function SquareMeterSteradianHertzToString(const AValue: TQuantity): string;
function SquareMeterSteradianHertzToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareMeterSteradianHertzToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareMeterSteradianHertzToVerboseString(const AValue: TQuantity): string;
function SquareMeterSteradianHertzToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareMeterSteradianHertzToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareMeterSteradianHertzToFloat(const AValue: TQuantity): double;
function SquareMeterSteradianHertzToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function WattPerSteradianToString(const AValue: TQuantity): string;
function WattPerSteradianToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerSteradianToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerSteradianToVerboseString(const AValue: TQuantity): string;
function WattPerSteradianToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerSteradianToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerSteradianToFloat(const AValue: TQuantity): double;
function WattPerSteradianToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function WattPerSteradianPerHertzToString(const AValue: TQuantity): string;
function WattPerSteradianPerHertzToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerSteradianPerHertzToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerSteradianPerHertzToVerboseString(const AValue: TQuantity): string;
function WattPerSteradianPerHertzToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerSteradianPerHertzToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerSteradianPerHertzToFloat(const AValue: TQuantity): double;
function WattPerSteradianPerHertzToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function WattPerMeterPerSteradianToString(const AValue: TQuantity): string;
function WattPerMeterPerSteradianToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerMeterPerSteradianToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerMeterPerSteradianToVerboseString(const AValue: TQuantity): string;
function WattPerMeterPerSteradianToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerMeterPerSteradianToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerMeterPerSteradianToFloat(const AValue: TQuantity): double;
function WattPerMeterPerSteradianToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function WattPerSquareMeterPerSteradianToString(const AValue: TQuantity): string;
function WattPerSquareMeterPerSteradianToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerSquareMeterPerSteradianToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerSquareMeterPerSteradianToVerboseString(const AValue: TQuantity): string;
function WattPerSquareMeterPerSteradianToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerSquareMeterPerSteradianToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerSquareMeterPerSteradianToFloat(const AValue: TQuantity): double;
function WattPerSquareMeterPerSteradianToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function WattPerCubicMeterPerSteradianToString(const AValue: TQuantity): string;
function WattPerCubicMeterPerSteradianToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerCubicMeterPerSteradianToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerCubicMeterPerSteradianToVerboseString(const AValue: TQuantity): string;
function WattPerCubicMeterPerSteradianToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerCubicMeterPerSteradianToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerCubicMeterPerSteradianToFloat(const AValue: TQuantity): double;
function WattPerCubicMeterPerSteradianToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function WattPerSquareMeterPerSteradianPerHertzToString(const AValue: TQuantity): string;
function WattPerSquareMeterPerSteradianPerHertzToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerSquareMeterPerSteradianPerHertzToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerSquareMeterPerSteradianPerHertzToVerboseString(const AValue: TQuantity): string;
function WattPerSquareMeterPerSteradianPerHertzToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerSquareMeterPerSteradianPerHertzToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerSquareMeterPerSteradianPerHertzToFloat(const AValue: TQuantity): double;
function WattPerSquareMeterPerSteradianPerHertzToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function KatalPerCubicMeterToString(const AValue: TQuantity): string;
function KatalPerCubicMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KatalPerCubicMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KatalPerCubicMeterToVerboseString(const AValue: TQuantity): string;
function KatalPerCubicMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KatalPerCubicMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KatalPerCubicMeterToFloat(const AValue: TQuantity): double;
function KatalPerCubicMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
function CoulombPerMoleToString(const AValue: TQuantity): string;
function CoulombPerMoleToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CoulombPerMoleToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CoulombPerMoleToVerboseString(const AValue: TQuantity): string;
function CoulombPerMoleToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CoulombPerMoleToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CoulombPerMoleToFloat(const AValue: TQuantity): double;
function CoulombPerMoleToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;

{ Power functions }

function SquarePower(const AValue: TQuantity): TQuantity;
function CubicPower(const AValue: TQuantity): TQuantity;
function QuarticPower(const AValue: TQuantity): TQuantity;
function QuinticPower(const AValue: TQuantity): TQuantity;
function SexticPower(const AValue: TQuantity): TQuantity;

function SquareRoot(const AValue: TQuantity): TQuantity;
function CubicRoot(const AValue: TQuantity): TQuantity;
function QuarticRoot(const AValue: TQuantity): TQuantity;
function QuinticRoot(const AValue: TQuantity): TQuantity;
function SexticRoot(const AValue: TQuantity): TQuantity;

{ Trigonometric functions }

function Cos(const AQuantity: TQuantity): double;
function Sin(const AQuantity: TQuantity): double;
function Tan(const AQuantity: TQuantity): double;
function Cotan(const AQuantity: TQuantity): double;
function Secant(const AQuantity: TQuantity): double;
function Cosecant(const AQuantity: TQuantity): double;

function ArcCos(const AQuantity: double): TQuantity;
function ArcSin(const AQuantity: double): TQuantity;
function ArcTan(const AQuantity: double): TQuantity;
function ArcTan2(const x, y: double): TQuantity;

{ Override trigonometric functions }

function Cos(const AQuantity: double): double;
function Sin(const AQuantity: double): double;
function Tan(const AQuantity: double): double;
function Cotan(const AQuantity: double): double;
function Secant(const AQuantity: double): double;
function Cosecant(const AQuantity: double): double;

{ Helper functions }

function SameValue(const ALeft, ARight: TQuantity): boolean;
function Min(const ALeft, ARight: TQuantity): TQuantity;
function Max(const ALeft, ARight: TQuantity): TQuantity;
function Exp(const AQuantity: TQuantity): TQuantity;

implementation

uses
  Math;

const

  { Mul Table }

  MulTable : array[0..159, 0..159] of longint = (
    (cScalar, cSecond, cSquareSecond, cCubicSecond, cQuarticSecond, cQuinticSecond, cSexticSecond, cMeter, cSquareRootMeter, cSquareMeter, cCubicMeter, cQuarticMeter, cQuinticMeter, cSexticMeter, cKilogram, cSquareKilogram, cAmpere, cSquareAmpere, cKelvin, cSquareKelvin, cCubicKelvin, cQuarticKelvin, cMole, cCandela, cHertz, cSquareHertz, cSquareHertz, cMeterPerSecond, cMeterPerSquareSecond, cMeterPerCubicSecond, cMeterPerQuarticSecond, cMeterPerQuinticSecond, cMeterPerSexticSecond, cSquareMeterPerSquareSecond, cMeterSecond, cKilogramMeter, cKilogramPerSecond, cKilogramMeterPerSecond, cSquareKilogramSquareMeterPerSquareSecond, cReciprocalSquareRootMeter, cReciprocalMeter, cReciprocalSquareRootCubicMeter, cReciprocalSquareMeter, cReciprocalCubicMeter, cReciprocalQuarticMeter, cKilogramSquareMeter, cKilogramSquareMeterPerSecond, cSecondPerMeter, cKilogramPerMeter, cKilogramPerSquareMeter, cKilogramPerCubicMeter, cNewton, cNewton, cSquareNewton, cPascal, cJoule, cJoule, cWatt, cCoulomb, cSquareCoulomb, cCoulombMeter, cVolt, cSquareVolt, cFarad, cOhm, cSiemens, cSiemensPerMeter, cTesla, cWeber, cHenry, cReciprocalHenry, cCandela, cLumenSecond, cLumenSecondPerCubicMeter, cLux, cLuxSecond, cKatal, cNewtonPerCubicMeter, cNewtonPerMeter, cCubicMeterPerSecond, cPoiseuille, cSquareMeterPerSecond, cKilogramPerQuarticMeter, cQuarticMeterSecond, cKilogramPerQuarticMeterPerSecond, cCubicMeterPerKilogram, cKilogramSquareSecond, cCubicMeterPerSquareSecond, cNewtonSquareMeter, cNewtonCubicMeter, cNewtonPerSquareKilogram, cSquareKilogramPerMeter, cSquareKilogramPerSquareMeter, cSquareMeterPerSquareKilogram, cNewtonSquareMeterPerSquareKilogram, cReciprocalKelvin, cKilogramKelvin, cJoulePerKelvin, cJoulePerKilogramPerKelvin, cMeterKelvin, cKelvinPerMeter, cWattPerMeter, cWattPerSquareMeter, cWattPerCubicMeter, cWattPerKelvin, cWattPerMeterPerKelvin, cKelvinPerWatt, cMeterPerWatt, cMeterKelvinPerWatt, cSquareMeterKelvin, cWattPerSquareMeterPerKelvin, cSquareMeterQuarticKelvin, cWattPerQuarticKelvin, cWattPerSquareMeterPerQuarticKelvin, cJoulePerMole, cMoleKelvin, cJoulePerMolePerKelvin, cOhmMeter, cVoltPerMeter, cCoulombPerMeter, cSquareCoulombPerMeter, cCoulombPerSquareMeter, cSquareMeterPerSquareCoulomb, cNewtonPerSquareCoulomb, cNewtonSquareMeterPerSquareCoulomb, cVoltMeter, cVoltMeterPerSecond, cFaradPerMeter, cAmperePerMeter, cMeterPerAmpere, cTeslaMeter, cTeslaPerAmpere, cHenryPerMeter, cReciprocalMeter, cSquareKilogramPerSquareSecond, cSquareSecondPerSquareMeter, cSquareJoule, cSquareJouleSquareSecond, cCoulombPerKilogram, cSquareMeterAmpere, cLumenPerWatt, cReciprocalMole, cAmperePerSquareMeter, cMolePerCubicMeter, cLux, cCoulombPerCubicMeter, cGrayPerSecond, cHertz, cMeter, cSquareMeter, cCubicMeter, cSquareMeterPerSecond, cWatt, cJoule, cWattPerMeter, cWattPerSquareMeter, cWattPerCubicMeter, cNewtonPerMeter, cKatalPerCubicMeter, cCoulombPerMole),
    (cSecond, cSquareSecond, cCubicSecond, cQuarticSecond, cQuinticSecond, cSexticSecond, -1, cMeterSecond, -1, -1, -1, cQuarticMeterSecond, -1, -1, -1, -1, cCoulomb, -1, -1, -1, -1, -1, -1, cLumenSecond, cScalar, cHertz, cHertz, cMeter, cMeterPerSecond, cMeterPerSquareSecond, cMeterPerCubicSecond, cMeterPerQuarticSecond, cMeterPerQuinticSecond, cSquareMeterPerSecond, -1, -1, cKilogram, cKilogramMeter, -1, -1, cSecondPerMeter, -1, -1, -1, -1, -1, cKilogramSquareMeter, -1, -1, -1, -1, cKilogramMeterPerSecond, cKilogramMeterPerSecond, -1, cPoiseuille, cKilogramSquareMeterPerSecond, cKilogramSquareMeterPerSecond, cJoule, -1, -1, -1, cWeber, -1, -1, cHenry, cFarad, cFaradPerMeter, -1, -1, -1, cSiemens, cLumenSecond, -1, -1, cLuxSecond, -1, cMole, -1, cKilogramPerSecond, cCubicMeter, cKilogramPerMeter, cSquareMeter, -1, -1, cKilogramPerQuarticMeter, -1, -1, cCubicMeterPerSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewton, cNewtonPerMeter, cPascal, cJoulePerKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cTeslaMeter, -1, -1, -1, -1, -1, cOhmMeter, -1, cVoltMeter, -1, cCoulombPerMeter, -1, -1, -1, -1, cSecondPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, cCoulombPerSquareMeter, -1, cLuxSecond, -1, cSquareMeterPerSquareSecond, cScalar, cMeterSecond, -1, -1, cSquareMeter, cJoule, cKilogramSquareMeterPerSecond, cNewton, cNewtonPerMeter, cPascal, cKilogramPerSecond, cMolePerCubicMeter, -1),
    (cSquareSecond, cCubicSecond, cQuarticSecond, cQuinticSecond, cSexticSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramSquareSecond, -1, -1, cSquareCoulomb, -1, -1, -1, -1, -1, -1, cSecond, cScalar, cScalar, cMeterSecond, cMeter, cMeterPerSecond, cMeterPerSquareSecond, cMeterPerCubicSecond, cMeterPerQuarticSecond, cSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, cSquareSecondPerSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramMeter, cKilogramMeter, cSquareKilogramSquareMeterPerSquareSecond, cKilogramPerMeter, cKilogramSquareMeter, cKilogramSquareMeter, cKilogramSquareMeterPerSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cFarad, -1, -1, -1, -1, -1, -1, cKilogramPerSquareMeter, cKilogram, -1, -1, -1, -1, -1, -1, -1, -1, cCubicMeter, -1, -1, -1, -1, -1, -1, cCubicMeterPerKilogram, -1, -1, -1, cSquareMeterKelvin, -1, -1, cKilogramMeterPerSecond, cKilogramPerSecond, cPoiseuille, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cHenryPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareKilogram, -1, cSquareJouleSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareMeterPerSecond, cSecond, -1, -1, -1, -1, cKilogramSquareMeterPerSecond, cKilogramSquareMeter, cKilogramMeterPerSecond, cKilogramPerSecond, cPoiseuille, cKilogram, -1, -1),
    (cCubicSecond, cQuarticSecond, cQuinticSecond, cSexticSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareSecond, cSecond, cSecond, -1, cMeterSecond, cMeter, cMeterPerSecond, cMeterPerSquareSecond, cMeterPerCubicSecond, -1, -1, -1, cKilogramSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramMeter, cKilogram, cKilogramPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareMeter, cSquareSecond, -1, -1, -1, -1, cKilogramSquareMeter, -1, cKilogramMeter, cKilogram, cKilogramPerMeter, -1, -1, -1),
    (cQuarticSecond, cQuinticSecond, cSexticSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCubicSecond, cSquareSecond, cSquareSecond, -1, -1, cMeterSecond, cMeter, cMeterPerSecond, cMeterPerSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCubicSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramSquareSecond, -1, -1),
    (cQuinticSecond, cSexticSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cQuarticSecond, cCubicSecond, cCubicSecond, -1, -1, -1, cMeterSecond, cMeter, cMeterPerSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cQuarticSecond, -1, -1, -1, -1, -1, -1, -1, cKilogramSquareSecond, -1, -1, -1, -1),
    (cSexticSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cQuinticSecond, cQuarticSecond, cQuarticSecond, -1, -1, -1, -1, cMeterSecond, cMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cQuinticSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cMeter, cMeterSecond, -1, -1, -1, -1, -1, cSquareMeter, -1, cCubicMeter, cQuarticMeter, cQuinticMeter, cSexticMeter, -1, cKilogramMeter, -1, -1, -1, cMeterKelvin, -1, -1, -1, -1, -1, cMeterPerSecond, cMeterPerSquareSecond, cMeterPerSquareSecond, cSquareMeterPerSecond, cSquareMeterPerSquareSecond, cGrayPerSecond, -1, -1, -1, cCubicMeterPerSquareSecond, -1, cKilogramSquareMeter, cKilogramMeterPerSecond, cKilogramSquareMeterPerSecond, -1, cSquareRootMeter, cScalar, cReciprocalSquareRootMeter, cReciprocalMeter, cReciprocalSquareMeter, cReciprocalCubicMeter, -1, -1, cSecond, cKilogram, cKilogramPerMeter, cKilogramPerSquareMeter, cJoule, cJoule, -1, cNewtonPerMeter, cNewtonSquareMeter, cNewtonSquareMeter, -1, cCoulombMeter, -1, -1, cVoltMeter, -1, -1, cOhmMeter, -1, cSiemens, cTeslaMeter, -1, -1, -1, -1, -1, cLuxSecond, -1, -1, -1, cPascal, cNewton, -1, cKilogramPerSecond, cCubicMeterPerSecond, cKilogramPerCubicMeter, -1, -1, -1, -1, -1, cNewtonCubicMeter, -1, -1, cSquareKilogram, cSquareKilogramPerMeter, -1, -1, -1, -1, -1, -1, -1, cKelvin, cWatt, cWattPerMeter, cWattPerSquareMeter, -1, cWattPerKelvin, cMeterKelvinPerWatt, -1, -1, -1, cWattPerMeterPerKelvin, -1, -1, -1, -1, -1, -1, -1, cVolt, cCoulomb, cSquareCoulomb, cCoulombPerMeter, -1, -1, -1, -1, -1, cFarad, cAmpere, -1, cWeber, cHenryPerMeter, cHenry, cScalar, -1, -1, -1, -1, -1, -1, -1, -1, cAmperePerMeter, -1, -1, cCoulombPerSquareMeter, -1, cMeterPerSecond, cSquareMeter, cCubicMeter, cQuarticMeter, cCubicMeterPerSecond, -1, cNewtonSquareMeter, cWatt, cWattPerMeter, cWattPerSquareMeter, cNewton, -1, -1),
    (cSquareRootMeter, -1, -1, -1, -1, -1, -1, -1, cMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cScalar, cReciprocalSquareRootMeter, cReciprocalMeter, cReciprocalSquareRootCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cReciprocalSquareRootMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cSquareMeter, -1, -1, -1, -1, -1, -1, cCubicMeter, -1, cQuarticMeter, cQuinticMeter, cSexticMeter, -1, -1, cKilogramSquareMeter, -1, cSquareMeterAmpere, -1, -1, -1, -1, cSquareMeterQuarticKelvin, -1, -1, cSquareMeterPerSecond, cSquareMeterPerSquareSecond, cSquareMeterPerSquareSecond, cCubicMeterPerSecond, cCubicMeterPerSquareSecond, -1, -1, -1, -1, -1, -1, -1, cKilogramSquareMeterPerSecond, -1, cSquareJouleSquareSecond, -1, cMeter, cSquareRootMeter, cScalar, cReciprocalMeter, cReciprocalSquareMeter, -1, -1, cMeterSecond, cKilogramMeter, cKilogram, cKilogramPerMeter, cNewtonSquareMeter, cNewtonSquareMeter, cSquareJoule, cNewton, cNewtonCubicMeter, cNewtonCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWeber, -1, -1, -1, -1, -1, -1, cCandela, cLumenSecond, -1, cNewtonPerMeter, cJoule, -1, cKilogramMeterPerSecond, -1, cKilogramPerSquareMeter, -1, -1, -1, -1, -1, -1, -1, cNewtonSquareMeterPerSquareKilogram, -1, cSquareKilogram, -1, -1, cSquareMeterKelvin, -1, -1, -1, -1, cMeterKelvin, -1, cWatt, cWattPerMeter, -1, -1, -1, -1, -1, -1, cWattPerKelvin, -1, -1, -1, -1, -1, -1, -1, cVoltMeter, cCoulombMeter, -1, cCoulomb, -1, cNewtonSquareMeterPerSquareCoulomb, -1, -1, -1, -1, -1, -1, -1, cHenry, -1, cMeter, cSquareKilogramSquareMeterPerSquareSecond, cSquareSecond, -1, -1, -1, -1, -1, -1, cAmpere, -1, cCandela, cCoulombPerMeter, -1, cSquareMeterPerSecond, cCubicMeter, cQuarticMeter, cQuinticMeter, -1, -1, cNewtonCubicMeter, -1, cWatt, cWattPerMeter, cJoule, -1, -1),
    (cCubicMeter, -1, -1, -1, -1, -1, -1, cQuarticMeter, -1, cQuinticMeter, cSexticMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCubicMeterPerSecond, cCubicMeterPerSquareSecond, cCubicMeterPerSquareSecond, -1, -1, -1, -1, -1, -1, -1, cQuarticMeterSecond, -1, -1, -1, -1, -1, cSquareMeter, -1, cMeter, cScalar, cReciprocalMeter, -1, -1, -1, cKilogramSquareMeter, cKilogramMeter, cKilogram, cNewtonCubicMeter, cNewtonCubicMeter, -1, cJoule, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cLumenSecond, -1, -1, -1, cNewton, cNewtonSquareMeter, -1, cKilogramSquareMeterPerSecond, -1, cKilogramPerMeter, -1, cPoiseuille, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWatt, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCoulombMeter, -1, -1, -1, -1, -1, -1, cSquareMeterAmpere, -1, -1, -1, -1, cSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMole, -1, cCoulomb, -1, cCubicMeterPerSecond, cQuarticMeter, cQuinticMeter, cSexticMeter, -1, -1, -1, -1, -1, cWatt, cNewtonSquareMeter, cKatal, -1),
    (cQuarticMeter, cQuarticMeterSecond, -1, -1, -1, -1, -1, cQuinticMeter, -1, cSexticMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCubicMeter, -1, cSquareMeter, cMeter, cScalar, -1, -1, -1, -1, cKilogramSquareMeter, cKilogramMeter, -1, -1, -1, cNewtonSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cJoule, cNewtonCubicMeter, -1, -1, -1, cKilogram, -1, cKilogramPerSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCubicMeter, cSquareJouleSquareSecond, -1, -1, -1, -1, -1, -1, -1, cSquareMeterAmpere, -1, -1, cCoulombMeter, -1, -1, cQuinticMeter, cSexticMeter, -1, -1, -1, -1, -1, -1, -1, cNewtonCubicMeter, -1, -1),
    (cQuinticMeter, -1, -1, -1, -1, -1, -1, cSexticMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cQuarticMeter, -1, cCubicMeter, cSquareMeter, cMeter, -1, -1, cQuarticMeterSecond, -1, -1, cKilogramSquareMeter, -1, -1, -1, cNewtonCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewtonSquareMeter, -1, -1, -1, -1, cKilogramMeter, -1, cKilogramMeterPerSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cQuarticMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSexticMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cSexticMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cQuinticMeter, -1, cQuarticMeter, cCubicMeter, cSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewtonCubicMeter, -1, -1, -1, -1, cKilogramSquareMeter, -1, cKilogramSquareMeterPerSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cQuinticMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cKilogram, -1, cKilogramSquareSecond, -1, -1, -1, -1, cKilogramMeter, -1, cKilogramSquareMeter, -1, -1, -1, -1, cSquareKilogram, -1, -1, -1, cKilogramKelvin, -1, -1, -1, -1, -1, cKilogramPerSecond, cNewtonPerMeter, cNewtonPerMeter, cKilogramMeterPerSecond, cNewton, cWattPerMeter, -1, -1, -1, cJoule, -1, -1, -1, -1, -1, -1, cKilogramPerMeter, -1, cKilogramPerSquareMeter, cKilogramPerCubicMeter, cKilogramPerQuarticMeter, -1, -1, -1, cSquareKilogramPerMeter, cSquareKilogramPerSquareMeter, -1, -1, -1, -1, -1, cSquareKilogramSquareMeterPerSquareSecond, cSquareKilogramSquareMeterPerSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareKilogramPerSquareSecond, -1, -1, cKilogramSquareMeterPerSecond, -1, -1, -1, cCubicMeter, -1, cNewtonSquareMeter, -1, cSquareJouleSquareSecond, cMeterPerSquareSecond, -1, -1, -1, cCubicMeterPerSquareSecond, -1, -1, -1, cJoulePerKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cHenry, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramPerMeter, -1, -1, -1, -1, cCoulomb, -1, -1, -1, -1, -1, -1, -1, cWatt, cKilogramPerSecond, cKilogramMeter, cKilogramSquareMeter, -1, cKilogramSquareMeterPerSecond, -1, cSquareKilogramSquareMeterPerSquareSecond, -1, -1, -1, cSquareKilogramPerSquareSecond, -1, -1),
    (cSquareKilogram, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareKilogramPerSquareSecond, cSquareKilogramPerSquareSecond, -1, -1, -1, -1, -1, -1, cSquareKilogramSquareMeterPerSquareSecond, -1, -1, -1, -1, -1, -1, cSquareKilogramPerMeter, -1, cSquareKilogramPerSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewton, -1, -1, cSquareMeter, cNewtonSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareKilogramPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cAmpere, cCoulomb, -1, -1, -1, -1, -1, -1, -1, cSquareMeterAmpere, -1, -1, -1, -1, -1, -1, cSquareAmpere, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCoulombMeter, -1, -1, -1, -1, -1, cAmperePerMeter, -1, cAmperePerSquareMeter, -1, -1, -1, -1, cCoulombPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWatt, -1, -1, cVolt, -1, -1, cNewtonPerMeter, cJoule, cWeber, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cVoltMeter, cWattPerMeter, -1, -1, -1, -1, -1, cVoltMeterPerSecond, -1, -1, -1, -1, cMeter, cNewton, cTesla, cTeslaMeter, cAmperePerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareMeterAmpere, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cSquareAmpere, -1, cSquareCoulomb, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWatt, -1, -1, -1, -1, cJoule, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareMeterPerSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, cNewtonPerMeter, cNewton, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cKelvin, -1, -1, -1, -1, -1, -1, cMeterKelvin, -1, -1, -1, -1, -1, -1, cKilogramKelvin, -1, -1, -1, cSquareKelvin, cCubicKelvin, cQuarticKelvin, -1, cMoleKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKelvinPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cScalar, -1, cJoule, cSquareMeterPerSquareSecond, -1, -1, -1, -1, -1, cWatt, cWattPerMeter, -1, cMeterKelvinPerWatt, -1, cSquareMeter, cWattPerSquareMeter, -1, -1, -1, -1, -1, cJoulePerMole, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKelvinPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeterKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cSquareKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCubicKelvin, cQuarticKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cCubicKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cQuarticKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWattPerKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cQuarticKelvin, -1, -1, -1, -1, -1, -1, -1, -1, cSquareMeterQuarticKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCubicKelvin, -1, -1, -1, -1, -1, -1, cWattPerSquareMeterPerQuarticKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWatt, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareMeterQuarticKelvin, -1, -1, -1, -1, -1, cWattPerSquareMeterPerQuarticKelvin, -1, -1, -1, -1),
    (cMole, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMoleKelvin, -1, -1, -1, -1, -1, cKatal, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMolePerCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cJoule, -1, cJoulePerKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cScalar, -1, -1, -1, -1, -1, cKatal, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCoulomb),
    (cCandela, cLumenSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cLux, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cHertz, cScalar, cSecond, cSquareSecond, cCubicSecond, cQuarticSecond, cQuinticSecond, cMeterPerSecond, -1, cSquareMeterPerSecond, cCubicMeterPerSecond, -1, -1, -1, cKilogramPerSecond, -1, -1, -1, -1, -1, -1, -1, cKatal, -1, cSquareHertz, -1, -1, cMeterPerSquareSecond, cMeterPerCubicSecond, cMeterPerQuarticSecond, cMeterPerQuinticSecond, cMeterPerSexticSecond, -1, cGrayPerSecond, cMeter, cKilogramMeterPerSecond, cNewtonPerMeter, cNewton, -1, -1, -1, -1, -1, -1, -1, cKilogramSquareMeterPerSecond, cJoule, cReciprocalMeter, cPoiseuille, -1, -1, cWattPerMeter, cWattPerMeter, -1, cWattPerCubicMeter, cWatt, cWatt, -1, cAmpere, -1, -1, -1, -1, cSiemens, -1, cReciprocalHenry, -1, -1, cVolt, cOhm, -1, -1, cCandela, -1, -1, cLux, -1, -1, cWattPerSquareMeter, cCubicMeterPerSquareSecond, cPascal, cSquareMeterPerSquareSecond, cKilogramPerQuarticMeterPerSecond, cQuarticMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWattPerKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewtonSquareMeterPerSquareCoulomb, -1, cAmperePerMeter, -1, cAmperePerSquareMeter, -1, -1, -1, cVoltMeterPerSecond, -1, cSiemensPerMeter, -1, -1, cVoltPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKatalPerCubicMeter, -1, -1, -1, cSquareHertz, cMeterPerSecond, cSquareMeterPerSecond, cCubicMeterPerSecond, cSquareMeterPerSquareSecond, -1, cWatt, -1, -1, -1, cWattPerSquareMeter, -1, -1),
    (cSquareHertz, cHertz, cScalar, cSecond, cSquareSecond, cCubicSecond, cQuarticSecond, cMeterPerSquareSecond, -1, cSquareMeterPerSquareSecond, cCubicMeterPerSquareSecond, -1, -1, -1, cNewtonPerMeter, cSquareKilogramPerSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeterPerCubicSecond, cMeterPerQuarticSecond, cMeterPerQuinticSecond, cMeterPerSexticSecond, -1, -1, -1, cMeterPerSecond, cNewton, cWattPerSquareMeter, cWattPerMeter, cSquareNewton, -1, -1, -1, -1, -1, -1, cJoule, cWatt, -1, cPascal, cNewtonPerCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareAmpere, -1, -1, -1, cReciprocalHenry, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWattPerCubicMeter, cGrayPerSecond, -1, -1, -1, cNewtonSquareMeterPerSquareKilogram, cKilogram, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cJoulePerKilogramPerKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewtonPerSquareCoulomb, -1, -1, cReciprocalSquareMeter, -1, cSquareJoule, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeterPerSquareSecond, cSquareMeterPerSquareSecond, cCubicMeterPerSquareSecond, cGrayPerSecond, -1, -1, -1, -1, -1, -1, -1, -1),
    (cSquareHertz, cHertz, cScalar, cSecond, cSquareSecond, cCubicSecond, cQuarticSecond, cMeterPerSquareSecond, -1, cSquareMeterPerSquareSecond, cCubicMeterPerSquareSecond, -1, -1, -1, cNewtonPerMeter, cSquareKilogramPerSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeterPerCubicSecond, cMeterPerQuarticSecond, cMeterPerQuinticSecond, cMeterPerSexticSecond, -1, -1, -1, cMeterPerSecond, cNewton, cWattPerSquareMeter, cWattPerMeter, cSquareNewton, -1, -1, -1, -1, -1, -1, cJoule, cWatt, -1, cPascal, cNewtonPerCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareAmpere, -1, -1, -1, cReciprocalHenry, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWattPerCubicMeter, cGrayPerSecond, -1, -1, -1, cNewtonSquareMeterPerSquareKilogram, cKilogram, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cJoulePerKilogramPerKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewtonPerSquareCoulomb, -1, -1, cReciprocalSquareMeter, -1, cSquareJoule, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeterPerSquareSecond, cSquareMeterPerSquareSecond, cCubicMeterPerSquareSecond, cGrayPerSecond, -1, -1, -1, -1, -1, -1, -1, -1),
    (cMeterPerSecond, cMeter, cMeterSecond, -1, -1, -1, -1, cSquareMeterPerSecond, -1, cCubicMeterPerSecond, -1, -1, -1, -1, cKilogramMeterPerSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeterPerSquareSecond, cMeterPerCubicSecond, cMeterPerCubicSecond, cSquareMeterPerSquareSecond, cGrayPerSecond, -1, -1, -1, -1, -1, cSquareMeter, cKilogramSquareMeterPerSecond, cNewton, cJoule, -1, -1, cHertz, -1, -1, -1, -1, -1, cNewtonSquareMeter, cScalar, cKilogramPerSecond, cPoiseuille, -1, cWatt, cWatt, -1, cWattPerSquareMeter, -1, -1, -1, -1, -1, cSquareMeterAmpere, cVoltMeterPerSecond, -1, -1, cNewtonSquareMeterPerSquareCoulomb, -1, cReciprocalHenry, cVoltPerMeter, cVoltMeter, cOhmMeter, -1, -1, -1, cLux, -1, -1, -1, cWattPerCubicMeter, cWattPerMeter, -1, cNewtonPerMeter, cCubicMeterPerSquareSecond, -1, cQuinticMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cAmpere, -1, cAmperePerMeter, -1, -1, -1, -1, -1, cSiemens, -1, -1, cVolt, -1, cOhm, cHertz, -1, cSecondPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, cAmperePerSquareMeter, -1, cMeterPerSquareSecond, cSquareMeterPerSecond, cCubicMeterPerSecond, -1, cCubicMeterPerSquareSecond, -1, -1, -1, -1, -1, cWattPerMeter, -1, -1),
    (cMeterPerSquareSecond, cMeterPerSecond, cMeter, cMeterSecond, -1, -1, -1, cSquareMeterPerSquareSecond, -1, cCubicMeterPerSquareSecond, -1, -1, -1, -1, cNewton, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeterPerCubicSecond, cMeterPerQuarticSecond, cMeterPerQuarticSecond, cGrayPerSecond, -1, -1, -1, -1, -1, -1, cSquareMeterPerSecond, cJoule, cWattPerMeter, cWatt, -1, -1, cSquareHertz, -1, -1, -1, -1, cNewtonSquareMeter, -1, cHertz, cNewtonPerMeter, cPascal, cNewtonPerCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cVoltMeterPerSecond, cNewtonSquareMeterPerSquareCoulomb, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWattPerSquareMeter, -1, -1, -1, -1, -1, cKilogramMeter, -1, -1, -1, -1, cSquareKilogramPerSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareAmpere, -1, -1, -1, -1, -1, -1, cReciprocalHenry, -1, -1, -1, cNewtonPerSquareCoulomb, -1, cSquareHertz, -1, cReciprocalMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeterPerCubicSecond, cSquareMeterPerSquareSecond, cCubicMeterPerSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cMeterPerCubicSecond, cMeterPerSquareSecond, cMeterPerSecond, cMeter, cMeterSecond, -1, -1, cGrayPerSecond, -1, -1, -1, -1, -1, -1, cWattPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeterPerQuarticSecond, cMeterPerQuinticSecond, cMeterPerQuinticSecond, -1, -1, -1, -1, -1, -1, -1, cSquareMeterPerSquareSecond, cWatt, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareHertz, cWattPerSquareMeter, cWattPerCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramMeterPerSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeterPerQuarticSecond, cGrayPerSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cMeterPerQuarticSecond, cMeterPerCubicSecond, cMeterPerSquareSecond, cMeterPerSecond, cMeter, cMeterSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeterPerQuinticSecond, cMeterPerSexticSecond, cMeterPerSexticSecond, -1, -1, -1, -1, -1, -1, -1, cGrayPerSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewton, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeterPerQuinticSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cMeterPerQuinticSecond, cMeterPerQuarticSecond, cMeterPerCubicSecond, cMeterPerSquareSecond, cMeterPerSecond, cMeter, cMeterSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeterPerSexticSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWattPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeterPerSexticSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cMeterPerSexticSecond, cMeterPerQuinticSecond, cMeterPerQuarticSecond, cMeterPerCubicSecond, cMeterPerSquareSecond, cMeterPerSecond, cMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cSquareMeterPerSquareSecond, cSquareMeterPerSecond, cSquareMeter, -1, -1, -1, -1, cCubicMeterPerSquareSecond, -1, -1, -1, -1, -1, -1, cJoule, cSquareKilogramSquareMeterPerSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, cGrayPerSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCubicMeterPerSecond, cNewtonSquareMeter, cWatt, -1, cSquareJoule, -1, cMeterPerSquareSecond, -1, cSquareHertz, -1, -1, cNewtonCubicMeter, -1, cMeterPerSecond, cNewton, cNewtonPerMeter, cPascal, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWattPerMeter, -1, cNewtonPerCubicMeter, -1, -1, -1, cKilogramSquareMeter, -1, -1, -1, -1, -1, cSquareKilogramPerSquareSecond, -1, -1, cJoulePerKilogramPerKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cVoltMeterPerSecond, -1, cNewtonSquareMeterPerSquareCoulomb, cMeterPerSquareSecond, cSquareNewton, cScalar, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cGrayPerSecond, cCubicMeterPerSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cMeterSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, cQuarticMeterSecond, -1, -1, -1, -1, -1, cCoulombMeter, -1, -1, -1, -1, -1, -1, -1, cMeter, cMeterPerSecond, cMeterPerSecond, cSquareMeter, cSquareMeterPerSecond, cSquareMeterPerSquareSecond, cGrayPerSecond, -1, -1, cCubicMeterPerSecond, -1, -1, cKilogramMeter, cKilogramSquareMeter, -1, -1, cSecond, -1, cSecondPerMeter, -1, -1, -1, -1, cSquareSecond, -1, -1, -1, cKilogramSquareMeterPerSecond, cKilogramSquareMeterPerSecond, -1, cKilogramPerSecond, -1, -1, cNewtonSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, cFarad, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cPoiseuille, cKilogramMeterPerSecond, cQuarticMeter, cKilogram, cCubicMeter, -1, -1, cKilogramPerCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cJoule, cNewton, cNewtonPerMeter, -1, cJoulePerKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWeber, -1, -1, -1, -1, cOhm, -1, -1, -1, -1, cCoulomb, -1, -1, -1, -1, cSecond, -1, -1, -1, -1, -1, -1, -1, -1, cCoulombPerMeter, -1, -1, -1, cCubicMeterPerSquareSecond, cMeter, -1, -1, cQuarticMeterSecond, cCubicMeter, cNewtonSquareMeter, -1, cJoule, cNewton, cNewtonPerMeter, cKilogramMeterPerSecond, -1, -1),
    (cKilogramMeter, -1, -1, -1, -1, -1, -1, cKilogramSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramMeterPerSecond, cNewton, cNewton, cKilogramSquareMeterPerSecond, cJoule, cWatt, -1, -1, -1, cNewtonSquareMeter, -1, -1, -1, -1, -1, -1, cKilogram, -1, cKilogramPerMeter, cKilogramPerSquareMeter, cKilogramPerCubicMeter, -1, -1, -1, cSquareKilogram, cSquareKilogramPerMeter, cSquareKilogramPerSquareMeter, cSquareKilogramSquareMeterPerSquareSecond, cSquareKilogramSquareMeterPerSquareSecond, -1, cSquareKilogramPerSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareCoulombPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cQuarticMeter, -1, cNewtonCubicMeter, cSquareJouleSquareSecond, -1, cSquareMeterPerSquareSecond, -1, -1, cCubicMeterPerKilogram, -1, -1, -1, -1, -1, -1, cKilogramKelvin, -1, -1, -1, -1, -1, -1, cCubicSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogram, -1, -1, -1, -1, cCoulombMeter, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramMeterPerSecond, cKilogramSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cKilogramPerSecond, cKilogram, -1, cKilogramSquareSecond, -1, -1, -1, cKilogramMeterPerSecond, -1, cKilogramSquareMeterPerSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewtonPerMeter, cWattPerSquareMeter, cWattPerSquareMeter, cNewton, cWattPerMeter, -1, -1, -1, -1, cWatt, cKilogramMeter, -1, cSquareKilogramPerSquareSecond, -1, -1, -1, cPoiseuille, -1, -1, -1, cKilogramPerQuarticMeterPerSecond, -1, cSquareKilogramSquareMeterPerSquareSecond, cKilogramPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareNewton, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewtonSquareMeter, -1, cJoule, -1, -1, -1, cCubicMeterPerSecond, -1, -1, -1, -1, cMeterPerCubicSecond, -1, -1, -1, -1, -1, -1, -1, cWattPerKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cOhm, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cPoiseuille, -1, -1, -1, -1, cAmpere, -1, -1, -1, -1, -1, -1, -1, -1, cNewtonPerMeter, cKilogramMeterPerSecond, cKilogramSquareMeterPerSecond, -1, cJoule, cSquareNewton, -1, -1, -1, -1, -1, -1, -1),
    (cKilogramMeterPerSecond, cKilogramMeter, -1, -1, -1, -1, -1, cKilogramSquareMeterPerSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewton, cWattPerMeter, cWattPerMeter, cJoule, cWatt, -1, -1, -1, -1, -1, cKilogramSquareMeter, -1, -1, cSquareKilogramSquareMeterPerSquareSecond, -1, -1, cKilogramPerSecond, -1, cPoiseuille, -1, -1, -1, -1, cKilogram, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareCoulombPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewtonCubicMeter, cSquareKilogramPerSquareSecond, cNewtonSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, cGrayPerSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareNewton, -1, -1, -1, -1, -1, cSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cOhmMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramPerSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewton, cKilogramSquareMeterPerSecond, -1, -1, cNewtonSquareMeter, -1, -1, cSquareNewton, -1, -1, -1, -1, -1),
    (cSquareKilogramSquareMeterPerSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, cSquareJouleSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareNewton, cSquareNewton, -1, -1, -1, -1, -1, -1, cSquareJoule, -1, -1, -1, -1, -1, -1, -1, -1, cSquareKilogramPerSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareKilogram, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareJouleSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cReciprocalSquareRootMeter, -1, -1, -1, -1, -1, -1, cSquareRootMeter, cScalar, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cReciprocalMeter, cReciprocalSquareRootCubicMeter, cReciprocalSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cReciprocalSquareRootCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareRootMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cReciprocalMeter, cSecondPerMeter, -1, -1, -1, -1, -1, cScalar, cReciprocalSquareRootMeter, cMeter, cSquareMeter, cCubicMeter, cQuarticMeter, cQuinticMeter, cKilogramPerMeter, cSquareKilogramPerMeter, cAmperePerMeter, -1, cKelvinPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, cHertz, cSquareHertz, -1, -1, -1, -1, cMeterPerSquareSecond, cSecond, cKilogram, cPoiseuille, cKilogramPerSecond, -1, cReciprocalSquareRootCubicMeter, cReciprocalSquareMeter, -1, cReciprocalCubicMeter, cReciprocalQuarticMeter, -1, cKilogramMeter, cKilogramMeterPerSecond, -1, cKilogramPerSquareMeter, cKilogramPerCubicMeter, cKilogramPerQuarticMeter, cNewtonPerMeter, cNewtonPerMeter, -1, cNewtonPerCubicMeter, cNewton, cNewton, cWattPerMeter, cCoulombPerMeter, cSquareCoulombPerMeter, cCoulomb, cVoltPerMeter, -1, cFaradPerMeter, -1, cSiemensPerMeter, -1, -1, cTeslaMeter, cHenryPerMeter, -1, -1, -1, -1, -1, cLumenSecondPerCubicMeter, -1, -1, cPascal, cSquareMeterPerSecond, -1, cMeterPerSecond, -1, -1, -1, -1, -1, cSquareMeterPerSquareSecond, cJoule, cNewtonSquareMeter, -1, cSquareKilogramPerSquareMeter, -1, -1, -1, -1, -1, -1, -1, cKelvin, -1, cWattPerSquareMeter, cWattPerCubicMeter, -1, cWattPerMeterPerKelvin, cWattPerSquareMeterPerKelvin, -1, -1, cKelvinPerWatt, -1, -1, -1, -1, -1, -1, -1, -1, cOhm, -1, cCoulombPerSquareMeter, -1, cCoulombPerCubicMeter, -1, -1, -1, cVolt, -1, -1, cAmperePerSquareMeter, -1, cTesla, -1, cTeslaPerAmpere, cReciprocalSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeterPerCubicSecond, -1, cScalar, cMeter, cSquareMeter, cMeterPerSecond, cWattPerMeter, cNewton, cWattPerSquareMeter, cWattPerCubicMeter, -1, cPascal, -1, -1),
    (cReciprocalSquareRootCubicMeter, -1, -1, -1, -1, -1, -1, cReciprocalSquareRootMeter, cReciprocalMeter, cSquareRootMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cReciprocalSquareMeter, -1, cReciprocalCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cReciprocalSquareRootMeter, cSquareRootMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cReciprocalSquareMeter, -1, cSquareSecondPerSquareMeter, -1, -1, -1, -1, cReciprocalMeter, cReciprocalSquareRootCubicMeter, cScalar, cMeter, cSquareMeter, cCubicMeter, cQuarticMeter, cKilogramPerSquareMeter, cSquareKilogramPerSquareMeter, cAmperePerSquareMeter, -1, -1, -1, -1, -1, -1, cLux, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareHertz, cSecondPerMeter, cKilogramPerMeter, -1, cPoiseuille, cSquareKilogramPerSquareSecond, -1, cReciprocalCubicMeter, -1, cReciprocalQuarticMeter, -1, -1, cKilogram, cKilogramPerSecond, -1, cKilogramPerCubicMeter, cKilogramPerQuarticMeter, -1, cPascal, cPascal, -1, -1, cNewtonPerMeter, cNewtonPerMeter, cWattPerSquareMeter, cCoulombPerSquareMeter, -1, cCoulombPerMeter, -1, -1, -1, -1, -1, -1, -1, cTesla, cTeslaPerAmpere, -1, cLux, cLuxSecond, -1, -1, -1, -1, -1, cNewtonPerCubicMeter, cMeterPerSecond, -1, cHertz, -1, -1, -1, -1, -1, cMeterPerSquareSecond, cNewton, cJoule, -1, -1, -1, -1, cNewtonPerSquareKilogram, -1, -1, -1, -1, cKelvinPerMeter, -1, cWattPerCubicMeter, -1, -1, cWattPerSquareMeterPerKelvin, -1, -1, -1, -1, cReciprocalKelvin, -1, cQuarticKelvin, -1, -1, -1, -1, -1, -1, -1, cCoulombPerCubicMeter, -1, -1, -1, -1, cNewtonPerSquareCoulomb, cVoltPerMeter, -1, -1, -1, -1, -1, -1, -1, cReciprocalCubicMeter, -1, -1, cSquareNewton, cSquareKilogramSquareMeterPerSquareSecond, -1, cAmpere, -1, -1, -1, -1, -1, -1, -1, -1, cReciprocalMeter, cScalar, cMeter, cHertz, cWattPerSquareMeter, cNewtonPerMeter, cWattPerCubicMeter, -1, -1, cNewtonPerCubicMeter, -1, -1),
    (cReciprocalCubicMeter, -1, -1, -1, -1, -1, -1, cReciprocalSquareMeter, -1, cReciprocalMeter, cScalar, cMeter, cSquareMeter, cCubicMeter, cKilogramPerCubicMeter, -1, -1, -1, -1, -1, -1, -1, cMolePerCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramPerSquareMeter, -1, -1, -1, -1, cReciprocalQuarticMeter, -1, -1, -1, -1, cKilogramPerMeter, cPoiseuille, -1, cKilogramPerQuarticMeter, -1, -1, cNewtonPerCubicMeter, cNewtonPerCubicMeter, -1, -1, cPascal, cPascal, cWattPerCubicMeter, cCoulombPerCubicMeter, -1, cCoulombPerSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cLumenSecondPerCubicMeter, -1, -1, -1, cKatalPerCubicMeter, -1, -1, cHertz, cKilogramPerQuarticMeterPerSecond, -1, -1, cMeterSecond, -1, -1, -1, cSquareHertz, cNewtonPerMeter, cNewton, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cReciprocalQuarticMeter, -1, -1, -1, -1, -1, cAmperePerMeter, -1, -1, -1, -1, -1, -1, -1, -1, cReciprocalSquareMeter, cReciprocalMeter, cScalar, -1, cWattPerCubicMeter, cPascal, -1, -1, -1, -1, -1, -1),
    (cReciprocalQuarticMeter, -1, -1, -1, -1, -1, -1, cReciprocalCubicMeter, -1, cReciprocalSquareMeter, cReciprocalMeter, cScalar, cMeter, cSquareMeter, cKilogramPerQuarticMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramPerCubicMeter, cKilogramPerQuarticMeterPerSecond, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramPerSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewtonPerCubicMeter, cNewtonPerCubicMeter, -1, -1, -1, cCoulombPerCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSecond, -1, -1, -1, -1, cPascal, cNewtonPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareKilogramPerSquareSecond, -1, cAmperePerSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, cReciprocalCubicMeter, cReciprocalSquareMeter, cReciprocalMeter, -1, -1, cNewtonPerCubicMeter, -1, -1, -1, -1, -1, -1),
    (cKilogramSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramSquareMeterPerSecond, cJoule, cJoule, -1, cNewtonSquareMeter, -1, -1, -1, -1, cNewtonCubicMeter, -1, -1, -1, -1, -1, -1, cKilogramMeter, -1, cKilogram, cKilogramPerMeter, cKilogramPerSquareMeter, -1, -1, -1, -1, cSquareKilogram, cSquareKilogramPerMeter, -1, -1, -1, -1, cSquareJouleSquareSecond, cSquareJouleSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareCoulomb, -1, -1, -1, -1, -1, -1, cSquareKilogramPerSquareSecond, cSquareKilogramSquareMeterPerSquareSecond, -1, -1, -1, cSquareKilogramPerSquareMeter, -1, -1, cQuinticMeter, -1, -1, -1, -1, cCubicMeterPerSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramMeter, -1, cKilogramSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramSquareMeterPerSecond, -1, -1, -1, -1, -1, cSquareJouleSquareSecond, -1, -1, -1, cSquareKilogramSquareMeterPerSquareSecond, -1, -1),
    (cKilogramSquareMeterPerSecond, cKilogramSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cJoule, cWatt, cWatt, cNewtonSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, cSquareKilogramSquareMeterPerSquareSecond, -1, -1, -1, cKilogramMeterPerSecond, -1, cKilogramPerSecond, cPoiseuille, -1, -1, cSquareJouleSquareSecond, cKilogramMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareJoule, -1, -1, -1, -1, -1, -1, -1, cSquareCoulomb, cSquareCoulombPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewtonCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareNewton, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramMeterPerSecond, -1, -1, -1, -1, cSquareMeterAmpere, -1, -1, -1, -1, -1, -1, -1, -1, cJoule, -1, -1, -1, cNewtonCubicMeter, cSquareJoule, -1, -1, cSquareNewton, -1, -1, -1, -1),
    (cSecondPerMeter, -1, -1, -1, -1, -1, -1, cSecond, -1, cMeterSecond, -1, -1, cQuarticMeterSecond, -1, -1, -1, cCoulombPerMeter, -1, -1, -1, -1, -1, -1, -1, cReciprocalMeter, -1, -1, cScalar, cHertz, cSquareHertz, -1, -1, -1, cMeterPerSecond, cSquareSecond, -1, cKilogramPerMeter, cKilogram, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramMeter, cSquareSecondPerSquareMeter, -1, -1, -1, cKilogramPerSecond, cKilogramPerSecond, -1, -1, cKilogramMeterPerSecond, cKilogramMeterPerSecond, cNewton, -1, -1, -1, cTeslaMeter, -1, -1, cHenryPerMeter, cFaradPerMeter, -1, -1, -1, -1, cSiemensPerMeter, -1, -1, -1, cLumenSecondPerCubicMeter, -1, -1, -1, cPoiseuille, cSquareMeter, cKilogramPerSquareMeter, cMeter, -1, -1, -1, -1, -1, cSquareMeterPerSecond, cKilogramSquareMeterPerSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewtonPerMeter, cPascal, cNewtonPerCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cHenry, cTesla, -1, -1, -1, -1, -1, cOhm, cWeber, cVolt, -1, cCoulombPerSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCoulombMeter, -1, -1, cCoulombPerCubicMeter, -1, cLumenSecondPerCubicMeter, -1, cMeterPerSquareSecond, cReciprocalMeter, cSecond, cMeterSecond, -1, cMeter, cNewton, cKilogramMeterPerSecond, cNewtonPerMeter, cPascal, cNewtonPerCubicMeter, cPoiseuille, -1, -1),
    (cKilogramPerMeter, -1, -1, -1, -1, -1, -1, cKilogram, -1, cKilogramMeter, cKilogramSquareMeter, -1, -1, -1, cSquareKilogramPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, cPoiseuille, cPascal, cPascal, cKilogramPerSecond, cNewtonPerMeter, cWattPerSquareMeter, -1, -1, -1, cNewton, -1, cSquareKilogram, -1, -1, -1, -1, cKilogramPerSquareMeter, -1, cKilogramPerCubicMeter, cKilogramPerQuarticMeter, -1, -1, -1, -1, cSquareKilogramPerSquareMeter, -1, -1, cSquareKilogramPerSquareSecond, cSquareKilogramPerSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramSquareMeterPerSecond, -1, cKilogramMeterPerSecond, -1, -1, -1, cSquareMeter, -1, cJoule, cSquareKilogramSquareMeterPerSquareSecond, -1, cSquareHertz, -1, -1, -1, cSquareMeterPerSquareSecond, -1, -1, -1, -1, cKilogramKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cHenryPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramPerSquareMeter, -1, -1, -1, -1, cCoulombPerMeter, -1, -1, -1, -1, -1, -1, -1, cWattPerMeter, cPoiseuille, cKilogram, cKilogramMeter, cKilogramSquareMeter, cKilogramMeterPerSecond, -1, -1, -1, -1, -1, -1, -1, -1),
    (cKilogramPerSquareMeter, -1, -1, -1, -1, -1, -1, cKilogramPerMeter, -1, cKilogram, cKilogramMeter, cKilogramSquareMeter, -1, -1, cSquareKilogramPerSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewtonPerCubicMeter, cNewtonPerCubicMeter, cPoiseuille, cPascal, cWattPerCubicMeter, -1, -1, -1, cNewtonPerMeter, -1, cSquareKilogramPerMeter, -1, -1, -1, -1, cKilogramPerCubicMeter, -1, cKilogramPerQuarticMeter, -1, -1, cSquareKilogram, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareKilogramPerSquareSecond, cSquareKilogramPerSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramMeterPerSecond, -1, cKilogramPerSecond, -1, -1, -1, cMeter, -1, cNewton, -1, cSquareKilogramSquareMeterPerSquareSecond, -1, -1, -1, -1, cMeterPerSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cTeslaPerAmpere, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramPerCubicMeter, -1, -1, -1, -1, cCoulombPerSquareMeter, -1, -1, -1, -1, -1, -1, -1, cWattPerSquareMeter, -1, cKilogramPerMeter, cKilogram, cKilogramMeter, cKilogramPerSecond, -1, cSquareKilogramPerSquareSecond, -1, -1, -1, -1, -1, -1),
    (cKilogramPerCubicMeter, -1, -1, -1, -1, -1, -1, cKilogramPerSquareMeter, -1, cKilogramPerMeter, cKilogram, cKilogramMeter, cKilogramSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewtonPerCubicMeter, -1, -1, -1, -1, cPascal, -1, cSquareKilogramPerSquareMeter, -1, -1, -1, -1, cKilogramPerQuarticMeter, -1, -1, -1, -1, cSquareKilogramPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramPerSecond, -1, cPoiseuille, -1, -1, -1, cScalar, -1, cNewtonPerMeter, cSquareKilogramPerSquareSecond, -1, -1, -1, -1, -1, cSquareHertz, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramPerQuarticMeter, -1, -1, -1, -1, cCoulombPerCubicMeter, -1, -1, -1, -1, -1, -1, -1, cWattPerCubicMeter, -1, cKilogramPerSquareMeter, cKilogramPerMeter, cKilogram, cPoiseuille, -1, -1, -1, -1, -1, -1, -1, -1),
    (cNewton, cKilogramMeterPerSecond, cKilogramMeter, -1, -1, -1, -1, cJoule, -1, cNewtonSquareMeter, cNewtonCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWattPerMeter, -1, -1, cWatt, -1, -1, -1, -1, -1, -1, cKilogramSquareMeterPerSecond, cSquareKilogramSquareMeterPerSquareSecond, -1, -1, -1, -1, cNewtonPerMeter, -1, cPascal, cNewtonPerCubicMeter, -1, -1, -1, cKilogramPerSecond, cSquareKilogramPerSquareSecond, -1, -1, cSquareNewton, cSquareNewton, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareCoulombPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareJoule, -1, -1, -1, -1, cNewtonSquareMeterPerSquareKilogram, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewtonSquareMeterPerSquareCoulomb, -1, cSquareVolt, -1, -1, -1, -1, cWeber, -1, -1, -1, cNewtonPerMeter, -1, cKilogramPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWattPerMeter, cJoule, cNewtonSquareMeter, cNewtonCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cNewton, cKilogramMeterPerSecond, cKilogramMeter, -1, -1, -1, -1, cJoule, -1, cNewtonSquareMeter, cNewtonCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWattPerMeter, -1, -1, cWatt, -1, -1, -1, -1, -1, -1, cKilogramSquareMeterPerSecond, cSquareKilogramSquareMeterPerSquareSecond, -1, -1, -1, -1, cNewtonPerMeter, -1, cPascal, cNewtonPerCubicMeter, -1, -1, -1, cKilogramPerSecond, cSquareKilogramPerSquareSecond, -1, -1, cSquareNewton, cSquareNewton, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareCoulombPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareJoule, -1, -1, -1, -1, cNewtonSquareMeterPerSquareKilogram, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewtonSquareMeterPerSquareCoulomb, -1, cSquareVolt, -1, -1, -1, -1, cWeber, -1, -1, -1, cNewtonPerMeter, -1, cKilogramPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWattPerMeter, cJoule, cNewtonSquareMeter, cNewtonCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cSquareNewton, -1, cSquareKilogramSquareMeterPerSquareSecond, -1, -1, -1, -1, -1, -1, cSquareJoule, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramMeterPerSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareVolt, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareKilogramPerSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareJoule, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cPascal, cPoiseuille, cKilogramPerMeter, -1, -1, -1, -1, cNewtonPerMeter, -1, cNewton, cJoule, cNewtonSquareMeter, cNewtonCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWattPerCubicMeter, -1, -1, cWattPerSquareMeter, -1, -1, -1, -1, -1, -1, cKilogramPerSecond, cSquareKilogramPerSquareSecond, -1, -1, -1, -1, cNewtonPerCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWatt, -1, cWattPerMeter, -1, -1, -1, cSquareMeterPerSquareSecond, cSquareKilogramPerMeter, -1, cSquareNewton, -1, -1, -1, -1, cNewtonPerSquareKilogram, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewtonPerSquareCoulomb, -1, -1, -1, -1, -1, -1, cTesla, -1, -1, -1, cNewtonPerCubicMeter, -1, cKilogramPerCubicMeter, -1, -1, -1, -1, cLumenSecondPerCubicMeter, -1, -1, -1, -1, -1, -1, cWattPerCubicMeter, cNewtonPerMeter, cNewton, cJoule, cWattPerMeter, -1, -1, -1, -1, -1, -1, -1, -1),
    (cJoule, cKilogramSquareMeterPerSecond, cKilogramSquareMeter, -1, -1, -1, -1, cNewtonSquareMeter, -1, cNewtonCubicMeter, -1, -1, -1, -1, cSquareKilogramSquareMeterPerSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWatt, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewton, -1, cNewtonPerMeter, cPascal, cNewtonPerCubicMeter, cSquareJouleSquareSecond, -1, cKilogramMeterPerSecond, -1, cSquareKilogramPerSquareSecond, -1, -1, -1, -1, -1, cSquareJoule, cSquareJoule, -1, -1, -1, -1, -1, -1, cSquareCoulomb, -1, -1, -1, -1, -1, -1, cSquareAmpere, -1, -1, -1, -1, -1, -1, -1, cSquareNewton, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cJoulePerKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeterSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareCoulombPerMeter, -1, -1, -1, -1, -1, cNewton, -1, cKilogram, -1, -1, -1, -1, cLumenSecond, cJoulePerMole, -1, -1, -1, -1, -1, cWatt, cNewtonSquareMeter, cNewtonCubicMeter, -1, -1, -1, cSquareJoule, -1, -1, -1, cSquareNewton, -1, -1),
    (cJoule, cKilogramSquareMeterPerSecond, cKilogramSquareMeter, -1, -1, -1, -1, cNewtonSquareMeter, -1, cNewtonCubicMeter, -1, -1, -1, -1, cSquareKilogramSquareMeterPerSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWatt, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewton, -1, cNewtonPerMeter, cPascal, cNewtonPerCubicMeter, cSquareJouleSquareSecond, -1, cKilogramMeterPerSecond, -1, cSquareKilogramPerSquareSecond, -1, -1, -1, -1, -1, cSquareJoule, cSquareJoule, -1, -1, -1, -1, -1, -1, cSquareCoulomb, -1, -1, -1, -1, -1, -1, cSquareAmpere, -1, -1, -1, -1, -1, -1, -1, cSquareNewton, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cJoulePerKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeterSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareCoulombPerMeter, -1, -1, -1, -1, -1, cNewton, -1, cKilogram, -1, -1, -1, -1, cLumenSecond, cJoulePerMole, -1, -1, -1, -1, -1, cWatt, cNewtonSquareMeter, cNewtonCubicMeter, -1, -1, -1, cSquareJoule, -1, -1, -1, cSquareNewton, -1, -1),
    (cWatt, cJoule, cKilogramSquareMeterPerSecond, cKilogramSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewtonSquareMeter, -1, cSquareNewton, -1, -1, -1, cWattPerMeter, -1, cWattPerSquareMeter, cWattPerCubicMeter, -1, -1, cSquareJoule, cNewton, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareVolt, cSquareAmpere, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWattPerKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKelvin, cMeter, cMeterKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cVoltMeter, -1, -1, -1, cWattPerMeter, -1, cKilogramPerSecond, -1, -1, -1, -1, cCandela, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cCoulomb, -1, -1, -1, -1, -1, -1, cCoulombMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cAmpere, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCoulombPerMeter, -1, cCoulombPerSquareMeter, cCoulombPerCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareCoulomb, -1, -1, cJoule, -1, -1, cWeber, -1, -1, cKilogramPerSecond, cKilogramSquareMeterPerSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareMeterAmpere, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewton, cSquareCoulombPerMeter, -1, -1, -1, cVoltPerMeter, cVoltMeter, cNewtonSquareMeter, -1, -1, -1, cMeterSecond, cKilogramMeterPerSecond, -1, -1, cCoulombPerMeter, -1, -1, -1, -1, -1, -1, -1, cCoulombPerMole, -1, -1, -1, -1, -1, cAmpere, cCoulombMeter, -1, -1, cSquareMeterAmpere, -1, -1, -1, -1, -1, -1, -1, -1),
    (cSquareCoulomb, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareAmpere, cSquareAmpere, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareCoulombPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareJoule, -1, cKilogramSquareMeterPerSecond, -1, -1, -1, -1, cKilogramSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareMeter, cNewton, cNewtonSquareMeter, -1, -1, -1, -1, -1, -1, cKilogram, cKilogramMeter, cSquareCoulombPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cCoulombMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareMeterAmpere, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCoulomb, -1, cCoulombPerMeter, cCoulombPerSquareMeter, cCoulombPerCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewtonSquareMeter, -1, -1, -1, -1, -1, cKilogramMeterPerSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cJoule, cSquareCoulomb, -1, cSquareCoulombPerMeter, -1, cVolt, -1, cNewtonCubicMeter, -1, -1, -1, -1, cKilogramSquareMeterPerSecond, -1, -1, cCoulomb, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cVolt, cWeber, -1, -1, -1, -1, -1, cVoltMeter, -1, -1, -1, -1, -1, -1, -1, -1, cWatt, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cVoltMeterPerSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cVoltPerMeter, -1, -1, -1, -1, -1, -1, cTeslaMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cJoule, -1, cNewtonSquareMeter, cSquareVolt, -1, cCoulomb, -1, cAmpere, cAmperePerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeterPerAmpere, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewton, -1, cNewtonPerMeter, -1, -1, -1, -1, -1, cCoulombPerMeter, cWattPerMeter, cOhmMeter, -1, -1, -1, cVoltPerMeter, -1, -1, -1, -1, cSquareMeterPerSquareSecond, -1, -1, -1, cWattPerSquareMeter, -1, -1, cPascal, -1, -1, cVoltMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cJoulePerMole),
    (cSquareVolt, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareJoule, -1, -1, -1, cJoule, -1, cWatt, cWattPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cOhmMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewton, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cFarad, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSiemens, cReciprocalHenry, cReciprocalHenry, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cFaradPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareCoulombPerMeter, cSquareCoulombPerMeter, -1, -1, cSquareCoulomb, cSquareCoulomb, -1, -1, -1, -1, cCoulomb, cJoule, -1, cSecond, -1, -1, -1, -1, cSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeterSecond, cCoulombPerMeter, -1, -1, -1, -1, cReciprocalMeter, cMeter, cCoulombMeter, -1, -1, -1, -1, -1, cSquareSecondPerSquareMeter, -1, cFaradPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSiemens, -1, -1, -1, -1, -1, cSquareCoulomb, -1, -1, -1, -1, -1, -1),
    (cOhm, cHenry, -1, -1, -1, -1, -1, cOhmMeter, -1, -1, -1, -1, -1, -1, -1, -1, cVolt, cWatt, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewtonSquareMeterPerSquareCoulomb, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cHenryPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareVolt, cWeber, cKilogramSquareMeterPerSecond, -1, -1, -1, cSecond, -1, cScalar, cReciprocalMeter, -1, -1, -1, cHertz, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cTeslaMeter, cKilogramMeterPerSecond, cTesla, -1, -1, -1, -1, -1, cSecondPerMeter, cVoltPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cOhmMeter, -1, -1, -1, cSquareVolt, -1, -1, -1, -1, -1, -1, -1),
    (cSiemens, cFarad, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cReciprocalHenry, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareCoulombPerMeter, -1, -1, cSiemensPerMeter, -1, -1, -1, -1, -1, cSquareCoulomb, cFaradPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareAmpere, -1, -1, -1, cAmpere, cWatt, -1, cScalar, -1, -1, cCoulombPerSquareMeter, cCoulomb, cSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeter, cAmperePerMeter, -1, -1, -1, -1, -1, cMeterPerSecond, -1, -1, -1, -1, -1, cCoulombPerMeter, -1, cSecondPerMeter, cSiemensPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cReciprocalHenry, -1, -1, -1, -1, cSquareAmpere, -1, -1, -1, -1, -1, -1, -1),
    (cSiemensPerMeter, cFaradPerMeter, -1, -1, -1, -1, -1, cSiemens, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cReciprocalHenry, -1, -1, -1, -1, -1, -1, cFarad, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareCoulombPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cAmperePerMeter, cWattPerMeter, -1, cReciprocalMeter, -1, -1, cCoulombPerCubicMeter, cCoulombPerMeter, cSecondPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cScalar, cAmperePerSquareMeter, -1, -1, -1, -1, -1, cHertz, cAmpere, -1, -1, -1, -1, cCoulombPerSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSiemens, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cTesla, -1, -1, -1, -1, -1, -1, cTeslaMeter, -1, cWeber, -1, -1, -1, -1, -1, -1, cNewtonPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cVoltPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramPerSecond, -1, cKilogramMeterPerSecond, -1, -1, -1, -1, cCoulombPerSquareMeter, cCoulombPerCubicMeter, -1, -1, -1, cAmperePerSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, cVoltMeter, -1, cVolt, -1, -1, -1, -1, -1, cVoltMeterPerSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cPoiseuille, -1, -1, -1, -1, -1, -1, -1, -1, cPascal, cHenryPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, cHertz, cJoule, -1, -1, cNewtonPerCubicMeter, -1, -1, -1, -1, -1, cTeslaMeter, cWeber, -1, cVolt, -1, -1, -1, -1, -1, -1, -1, -1),
    (cWeber, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cJoule, -1, -1, -1, -1, -1, -1, -1, cVolt, -1, -1, cVoltMeter, cVoltMeterPerSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cTeslaMeter, -1, cTesla, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramSquareMeterPerSecond, -1, -1, -1, -1, -1, -1, cCoulomb, cCoulombPerMeter, -1, -1, -1, cAmpere, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramMeterPerSecond, -1, cKilogramPerSecond, -1, -1, -1, -1, -1, -1, cNewton, -1, -1, -1, -1, cTeslaMeter, -1, -1, -1, -1, cSquareMeterPerSecond, cNewtonCubicMeter, -1, -1, cNewtonPerMeter, -1, -1, cPoiseuille, -1, cVolt, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cHenry, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWeber, cJoule, -1, -1, -1, -1, -1, -1, cOhm, -1, -1, cOhmMeter, cNewtonSquareMeterPerSquareCoulomb, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cHenryPerMeter, -1, cTeslaPerAmpere, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramSquareMeter, -1, -1, -1, cSquareSecond, -1, cSecond, cSecondPerMeter, -1, -1, -1, cScalar, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramMeter, -1, -1, -1, -1, -1, -1, -1, cTeslaMeter, -1, -1, -1, -1, cHenryPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, cTesla, -1, -1, -1, -1, cOhm, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cReciprocalHenry, cSiemens, cFarad, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareCoulombPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareCoulomb, -1, cSiemensPerMeter, -1, -1, -1, -1, -1, -1, -1, cSquareAmpere, cSquareAmpere, -1, -1, -1, -1, -1, -1, -1, cHertz, -1, -1, cAmperePerSquareMeter, cAmpere, cScalar, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeterPerSecond, -1, -1, -1, -1, -1, -1, cMeterPerSquareSecond, -1, -1, -1, -1, -1, cAmperePerMeter, cReciprocalSquareMeter, cReciprocalMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareAmpere, -1, -1, -1, -1, -1, -1),
    (cCandela, cLumenSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cLux, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cLumenSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCandela, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cLuxSecond, cLumenSecondPerCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCandela, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cLumenSecondPerCubicMeter, -1, -1, -1, -1, -1, -1, cLuxSecond, -1, -1, cLumenSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cLux, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCandela, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cLuxSecond, -1, cLumenSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cLux, cLuxSecond, -1, -1, -1, -1, -1, -1, -1, cCandela, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cLumenSecondPerCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCandela, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cLuxSecond, -1, -1, -1, -1, -1, -1, -1, -1, cLumenSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cLux, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cLumenSecondPerCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCandela, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cLumenSecondPerCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cLux, -1, cLumenSecond, -1, cCandela, -1, -1, -1, -1, -1, -1, -1, -1),
    (cKatal, cMole, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKatalPerCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWatt, -1, cWattPerKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cHertz, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cAmpere),
    (cNewtonPerCubicMeter, -1, cKilogramPerSquareMeter, -1, -1, -1, -1, cPascal, -1, cNewtonPerMeter, cNewton, cJoule, cNewtonSquareMeter, cNewtonCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWattPerCubicMeter, -1, -1, -1, -1, -1, -1, cPoiseuille, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareKilogramPerSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWattPerMeter, -1, cWattPerSquareMeter, -1, cKilogramSquareMeterPerSecond, -1, cMeterPerSquareSecond, cSquareKilogramPerSquareMeter, -1, -1, cSquareNewton, -1, -1, -1, -1, cMeterPerQuarticSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramPerQuarticMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cPascal, cNewtonPerMeter, cNewton, cWattPerSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1),
    (cNewtonPerMeter, cKilogramPerSecond, cKilogram, -1, cKilogramSquareSecond, -1, -1, cNewton, -1, cJoule, cNewtonSquareMeter, cNewtonCubicMeter, -1, -1, cSquareKilogramPerSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWattPerSquareMeter, -1, -1, cWattPerMeter, -1, -1, -1, -1, -1, -1, cKilogramMeterPerSecond, -1, -1, -1, -1, -1, cPascal, -1, cNewtonPerCubicMeter, -1, -1, cSquareKilogramSquareMeterPerSquareSecond, -1, cPoiseuille, -1, -1, -1, -1, -1, -1, -1, cSquareNewton, cSquareNewton, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWatt, -1, -1, -1, cCubicMeterPerSquareSecond, cSquareKilogram, -1, -1, cSquareJoule, cMeterPerQuarticSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSecondPerMeter, -1, cJoulePerKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cTeslaMeter, -1, -1, -1, cPascal, -1, cKilogramPerSquareMeter, -1, -1, -1, -1, cLuxSecond, -1, -1, -1, -1, -1, -1, cWattPerSquareMeter, cNewton, cJoule, cNewtonSquareMeter, cWatt, -1, cSquareNewton, -1, -1, -1, -1, -1, -1),
    (cCubicMeterPerSecond, cCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCubicMeterPerSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, cQuarticMeter, -1, cNewtonSquareMeter, cNewtonCubicMeter, -1, -1, cSquareMeterPerSecond, -1, cMeterPerSecond, cHertz, -1, -1, -1, cSquareMeter, cKilogramSquareMeterPerSecond, cKilogramMeterPerSecond, cKilogramPerSecond, -1, -1, -1, cWatt, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cVoltMeter, -1, -1, -1, -1, -1, cCandela, -1, -1, -1, cWattPerMeter, -1, -1, cJoule, -1, cPoiseuille, -1, cPascal, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareMeterAmpere, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cOhmMeter, -1, cSquareMeterPerSecond, -1, cMeterSecond, -1, -1, -1, -1, -1, -1, -1, cKatal, -1, cAmpere, -1, cCubicMeterPerSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cPoiseuille, cKilogramPerMeter, -1, -1, -1, -1, -1, cKilogramPerSecond, -1, cKilogramMeterPerSecond, cKilogramSquareMeterPerSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cPascal, cWattPerCubicMeter, cWattPerCubicMeter, cNewtonPerMeter, cWattPerSquareMeter, -1, -1, -1, -1, cWattPerMeter, cKilogram, -1, -1, cSquareKilogramPerSquareSecond, -1, -1, -1, -1, -1, cKilogramPerQuarticMeterPerSecond, -1, -1, -1, cKilogramPerSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cJoule, -1, cNewton, -1, -1, -1, cSquareMeterPerSecond, -1, cWatt, -1, -1, -1, -1, -1, -1, cGrayPerSecond, -1, -1, -1, cWattPerMeterPerKelvin, -1, -1, -1, -1, -1, -1, -1, -1, cSquareSecondPerSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cAmperePerMeter, -1, -1, -1, -1, -1, -1, -1, -1, cPascal, cKilogramPerSecond, cKilogramMeterPerSecond, cKilogramSquareMeterPerSecond, cNewton, -1, -1, -1, -1, -1, -1, -1, -1),
    (cSquareMeterPerSecond, cSquareMeter, -1, -1, -1, -1, -1, cCubicMeterPerSecond, -1, -1, -1, -1, -1, -1, cKilogramSquareMeterPerSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareMeterPerSquareSecond, cGrayPerSecond, cGrayPerSecond, cCubicMeterPerSquareSecond, -1, -1, -1, -1, -1, -1, cCubicMeter, -1, cJoule, cNewtonSquareMeter, -1, -1, cMeterPerSecond, -1, cHertz, -1, -1, -1, cNewtonCubicMeter, cMeter, cKilogramMeterPerSecond, cKilogramPerSecond, cPoiseuille, -1, -1, -1, cWattPerMeter, -1, -1, -1, cSquareMeterAmpere, -1, -1, -1, -1, -1, -1, -1, -1, cVolt, -1, -1, -1, -1, -1, -1, -1, cCandela, -1, cWattPerSquareMeter, cWatt, -1, cNewton, -1, -1, cSexticMeter, cNewtonPerCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cVoltMeterPerSecond, -1, -1, cAmpere, -1, -1, -1, -1, -1, -1, -1, -1, cVoltMeter, cOhm, cOhmMeter, cMeterPerSecond, -1, cSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, cAmperePerMeter, -1, cSquareMeterPerSquareSecond, cCubicMeterPerSecond, -1, -1, -1, -1, -1, -1, -1, -1, cWatt, -1, -1),
    (cKilogramPerQuarticMeter, -1, -1, -1, -1, -1, -1, cKilogramPerCubicMeter, -1, cKilogramPerSquareMeter, cKilogramPerMeter, cKilogram, cKilogramMeter, cKilogramSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramPerQuarticMeterPerSecond, -1, -1, -1, -1, -1, -1, -1, -1, cNewtonPerCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareKilogramPerSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cPoiseuille, -1, -1, -1, -1, -1, cReciprocalMeter, -1, cPascal, -1, cSquareKilogramPerSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramPerQuarticMeterPerSecond, cKilogramPerCubicMeter, cKilogramPerSquareMeter, cKilogramPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cQuarticMeterSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cQuarticMeter, -1, -1, cQuinticMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeterSecond, cSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramSquareMeterPerSecond, -1, -1, -1, cSexticMeter, -1, -1, cKilogram, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewtonCubicMeter, cNewtonSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cQuarticMeter, -1, -1, -1, cSexticMeter, -1, -1, -1, cNewtonCubicMeter, cNewtonSquareMeter, -1, -1, -1),
    (cKilogramPerQuarticMeterPerSecond, cKilogramPerQuarticMeter, -1, -1, -1, -1, -1, -1, -1, -1, cPoiseuille, cKilogramPerSecond, cKilogramMeterPerSecond, cKilogramSquareMeterPerSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramPerCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cPascal, -1, cNewtonPerCubicMeter, -1, cKilogram, -1, -1, -1, cWattPerCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cPoiseuille, cNewtonPerCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1),
    (cCubicMeterPerKilogram, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewtonSquareMeterPerSquareKilogram, cNewtonSquareMeterPerSquareKilogram, -1, -1, -1, -1, -1, -1, -1, -1, cQuarticMeter, cCubicMeterPerSecond, -1, -1, -1, -1, -1, -1, -1, -1, cQuinticMeter, -1, -1, cSquareMeter, cMeter, cScalar, -1, -1, -1, cSquareMeterPerSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeterPerSquareSecond, cCubicMeterPerSquareSecond, -1, cSquareMeterPerSecond, -1, cReciprocalMeter, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramSquareMeter, cKilogramMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cGrayPerSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewtonSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCoulombPerKilogram, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cGrayPerSecond, cCubicMeterPerSquareSecond, -1, -1),
    (cKilogramSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogram, cKilogram, -1, cKilogramMeter, cKilogramMeterPerSecond, cNewton, cWattPerMeter, -1, cKilogramSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareKilogramPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareKilogramPerSquareMeter, cSquareKilogram, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeter, -1, -1, -1, cCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramSquareMeterPerSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareKilogram, -1, -1),
    (cCubicMeterPerSquareSecond, cCubicMeterPerSecond, cCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewtonSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewtonCubicMeter, -1, -1, -1, -1, cSquareMeterPerSquareSecond, -1, cMeterPerSquareSecond, cSquareHertz, -1, -1, -1, cSquareMeterPerSecond, cJoule, cNewton, cNewtonPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cVoltMeterPerSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWatt, -1, cPascal, -1, cWattPerCubicMeter, -1, -1, -1, -1, -1, -1, cSquareKilogramSquareMeterPerSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewtonSquareMeterPerSquareCoulomb, -1, cSquareMeterPerSquareSecond, -1, cMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cNewtonSquareMeter, -1, -1, -1, -1, -1, -1, cNewtonCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareJouleSquareSecond, -1, -1, -1, -1, cJoule, -1, cNewton, cNewtonPerMeter, cPascal, -1, -1, cKilogramSquareMeterPerSecond, cSquareKilogramSquareMeterPerSquareSecond, -1, cSquareKilogramPerSquareSecond, cSquareJoule, cSquareJoule, -1, cSquareNewton, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareVolt, -1, -1, -1, cSquareCoulomb, -1, -1, -1, -1, -1, cJoule, -1, cKilogramMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewtonCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cNewtonCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareJouleSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewtonSquareMeter, -1, cJoule, cNewton, cNewtonPerMeter, -1, -1, -1, -1, cSquareKilogramSquareMeterPerSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareNewton, cSquareJoule, -1, -1, -1, cSquareKilogramPerSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewtonSquareMeter, -1, cKilogramSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareJoule, -1, -1),
    (cNewtonPerSquareKilogram, -1, -1, -1, -1, -1, -1, -1, -1, cNewtonSquareMeterPerSquareKilogram, -1, -1, -1, -1, cMeterPerSquareSecond, cNewton, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareMeterPerSquareSecond, cMeterPerCubicSecond, cGrayPerSecond, -1, -1, -1, -1, -1, -1, -1, cCubicMeterPerSquareSecond, -1, -1, cSquareHertz, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeterPerQuarticSecond, -1, -1, -1, -1, -1, -1, -1, cMeter, -1, -1, -1, -1, cNewtonPerMeter, cPascal, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeterPerQuinticSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewtonSquareMeterPerSquareKilogram, -1, -1, -1, -1, -1, cMeterPerQuinticSecond, -1, cMeterPerQuarticSecond, -1, -1),
    (cSquareKilogramPerMeter, -1, -1, -1, -1, -1, -1, cSquareKilogram, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareKilogramPerSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareKilogramPerSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramSquareMeter, -1, cSquareKilogramSquareMeterPerSquareSecond, -1, -1, cNewtonPerMeter, -1, -1, cMeter, cJoule, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareKilogramPerSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareKilogram, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cSquareKilogramPerSquareMeter, -1, -1, -1, -1, -1, -1, cSquareKilogramPerMeter, -1, cSquareKilogram, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareKilogramPerSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramMeter, -1, -1, -1, -1, cPascal, -1, -1, cScalar, cNewton, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareKilogramPerMeter, cSquareKilogram, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cSquareMeterPerSquareKilogram, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCubicMeterPerKilogram, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewtonSquareMeterPerSquareKilogram, cNewtonSquareMeterPerSquareKilogram, -1, cNewtonPerSquareKilogram, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeter, cScalar, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareMeterPerSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cNewtonSquareMeterPerSquareKilogram, -1, cCubicMeterPerKilogram, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCubicMeterPerSquareSecond, cNewtonSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewtonPerSquareKilogram, -1, -1, -1, -1, -1, cSquareMeterPerSquareSecond, cMeterPerSquareSecond, cSquareHertz, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeterPerQuarticSecond, -1, -1, cGrayPerSecond, -1, -1, -1, -1, -1, cCubicMeter, -1, -1, -1, -1, cJoule, cNewton, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cReciprocalKelvin, -1, -1, -1, -1, -1, -1, -1, -1, cSquareMeterKelvin, -1, -1, -1, -1, -1, -1, -1, -1, cScalar, cKelvin, cSquareKelvin, cCubicKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cJoulePerKilogramPerKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cJoulePerKelvin, cJoulePerKelvin, cWattPerKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogram, -1, -1, cMeter, cReciprocalMeter, cWattPerMeterPerKelvin, cWattPerSquareMeterPerKelvin, -1, -1, -1, -1, -1, cMeterPerWatt, -1, -1, -1, -1, -1, cJoulePerMolePerKelvin, cMole, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareMeterKelvin, -1, -1, cWattPerKelvin, cJoulePerKelvin, cWattPerMeterPerKelvin, cWattPerSquareMeterPerKelvin, -1, -1, -1, -1),
    (cKilogramKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogram, -1, cSquareKilogramSquareMeterPerSquareSecond, cJoule, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cJoulePerKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cJoule, -1, -1, -1, -1, -1, cWattPerKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareKilogramSquareMeterPerSquareSecond, -1, -1, cNewtonSquareMeter, cNewton, -1, -1, -1, -1, -1, cSecond, -1, cMeterSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cJoulePerMolePerKelvin, -1, -1, -1, -1, -1, cWattPerKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cJoulePerKilogramPerKelvin, -1, cSquareMeterKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cJoulePerKelvin, -1, -1, -1, cSquareMeterPerSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWattPerKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWattPerMeterPerKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cJoule, -1, -1, cCubicMeterPerSquareSecond, cMeterPerSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cReciprocalKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cMeterKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKelvin, -1, cKelvinPerMeter, -1, -1, -1, -1, -1, cKilogramKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeter, -1, cNewtonSquareMeter, cCubicMeterPerSquareSecond, -1, cSquareKelvin, -1, -1, -1, -1, cWatt, -1, -1, -1, cCubicMeter, cWattPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cKelvinPerMeter, -1, -1, -1, -1, -1, -1, cKelvin, -1, cMeterKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cReciprocalMeter, -1, cNewton, cMeterPerSquareSecond, cSquareKelvin, -1, -1, -1, -1, cWattPerMeter, cWattPerSquareMeter, -1, cKelvinPerWatt, -1, cMeter, cWattPerCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKelvin, cMeterKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cWattPerMeter, cNewton, cKilogramMeterPerSecond, cKilogramMeter, -1, -1, -1, cWatt, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cJoule, -1, -1, cSquareNewton, -1, -1, cWattPerSquareMeter, -1, cWattPerCubicMeter, -1, -1, -1, -1, cNewtonPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWattPerMeterPerKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKelvinPerMeter, cScalar, cKelvin, -1, -1, -1, -1, -1, -1, -1, -1, cSquareVolt, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cVolt, -1, -1, -1, cWattPerSquareMeter, -1, cPoiseuille, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWatt, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cWattPerSquareMeter, cNewtonPerMeter, cKilogramPerSecond, cKilogram, -1, cKilogramSquareSecond, -1, cWattPerMeter, -1, cWatt, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWattPerSquareMeterPerQuarticKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewton, -1, -1, -1, -1, -1, cWattPerCubicMeter, -1, -1, -1, -1, -1, cSquareNewton, cPascal, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewtonCubicMeter, -1, -1, -1, -1, -1, -1, cMeterPerQuinticSecond, -1, -1, -1, -1, cWattPerSquareMeterPerKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cReciprocalMeter, cKelvinPerMeter, cWattPerKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cVoltPerMeter, -1, -1, -1, cWattPerCubicMeter, -1, -1, -1, -1, -1, -1, cLux, -1, -1, -1, -1, -1, -1, -1, cWattPerMeter, cWatt, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cWattPerCubicMeter, cPascal, cPoiseuille, cKilogramPerMeter, -1, -1, -1, cWattPerSquareMeter, -1, cWattPerMeter, cWatt, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewtonPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewtonPerCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewtonSquareMeter, -1, cGrayPerSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cReciprocalSquareMeter, -1, cWattPerMeterPerKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWattPerSquareMeter, cWattPerMeter, cWatt, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cWattPerKelvin, cJoulePerKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWatt, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWattPerMeterPerKelvin, -1, cWattPerSquareMeterPerKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWattPerMeter, -1, -1, -1, -1, -1, cScalar, -1, cMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWattPerMeterPerKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cWattPerMeterPerKelvin, -1, -1, -1, -1, -1, -1, cWattPerKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWattPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cJoulePerKelvin, -1, -1, -1, -1, -1, cWattPerSquareMeterPerKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWatt, cWattPerSquareMeter, -1, -1, -1, -1, -1, cReciprocalMeter, cReciprocalKelvin, cScalar, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWattPerSquareMeterPerKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWattPerKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cKelvinPerWatt, -1, -1, -1, -1, -1, -1, cMeterKelvinPerWatt, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSecond, -1, -1, -1, cKelvinPerMeter, -1, -1, cScalar, cReciprocalMeter, -1, -1, -1, -1, cReciprocalSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeterKelvinPerWatt, -1, -1, -1, cKelvin, -1, cKelvinPerMeter, -1, -1, -1, -1, -1),
    (cMeterPerWatt, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeterKelvinPerWatt, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCubicSecond, -1, cSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSecond, cSecond, cKilogramMeterPerSecond, -1, cMeterSecond, cMeterSecond, cMeter, -1, -1, -1, cMeterPerAmpere, cOhmMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSecondPerMeter, -1, cSquareSecondPerSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKelvinPerWatt, cScalar, cReciprocalMeter, cReciprocalSquareMeter, -1, cReciprocalKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeter, cMeterSecond, cScalar, cReciprocalMeter, cReciprocalSquareMeter, cSecondPerMeter, -1, -1),
    (cMeterKelvinPerWatt, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKelvinPerWatt, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeterKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeterPerWatt, -1, cMeterSecond, -1, -1, -1, cKelvin, cKelvinPerMeter, -1, cMeter, cScalar, -1, -1, -1, -1, cReciprocalMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKelvinPerWatt, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeterKelvin, -1, cKelvin, cKelvinPerMeter, -1, -1, -1, -1),
    (cSquareMeterKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareMeter, -1, -1, -1, -1, -1, -1, cJoulePerKilogramPerKelvin, cJoulePerKilogramPerKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cReciprocalKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cJoulePerKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramSquareMeter, -1, -1, cCubicMeter, cMeter, -1, cWattPerKelvin, cWattPerMeterPerKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWattPerKelvin, cWattPerMeterPerKelvin, cJoulePerKelvin, -1, -1),
    (cWattPerSquareMeterPerKelvin, -1, -1, -1, -1, -1, -1, cWattPerMeterPerKelvin, -1, cWattPerKelvin, -1, -1, -1, -1, -1, -1, -1, -1, cWattPerSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWattPerMeter, cWattPerCubicMeter, -1, -1, -1, -1, -1, cReciprocalSquareMeter, -1, cReciprocalMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWattPerMeterPerKelvin, cWattPerKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cSquareMeterQuarticKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cQuarticKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cWattPerQuarticKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWattPerKelvin, cWatt, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cWattPerSquareMeterPerQuarticKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cJoulePerMole, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cJoule, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWatt, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cJoulePerMolePerKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cPascal, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWattPerCubicMeter, -1),
    (cMoleKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMole, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cJoule, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cJoulePerMolePerKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cJoulePerMole, -1, -1, -1, cJoulePerKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWattPerKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cJoule, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cOhmMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cVoltMeter, -1, -1, -1, -1, -1, -1, -1, cNewtonSquareMeterPerSquareCoulomb, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cOhm, -1, -1, -1, -1, -1, -1, cHenry, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeterSecond, -1, cMeter, cScalar, -1, -1, -1, cMeterPerSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareVolt, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWeber, cKilogramSquareMeterPerSecond, cTeslaMeter, -1, -1, -1, -1, -1, cSecond, cVolt, -1, -1, -1, -1, cOhm, -1, -1, -1, -1, -1, -1, -1, -1, cVoltPerMeter, -1, -1, cTesla, -1, cNewtonSquareMeterPerSquareCoulomb, -1, -1, -1, -1, -1, -1, cSquareVolt, -1, -1, -1, -1, -1),
    (cVoltPerMeter, cTeslaMeter, -1, -1, -1, -1, -1, cVolt, -1, cVoltMeter, -1, -1, -1, -1, -1, -1, cWattPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWeber, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cTesla, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewton, -1, cJoule, -1, -1, cCoulombPerMeter, -1, cAmperePerMeter, cAmperePerSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cVoltMeterPerSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewtonPerMeter, -1, cPascal, -1, -1, -1, cSquareVolt, -1, cCoulombPerSquareMeter, cWattPerSquareMeter, cOhm, -1, -1, -1, -1, -1, -1, -1, -1, cMeterPerSquareSecond, -1, -1, -1, cWattPerCubicMeter, -1, -1, cNewtonPerCubicMeter, -1, -1, cVolt, cVoltMeter, -1, cVoltMeterPerSecond, -1, -1, -1, -1, -1, -1, -1, -1),
    (cCoulombPerMeter, -1, -1, -1, -1, -1, -1, cCoulomb, -1, cCoulombMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cAmperePerMeter, -1, -1, cAmpere, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCoulombPerSquareMeter, -1, cCoulombPerCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareCoulombPerMeter, -1, cSquareCoulomb, cNewton, -1, -1, cTeslaMeter, -1, -1, cPoiseuille, cKilogramMeterPerSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareMeterAmpere, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWeber, cNewtonPerMeter, -1, -1, -1, -1, -1, cVolt, cJoule, cWatt, -1, -1, cSecond, cKilogramPerSecond, -1, -1, cCoulombPerSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cAmperePerMeter, cCoulomb, cCoulombMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cSquareCoulombPerMeter, -1, -1, -1, -1, -1, -1, cSquareCoulomb, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareAmpere, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramMeterPerSecond, -1, -1, -1, -1, cKilogramMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramSquareMeterPerSecond, -1, -1, -1, -1, cMeter, cNewtonPerMeter, cJoule, -1, -1, -1, -1, -1, -1, cKilogramPerMeter, cKilogram, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareCoulomb, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cCoulombPerSquareMeter, -1, -1, -1, -1, -1, -1, cCoulombPerMeter, -1, cCoulomb, cCoulombMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cAmperePerSquareMeter, -1, -1, cAmperePerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCoulombPerCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareCoulombPerMeter, cNewtonPerMeter, -1, -1, cTesla, -1, -1, -1, cKilogramPerSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cAmpere, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cTeslaMeter, cPascal, -1, -1, -1, -1, -1, cVoltPerMeter, cNewton, cWattPerMeter, -1, -1, cSecondPerMeter, cPoiseuille, -1, -1, cCoulombPerCubicMeter, -1, -1, -1, -1, cReciprocalHenry, -1, -1, -1, -1, -1, -1, -1, -1, cAmperePerSquareMeter, cCoulombPerMeter, cCoulomb, cCoulombMeter, cAmpere, -1, -1, -1, -1, -1, -1, -1, -1),
    (cSquareMeterPerSquareCoulomb, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cHenry, -1, -1, cSquareMeterPerSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cOhm, cOhmMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cHenryPerMeter, cTeslaPerAmpere, -1, cNewtonSquareMeterPerSquareCoulomb, cNewtonSquareMeterPerSquareCoulomb, cSquareVolt, cNewtonPerSquareCoulomb, -1, -1, -1, -1, cSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cNewtonPerSquareCoulomb, -1, cHenryPerMeter, -1, -1, -1, -1, -1, -1, cNewtonSquareMeterPerSquareCoulomb, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cOhm, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cVoltPerMeter, cNewton, cVolt, -1, -1, cReciprocalMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareVolt, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewtonPerMeter, -1, -1, -1, -1, -1, -1, cReciprocalSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cVoltMeterPerSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewtonSquareMeterPerSquareCoulomb, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cNewtonSquareMeterPerSquareCoulomb, cOhmMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cVoltMeterPerSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewtonPerSquareCoulomb, -1, -1, -1, -1, cOhm, -1, -1, -1, cSquareVolt, cSquareVolt, -1, -1, -1, -1, -1, cVoltMeter, cNewtonSquareMeter, -1, -1, -1, cMeter, -1, cMeterPerSecond, cHertz, -1, -1, -1, cMeterPerSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cVolt, cJoule, cVoltPerMeter, -1, -1, -1, -1, -1, cScalar, -1, -1, -1, -1, -1, -1, -1, cHenryPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cVoltMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cVoltMeterPerSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cVolt, -1, cVoltPerMeter, -1, -1, -1, -1, cWeber, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewtonSquareMeter, -1, cNewtonCubicMeter, -1, -1, cCoulombMeter, -1, -1, cAmpere, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareVolt, cJoule, -1, cNewton, -1, -1, -1, -1, -1, cCoulomb, cWatt, -1, -1, -1, -1, cVolt, -1, -1, -1, -1, cCubicMeterPerSquareSecond, -1, -1, -1, cWattPerMeter, -1, -1, cNewtonPerMeter, -1, cVoltMeterPerSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cVoltMeterPerSecond, cVoltMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cVolt, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWatt, -1, cWattPerMeter, -1, -1, -1, -1, -1, cAmpere, -1, -1, cSquareVolt, -1, -1, -1, -1, cTeslaMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWattPerSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cFaradPerMeter, -1, -1, -1, -1, -1, -1, cFarad, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSiemensPerMeter, -1, -1, cSiemens, cReciprocalHenry, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareCoulombPerMeter, cSquareCoulombPerMeter, -1, -1, -1, -1, cCoulombPerMeter, cNewton, -1, cSecondPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareCoulomb, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSecond, cCoulombPerSquareMeter, -1, -1, -1, -1, cReciprocalSquareMeter, cScalar, cCoulomb, cAmpere, -1, -1, -1, -1, -1, cSquareSecondPerSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSiemensPerMeter, cFarad, -1, -1, -1, -1, cSquareCoulombPerMeter, -1, -1, -1, -1, -1, -1),
    (cAmperePerMeter, cCoulombPerMeter, -1, -1, -1, -1, -1, cAmpere, -1, -1, cSquareMeterAmpere, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCoulomb, -1, -1, -1, -1, -1, cAmperePerSquareMeter, -1, -1, -1, -1, -1, -1, cCoulombPerSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWattPerMeter, -1, -1, cVoltPerMeter, -1, -1, cPascal, cNewton, cTeslaMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cVolt, cWattPerSquareMeter, -1, -1, -1, -1, -1, -1, cWatt, -1, -1, -1, cScalar, cNewtonPerMeter, -1, cTesla, cAmperePerSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cAmpere, -1, cSquareMeterAmpere, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cMeterPerAmpere, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWeber, cWeber, -1, cTesla, -1, -1, cVoltMeter, cMeterSecond, -1, -1, cOhmMeter, -1, -1, -1, -1, -1, cHenryPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cTeslaMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cVolt, cVoltPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cOhm, cSecond, -1, cSecondPerMeter, -1, -1, -1, -1, -1, -1, cScalar, -1, cHenry, -1, -1, -1, -1, -1, -1, -1, -1, cCubicMeter, -1, -1, cReciprocalMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, cVoltMeter, -1, cVolt, cVoltPerMeter, -1, cTeslaMeter, -1, -1),
    (cTeslaMeter, -1, -1, -1, -1, -1, -1, cWeber, -1, -1, -1, -1, -1, -1, -1, -1, cNewton, -1, -1, -1, -1, -1, -1, -1, cVoltPerMeter, -1, -1, cVolt, -1, -1, -1, -1, -1, cVoltMeterPerSecond, -1, -1, -1, -1, -1, -1, cTesla, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramMeterPerSecond, -1, cKilogramSquareMeterPerSecond, -1, -1, -1, -1, cCoulombPerMeter, cCoulombPerSquareMeter, -1, -1, -1, cAmperePerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cVoltMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramPerSecond, -1, cPoiseuille, -1, -1, -1, -1, cSquareVolt, -1, cNewtonPerMeter, cHenry, -1, -1, -1, cTesla, -1, -1, -1, -1, cMeterPerSecond, cNewtonSquareMeter, -1, -1, cPascal, -1, -1, -1, -1, cVoltPerMeter, cWeber, -1, -1, cVoltMeter, -1, -1, -1, -1, -1, -1, -1, -1),
    (cTeslaPerAmpere, -1, -1, -1, -1, -1, -1, cHenryPerMeter, -1, cHenry, -1, -1, -1, -1, -1, -1, cTesla, cNewtonPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewtonPerSquareCoulomb, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogram, -1, -1, -1, cSquareSecondPerSquareMeter, -1, -1, -1, -1, -1, -1, cReciprocalSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, cOhmMeter, -1, cOhm, -1, -1, -1, -1, -1, cNewtonSquareMeterPerSquareCoulomb, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWeber, -1, -1, -1, -1, -1, -1, -1, -1, cHenryPerMeter, cHenry, -1, cOhm, -1, -1, -1, -1, -1, -1, -1, -1),
    (cHenryPerMeter, -1, -1, -1, -1, -1, -1, cHenry, -1, -1, -1, -1, -1, -1, -1, -1, cTeslaMeter, cNewton, -1, -1, -1, -1, -1, -1, -1, cNewtonPerSquareCoulomb, cNewtonPerSquareCoulomb, cOhm, -1, -1, -1, -1, -1, cNewtonSquareMeterPerSquareCoulomb, -1, -1, -1, -1, -1, -1, cTeslaPerAmpere, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramMeter, -1, -1, -1, -1, -1, cSecondPerMeter, -1, -1, -1, -1, cReciprocalMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cOhmMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogram, -1, -1, -1, -1, -1, -1, cSquareSecondPerSquareMeter, cTesla, -1, -1, -1, -1, cTeslaPerAmpere, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cHenry, -1, -1, cOhmMeter, -1, -1, -1, -1, -1, -1, -1, -1),
    (cReciprocalMeter, cSecondPerMeter, -1, -1, -1, -1, -1, cScalar, cReciprocalSquareRootMeter, cMeter, cSquareMeter, cCubicMeter, cQuarticMeter, cQuinticMeter, cKilogramPerMeter, cSquareKilogramPerMeter, cAmperePerMeter, -1, cKelvinPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, cHertz, cSquareHertz, -1, -1, -1, -1, cMeterPerSquareSecond, cSecond, cKilogram, cPoiseuille, cKilogramPerSecond, -1, cReciprocalSquareRootCubicMeter, cReciprocalSquareMeter, -1, cReciprocalCubicMeter, cReciprocalQuarticMeter, -1, cKilogramMeter, cKilogramMeterPerSecond, -1, cKilogramPerSquareMeter, cKilogramPerCubicMeter, cKilogramPerQuarticMeter, cNewtonPerMeter, cNewtonPerMeter, -1, cNewtonPerCubicMeter, cNewton, cNewton, cWattPerMeter, cCoulombPerMeter, cSquareCoulombPerMeter, cCoulomb, cVoltPerMeter, -1, cFaradPerMeter, -1, cSiemensPerMeter, -1, -1, cTeslaMeter, cHenryPerMeter, -1, -1, -1, -1, -1, cLumenSecondPerCubicMeter, -1, -1, cPascal, cSquareMeterPerSecond, -1, cMeterPerSecond, -1, -1, -1, -1, -1, cSquareMeterPerSquareSecond, cJoule, cNewtonSquareMeter, -1, cSquareKilogramPerSquareMeter, -1, -1, -1, -1, -1, -1, -1, cKelvin, -1, cWattPerSquareMeter, cWattPerCubicMeter, -1, cWattPerMeterPerKelvin, cWattPerSquareMeterPerKelvin, -1, -1, cKelvinPerWatt, -1, -1, -1, -1, -1, -1, -1, -1, cOhm, -1, cCoulombPerSquareMeter, -1, cCoulombPerCubicMeter, -1, -1, -1, cVolt, -1, -1, cAmperePerSquareMeter, -1, cTesla, -1, cTeslaPerAmpere, cReciprocalSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeterPerCubicSecond, -1, cScalar, cMeter, cSquareMeter, cMeterPerSecond, cWattPerMeter, cNewton, cWattPerSquareMeter, cWattPerCubicMeter, -1, cPascal, -1, -1),
    (cSquareKilogramPerSquareSecond, -1, cSquareKilogram, -1, -1, -1, -1, -1, -1, cSquareKilogramSquareMeterPerSquareSecond, -1, cSquareJouleSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareNewton, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewtonSquareMeter, -1, -1, -1, -1, -1, -1, -1, cSquareMeterPerSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareKilogramPerSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareKilogramSquareMeterPerSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cSquareSecondPerSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, cSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cReciprocalSquareMeter, cReciprocalSquareMeter, cSecondPerMeter, cReciprocalMeter, -1, -1, -1, -1, cScalar, -1, -1, -1, -1, cSquareKilogram, -1, -1, -1, -1, -1, -1, cKilogramSquareSecond, -1, -1, -1, -1, -1, cKilogramPerMeter, cKilogramPerMeter, cSquareKilogramPerSquareSecond, cKilogramPerCubicMeter, cKilogram, cKilogram, cKilogramPerSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramPerQuarticMeter, cKilogramPerSquareMeter, cMeterSecond, -1, cSecond, -1, -1, -1, -1, -1, cMeter, cKilogramMeter, cKilogramSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, cReciprocalKelvin, -1, -1, cPoiseuille, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cHenryPerMeter, -1, cTeslaMeter, -1, -1, -1, -1, -1, -1, -1, cSquareKilogramPerSquareMeter, -1, cSquareKilogramSquareMeterPerSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, cHertz, -1, -1, cSquareSecond, -1, cSecond, cKilogramPerSecond, cKilogram, cPoiseuille, -1, -1, cKilogramPerSquareMeter, -1, -1),
    (cSquareJoule, -1, cSquareJouleSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareNewton, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareKilogramSquareMeterPerSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cSquareJouleSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareJoule, cSquareJoule, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareKilogramSquareMeterPerSquareSecond, -1, cSquareKilogramPerSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cCoulombPerKilogram, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCoulomb, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCoulombMeter, cAmpere, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareMeterAmpere, -1, cCoulombPerMeter, cCoulombPerSquareMeter, cCoulombPerCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareMeterPerSquareSecond, -1, -1, -1, -1, -1, cHertz, cSquareMeterPerSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cAmperePerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeterPerSquareSecond, -1, -1, cReciprocalHenry, -1, -1, -1, cCubicMeterPerSquareSecond, -1, -1, -1, -1, cMeterPerSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cSquareMeterAmpere, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cAmpere, cAmperePerMeter, cAmperePerSquareMeter, -1, -1, cCoulombMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cJoule, cNewtonCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cVoltMeterPerSecond, -1, -1, -1, -1, -1, cCubicMeter, cNewtonSquareMeter, cWeber, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareAmpere, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cLumenPerWatt, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cLumenSecondPerCubicMeter, cLumenSecond, cLumenSecond, cCandela, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cLuxSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cLux, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCandela, cLumenSecond, -1, cLux, -1, cLuxSecond, -1, -1),
    (cReciprocalMole, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cScalar, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cJoulePerMole, cJoulePerMole, -1, cCoulombPerMole, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cHertz, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cJoulePerMolePerKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cReciprocalCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, cJoulePerMole, -1, -1, -1, -1, -1, -1),
    (cAmperePerSquareMeter, cCoulombPerSquareMeter, -1, -1, -1, -1, -1, cAmperePerMeter, -1, cAmpere, -1, cSquareMeterAmpere, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCoulombPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCoulombPerCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWattPerSquareMeter, -1, -1, -1, -1, -1, cNewtonPerCubicMeter, cNewtonPerMeter, cTesla, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cVoltPerMeter, cWattPerCubicMeter, -1, -1, -1, -1, -1, -1, cWattPerMeter, -1, -1, -1, cReciprocalMeter, cPascal, -1, -1, -1, -1, -1, -1, -1, -1, cSquareAmpere, -1, -1, -1, -1, -1, -1, -1, -1, cAmperePerMeter, cAmpere, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cMolePerCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMole, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKatalPerCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKatal, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cPascal, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cReciprocalCubicMeter, -1, -1, -1, -1, -1, cKatalPerCubicMeter, -1, -1, cMole, -1, -1, -1, -1, -1, -1, -1, -1, cCoulombPerCubicMeter),
    (cLux, cLuxSecond, -1, -1, -1, -1, -1, -1, -1, cCandela, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cLumenSecondPerCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCandela, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cCoulombPerCubicMeter, -1, -1, -1, -1, -1, -1, cCoulombPerSquareMeter, -1, cCoulombPerMeter, cCoulomb, cCoulombMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cAmperePerSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cPascal, -1, -1, -1, -1, -1, -1, cPoiseuille, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cAmpere, -1, cAmperePerMeter, -1, -1, -1, cCoulombPerKilogram, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cTesla, cNewtonPerCubicMeter, -1, -1, -1, -1, -1, -1, cNewtonPerMeter, cWattPerSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCoulombPerSquareMeter, cCoulombPerMeter, cCoulomb, cAmperePerMeter, -1, -1, -1, -1, -1, -1, -1, -1),
    (cGrayPerSecond, cSquareMeterPerSquareSecond, cSquareMeterPerSecond, cSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWatt, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCubicMeterPerSquareSecond, -1, -1, -1, -1, -1, cMeterPerCubicSecond, -1, -1, -1, -1, -1, -1, cMeterPerSquareSecond, cWattPerMeter, cWattPerSquareMeter, cWattPerCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramSquareMeterPerSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeterPerCubicSecond, -1, cHertz, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cHertz, cScalar, cSecond, cSquareSecond, cCubicSecond, cQuarticSecond, cQuinticSecond, cMeterPerSecond, -1, cSquareMeterPerSecond, cCubicMeterPerSecond, -1, -1, -1, cKilogramPerSecond, -1, -1, -1, -1, -1, -1, -1, cKatal, -1, cSquareHertz, -1, -1, cMeterPerSquareSecond, cMeterPerCubicSecond, cMeterPerQuarticSecond, cMeterPerQuinticSecond, cMeterPerSexticSecond, -1, cGrayPerSecond, cMeter, cKilogramMeterPerSecond, cNewtonPerMeter, cNewton, -1, -1, -1, -1, -1, -1, -1, cKilogramSquareMeterPerSecond, cJoule, cReciprocalMeter, cPoiseuille, -1, -1, cWattPerMeter, cWattPerMeter, -1, cWattPerCubicMeter, cWatt, cWatt, -1, cAmpere, -1, -1, -1, -1, cSiemens, -1, cReciprocalHenry, -1, -1, cVolt, cOhm, -1, -1, cCandela, -1, -1, cLux, -1, -1, cWattPerSquareMeter, cCubicMeterPerSquareSecond, cPascal, cSquareMeterPerSquareSecond, cKilogramPerQuarticMeterPerSecond, cQuarticMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWattPerKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewtonSquareMeterPerSquareCoulomb, -1, cAmperePerMeter, -1, cAmperePerSquareMeter, -1, -1, -1, cVoltMeterPerSecond, -1, cSiemensPerMeter, -1, -1, cVoltPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKatalPerCubicMeter, -1, -1, -1, cSquareHertz, cMeterPerSecond, cSquareMeterPerSecond, cCubicMeterPerSecond, cSquareMeterPerSquareSecond, -1, cWatt, -1, -1, -1, cWattPerSquareMeter, -1, -1),
    (cMeter, cMeterSecond, -1, -1, -1, -1, -1, cSquareMeter, -1, cCubicMeter, cQuarticMeter, cQuinticMeter, cSexticMeter, -1, cKilogramMeter, -1, -1, -1, cMeterKelvin, -1, -1, -1, -1, -1, cMeterPerSecond, cMeterPerSquareSecond, cMeterPerSquareSecond, cSquareMeterPerSecond, cSquareMeterPerSquareSecond, cGrayPerSecond, -1, -1, -1, cCubicMeterPerSquareSecond, -1, cKilogramSquareMeter, cKilogramMeterPerSecond, cKilogramSquareMeterPerSecond, -1, cSquareRootMeter, cScalar, cReciprocalSquareRootMeter, cReciprocalMeter, cReciprocalSquareMeter, cReciprocalCubicMeter, -1, -1, cSecond, cKilogram, cKilogramPerMeter, cKilogramPerSquareMeter, cJoule, cJoule, -1, cNewtonPerMeter, cNewtonSquareMeter, cNewtonSquareMeter, -1, cCoulombMeter, -1, -1, cVoltMeter, -1, -1, cOhmMeter, -1, cSiemens, cTeslaMeter, -1, -1, -1, -1, -1, cLuxSecond, -1, -1, -1, cPascal, cNewton, -1, cKilogramPerSecond, cCubicMeterPerSecond, cKilogramPerCubicMeter, -1, -1, -1, -1, -1, cNewtonCubicMeter, -1, -1, cSquareKilogram, cSquareKilogramPerMeter, -1, -1, -1, -1, -1, -1, -1, cKelvin, cWatt, cWattPerMeter, cWattPerSquareMeter, -1, cWattPerKelvin, cMeterKelvinPerWatt, -1, -1, -1, cWattPerMeterPerKelvin, -1, -1, -1, -1, -1, -1, -1, cVolt, cCoulomb, cSquareCoulomb, cCoulombPerMeter, -1, -1, -1, -1, -1, cFarad, cAmpere, -1, cWeber, cHenryPerMeter, cHenry, cScalar, -1, -1, -1, -1, -1, -1, -1, -1, cAmperePerMeter, -1, -1, cCoulombPerSquareMeter, -1, cMeterPerSecond, cSquareMeter, cCubicMeter, cQuarticMeter, cCubicMeterPerSecond, -1, cNewtonSquareMeter, cWatt, cWattPerMeter, cWattPerSquareMeter, cNewton, -1, -1),
    (cSquareMeter, -1, -1, -1, -1, -1, -1, cCubicMeter, -1, cQuarticMeter, cQuinticMeter, cSexticMeter, -1, -1, cKilogramSquareMeter, -1, cSquareMeterAmpere, -1, -1, -1, -1, cSquareMeterQuarticKelvin, -1, -1, cSquareMeterPerSecond, cSquareMeterPerSquareSecond, cSquareMeterPerSquareSecond, cCubicMeterPerSecond, cCubicMeterPerSquareSecond, -1, -1, -1, -1, -1, -1, -1, cKilogramSquareMeterPerSecond, -1, cSquareJouleSquareSecond, -1, cMeter, cSquareRootMeter, cScalar, cReciprocalMeter, cReciprocalSquareMeter, -1, -1, cMeterSecond, cKilogramMeter, cKilogram, cKilogramPerMeter, cNewtonSquareMeter, cNewtonSquareMeter, cSquareJoule, cNewton, cNewtonCubicMeter, cNewtonCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWeber, -1, -1, -1, -1, -1, -1, cCandela, cLumenSecond, -1, cNewtonPerMeter, cJoule, -1, cKilogramMeterPerSecond, -1, cKilogramPerSquareMeter, -1, -1, -1, -1, -1, -1, -1, cNewtonSquareMeterPerSquareKilogram, -1, cSquareKilogram, -1, -1, cSquareMeterKelvin, -1, -1, -1, -1, cMeterKelvin, -1, cWatt, cWattPerMeter, -1, -1, -1, -1, -1, -1, cWattPerKelvin, -1, -1, -1, -1, -1, -1, -1, cVoltMeter, cCoulombMeter, -1, cCoulomb, -1, cNewtonSquareMeterPerSquareCoulomb, -1, -1, -1, -1, -1, -1, -1, cHenry, -1, cMeter, cSquareKilogramSquareMeterPerSquareSecond, cSquareSecond, -1, -1, -1, -1, -1, -1, cAmpere, -1, cCandela, cCoulombPerMeter, -1, cSquareMeterPerSecond, cCubicMeter, cQuarticMeter, cQuinticMeter, -1, -1, cNewtonCubicMeter, -1, cWatt, cWattPerMeter, cJoule, -1, -1),
    (cCubicMeter, -1, -1, -1, -1, -1, -1, cQuarticMeter, -1, cQuinticMeter, cSexticMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCubicMeterPerSecond, cCubicMeterPerSquareSecond, cCubicMeterPerSquareSecond, -1, -1, -1, -1, -1, -1, -1, cQuarticMeterSecond, -1, -1, -1, -1, -1, cSquareMeter, -1, cMeter, cScalar, cReciprocalMeter, -1, -1, -1, cKilogramSquareMeter, cKilogramMeter, cKilogram, cNewtonCubicMeter, cNewtonCubicMeter, -1, cJoule, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cLumenSecond, -1, -1, -1, cNewton, cNewtonSquareMeter, -1, cKilogramSquareMeterPerSecond, -1, cKilogramPerMeter, -1, cPoiseuille, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWatt, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCoulombMeter, -1, -1, -1, -1, -1, -1, cSquareMeterAmpere, -1, -1, -1, -1, cSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMole, -1, cCoulomb, -1, cCubicMeterPerSecond, cQuarticMeter, cQuinticMeter, cSexticMeter, -1, -1, -1, -1, -1, cWatt, cNewtonSquareMeter, cKatal, -1),
    (cSquareMeterPerSecond, cSquareMeter, -1, -1, -1, -1, -1, cCubicMeterPerSecond, -1, -1, -1, -1, -1, -1, cKilogramSquareMeterPerSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareMeterPerSquareSecond, cGrayPerSecond, cGrayPerSecond, cCubicMeterPerSquareSecond, -1, -1, -1, -1, -1, -1, cCubicMeter, -1, cJoule, cNewtonSquareMeter, -1, -1, cMeterPerSecond, -1, cHertz, -1, -1, -1, cNewtonCubicMeter, cMeter, cKilogramMeterPerSecond, cKilogramPerSecond, cPoiseuille, -1, -1, -1, cWattPerMeter, -1, -1, -1, cSquareMeterAmpere, -1, -1, -1, -1, -1, -1, -1, -1, cVolt, -1, -1, -1, -1, -1, -1, -1, cCandela, -1, cWattPerSquareMeter, cWatt, -1, cNewton, -1, -1, cSexticMeter, cNewtonPerCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cVoltMeterPerSecond, -1, -1, cAmpere, -1, -1, -1, -1, -1, -1, -1, -1, cVoltMeter, cOhm, cOhmMeter, cMeterPerSecond, -1, cSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, cAmperePerMeter, -1, cSquareMeterPerSquareSecond, cCubicMeterPerSecond, -1, -1, -1, -1, -1, -1, -1, -1, cWatt, -1, -1),
    (cWatt, cJoule, cKilogramSquareMeterPerSecond, cKilogramSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewtonSquareMeter, -1, cSquareNewton, -1, -1, -1, cWattPerMeter, -1, cWattPerSquareMeter, cWattPerCubicMeter, -1, -1, cSquareJoule, cNewton, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareVolt, cSquareAmpere, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWattPerKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKelvin, cMeter, cMeterKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cVoltMeter, -1, -1, -1, cWattPerMeter, -1, cKilogramPerSecond, -1, -1, -1, -1, cCandela, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cJoule, cKilogramSquareMeterPerSecond, cKilogramSquareMeter, -1, -1, -1, -1, cNewtonSquareMeter, -1, cNewtonCubicMeter, -1, -1, -1, -1, cSquareKilogramSquareMeterPerSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWatt, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewton, -1, cNewtonPerMeter, cPascal, cNewtonPerCubicMeter, cSquareJouleSquareSecond, -1, cKilogramMeterPerSecond, -1, cSquareKilogramPerSquareSecond, -1, -1, -1, -1, -1, cSquareJoule, cSquareJoule, -1, -1, -1, -1, -1, -1, cSquareCoulomb, -1, -1, -1, -1, -1, -1, cSquareAmpere, -1, -1, -1, -1, -1, -1, -1, cSquareNewton, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cJoulePerKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeterSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareCoulombPerMeter, -1, -1, -1, -1, -1, cNewton, -1, cKilogram, -1, -1, -1, -1, cLumenSecond, cJoulePerMole, -1, -1, -1, -1, -1, cWatt, cNewtonSquareMeter, cNewtonCubicMeter, -1, -1, -1, cSquareJoule, -1, -1, -1, cSquareNewton, -1, -1),
    (cWattPerMeter, cNewton, cKilogramMeterPerSecond, cKilogramMeter, -1, -1, -1, cWatt, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cJoule, -1, -1, cSquareNewton, -1, -1, cWattPerSquareMeter, -1, cWattPerCubicMeter, -1, -1, -1, -1, cNewtonPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWattPerMeterPerKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKelvinPerMeter, cScalar, cKelvin, -1, -1, -1, -1, -1, -1, -1, -1, cSquareVolt, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cVolt, -1, -1, -1, cWattPerSquareMeter, -1, cPoiseuille, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWatt, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cWattPerSquareMeter, cNewtonPerMeter, cKilogramPerSecond, cKilogram, -1, cKilogramSquareSecond, -1, cWattPerMeter, -1, cWatt, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWattPerSquareMeterPerQuarticKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewton, -1, -1, -1, -1, -1, cWattPerCubicMeter, -1, -1, -1, -1, -1, cSquareNewton, cPascal, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewtonCubicMeter, -1, -1, -1, -1, -1, -1, cMeterPerQuinticSecond, -1, -1, -1, -1, cWattPerSquareMeterPerKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cReciprocalMeter, cKelvinPerMeter, cWattPerKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cVoltPerMeter, -1, -1, -1, cWattPerCubicMeter, -1, -1, -1, -1, -1, -1, cLux, -1, -1, -1, -1, -1, -1, -1, cWattPerMeter, cWatt, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cWattPerCubicMeter, cPascal, cPoiseuille, cKilogramPerMeter, -1, -1, -1, cWattPerSquareMeter, -1, cWattPerMeter, cWatt, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewtonPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewtonPerCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewtonSquareMeter, -1, cGrayPerSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cReciprocalSquareMeter, -1, cWattPerMeterPerKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWattPerSquareMeter, cWattPerMeter, cWatt, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cNewtonPerMeter, cKilogramPerSecond, cKilogram, -1, cKilogramSquareSecond, -1, -1, cNewton, -1, cJoule, cNewtonSquareMeter, cNewtonCubicMeter, -1, -1, cSquareKilogramPerSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWattPerSquareMeter, -1, -1, cWattPerMeter, -1, -1, -1, -1, -1, -1, cKilogramMeterPerSecond, -1, -1, -1, -1, -1, cPascal, -1, cNewtonPerCubicMeter, -1, -1, cSquareKilogramSquareMeterPerSquareSecond, -1, cPoiseuille, -1, -1, -1, -1, -1, -1, -1, cSquareNewton, cSquareNewton, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWatt, -1, -1, -1, cCubicMeterPerSquareSecond, cSquareKilogram, -1, -1, cSquareJoule, cMeterPerQuarticSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSecondPerMeter, -1, cJoulePerKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cTeslaMeter, -1, -1, -1, cPascal, -1, cKilogramPerSquareMeter, -1, -1, -1, -1, cLuxSecond, -1, -1, -1, -1, -1, -1, cWattPerSquareMeter, cNewton, cJoule, cNewtonSquareMeter, cWatt, -1, cSquareNewton, -1, -1, -1, -1, -1, -1),
    (cKatalPerCubicMeter, cMolePerCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, cKatal, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWattPerCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKatal, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cCoulombPerMole, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCoulomb, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cJoulePerMole, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cAmpere, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCoulombPerCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1)
  );

  { Div Table }

  DivTable : array[0..159, 0..159] of longint = (
    (cScalar, cHertz, cSquareHertz, -1, -1, -1, -1, cReciprocalMeter, cReciprocalSquareRootMeter, cReciprocalSquareMeter, cReciprocalCubicMeter, cReciprocalQuarticMeter, -1, -1, -1, -1, -1, -1, cReciprocalKelvin, -1, -1, -1, cReciprocalMole, -1, cSecond, cSquareSecond, cSquareSecond, cSecondPerMeter, -1, -1, -1, -1, -1, cSquareSecondPerSquareMeter, -1, -1, -1, -1, -1, cSquareRootMeter, cMeter, -1, cSquareMeter, cCubicMeter, cQuarticMeter, -1, -1, cMeterPerSecond, -1, -1, cCubicMeterPerKilogram, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSiemens, cOhm, cOhmMeter, -1, -1, cReciprocalHenry, cHenry, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramPerCubicMeter, -1, -1, -1, -1, -1, -1, cSquareMeterPerSquareKilogram, cSquareKilogramPerSquareMeter, -1, cKelvin, -1, -1, -1, -1, -1, cMeterPerWatt, -1, -1, cKelvinPerWatt, cMeterKelvinPerWatt, cWattPerKelvin, cWattPerMeter, cWattPerMeterPerKelvin, -1, -1, -1, -1, -1, -1, -1, -1, cSiemensPerMeter, -1, -1, -1, -1, -1, -1, cFaradPerMeter, -1, -1, cNewtonSquareMeterPerSquareCoulomb, cMeterPerAmpere, cAmperePerMeter, -1, -1, -1, cMeter, -1, cSquareMeterPerSquareSecond, -1, -1, -1, -1, -1, cMole, -1, -1, -1, -1, -1, cSecond, cReciprocalMeter, cReciprocalSquareMeter, cReciprocalCubicMeter, -1, -1, -1, cMeterPerWatt, -1, -1, -1, -1, -1),
    (cSecond, cScalar, cHertz, cSquareHertz, -1, -1, -1, cSecondPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareSecond, cCubicSecond, cCubicSecond, -1, -1, -1, -1, -1, -1, -1, cReciprocalMeter, -1, -1, -1, -1, -1, cMeterSecond, -1, -1, -1, cQuarticMeterSecond, -1, -1, cMeter, -1, -1, -1, cMeterPerWatt, cMeterPerWatt, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cOhm, cFarad, cHenry, -1, -1, -1, cSiemens, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareSecondPerSquareMeter, -1, cReciprocalQuarticMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKelvinPerWatt, -1, -1, -1, -1, -1, -1, -1, -1, cJoulePerKelvin, cNewton, -1, -1, -1, -1, -1, -1, -1, -1, -1, cFaradPerMeter, -1, cMeterPerAmpere, -1, -1, -1, -1, -1, -1, -1, cOhmMeter, -1, cCoulombPerMeter, -1, -1, -1, cMeterSecond, -1, cSquareMeterPerSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareSecond, cSecondPerMeter, -1, -1, cSquareSecondPerSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1),
    (cSquareSecond, cSecond, cScalar, cHertz, cSquareHertz, -1, -1, -1, -1, cSquareSecondPerSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCubicSecond, cQuarticSecond, cQuarticSecond, -1, -1, -1, -1, -1, -1, -1, cSecondPerMeter, -1, -1, cMeterPerWatt, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeterSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cHenry, -1, -1, -1, -1, -1, cFarad, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramMeterPerSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCubicSecond, -1, cSquareSecondPerSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cCubicSecond, cSquareSecond, cSecond, cScalar, cHertz, cSquareHertz, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cQuarticSecond, cQuinticSecond, cQuinticSecond, -1, -1, -1, -1, -1, -1, -1, -1, cMeterPerWatt, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cQuarticSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cQuarticSecond, cCubicSecond, cSquareSecond, cSecond, cScalar, cHertz, cSquareHertz, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cQuinticSecond, cSexticSecond, cSexticSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cQuinticSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cQuinticSecond, cQuarticSecond, cCubicSecond, cSquareSecond, cSecond, cScalar, cHertz, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSexticSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSexticSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cSexticSecond, cQuinticSecond, cQuarticSecond, cCubicSecond, cSquareSecond, cSecond, cScalar, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cMeter, cMeterPerSecond, cMeterPerSquareSecond, cMeterPerCubicSecond, cMeterPerQuarticSecond, cMeterPerQuinticSecond, cMeterPerSexticSecond, cScalar, cSquareRootMeter, cReciprocalMeter, cReciprocalSquareMeter, cReciprocalCubicMeter, cReciprocalQuarticMeter, -1, -1, -1, cMeterPerAmpere, -1, -1, -1, -1, -1, -1, -1, cMeterSecond, -1, -1, cSecond, cSquareSecond, cCubicSecond, cQuarticSecond, cQuinticSecond, cSexticSecond, -1, cHertz, -1, -1, -1, -1, -1, cSquareMeter, -1, cCubicMeter, cQuarticMeter, cQuinticMeter, -1, -1, cSquareMeterPerSecond, -1, cCubicMeterPerKilogram, -1, -1, -1, -1, -1, -1, -1, cMeterPerWatt, -1, -1, -1, -1, -1, cNewtonSquareMeterPerSquareCoulomb, -1, cOhmMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSecondPerMeter, -1, -1, -1, cKilogramPerSquareMeter, cNewtonPerSquareKilogram, cSquareSecondPerSquareMeter, -1, -1, cKilogramSquareSecond, cSquareMeterPerSquareKilogram, -1, cSquareKilogramPerMeter, -1, cMeterKelvin, -1, -1, -1, cReciprocalKelvin, cSquareMeterKelvin, -1, -1, -1, cMeterKelvinPerWatt, -1, -1, cWatt, cWattPerKelvin, cKelvinPerMeter, -1, -1, -1, -1, -1, -1, -1, cSiemens, -1, -1, cSquareMeterPerSquareCoulomb, -1, cSquareCoulombPerMeter, -1, cFarad, -1, -1, -1, -1, cAmpere, -1, -1, -1, cSquareMeter, -1, cCubicMeterPerSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeterSecond, cScalar, cReciprocalMeter, cReciprocalSquareMeter, cSecondPerMeter, cMeterPerWatt, -1, -1, -1, -1, -1, -1, -1),
    (cSquareRootMeter, -1, -1, -1, -1, -1, -1, cReciprocalSquareRootMeter, cScalar, cReciprocalSquareRootCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeter, -1, cSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cReciprocalSquareRootMeter, cReciprocalSquareRootCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cSquareMeter, cSquareMeterPerSecond, cSquareMeterPerSquareSecond, cGrayPerSecond, -1, -1, -1, cMeter, -1, cScalar, cReciprocalMeter, cReciprocalSquareMeter, cReciprocalCubicMeter, cReciprocalQuarticMeter, -1, cSquareMeterPerSquareKilogram, -1, -1, cSquareMeterKelvin, -1, -1, -1, -1, -1, -1, -1, -1, cMeterSecond, -1, -1, -1, -1, -1, cSquareSecond, cMeterPerSecond, -1, -1, -1, -1, -1, cCubicMeter, -1, cQuarticMeter, cQuinticMeter, cSexticMeter, -1, -1, cCubicMeterPerSecond, cCubicMeterPerKilogram, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareMeterPerSquareCoulomb, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSecondPerMeter, -1, cSecond, -1, -1, -1, cKilogramPerMeter, -1, -1, -1, -1, -1, -1, -1, cSquareKilogram, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareCoulomb, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCubicSecond, -1, cMeter, cScalar, cReciprocalMeter, cSecond, -1, -1, -1, -1, -1, -1, -1, -1),
    (cCubicMeter, cCubicMeterPerSecond, cCubicMeterPerSquareSecond, -1, -1, -1, -1, cSquareMeter, -1, cMeter, cScalar, cReciprocalMeter, cReciprocalSquareMeter, cReciprocalCubicMeter, cCubicMeterPerKilogram, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareMeterPerSecond, -1, -1, -1, -1, -1, cQuarticMeter, -1, cQuinticMeter, cSexticMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSecond, -1, cMeterSecond, -1, -1, -1, cKilogram, cNewtonSquareMeterPerSquareKilogram, cSquareSecond, -1, -1, -1, -1, -1, -1, cKilogramSquareSecond, -1, -1, -1, -1, cSquareMeterKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeterKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareMeterAmpere, -1, -1, -1, cQuarticMeter, -1, -1, -1, -1, -1, cMeterPerAmpere, -1, -1, -1, -1, -1, -1, -1, -1, cSquareMeter, cMeter, cScalar, cMeterSecond, -1, -1, -1, -1, -1, -1, -1, -1),
    (cQuarticMeter, -1, -1, -1, -1, -1, -1, cCubicMeter, -1, cSquareMeter, cMeter, cScalar, cReciprocalMeter, cReciprocalSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cQuarticMeterSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCubicMeterPerSecond, cCubicMeterPerKilogram, -1, -1, -1, -1, cQuinticMeter, -1, cSexticMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeterSecond, -1, -1, -1, cHertz, -1, cKilogramMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cQuinticMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cQuarticMeterSecond, cCubicMeter, cSquareMeter, cMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cQuinticMeter, -1, -1, -1, -1, -1, -1, cQuarticMeter, -1, cCubicMeter, cSquareMeter, cMeter, cScalar, cReciprocalMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cQuarticMeterSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSexticMeter, -1, -1, -1, -1, cCubicMeterPerKilogram, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeterPerSecond, -1, cKilogramSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSexticMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cQuarticMeter, cCubicMeter, cSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cSexticMeter, -1, -1, -1, -1, -1, -1, cQuinticMeter, -1, cQuarticMeter, cCubicMeter, cSquareMeter, cMeter, cScalar, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cQuarticMeterSecond, -1, cSquareMeterPerSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cQuinticMeter, cQuarticMeter, cCubicMeter, cQuarticMeterSecond, -1, -1, -1, -1, -1, -1, -1, -1),
    (cKilogram, cKilogramPerSecond, cNewtonPerMeter, cWattPerSquareMeter, -1, -1, -1, cKilogramPerMeter, -1, cKilogramPerSquareMeter, cKilogramPerCubicMeter, cKilogramPerQuarticMeter, -1, -1, cScalar, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramSquareSecond, cKilogramSquareSecond, -1, -1, -1, -1, -1, -1, -1, cPoiseuille, cReciprocalMeter, cSecond, cSecondPerMeter, -1, -1, cKilogramMeter, -1, cKilogramSquareMeter, -1, -1, cReciprocalSquareMeter, -1, cKilogramMeterPerSecond, cMeter, cSquareMeter, cCubicMeter, -1, -1, -1, -1, cSquareSecondPerSquareMeter, cSquareSecondPerSquareMeter, -1, -1, cTeslaPerAmpere, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareSecond, -1, cMeterSecond, -1, cQuarticMeter, cKilogramPerQuarticMeterPerSecond, cQuarticMeterSecond, -1, cSquareHertz, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramKelvin, cReciprocalKelvin, -1, -1, -1, -1, -1, cCubicSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cHenryPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareCoulomb, cSquareCoulombPerMeter, cKilogramMeter, -1, cJoule, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramPerMeter, cKilogramPerSquareMeter, cKilogramPerCubicMeter, -1, -1, cSquareSecondPerSquareMeter, -1, cCubicSecond, -1, cSquareSecond, -1, -1),
    (cSquareKilogram, -1, cSquareKilogramPerSquareSecond, -1, -1, -1, -1, cSquareKilogramPerMeter, -1, cSquareKilogramPerSquareMeter, -1, -1, -1, -1, cKilogram, cScalar, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramPerMeter, -1, -1, cSquareSecondPerSquareMeter, -1, -1, -1, -1, -1, -1, cKilogramPerSquareMeter, -1, -1, cKilogramMeter, cKilogramSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramSquareSecond, -1, -1, -1, -1, -1, -1, -1, cNewtonPerMeter, -1, -1, -1, -1, cMeter, cSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareSecond, cSquareKilogramSquareMeterPerSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareKilogramPerMeter, cSquareKilogramPerSquareMeter, -1, -1, -1, -1, -1, -1, -1, cKilogramSquareSecond, -1, -1),
    (cAmpere, -1, -1, -1, -1, -1, -1, cAmperePerMeter, -1, cAmperePerSquareMeter, -1, -1, -1, -1, -1, -1, cScalar, -1, -1, -1, -1, -1, -1, -1, cCoulomb, -1, -1, cCoulombPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, cCoulombPerKilogram, -1, -1, -1, -1, -1, cSquareMeterAmpere, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cHertz, -1, -1, cSiemens, -1, -1, -1, cVolt, cVoltMeter, -1, cReciprocalHenry, -1, cWeber, -1, -1, -1, -1, -1, cCoulombPerMole, -1, -1, cCoulombPerCubicMeter, -1, cCoulombPerSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeterPerSecond, -1, cSquareMeterPerSecond, -1, -1, -1, cSiemensPerMeter, cFaradPerMeter, cVoltMeterPerSecond, cMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramPerSecond, cReciprocalSquareMeter, -1, -1, cSquareMeter, -1, -1, cCubicMeterPerSecond, -1, cCoulomb, cAmperePerMeter, cAmperePerSquareMeter, -1, cCoulombPerSquareMeter, -1, -1, -1, -1, -1, -1, -1, cKatal),
    (cSquareAmpere, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cAmpere, cScalar, -1, -1, -1, -1, -1, -1, -1, cSquareCoulomb, cSquareCoulomb, -1, cSquareCoulombPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cReciprocalHenry, cReciprocalHenry, cSiemens, -1, cSquareHertz, -1, -1, -1, -1, -1, cWatt, -1, -1, -1, -1, cJoule, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeterPerSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cAmperePerSquareMeter, -1, -1, cSquareMeterAmpere, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSiemens, cReciprocalHenry, -1, -1, -1, -1, -1, -1),
    (cKelvin, -1, -1, -1, -1, -1, -1, cKelvinPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cScalar, cReciprocalKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeterKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKelvinPerWatt, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareKelvin, -1, -1, -1, cReciprocalMeter, cMeter, cMeterKelvinPerWatt, -1, -1, -1, -1, cWatt, -1, cWattPerMeter, -1, -1, -1, -1, -1, -1, cReciprocalMole, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeterKelvin, -1, -1, -1, -1, -1, -1, -1, cMoleKelvin, -1, -1, -1, -1, -1, -1, cKelvinPerMeter, -1, -1, -1, cKelvinPerWatt, -1, cMeterKelvinPerWatt, -1, -1, -1, -1, -1),
    (cSquareKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKelvin, cScalar, cReciprocalKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCubicKelvin, -1, -1, -1, cKelvinPerMeter, cMeterKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cCubicKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareKelvin, cKelvin, cScalar, cReciprocalKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cQuarticKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cQuarticKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCubicKelvin, cSquareKelvin, cKelvin, cScalar, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareMeterQuarticKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cReciprocalSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cMole, cKatal, -1, -1, -1, -1, -1, -1, -1, -1, cMolePerCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cScalar, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMoleKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cReciprocalKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCubicMeter, -1, -1, -1, -1, -1, -1, cMolePerCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cCandela, -1, -1, -1, -1, -1, -1, -1, -1, cLux, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cScalar, cLumenSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cLumenPerWatt, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cScalar, cHertz, cCubicMeterPerSecond, cSquareMeter, cSquareMeterPerSecond, -1, -1, -1, cLumenSecondPerCubicMeter, -1, cLuxSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWatt, -1, -1, -1, cSquareMeter, -1, -1, cLumenSecond, -1, cLux, -1, cLuxSecond, cLumenPerWatt, -1, -1, -1, -1, -1, -1, -1),
    (cHertz, cSquareHertz, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cScalar, cSecond, cSecond, cReciprocalMeter, cSecondPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeterPerSecond, -1, cSquareMeterPerSecond, cCubicMeterPerSecond, -1, -1, -1, cMeterPerSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cReciprocalHenry, -1, cNewtonSquareMeterPerSquareCoulomb, cCoulombPerKilogram, -1, -1, cOhm, -1, -1, -1, -1, -1, cReciprocalMole, -1, -1, cReciprocalCubicMeter, -1, cReciprocalSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSiemensPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, cMeterPerSecond, -1, cGrayPerSecond, -1, -1, cTesla, -1, -1, cKatal, -1, -1, -1, -1, cSquareSecondPerSquareMeter, cScalar, -1, -1, -1, cReciprocalSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1),
    (cSquareHertz, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cHertz, cScalar, cScalar, -1, cReciprocalMeter, cSecondPerMeter, -1, -1, -1, cReciprocalSquareMeter, -1, -1, -1, -1, -1, -1, cMeterPerSquareSecond, -1, cSquareMeterPerSquareSecond, cCubicMeterPerSquareSecond, -1, -1, -1, cMeterPerCubicSecond, cNewtonPerSquareKilogram, -1, cNewtonSquareMeterPerSquareKilogram, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cReciprocalCubicMeter, -1, -1, cKilogramPerMeter, -1, -1, -1, cKilogramPerCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeterPerSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cHertz, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cSquareHertz, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cHertz, cScalar, cScalar, -1, cReciprocalMeter, cSecondPerMeter, -1, -1, -1, cReciprocalSquareMeter, -1, -1, -1, -1, -1, -1, cMeterPerSquareSecond, -1, cSquareMeterPerSquareSecond, cCubicMeterPerSquareSecond, -1, -1, -1, cMeterPerCubicSecond, cNewtonPerSquareKilogram, -1, cNewtonSquareMeterPerSquareKilogram, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cReciprocalCubicMeter, -1, -1, cKilogramPerMeter, -1, -1, -1, cKilogramPerCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeterPerSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cHertz, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cMeterPerSecond, cMeterPerSquareSecond, cMeterPerCubicSecond, cMeterPerQuarticSecond, cMeterPerQuinticSecond, cMeterPerSexticSecond, -1, cHertz, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeter, cMeterSecond, cMeterSecond, cScalar, cSecond, cSquareSecond, cCubicSecond, cQuarticSecond, cQuinticSecond, cSecondPerMeter, cSquareHertz, -1, -1, -1, -1, -1, cSquareMeterPerSecond, -1, cCubicMeterPerSecond, -1, -1, -1, -1, cSquareMeterPerSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewtonSquareMeterPerSquareCoulomb, -1, -1, -1, -1, cOhmMeter, -1, -1, -1, -1, -1, -1, -1, -1, cReciprocalSquareMeter, -1, cReciprocalMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cReciprocalHenry, -1, -1, -1, -1, -1, -1, cSiemens, -1, -1, -1, -1, -1, cCoulombPerKilogram, -1, -1, cSquareMeterPerSecond, -1, -1, -1, -1, cTeslaMeter, -1, -1, -1, -1, -1, -1, -1, -1, cMeter, cHertz, -1, -1, cReciprocalMeter, -1, -1, -1, -1, -1, -1, -1, -1),
    (cMeterPerSquareSecond, cMeterPerCubicSecond, cMeterPerQuarticSecond, cMeterPerQuinticSecond, cMeterPerSexticSecond, -1, -1, cSquareHertz, -1, -1, -1, -1, -1, -1, cNewtonPerSquareKilogram, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeterPerSecond, cMeter, cMeter, cHertz, cScalar, cSecond, cSquareSecond, cCubicSecond, cQuarticSecond, cReciprocalMeter, -1, -1, -1, -1, -1, -1, cSquareMeterPerSquareSecond, -1, cCubicMeterPerSquareSecond, -1, -1, -1, -1, cGrayPerSecond, -1, cNewtonSquareMeterPerSquareKilogram, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewtonSquareMeterPerSquareCoulomb, -1, -1, -1, -1, -1, -1, cCubicMeterPerKilogram, -1, -1, -1, -1, -1, -1, -1, cNewtonPerCubicMeter, -1, cReciprocalSquareMeter, -1, -1, cKilogram, -1, -1, -1, cKilogramPerSquareMeter, -1, -1, -1, cKelvinPerMeter, -1, cJoulePerKilogramPerKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCoulombPerKilogram, -1, -1, -1, -1, -1, cReciprocalHenry, -1, -1, -1, -1, -1, -1, -1, -1, cSquareMeterPerSquareSecond, -1, -1, -1, -1, cVoltPerMeter, -1, -1, -1, -1, -1, -1, -1, cSecondPerMeter, cMeterPerSecond, cSquareHertz, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cMeterPerCubicSecond, cMeterPerQuarticSecond, cMeterPerQuinticSecond, cMeterPerSexticSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeterPerSquareSecond, cMeterPerSecond, cMeterPerSecond, cSquareHertz, cHertz, cScalar, cSecond, cSquareSecond, cCubicSecond, -1, -1, -1, cNewtonPerSquareKilogram, -1, -1, -1, cGrayPerSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramPerSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cGrayPerSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cReciprocalMeter, cMeterPerSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cMeterPerQuarticSecond, cMeterPerQuinticSecond, cMeterPerSexticSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeterPerCubicSecond, cMeterPerSquareSecond, cMeterPerSquareSecond, -1, cSquareHertz, cHertz, cScalar, cSecond, cSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewtonSquareMeterPerSquareKilogram, cNewtonPerSquareKilogram, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewtonPerMeter, -1, -1, -1, cNewtonPerCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeterPerCubicSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewtonPerSquareKilogram, -1, -1),
    (cMeterPerQuinticSecond, cMeterPerSexticSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeterPerQuarticSecond, cMeterPerCubicSecond, cMeterPerCubicSecond, -1, -1, cSquareHertz, cHertz, cScalar, cSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWattPerSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewtonPerSquareKilogram, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeterPerQuarticSecond, -1, -1, -1, -1, -1, -1, -1, cNewtonPerSquareKilogram, -1, -1, -1, -1),
    (cMeterPerSexticSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeterPerQuinticSecond, cMeterPerQuarticSecond, cMeterPerQuarticSecond, -1, -1, -1, cSquareHertz, cHertz, cScalar, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeterPerQuinticSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cSquareMeterPerSquareSecond, cGrayPerSecond, -1, -1, -1, -1, -1, cMeterPerSquareSecond, -1, cSquareHertz, -1, -1, -1, -1, -1, -1, -1, cSquareMeterPerSquareCoulomb, cJoulePerKilogramPerKelvin, -1, -1, -1, -1, -1, cSquareMeterPerSecond, cSquareMeter, cSquareMeter, cMeterPerSecond, cMeter, cMeterSecond, -1, -1, -1, cScalar, cMeterPerCubicSecond, cNewtonPerSquareKilogram, -1, -1, -1, -1, cCubicMeterPerSquareSecond, -1, -1, -1, -1, -1, -1, -1, cNewtonSquareMeterPerSquareKilogram, -1, -1, -1, -1, -1, cCubicMeterPerKilogram, -1, -1, -1, -1, -1, -1, cCoulombPerKilogram, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cHertz, -1, -1, -1, cPascal, -1, cReciprocalMeter, -1, -1, cKilogramMeter, -1, -1, cSquareKilogramPerSquareSecond, cKilogramPerMeter, -1, -1, -1, cKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareAmpere, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCubicMeterPerSquareSecond, cSquareMeterPerSquareKilogram, -1, -1, -1, cVolt, -1, -1, -1, -1, -1, -1, -1, cSecond, cSquareMeterPerSecond, cMeterPerSquareSecond, cSquareHertz, -1, cHertz, -1, -1, -1, -1, -1, -1, -1, -1),
    (cMeterSecond, cMeter, cMeterPerSecond, cMeterPerSquareSecond, cMeterPerCubicSecond, cMeterPerQuarticSecond, cMeterPerQuinticSecond, cSecond, -1, cSecondPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareSecond, cCubicSecond, cQuarticSecond, cQuinticSecond, cSexticSecond, -1, -1, cScalar, -1, -1, -1, -1, -1, -1, -1, -1, cQuarticMeterSecond, -1, -1, -1, cSquareMeter, -1, -1, -1, -1, -1, -1, -1, cMeterPerWatt, cMeterPerWatt, -1, cMeterPerAmpere, -1, -1, -1, -1, cOhmMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareSecondPerSquareMeter, -1, -1, -1, cReciprocalCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeterKelvinPerWatt, -1, -1, -1, -1, -1, -1, -1, -1, -1, cJoule, cJoulePerKelvin, -1, -1, -1, -1, -1, -1, -1, -1, cFarad, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCoulomb, -1, -1, -1, -1, -1, cCubicMeterPerSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSecond, cSecondPerMeter, -1, -1, -1, cMeterPerWatt, -1, -1, -1, -1, -1, -1),
    (cKilogramMeter, cKilogramMeterPerSecond, cNewton, cWattPerMeter, -1, -1, -1, cKilogram, -1, cKilogramPerMeter, cKilogramPerSquareMeter, cKilogramPerCubicMeter, cKilogramPerQuarticMeter, -1, cMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramSquareSecond, -1, -1, -1, -1, -1, cKilogramPerSecond, cScalar, cMeterSecond, cSecond, -1, -1, cKilogramSquareMeter, -1, -1, -1, -1, cReciprocalMeter, cSecondPerMeter, cKilogramSquareMeterPerSecond, cSquareMeter, cCubicMeter, cQuarticMeter, cSquareSecond, cSquareSecond, -1, -1, -1, -1, -1, -1, cHenryPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareCoulombPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cQuinticMeter, -1, -1, cSquareKilogramPerSquareMeter, cMeterPerSquareSecond, -1, cSquareSecondPerSquareMeter, -1, -1, -1, cCubicMeterPerKilogram, -1, -1, -1, -1, -1, -1, -1, -1, cCubicSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cHenry, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareCoulomb, cKilogramSquareMeter, -1, cNewtonSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogram, cKilogramPerMeter, cKilogramPerSquareMeter, -1, -1, -1, cCubicSecond, -1, -1, -1, -1, -1),
    (cKilogramPerSecond, cNewtonPerMeter, cWattPerSquareMeter, -1, -1, -1, -1, cPoiseuille, -1, -1, -1, cKilogramPerQuarticMeterPerSecond, -1, -1, cHertz, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogram, -1, -1, cKilogramPerMeter, -1, -1, -1, -1, -1, -1, cPascal, -1, cScalar, cReciprocalMeter, -1, -1, cKilogramMeterPerSecond, -1, cKilogramSquareMeterPerSecond, -1, -1, -1, cReciprocalSquareMeter, cNewton, cMeterPerSecond, cSquareMeterPerSecond, cCubicMeterPerSecond, cSecondPerMeter, cSecondPerMeter, -1, cMeterSecond, -1, -1, cSquareSecondPerSquareMeter, cTesla, -1, -1, -1, -1, -1, -1, -1, -1, cCoulomb, cCoulombPerSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSecond, cKilogramPerCubicMeter, cMeter, cKilogramPerSquareMeter, -1, -1, cQuarticMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cTeslaMeter, -1, cWeber, -1, -1, -1, -1, -1, -1, -1, -1, cCoulombPerMeter, -1, -1, cKilogramMeterPerSecond, -1, cWatt, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogram, cPoiseuille, -1, -1, cKilogramPerSquareMeter, cSquareSecondPerSquareMeter, -1, -1, cSquareSecond, -1, cSecond, -1, -1),
    (cKilogramMeterPerSecond, cNewton, cWattPerMeter, -1, -1, -1, -1, cKilogramPerSecond, -1, cPoiseuille, -1, -1, cKilogramPerQuarticMeterPerSecond, -1, cMeterPerSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramMeter, -1, -1, cKilogram, -1, cKilogramSquareSecond, -1, -1, -1, -1, cNewtonPerMeter, cHertz, cMeter, cScalar, -1, -1, cKilogramSquareMeterPerSecond, -1, -1, -1, -1, -1, cReciprocalMeter, cJoule, cSquareMeterPerSecond, cCubicMeterPerSecond, -1, cSecond, cSecond, cMeterPerWatt, -1, cSecondPerMeter, cSecondPerMeter, -1, cTeslaMeter, -1, cTesla, -1, -1, -1, cSquareCoulombPerMeter, -1, -1, cCoulombMeter, cCoulombPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeterSecond, cKilogramPerSquareMeter, cSquareMeter, cKilogramPerMeter, -1, -1, cQuinticMeter, -1, cMeterPerCubicSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareSecond, -1, -1, -1, -1, -1, cSquareNewton, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWeber, cOhm, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCoulomb, -1, -1, cKilogramSquareMeterPerSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramMeter, cKilogramPerSecond, cPoiseuille, -1, cKilogramPerMeter, -1, cSecondPerMeter, cSquareSecond, -1, -1, cMeterSecond, -1, -1),
    (cSquareKilogramSquareMeterPerSquareSecond, -1, cSquareNewton, -1, -1, -1, -1, -1, -1, cSquareKilogramPerSquareSecond, -1, -1, -1, -1, cJoule, cSquareMeterPerSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareKilogram, -1, cNewton, cKilogramSquareMeterPerSecond, cKilogramMeterPerSecond, cScalar, -1, -1, -1, cSquareJouleSquareSecond, -1, -1, cNewtonPerMeter, cKilogramPerSecond, -1, cNewtonSquareMeter, cNewtonCubicMeter, -1, cKilogramMeter, cKilogramMeter, cSquareSecond, -1, cKilogram, cKilogram, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, cSquareKilogramPerMeter, cKilogramPerMeter, cKilogramPerSquareMeter, -1, cCubicMeterPerSquareSecond, -1, -1, -1, -1, cJoulePerKelvin, cKilogramKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareMeter, cSquareJoule, cSquareSecondPerSquareMeter, cReciprocalSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareKilogramPerSquareSecond, -1, -1, -1, cKilogram, -1, -1, -1, cKilogramSquareMeter, -1, -1),
    (cReciprocalSquareRootMeter, -1, -1, -1, -1, -1, -1, cReciprocalSquareRootCubicMeter, cReciprocalMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cScalar, cSquareRootMeter, cMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareRootMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cReciprocalSquareRootCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cReciprocalMeter, -1, -1, -1, -1, -1, -1, cReciprocalSquareMeter, cReciprocalSquareRootCubicMeter, cReciprocalCubicMeter, cReciprocalQuarticMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSecondPerMeter, -1, -1, -1, cSquareSecondPerSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cReciprocalSquareRootMeter, cScalar, cSquareRootMeter, cMeter, cSquareMeter, cCubicMeter, -1, -1, cHertz, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewtonPerSquareCoulomb, cSiemensPerMeter, -1, cOhm, -1, -1, -1, cHenryPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCubicMeterPerKilogram, -1, -1, cKilogramPerQuarticMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKelvinPerMeter, -1, -1, -1, -1, cReciprocalKelvin, -1, cMeterPerWatt, -1, -1, cKelvinPerWatt, cWattPerMeterPerKelvin, cWattPerSquareMeter, cWattPerSquareMeterPerKelvin, -1, cMeterKelvinPerWatt, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cFarad, -1, -1, -1, -1, -1, cAmperePerSquareMeter, -1, -1, cReciprocalHenry, cScalar, -1, cMeterPerSquareSecond, -1, -1, -1, -1, -1, -1, cMeterPerAmpere, -1, -1, -1, -1, cSecondPerMeter, cReciprocalSquareMeter, cReciprocalCubicMeter, cReciprocalQuarticMeter, -1, -1, -1, -1, cMeterPerWatt, -1, -1, -1, -1),
    (cReciprocalSquareRootCubicMeter, -1, -1, -1, -1, -1, -1, -1, cReciprocalSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cReciprocalMeter, cReciprocalSquareRootMeter, cScalar, cSquareRootMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cReciprocalSquareRootMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cReciprocalSquareMeter, -1, -1, -1, -1, -1, -1, cReciprocalCubicMeter, -1, cReciprocalQuarticMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareSecondPerSquareMeter, cSquareSecondPerSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cReciprocalSquareRootCubicMeter, cReciprocalMeter, cReciprocalSquareRootMeter, cScalar, cMeter, cSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cTeslaPerAmpere, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeterPerWatt, -1, -1, cWattPerSquareMeterPerKelvin, cWattPerCubicMeter, -1, -1, cKelvinPerWatt, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cFaradPerMeter, -1, -1, -1, cNewtonPerSquareCoulomb, -1, -1, -1, cReciprocalHenry, -1, cReciprocalMeter, -1, cSquareHertz, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cReciprocalCubicMeter, cReciprocalQuarticMeter, -1, -1, -1, -1, -1, -1, cMeterPerWatt, -1, -1, -1),
    (cReciprocalCubicMeter, -1, -1, -1, -1, -1, -1, cReciprocalQuarticMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cReciprocalSquareMeter, cReciprocalSquareRootCubicMeter, cReciprocalMeter, cScalar, cMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cReciprocalSquareMeter, -1, -1, -1, -1, -1, -1, -1, cMolePerCubicMeter, -1, cReciprocalMole, -1, -1, -1, -1, cReciprocalQuarticMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cReciprocalQuarticMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cReciprocalCubicMeter, -1, cReciprocalSquareMeter, cReciprocalMeter, cScalar, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cReciprocalCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cKilogramSquareMeter, cKilogramSquareMeterPerSecond, cJoule, cWatt, -1, -1, -1, cKilogramMeter, -1, cKilogram, cKilogramPerMeter, cKilogramPerSquareMeter, cKilogramPerCubicMeter, cKilogramPerQuarticMeter, cSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramSquareSecond, cKilogramMeterPerSecond, cMeter, -1, cMeterSecond, -1, -1, -1, -1, -1, -1, -1, cScalar, cSecond, -1, cCubicMeter, cQuarticMeter, cQuinticMeter, -1, -1, -1, -1, cSquareSecond, cSquareSecond, cCubicSecond, -1, cHenry, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareCoulomb, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSexticMeter, -1, -1, cSquareKilogramPerMeter, cSquareMeterPerSquareSecond, -1, -1, cSquareSecondPerSquareMeter, -1, cCubicMeterPerKilogram, -1, -1, -1, -1, cSquareMeterKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewtonCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramMeter, cKilogram, cKilogramPerMeter, -1, cCubicSecond, cSquareSecond, -1, -1, -1, -1, -1, -1),
    (cKilogramSquareMeterPerSecond, cJoule, cWatt, -1, -1, -1, -1, cKilogramMeterPerSecond, -1, cKilogramPerSecond, cPoiseuille, -1, -1, cKilogramPerQuarticMeterPerSecond, cSquareMeterPerSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramSquareMeter, -1, -1, cKilogramMeter, -1, -1, -1, -1, -1, -1, cNewton, cMeterPerSecond, cSquareMeter, cMeter, -1, -1, -1, -1, -1, -1, -1, cHertz, cScalar, cNewtonSquareMeter, cCubicMeterPerSecond, -1, -1, cMeterSecond, cMeterSecond, -1, -1, cSecond, cSecond, cSquareSecond, cWeber, cOhm, cTeslaMeter, -1, -1, -1, cSquareCoulomb, -1, -1, -1, cCoulomb, -1, -1, -1, -1, -1, -1, -1, -1, cQuarticMeterSecond, -1, cKilogramPerMeter, cCubicMeter, cKilogram, -1, cNewtonPerCubicMeter, cSexticMeter, -1, cGrayPerSecond, -1, cSecondPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareCoulombPerMeter, -1, -1, cOhmMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCoulombMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramSquareSecond, cKilogramSquareMeter, cKilogramMeterPerSecond, cKilogramPerSecond, cPoiseuille, cKilogram, cSquareSecond, cSecond, -1, -1, -1, -1, -1, -1),
    (cSecondPerMeter, cReciprocalMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareSecondPerSquareMeter, -1, -1, -1, -1, -1, -1, cReciprocalSquareMeter, -1, -1, -1, -1, -1, cSecond, -1, cMeterSecond, -1, -1, -1, -1, cScalar, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cFaradPerMeter, cHenryPerMeter, cHenry, -1, -1, cSiemensPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, cMeterPerWatt, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewtonPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeterPerAmpere, -1, -1, -1, -1, -1, cOhm, -1, cCoulombPerSquareMeter, -1, -1, cSiemens, cSecond, -1, cMeterPerSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeterPerWatt, -1, -1),
    (cKilogramPerMeter, cPoiseuille, cPascal, cWattPerCubicMeter, -1, -1, -1, cKilogramPerSquareMeter, -1, cKilogramPerCubicMeter, cKilogramPerQuarticMeter, -1, -1, -1, cReciprocalMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cReciprocalSquareMeter, cSecondPerMeter, -1, -1, -1, cKilogram, -1, cKilogramMeter, cKilogramSquareMeter, -1, cReciprocalCubicMeter, -1, cKilogramPerSecond, cScalar, cMeter, cSquareMeter, cSquareSecondPerSquareMeter, cSquareSecondPerSquareMeter, -1, cSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSecond, -1, cCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCubicSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cTeslaPerAmpere, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareCoulombPerMeter, -1, cKilogram, -1, cNewton, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramPerSquareMeter, cKilogramPerCubicMeter, cKilogramPerQuarticMeter, -1, -1, -1, -1, -1, cCubicSecond, -1, -1, -1),
    (cKilogramPerSquareMeter, -1, cNewtonPerCubicMeter, -1, -1, -1, -1, cKilogramPerCubicMeter, -1, cKilogramPerQuarticMeter, -1, -1, -1, -1, cReciprocalSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cReciprocalCubicMeter, -1, -1, -1, -1, cKilogramPerMeter, -1, cKilogram, cKilogramMeter, cKilogramSquareMeter, cReciprocalQuarticMeter, -1, cPoiseuille, cReciprocalMeter, cScalar, cMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareSecond, cSquareSecondPerSquareMeter, -1, cSecondPerMeter, -1, cSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramPerMeter, -1, cNewtonPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramPerCubicMeter, cKilogramPerQuarticMeter, -1, -1, -1, -1, -1, -1, -1, cSquareSecondPerSquareMeter, -1, -1),
    (cKilogramPerCubicMeter, -1, -1, -1, -1, -1, -1, cKilogramPerQuarticMeter, -1, -1, -1, -1, -1, -1, cReciprocalCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramPerQuarticMeterPerSecond, cReciprocalQuarticMeter, -1, -1, -1, -1, cKilogramPerSquareMeter, -1, cKilogramPerMeter, cKilogram, cKilogramMeter, -1, -1, -1, cReciprocalSquareMeter, cReciprocalMeter, cScalar, -1, -1, -1, cSquareSecondPerSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeter, -1, cMeterSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramPerSquareMeter, -1, cPascal, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramPerQuarticMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cNewton, cWattPerMeter, -1, -1, -1, -1, -1, cNewtonPerMeter, -1, cPascal, cNewtonPerCubicMeter, -1, -1, -1, cMeterPerSquareSecond, cNewtonPerSquareKilogram, cTeslaMeter, cHenryPerMeter, -1, -1, -1, -1, -1, -1, cKilogramMeterPerSecond, cKilogramMeter, cKilogramMeter, cKilogramPerSecond, cKilogram, -1, cKilogramSquareSecond, -1, -1, cKilogramPerMeter, cWattPerSquareMeter, cSquareHertz, cMeterPerSecond, cHertz, -1, -1, cJoule, -1, cNewtonSquareMeter, cNewtonCubicMeter, -1, -1, -1, cWatt, cSquareMeterPerSquareSecond, cCubicMeterPerSquareSecond, -1, cScalar, cScalar, -1, cSquareMeter, cReciprocalMeter, cReciprocalMeter, cSecondPerMeter, cVoltPerMeter, cNewtonPerSquareCoulomb, -1, cCoulombPerMeter, cFaradPerMeter, -1, -1, -1, -1, -1, cAmperePerMeter, -1, -1, -1, -1, -1, -1, -1, -1, cCubicMeter, cMeter, -1, cSquareMeterPerSecond, cPoiseuille, -1, -1, -1, -1, cMeterPerQuarticSecond, cKilogramPerSquareMeter, cReciprocalSquareMeter, cReciprocalCubicMeter, cSquareKilogram, -1, cNewtonSquareMeterPerSquareKilogram, -1, cSquareKilogramPerSquareMeter, -1, -1, cKelvinPerMeter, -1, -1, cJoulePerKelvin, cSecond, cMeterSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCoulomb, cVolt, -1, cVoltMeter, -1, cSquareCoulomb, -1, cCoulombPerSquareMeter, -1, cSquareVolt, cWeber, -1, cAmpere, -1, cSquareAmpere, cJoule, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramMeterPerSecond, cNewtonPerMeter, cPascal, cNewtonPerCubicMeter, cPoiseuille, cSecondPerMeter, cReciprocalMeter, cSecond, cMeterSecond, -1, cMeter, -1, -1),
    (cNewton, cWattPerMeter, -1, -1, -1, -1, -1, cNewtonPerMeter, -1, cPascal, cNewtonPerCubicMeter, -1, -1, -1, cMeterPerSquareSecond, cNewtonPerSquareKilogram, cTeslaMeter, cHenryPerMeter, -1, -1, -1, -1, -1, -1, cKilogramMeterPerSecond, cKilogramMeter, cKilogramMeter, cKilogramPerSecond, cKilogram, -1, cKilogramSquareSecond, -1, -1, cKilogramPerMeter, cWattPerSquareMeter, cSquareHertz, cMeterPerSecond, cHertz, -1, -1, cJoule, -1, cNewtonSquareMeter, cNewtonCubicMeter, -1, -1, -1, cWatt, cSquareMeterPerSquareSecond, cCubicMeterPerSquareSecond, -1, cScalar, cScalar, -1, cSquareMeter, cReciprocalMeter, cReciprocalMeter, cSecondPerMeter, cVoltPerMeter, cNewtonPerSquareCoulomb, -1, cCoulombPerMeter, cFaradPerMeter, -1, -1, -1, -1, -1, cAmperePerMeter, -1, -1, -1, -1, -1, -1, -1, -1, cCubicMeter, cMeter, -1, cSquareMeterPerSecond, cPoiseuille, -1, -1, -1, -1, cMeterPerQuarticSecond, cKilogramPerSquareMeter, cReciprocalSquareMeter, cReciprocalCubicMeter, cSquareKilogram, -1, cNewtonSquareMeterPerSquareKilogram, -1, cSquareKilogramPerSquareMeter, -1, -1, cKelvinPerMeter, -1, -1, cJoulePerKelvin, cSecond, cMeterSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCoulomb, cVolt, -1, cVoltMeter, -1, cSquareCoulomb, -1, cCoulombPerSquareMeter, -1, cSquareVolt, cWeber, -1, cAmpere, -1, cSquareAmpere, cJoule, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramMeterPerSecond, cNewtonPerMeter, cPascal, cNewtonPerCubicMeter, cPoiseuille, cSecondPerMeter, cReciprocalMeter, cSecond, cMeterSecond, -1, cMeter, -1, -1),
    (cSquareNewton, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareKilogramSquareMeterPerSquareSecond, cSquareKilogramSquareMeterPerSquareSecond, -1, -1, -1, -1, -1, -1, cSquareKilogramPerSquareSecond, -1, -1, cWatt, cWattPerMeter, cSquareHertz, -1, -1, -1, cSquareJoule, -1, -1, -1, cWattPerSquareMeter, -1, -1, -1, -1, cNewton, cNewton, cScalar, cNewtonSquareMeter, cNewtonPerMeter, cNewtonPerMeter, cKilogramPerSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewtonCubicMeter, cJoule, -1, -1, -1, -1, -1, -1, -1, -1, -1, cPascal, cNewtonPerCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramMeterPerSecond, cKilogramSquareMeterPerSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareMeterPerSquareSecond, -1, cReciprocalSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramPerSecond, cNewtonPerMeter, cKilogramMeterPerSecond, cKilogramSquareMeterPerSecond, -1, cJoule, -1, -1),
    (cPascal, cWattPerCubicMeter, -1, -1, -1, -1, -1, cNewtonPerCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cPoiseuille, cKilogramPerMeter, cKilogramPerMeter, -1, cKilogramPerSquareMeter, -1, -1, -1, -1, cKilogramPerCubicMeter, -1, -1, -1, -1, -1, -1, cNewtonPerMeter, -1, cNewton, cJoule, cNewtonSquareMeter, -1, -1, cWattPerSquareMeter, cSquareHertz, cMeterPerSquareSecond, cSquareMeterPerSquareSecond, cReciprocalSquareMeter, cReciprocalSquareMeter, -1, cScalar, cReciprocalCubicMeter, cReciprocalCubicMeter, -1, -1, -1, -1, cCoulombPerCubicMeter, -1, -1, -1, -1, -1, cAmperePerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeter, cReciprocalMeter, cKilogramPerQuarticMeterPerSecond, cHertz, -1, cCubicMeterPerSquareSecond, -1, cCubicMeterPerSecond, -1, -1, cKilogramPerQuarticMeter, cReciprocalQuarticMeter, -1, cSquareKilogramPerSquareMeter, -1, cNewtonPerSquareKilogram, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSecondPerMeter, cSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMolePerCubicMeter, -1, -1, -1, cCoulombPerSquareMeter, -1, -1, cVoltPerMeter, -1, -1, -1, -1, -1, -1, cTesla, -1, cAmperePerSquareMeter, -1, -1, cNewtonPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, cTeslaMeter, cJoulePerMole, -1, cVolt, -1, cPoiseuille, cNewtonPerCubicMeter, -1, -1, -1, -1, cReciprocalCubicMeter, -1, cSecondPerMeter, cSecond, cReciprocalMeter, -1, -1),
    (cJoule, cWatt, -1, -1, -1, -1, -1, cNewton, -1, cNewtonPerMeter, cPascal, cNewtonPerCubicMeter, -1, -1, cSquareMeterPerSquareSecond, -1, cWeber, cHenry, cJoulePerKelvin, -1, -1, -1, cJoulePerMole, -1, cKilogramSquareMeterPerSecond, cKilogramSquareMeter, cKilogramSquareMeter, cKilogramMeterPerSecond, cKilogramMeter, -1, -1, -1, -1, cKilogram, cWattPerMeter, cMeterPerSquareSecond, cSquareMeterPerSecond, cMeterPerSecond, -1, -1, cNewtonSquareMeter, -1, cNewtonCubicMeter, -1, -1, cSquareHertz, cHertz, -1, cCubicMeterPerSquareSecond, -1, -1, cMeter, cMeter, -1, cCubicMeter, cScalar, cScalar, cSecond, cVolt, -1, cVoltPerMeter, cCoulomb, cFarad, cSquareVolt, -1, -1, -1, cSquareMeterAmpere, cAmpere, cSquareAmpere, -1, -1, -1, -1, -1, -1, -1, cQuarticMeter, cSquareMeter, cPoiseuille, cCubicMeterPerSecond, cKilogramPerSecond, -1, -1, -1, -1, -1, cKilogramPerMeter, cReciprocalMeter, cReciprocalSquareMeter, -1, cNewtonSquareMeterPerSquareKilogram, -1, -1, cSquareKilogramPerMeter, -1, cJoulePerKilogramPerKelvin, cKelvin, cKilogramKelvin, -1, -1, cMeterSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMole, cJoulePerMolePerKelvin, cMoleKelvin, -1, cCoulombMeter, cVoltMeter, cNewtonSquareMeterPerSquareCoulomb, -1, -1, -1, cSquareCoulombPerMeter, cCoulombPerMeter, -1, -1, -1, -1, -1, -1, -1, cNewtonSquareMeter, -1, -1, -1, -1, -1, cTesla, -1, -1, -1, -1, -1, -1, -1, cKilogramSquareMeterPerSecond, cNewton, cNewtonPerMeter, cPascal, cKilogramPerSecond, cSecond, cScalar, cMeterSecond, -1, -1, cSquareMeter, -1, -1),
    (cJoule, cWatt, -1, -1, -1, -1, -1, cNewton, -1, cNewtonPerMeter, cPascal, cNewtonPerCubicMeter, -1, -1, cSquareMeterPerSquareSecond, -1, cWeber, cHenry, cJoulePerKelvin, -1, -1, -1, cJoulePerMole, -1, cKilogramSquareMeterPerSecond, cKilogramSquareMeter, cKilogramSquareMeter, cKilogramMeterPerSecond, cKilogramMeter, -1, -1, -1, -1, cKilogram, cWattPerMeter, cMeterPerSquareSecond, cSquareMeterPerSecond, cMeterPerSecond, -1, -1, cNewtonSquareMeter, -1, cNewtonCubicMeter, -1, -1, cSquareHertz, cHertz, -1, cCubicMeterPerSquareSecond, -1, -1, cMeter, cMeter, -1, cCubicMeter, cScalar, cScalar, cSecond, cVolt, -1, cVoltPerMeter, cCoulomb, cFarad, cSquareVolt, -1, -1, -1, cSquareMeterAmpere, cAmpere, cSquareAmpere, -1, -1, -1, -1, -1, -1, -1, cQuarticMeter, cSquareMeter, cPoiseuille, cCubicMeterPerSecond, cKilogramPerSecond, -1, -1, -1, -1, -1, cKilogramPerMeter, cReciprocalMeter, cReciprocalSquareMeter, -1, cNewtonSquareMeterPerSquareKilogram, -1, -1, cSquareKilogramPerMeter, -1, cJoulePerKilogramPerKelvin, cKelvin, cKilogramKelvin, -1, -1, cMeterSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMole, cJoulePerMolePerKelvin, cMoleKelvin, -1, cCoulombMeter, cVoltMeter, cNewtonSquareMeterPerSquareCoulomb, -1, -1, -1, cSquareCoulombPerMeter, cCoulombPerMeter, -1, -1, -1, -1, -1, -1, -1, cNewtonSquareMeter, -1, -1, -1, -1, -1, cTesla, -1, -1, -1, -1, -1, -1, -1, cKilogramSquareMeterPerSecond, cNewton, cNewtonPerMeter, cPascal, cKilogramPerSecond, cSecond, cScalar, cMeterSecond, -1, -1, cSquareMeter, -1, -1),
    (cWatt, -1, -1, -1, -1, -1, -1, cWattPerMeter, -1, cWattPerSquareMeter, cWattPerCubicMeter, -1, -1, -1, cGrayPerSecond, -1, cVolt, cOhm, cWattPerKelvin, -1, -1, cWattPerQuarticKelvin, -1, -1, cJoule, cKilogramSquareMeterPerSecond, cKilogramSquareMeterPerSecond, cNewton, cKilogramMeterPerSecond, cKilogramMeter, -1, -1, -1, cKilogramPerSecond, -1, cMeterPerCubicSecond, cSquareMeterPerSquareSecond, cMeterPerSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, cSquareHertz, -1, -1, -1, -1, cMeterPerSecond, cMeterPerSecond, -1, cCubicMeterPerSecond, cHertz, cHertz, cScalar, -1, -1, -1, cAmpere, cSiemens, -1, cSquareAmpere, cSquareVolt, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cJoulePerMole, -1, cSquareMeterPerSecond, cPascal, cCubicMeterPerSquareSecond, cNewtonPerMeter, -1, -1, -1, -1, -1, cPoiseuille, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWattPerMeterPerKelvin, -1, cMeter, cSquareMeter, cCubicMeter, cKelvin, cMeterKelvin, -1, -1, -1, -1, -1, -1, cQuarticKelvin, -1, cKatal, -1, -1, -1, -1, cVoltMeterPerSecond, -1, -1, -1, -1, -1, cAmperePerMeter, cCoulombPerMeter, -1, cVoltMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogram, cJoule, cWattPerMeter, cWattPerSquareMeter, cWattPerCubicMeter, cNewtonPerMeter, cScalar, cHertz, cMeter, cSquareMeter, cCubicMeter, cSquareMeterPerSecond, -1, -1),
    (cCoulomb, cAmpere, -1, -1, -1, -1, -1, cCoulombPerMeter, -1, cCoulombPerSquareMeter, cCoulombPerCubicMeter, -1, -1, -1, cCoulombPerKilogram, -1, cSecond, -1, -1, -1, -1, -1, cCoulombPerMole, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cAmperePerMeter, -1, -1, -1, -1, -1, cCoulombMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cScalar, -1, cReciprocalMeter, cFarad, -1, cVolt, -1, cWeber, -1, -1, cSiemens, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeter, -1, cSquareMeter, -1, -1, -1, cFaradPerMeter, -1, cVoltMeter, cMeterSecond, -1, -1, -1, -1, cCoulombMeter, -1, -1, -1, -1, cKilogram, -1, -1, -1, -1, -1, -1, cCubicMeter, -1, -1, cCoulombPerMeter, cCoulombPerSquareMeter, cCoulombPerCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, cMole),
    (cSquareCoulomb, -1, cSquareAmpere, -1, -1, -1, -1, cSquareCoulombPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cReciprocalHenry, cSiemens, -1, -1, -1, -1, -1, -1, -1, -1, cFarad, cFarad, -1, cCoulomb, cScalar, cCoulombPerMeter, -1, -1, cJoule, -1, cKilogramSquareMeterPerSecond, -1, -1, -1, -1, cKilogramSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cFaradPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCoulombMeter, cMeter, -1, -1, -1, -1, -1, -1, cNewtonSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareCoulombPerMeter, -1, -1, -1, -1, cFarad, -1, -1, -1, -1, -1, -1),
    (cCoulombMeter, -1, -1, -1, -1, -1, -1, cCoulomb, -1, cCoulombPerMeter, cCoulombPerSquareMeter, cCoulombPerCubicMeter, -1, -1, -1, -1, cMeterSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cAmpere, cCoulombPerKilogram, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareMeterAmpere, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeter, -1, cScalar, -1, -1, cVoltMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareMeter, -1, cCubicMeter, -1, -1, -1, cFarad, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramMeter, cSecondPerMeter, -1, -1, -1, -1, -1, cQuarticMeter, -1, -1, cCoulomb, cCoulombPerMeter, cCoulombPerSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cVolt, -1, -1, -1, -1, -1, -1, cVoltPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, cOhm, -1, -1, -1, -1, -1, -1, -1, cWeber, -1, -1, cTeslaMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cVoltMeter, -1, -1, -1, -1, -1, -1, cVoltMeterPerSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewtonPerSquareCoulomb, cScalar, -1, -1, cAmpere, -1, -1, cSquareMeterPerSecond, cHertz, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cTesla, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeterPerAmpere, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cAmperePerMeter, cMeter, cNewtonSquareMeterPerSquareCoulomb, -1, -1, -1, cCoulombMeter, cCoulombPerMeter, cReciprocalMeter, cSecondPerMeter, -1, cOhmMeter, cWattPerMeter, cMeterPerSecond, -1, -1, cVoltMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWeber, cVoltPerMeter, -1, -1, cTesla, -1, -1, cMeterPerAmpere, -1, -1, -1, -1, -1),
    (cSquareVolt, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewtonSquareMeterPerSquareCoulomb, cNewtonSquareMeterPerSquareCoulomb, cSquareMeterPerSquareCoulomb, -1, -1, -1, cOhm, -1, -1, -1, cVolt, cScalar, -1, cWatt, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewtonPerSquareCoulomb, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cOhmMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWattPerMeter, cVoltMeter, -1, -1, -1, cSquareNewton, cNewtonSquareMeter, cNewton, cVoltPerMeter, cTeslaMeter, -1, -1, -1, cVoltMeterPerSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cOhm, -1, cOhmMeter, -1, -1, -1, -1, -1),
    (cFarad, cSiemens, cReciprocalHenry, -1, -1, -1, -1, cFaradPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSiemensPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cScalar, -1, cSecond, cMeterSecond, -1, -1, -1, cSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cFaradPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cOhm, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cHenry, -1, -1, cHenryPerMeter, -1, -1, -1, -1, -1, -1, cNewtonPerSquareCoulomb, -1, cSquareMeterPerSquareCoulomb, -1, -1, -1, cOhmMeter, -1, -1, -1, -1, -1, -1, cNewtonSquareMeterPerSquareCoulomb, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cScalar, -1, -1, -1, -1, cHertz, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cTeslaPerAmpere, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cReciprocalMeter, cMeterPerAmpere, -1, -1, -1, cKilogramPerSecond, cMeterSecond, cSecondPerMeter, -1, -1, -1, -1, cVoltPerMeter, -1, cSquareMeterPerSecond, cMeterPerSecond, cOhmMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cHenry, -1, -1, -1, cTeslaPerAmpere, -1, -1, -1, -1, -1, -1, -1, -1),
    (cSiemens, cReciprocalHenry, -1, -1, -1, -1, -1, cSiemensPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cFarad, -1, -1, cFaradPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cHertz, -1, cScalar, cMeter, -1, -1, -1, cSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeterPerSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cFarad, cSiemensPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cSiemensPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cFaradPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSiemens, -1, -1, -1, -1, -1, -1, cReciprocalHenry, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cReciprocalMeter, cScalar, -1, -1, -1, cSecondPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cHertz, -1, -1, -1, -1, -1, cSiemens, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cFaradPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cTesla, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cTeslaPerAmpere, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cTeslaMeter, -1, cWeber, -1, -1, -1, -1, cVoltPerMeter, -1, -1, -1, -1, -1, -1, cMeterPerAmpere, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCoulombPerSquareMeter, -1, -1, cScalar, cReciprocalSquareMeter, cAmperePerSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCoulombPerCubicMeter, cSecondPerMeter, -1, -1, cOhm, -1, -1, -1, -1, -1, -1, cHenryPerMeter, cPascal, cReciprocalMeter, cAmpere, cAmperePerMeter, cTeslaMeter, -1, -1, -1, -1, -1, -1, -1, -1, cHenry, -1, -1, cOhmMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cWeber, cVolt, -1, -1, -1, -1, -1, cTeslaMeter, -1, cTesla, -1, -1, -1, -1, -1, -1, cHenry, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cVoltPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cVoltMeter, -1, -1, -1, cMeterPerAmpere, cMeterPerAmpere, -1, -1, -1, -1, -1, cOhm, -1, -1, cSecond, -1, -1, cCoulomb, -1, -1, cSquareMeter, cScalar, cAmpere, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCoulombPerMeter, cMeterSecond, cOhmMeter, -1, -1, -1, -1, -1, cSecondPerMeter, -1, -1, -1, cNewton, cMeter, cSquareMeterAmpere, -1, -1, -1, -1, -1, -1, -1, cTeslaPerAmpere, -1, -1, -1, -1, -1, -1, -1, -1, cTeslaMeter, cTesla, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cHenry, cOhm, -1, -1, -1, -1, -1, cHenryPerMeter, -1, cTeslaPerAmpere, -1, -1, -1, -1, cSquareMeterPerSquareCoulomb, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cOhmMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSecond, -1, -1, -1, -1, cScalar, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSecondPerMeter, -1, -1, -1, -1, cKilogram, -1, -1, -1, -1, -1, -1, cTeslaMeter, cMeterPerAmpere, cSquareMeter, cMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cHenryPerMeter, cTeslaPerAmpere, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cReciprocalHenry, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSiemens, cFarad, cFarad, cSiemensPerMeter, cFaradPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareHertz, -1, cHertz, cMeterPerSecond, -1, -1, -1, cScalar, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCoulombPerKilogram, -1, -1, -1, -1, -1, cMeterPerSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCoulombPerSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, cSiemens, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cCandela, -1, -1, -1, -1, -1, -1, -1, -1, cLux, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cScalar, cLumenSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cLumenPerWatt, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cScalar, cHertz, cCubicMeterPerSecond, cSquareMeter, cSquareMeterPerSecond, -1, -1, -1, cLumenSecondPerCubicMeter, -1, cLuxSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWatt, -1, -1, -1, cSquareMeter, -1, -1, cLumenSecond, -1, cLux, -1, cLuxSecond, cLumenPerWatt, -1, -1, -1, -1, -1, -1, -1),
    (cLumenSecond, cCandela, -1, -1, -1, -1, -1, -1, -1, cLuxSecond, cLumenSecondPerCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cLumenPerWatt, cLumenPerWatt, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSecond, cScalar, cCubicMeter, -1, cSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cJoule, -1, -1, -1, -1, -1, -1, -1, -1, cLuxSecond, cLumenSecondPerCubicMeter, -1, -1, cLumenPerWatt, -1, -1, -1, -1, -1, -1),
    (cLumenSecondPerCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cLuxSecond, -1, -1, cLumenSecond, -1, -1, -1, cLux, -1, -1, -1, -1, -1, -1, cLumenPerWatt, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cReciprocalCubicMeter, cScalar, cSecondPerMeter, cReciprocalMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cLuxSecond, -1, -1, -1, -1, -1, -1, cPascal, -1, -1, -1, cSecondPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cLux, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cReciprocalSquareMeter, cLuxSecond, -1, -1, cLumenSecondPerCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCandela, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cReciprocalSquareMeter, -1, cMeterPerSecond, cScalar, cHertz, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cLumenPerWatt, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWattPerSquareMeter, -1, -1, -1, cScalar, -1, -1, cLuxSecond, -1, -1, -1, -1, -1, -1, -1, cLumenPerWatt, -1, -1, -1, -1),
    (cLuxSecond, cLux, -1, -1, -1, -1, -1, cLumenSecondPerCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cLumenSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cReciprocalSquareMeter, cMeter, cSecond, cScalar, -1, -1, cLumenPerWatt, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewtonPerMeter, -1, -1, -1, cSecond, -1, -1, -1, cLumenSecondPerCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, cLumenPerWatt, -1, -1),
    (cKatal, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKatalPerCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cHertz, -1, cMole, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cScalar, -1, -1, cMolePerCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCubicMeterPerSecond, -1, -1, -1, cMole, -1, -1, cKatalPerCubicMeter, -1, -1, -1, -1, -1, -1, -1, cCubicMeter, -1),
    (cNewtonPerCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramPerSquareMeter, cKilogramPerSquareMeter, -1, cKilogramPerCubicMeter, -1, -1, -1, -1, cKilogramPerQuarticMeter, -1, -1, -1, -1, -1, -1, cPascal, -1, cNewtonPerMeter, cNewton, cJoule, -1, -1, cWattPerCubicMeter, -1, cSquareHertz, cMeterPerSquareSecond, cReciprocalCubicMeter, cReciprocalCubicMeter, -1, cReciprocalMeter, cReciprocalQuarticMeter, cReciprocalQuarticMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cAmperePerSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, cScalar, cReciprocalSquareMeter, -1, -1, cKilogramPerQuarticMeterPerSecond, cSquareMeterPerSquareSecond, -1, cSquareMeterPerSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSecondPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCoulombPerCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cPascal, -1, -1, -1, -1, -1, -1, -1, -1, cTesla, -1, -1, cVoltPerMeter, -1, -1, -1, -1, -1, cKilogramPerQuarticMeterPerSecond, -1, cReciprocalQuarticMeter, -1, -1, cSecondPerMeter, cReciprocalSquareMeter, -1, -1),
    (cNewtonPerMeter, cWattPerSquareMeter, -1, -1, -1, -1, -1, cPascal, -1, cNewtonPerCubicMeter, -1, -1, -1, -1, cSquareHertz, -1, cTesla, cTeslaPerAmpere, -1, -1, -1, -1, -1, -1, cKilogramPerSecond, cKilogram, cKilogram, cPoiseuille, cKilogramPerMeter, -1, -1, -1, -1, cKilogramPerSquareMeter, cWattPerCubicMeter, -1, cHertz, -1, -1, -1, cNewton, -1, cJoule, cNewtonSquareMeter, cNewtonCubicMeter, -1, -1, cWattPerMeter, cMeterPerSquareSecond, cSquareMeterPerSquareSecond, cCubicMeterPerSquareSecond, cReciprocalMeter, cReciprocalMeter, -1, cMeter, cReciprocalSquareMeter, cReciprocalSquareMeter, -1, -1, -1, -1, cCoulombPerSquareMeter, -1, -1, -1, -1, -1, cAmpere, cAmperePerSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, cSquareMeter, cScalar, -1, cMeterPerSecond, -1, -1, -1, -1, -1, -1, cKilogramPerCubicMeter, cReciprocalCubicMeter, cReciprocalQuarticMeter, cSquareKilogramPerMeter, cNewtonPerSquareKilogram, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSecondPerMeter, cSecond, cMeterSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCoulombPerMeter, cVoltPerMeter, cNewtonPerSquareCoulomb, cVolt, -1, cSquareCoulombPerMeter, -1, cCoulombPerCubicMeter, -1, -1, cTeslaMeter, -1, cAmperePerMeter, cSquareAmpere, -1, cNewton, -1, -1, -1, -1, -1, -1, -1, -1, cWeber, -1, -1, cVoltMeter, -1, cKilogramPerSecond, cPascal, cNewtonPerCubicMeter, -1, -1, -1, cReciprocalSquareMeter, cSecondPerMeter, cSecond, cMeterSecond, cScalar, -1, -1),
    (cCubicMeterPerSecond, cCubicMeterPerSquareSecond, -1, -1, -1, -1, -1, cSquareMeterPerSecond, -1, cMeterPerSecond, cHertz, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCubicMeter, -1, -1, cSquareMeter, -1, -1, -1, -1, -1, cMeterSecond, cSquareMeterPerSquareSecond, -1, cCubicMeterPerKilogram, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cScalar, -1, cMeter, -1, -1, -1, cKilogramPerSecond, -1, cSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCubicMeter, cSquareMeterPerSecond, cMeterPerSecond, cHertz, cMeter, -1, -1, -1, -1, -1, -1, -1, -1),
    (cPoiseuille, cPascal, cWattPerCubicMeter, -1, -1, -1, -1, -1, -1, -1, cKilogramPerQuarticMeterPerSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramPerMeter, -1, -1, cKilogramPerSquareMeter, -1, -1, -1, -1, -1, -1, cNewtonPerCubicMeter, -1, cReciprocalMeter, cReciprocalSquareMeter, -1, -1, cKilogramPerSecond, -1, cKilogramMeterPerSecond, cKilogramSquareMeterPerSecond, -1, -1, cReciprocalCubicMeter, cNewtonPerMeter, cHertz, cMeterPerSecond, cSquareMeterPerSecond, -1, -1, -1, cSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCoulombPerMeter, cCoulombPerCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, cMeterSecond, cSecondPerMeter, cKilogramPerQuarticMeter, cScalar, cKilogramPerCubicMeter, cCubicMeterPerSecond, -1, cCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareSecondPerSquareMeter, -1, cSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cTesla, -1, cTeslaMeter, -1, -1, -1, -1, -1, -1, -1, -1, cCoulombPerSquareMeter, -1, -1, cKilogramPerSecond, -1, cWattPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWeber, -1, cKilogramPerMeter, -1, -1, cKilogramPerQuarticMeterPerSecond, cKilogramPerCubicMeter, -1, -1, cSquareSecondPerSquareMeter, -1, cSquareSecond, cSecondPerMeter, -1, -1),
    (cSquareMeterPerSecond, cSquareMeterPerSquareSecond, cGrayPerSecond, -1, -1, -1, -1, cMeterPerSecond, -1, cHertz, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareMeter, -1, -1, cMeter, cMeterSecond, -1, -1, -1, -1, cSecond, cMeterPerSquareSecond, -1, -1, -1, -1, -1, cCubicMeterPerSecond, -1, -1, -1, -1, -1, -1, cCubicMeterPerSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCoulombPerKilogram, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cReciprocalMeter, cCubicMeterPerKilogram, cScalar, -1, -1, -1, cPoiseuille, -1, cSecondPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCubicMeterPerSecond, -1, -1, -1, -1, cWeber, -1, -1, -1, -1, -1, -1, -1, cSquareSecond, cSquareMeter, cMeterPerSecond, cHertz, -1, cScalar, -1, -1, -1, -1, -1, -1, -1, -1),
    (cKilogramPerQuarticMeter, cKilogramPerQuarticMeterPerSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cReciprocalQuarticMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramPerCubicMeter, -1, cKilogramPerSquareMeter, cKilogramPerMeter, cKilogram, -1, -1, -1, cReciprocalCubicMeter, cReciprocalSquareMeter, cReciprocalMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareSecondPerSquareMeter, -1, -1, -1, -1, cScalar, -1, cSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramPerCubicMeter, -1, cNewtonPerCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cQuarticMeterSecond, cQuarticMeter, -1, -1, -1, -1, -1, -1, -1, -1, cMeterSecond, cSecond, cSecondPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cQuinticMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cScalar, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeterSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cKilogramPerQuarticMeterPerSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramPerQuarticMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cReciprocalQuarticMeter, -1, -1, -1, -1, -1, -1, cPoiseuille, cKilogramPerSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cReciprocalCubicMeter, -1, cHertz, -1, cScalar, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramPerQuarticMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cCubicMeterPerKilogram, -1, cNewtonSquareMeterPerSquareKilogram, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareMeterPerSquareKilogram, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cScalar, -1, -1, -1, -1, -1, -1, -1, cKilogramMeter, cSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cKilogramSquareSecond, -1, cKilogram, cKilogramPerSecond, cNewtonPerMeter, cWattPerSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, cSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCubicSecond, -1, -1, -1, -1, -1, -1, -1, -1, cSquareSecondPerSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cQuarticSecond, -1, -1, -1, -1, -1, -1, -1, cScalar, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cQuinticSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cQuinticSecond, -1, cQuarticSecond, -1, -1),
    (cCubicMeterPerSquareSecond, -1, -1, -1, -1, -1, -1, cSquareMeterPerSquareSecond, -1, cMeterPerSquareSecond, cSquareHertz, -1, -1, -1, cNewtonSquareMeterPerSquareKilogram, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCubicMeterPerSecond, cCubicMeter, cCubicMeter, cSquareMeterPerSecond, cSquareMeter, -1, -1, -1, -1, cMeter, cGrayPerSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewtonPerSquareKilogram, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCubicMeterPerKilogram, cHertz, -1, cMeterPerSecond, -1, -1, -1, cNewtonPerMeter, -1, cScalar, -1, -1, cKilogramSquareMeter, -1, -1, -1, cKilogram, -1, -1, -1, cMeterKelvin, cJoulePerKilogramPerKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCoulombPerKilogram, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cVoltMeter, -1, -1, -1, -1, -1, -1, -1, cMeterSecond, cCubicMeterPerSecond, cSquareMeterPerSquareSecond, cMeterPerSquareSecond, cSquareHertz, cMeterPerSecond, -1, -1, -1, -1, -1, cCubicMeterPerKilogram, -1, -1),
    (cNewtonSquareMeter, -1, -1, -1, -1, -1, -1, cJoule, -1, cNewton, cNewtonPerMeter, cPascal, cNewtonPerCubicMeter, -1, cCubicMeterPerSquareSecond, cNewtonSquareMeterPerSquareKilogram, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramSquareMeterPerSecond, cKilogramSquareMeter, -1, -1, -1, -1, cKilogramMeter, cWatt, cSquareMeterPerSquareSecond, cCubicMeterPerSecond, cSquareMeterPerSecond, -1, -1, cNewtonCubicMeter, -1, -1, -1, -1, cMeterPerSquareSecond, cMeterPerSecond, -1, -1, -1, -1, cSquareMeter, cSquareMeter, -1, cQuarticMeter, cMeter, cMeter, cMeterSecond, cVoltMeter, cNewtonSquareMeterPerSquareCoulomb, cVolt, cCoulombMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cQuinticMeter, cCubicMeter, cKilogramPerSecond, -1, cKilogramMeterPerSecond, -1, cWattPerCubicMeter, -1, cSquareKilogramPerSquareSecond, -1, cKilogram, cScalar, cReciprocalMeter, -1, -1, -1, -1, cSquareKilogram, -1, -1, cMeterKelvin, -1, cJoulePerKelvin, -1, -1, -1, cQuarticMeterSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareCoulomb, cCoulomb, -1, -1, -1, -1, cSquareMeterAmpere, -1, -1, cNewtonCubicMeter, cCubicMeterPerKilogram, -1, -1, -1, -1, cTeslaMeter, -1, -1, -1, -1, -1, -1, -1, -1, cJoule, cNewton, cNewtonPerMeter, cKilogramMeterPerSecond, cMeterSecond, cMeter, -1, -1, cQuarticMeterSecond, cCubicMeter, -1, -1),
    (cNewtonCubicMeter, -1, -1, -1, -1, -1, -1, cNewtonSquareMeter, -1, cJoule, cNewton, cNewtonPerMeter, cPascal, cNewtonPerCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramSquareMeter, -1, cCubicMeterPerSquareSecond, -1, cCubicMeterPerSecond, -1, -1, -1, -1, -1, -1, -1, cSquareMeterPerSquareSecond, cSquareMeterPerSecond, -1, -1, -1, -1, cCubicMeter, cCubicMeter, -1, cQuinticMeter, cSquareMeter, cSquareMeter, -1, -1, -1, cVoltMeter, -1, -1, -1, -1, -1, -1, -1, cSquareMeterAmpere, -1, -1, -1, -1, -1, -1, -1, -1, cSexticMeter, cQuarticMeter, cKilogramMeterPerSecond, -1, cKilogramSquareMeterPerSecond, -1, cWattPerSquareMeter, -1, -1, -1, cKilogramMeter, cMeter, cScalar, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cQuarticMeterSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCoulombMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWeber, -1, -1, -1, -1, -1, -1, -1, -1, cNewtonSquareMeter, cJoule, cNewton, cKilogramSquareMeterPerSecond, -1, cSquareMeter, -1, cQuarticMeterSecond, -1, cQuarticMeter, -1, -1),
    (cNewtonPerSquareKilogram, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewtonSquareMeterPerSquareKilogram, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareMeterPerSquareKilogram, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cScalar, -1, -1, cPascal, cReciprocalSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cSquareKilogramPerMeter, -1, -1, -1, -1, -1, -1, cSquareKilogramPerSquareMeter, -1, -1, -1, -1, -1, -1, cKilogramPerMeter, cReciprocalMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramPerSquareMeter, -1, -1, -1, -1, cSquareKilogram, -1, -1, -1, -1, cKilogramPerCubicMeter, -1, -1, cKilogram, cKilogramMeter, cKilogramSquareMeter, -1, -1, -1, cKilogramSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cPascal, -1, -1, -1, -1, cScalar, cMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareKilogram, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareKilogramPerSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cSquareKilogramPerSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramPerSquareMeter, cReciprocalSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramPerCubicMeter, -1, -1, -1, -1, cSquareKilogramPerMeter, -1, cSquareKilogram, -1, -1, cKilogramPerQuarticMeter, -1, -1, cKilogramPerMeter, cKilogram, cKilogramMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramSquareSecond, -1, -1, -1, -1, cKilogramSquareMeter, -1, -1, -1, cNewtonPerCubicMeter, -1, -1, -1, -1, cReciprocalMeter, cScalar, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareKilogramPerMeter, cSquareSecondPerSquareMeter, cSquareKilogramPerSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cSquareMeterPerSquareKilogram, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cScalar, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cNewtonSquareMeterPerSquareKilogram, -1, -1, -1, -1, -1, -1, -1, -1, cNewtonPerSquareKilogram, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCubicMeterPerKilogram, cCubicMeterPerKilogram, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareMeterPerSquareKilogram, cSquareMeterPerSquareKilogram, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareHertz, -1, -1, -1, -1, cSquareMeter, -1, -1, cNewton, cScalar, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewtonPerSquareKilogram, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cReciprocalKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareMeterKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cScalar, -1, -1, cSquareSecondPerSquareMeter, -1, -1, -1, -1, -1, -1, cMeterPerWatt, -1, cWattPerMeterPerKelvin, -1, cReciprocalSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cJoulePerKilogramPerKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cKilogramKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKelvin, -1, -1, -1, cKilogram, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKelvinPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeterKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cScalar, -1, -1, cKilogramPerMeter, cKilogramMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cJoulePerKelvin, cWattPerKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cJoulePerKilogramPerKelvin, -1, -1, -1, -1, -1, -1, -1, cJoulePerMolePerKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWattPerMeterPerKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cReciprocalKelvin, cReciprocalKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareMeterKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cJoule, -1, cScalar, cKilogram, -1, -1, -1, -1, -1, cSecond, cMeterSecond, -1, -1, -1, cNewtonPerMeter, -1, -1, -1, -1, -1, -1, cMole, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cReciprocalKelvin, -1, -1, -1, cSquareMeterKelvin, -1, -1),
    (cJoulePerKilogramPerKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareMeterKelvin, cSquareMeterKelvin, -1, -1, -1, -1, -1, -1, cReciprocalKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareMeterPerSquareSecond, -1, -1, cScalar, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareHertz, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cMeterKelvin, -1, -1, -1, -1, -1, -1, cKelvin, -1, cKelvinPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, cMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeterKelvinPerWatt, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cScalar, cSquareMeter, -1, -1, -1, -1, -1, -1, -1, cWatt, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKelvin, cKelvinPerMeter, -1, -1, cMeterKelvinPerWatt, -1, -1, -1, -1, -1, -1, -1),
    (cKelvinPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cReciprocalMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKelvin, -1, cMeterKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cReciprocalSquareMeter, cScalar, cKelvinPerWatt, cMeterKelvinPerWatt, -1, -1, -1, cWattPerMeter, -1, cWattPerSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKelvinPerWatt, cMeterKelvinPerWatt, -1, -1, -1, -1),
    (cWattPerMeter, -1, -1, -1, -1, -1, -1, cWattPerSquareMeter, -1, cWattPerCubicMeter, -1, -1, -1, -1, cMeterPerCubicSecond, -1, cVoltPerMeter, -1, cWattPerMeterPerKelvin, -1, -1, -1, -1, -1, cNewton, cKilogramMeterPerSecond, cKilogramMeterPerSecond, cNewtonPerMeter, cKilogramPerSecond, cKilogram, -1, cKilogramSquareSecond, -1, cPoiseuille, -1, -1, cMeterPerSquareSecond, cSquareHertz, -1, -1, cWatt, -1, -1, -1, -1, -1, -1, -1, cGrayPerSecond, -1, -1, cHertz, cHertz, -1, cSquareMeterPerSecond, -1, -1, cReciprocalMeter, -1, -1, -1, cAmperePerMeter, cSiemensPerMeter, -1, -1, -1, cSquareVolt, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCubicMeterPerSecond, cMeterPerSecond, cNewtonPerCubicMeter, cSquareMeterPerSquareSecond, cPascal, -1, -1, -1, -1, cMeterPerQuinticSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWattPerSquareMeterPerKelvin, cWattPerKelvin, cScalar, cMeter, cSquareMeter, cKelvinPerMeter, cKelvin, -1, -1, -1, -1, cMeterKelvin, -1, -1, -1, -1, -1, -1, -1, cAmpere, -1, -1, cVoltMeterPerSecond, -1, -1, -1, cAmperePerSquareMeter, cCoulombPerSquareMeter, -1, cVolt, -1, -1, -1, -1, cWatt, -1, -1, -1, -1, -1, -1, -1, -1, cVoltMeter, -1, -1, -1, cKilogramPerMeter, cNewton, cWattPerSquareMeter, cWattPerCubicMeter, -1, cPascal, cReciprocalMeter, -1, cScalar, cMeter, cSquareMeter, cMeterPerSecond, -1, -1),
    (cWattPerSquareMeter, -1, -1, -1, -1, -1, -1, cWattPerCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWattPerSquareMeterPerKelvin, -1, -1, -1, -1, -1, cNewtonPerMeter, cKilogramPerSecond, cKilogramPerSecond, cPascal, cPoiseuille, cKilogramPerMeter, -1, -1, -1, -1, -1, -1, cSquareHertz, -1, -1, -1, cWattPerMeter, -1, cWatt, -1, -1, -1, -1, -1, cMeterPerCubicSecond, cGrayPerSecond, -1, -1, -1, -1, cMeterPerSecond, -1, -1, cReciprocalSquareMeter, -1, -1, -1, cAmperePerSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareMeterPerSecond, cHertz, -1, cMeterPerSquareSecond, cNewtonPerCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWattPerMeterPerKelvin, cReciprocalMeter, cScalar, cMeter, -1, cKelvinPerMeter, -1, -1, -1, -1, cKelvin, -1, -1, -1, -1, -1, -1, -1, cAmperePerMeter, -1, -1, -1, -1, -1, -1, -1, cCoulombPerCubicMeter, -1, cVoltPerMeter, -1, -1, -1, -1, cWattPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, cVolt, -1, -1, cVoltMeterPerSecond, cKilogramPerSquareMeter, cNewtonPerMeter, cWattPerCubicMeter, -1, -1, cNewtonPerCubicMeter, cReciprocalSquareMeter, -1, cReciprocalMeter, cScalar, cMeter, cHertz, -1, -1),
    (cWattPerCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cPascal, cPoiseuille, cPoiseuille, cNewtonPerCubicMeter, -1, cKilogramPerSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWattPerSquareMeter, -1, cWattPerMeter, cWatt, -1, -1, -1, -1, -1, cMeterPerCubicSecond, cGrayPerSecond, -1, -1, -1, cHertz, -1, -1, cReciprocalCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeterPerSecond, -1, -1, cSquareHertz, -1, -1, -1, cCubicMeterPerSquareSecond, -1, -1, cKilogramPerQuarticMeterPerSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWattPerSquareMeterPerKelvin, cReciprocalSquareMeter, cReciprocalMeter, cScalar, -1, -1, -1, -1, -1, -1, cKelvinPerMeter, -1, -1, -1, cKatalPerCubicMeter, -1, -1, -1, cAmperePerSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWattPerSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, cVoltPerMeter, -1, -1, -1, cKilogramPerCubicMeter, cPascal, -1, -1, -1, -1, cReciprocalCubicMeter, -1, cReciprocalSquareMeter, cReciprocalMeter, cScalar, -1, cJoulePerMole, -1),
    (cWattPerKelvin, -1, -1, -1, -1, -1, -1, cWattPerMeterPerKelvin, -1, cWattPerSquareMeterPerKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWattPerQuarticKelvin, -1, -1, -1, cJoulePerKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cJoulePerKilogramPerKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cReciprocalKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cJoulePerMolePerKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWatt, -1, cHertz, cKilogramPerSecond, -1, -1, -1, cSquareMeterKelvin, -1, cScalar, cMeter, -1, -1, -1, cWattPerSquareMeter, cSquareMeter, -1, cCubicKelvin, -1, -1, -1, cKatal, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cJoulePerKelvin, cWattPerMeterPerKelvin, cWattPerSquareMeterPerKelvin, -1, -1, cReciprocalKelvin, -1, -1, cSquareMeterKelvin, -1, -1, -1, -1),
    (cWattPerMeterPerKelvin, -1, -1, -1, -1, -1, -1, cWattPerSquareMeterPerKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWattPerKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cJoulePerKilogramPerKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWattPerMeter, -1, -1, cPoiseuille, -1, -1, cReciprocalKelvin, -1, cSquareMeterKelvin, cReciprocalMeter, cScalar, -1, -1, -1, cWattPerCubicMeter, cMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWattPerKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWattPerSquareMeterPerKelvin, -1, -1, -1, -1, -1, cReciprocalKelvin, -1, cSquareMeterKelvin, -1, -1, -1),
    (cKelvinPerWatt, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeterKelvinPerWatt, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeterPerWatt, -1, -1, -1, -1, -1, cScalar, cKelvinPerMeter, cReciprocalMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeterKelvinPerWatt, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cMeterPerWatt, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeterKelvinPerWatt, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cScalar, cReciprocalKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cMeterKelvinPerWatt, -1, -1, -1, -1, -1, -1, cKelvinPerWatt, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeterPerWatt, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeter, cKelvin, cScalar, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKelvinPerWatt, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cSquareMeterKelvin, -1, cJoulePerKilogramPerKelvin, -1, -1, -1, -1, -1, -1, cReciprocalKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareMeter, -1, -1, cSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cScalar, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cReciprocalKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cWattPerSquareMeterPerKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWattPerMeterPerKelvin, -1, cWattPerKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWattPerSquareMeter, -1, -1, -1, -1, -1, -1, cReciprocalKelvin, -1, cReciprocalSquareMeter, cReciprocalMeter, -1, -1, -1, -1, cScalar, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWattPerMeterPerKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cReciprocalKelvin, -1, -1, -1, -1),
    (cSquareMeterQuarticKelvin, -1, -1, -1, -1, -1, -1, -1, -1, cQuarticKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cScalar, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cQuarticKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cWattPerQuarticKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cScalar, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cWattPerSquareMeterPerQuarticKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWattPerSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cQuarticKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cScalar, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cQuarticKelvin, -1, -1, -1, -1),
    (cJoulePerMole, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cJoulePerMolePerKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cReciprocalMole, cReciprocalMole, -1, -1, -1, -1, cCoulombPerMole, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cScalar, -1, cKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cJoule, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cReciprocalMole, -1, -1, -1, -1, -1, cVolt),
    (cMoleKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMole, -1, -1, -1, cKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cScalar, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cJoulePerMolePerKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cJoulePerMole, -1, cReciprocalMole, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cReciprocalKelvin, -1, cScalar, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cJoulePerKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cOhmMeter, cNewtonSquareMeterPerSquareCoulomb, -1, -1, -1, -1, -1, cOhm, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cHenry, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareMeterPerSquareCoulomb, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeterPerAmpere, cMeterPerWatt, -1, cMeter, -1, -1, -1, -1, cMeterPerSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, cTeslaPerAmpere, -1, cHenryPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareVolt, -1, -1, -1, -1, -1, -1, -1, -1, -1, cScalar, -1, -1, -1, -1, cKilogramMeterPerSecond, -1, cSecond, -1, -1, -1, -1, cVolt, -1, cCubicMeterPerSecond, cSquareMeterPerSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cOhm, -1, -1, cHenryPerMeter, -1, -1, -1, -1, -1, -1, -1, -1),
    (cVoltPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cTeslaMeter, -1, -1, cTesla, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cVolt, -1, cVoltMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewtonPerSquareCoulomb, -1, -1, cReciprocalMeter, -1, -1, cAmperePerMeter, -1, -1, cMeterPerSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeterPerAmpere, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cAmperePerSquareMeter, cScalar, -1, -1, cNewtonSquareMeterPerSquareCoulomb, -1, cCoulomb, cCoulombPerSquareMeter, cReciprocalSquareMeter, -1, -1, cOhm, cWattPerSquareMeter, cHertz, -1, -1, cVolt, -1, -1, -1, -1, -1, -1, -1, -1, cOhmMeter, -1, -1, -1, -1, cTeslaMeter, -1, -1, -1, -1, -1, -1, -1, cMeterPerAmpere, -1, -1, -1, -1),
    (cCoulombPerMeter, cAmperePerMeter, -1, -1, -1, -1, -1, cCoulombPerSquareMeter, -1, cCoulombPerCubicMeter, -1, -1, -1, -1, -1, -1, cSecondPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cAmperePerSquareMeter, -1, -1, -1, -1, -1, cCoulomb, -1, cCoulombMeter, -1, -1, -1, -1, cAmpere, cCoulombPerKilogram, -1, -1, -1, -1, -1, -1, -1, -1, -1, cReciprocalMeter, -1, cReciprocalSquareMeter, cFaradPerMeter, -1, cVoltPerMeter, -1, cTeslaMeter, cWeber, -1, cSiemensPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cFarad, cScalar, -1, cMeter, -1, -1, -1, -1, -1, cVolt, cSecond, -1, cSiemens, -1, -1, cCoulomb, -1, -1, -1, -1, cKilogramPerMeter, -1, -1, -1, cMeterSecond, -1, -1, cSquareMeter, -1, -1, cCoulombPerSquareMeter, cCoulombPerCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cSquareCoulombPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cReciprocalHenry, -1, cSiemens, -1, -1, cSquareCoulomb, -1, -1, -1, -1, -1, cSiemensPerMeter, -1, -1, -1, -1, cFarad, cFarad, -1, -1, cFaradPerMeter, cFaradPerMeter, -1, cCoulombPerMeter, cReciprocalMeter, cCoulombPerSquareMeter, -1, -1, cNewton, -1, cKilogramMeterPerSecond, cKilogramSquareMeterPerSecond, -1, -1, -1, cKilogramMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCoulomb, cScalar, cCoulombMeter, -1, -1, -1, -1, -1, cJoule, -1, -1, -1, -1, -1, cSquareCoulomb, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cFaradPerMeter, -1, -1, -1, -1, -1, -1),
    (cCoulombPerSquareMeter, cAmperePerSquareMeter, -1, -1, -1, -1, -1, cCoulombPerCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCoulombPerMeter, -1, cCoulomb, cCoulombMeter, -1, -1, -1, cAmperePerMeter, -1, cCoulombPerKilogram, -1, -1, -1, -1, -1, -1, -1, -1, cReciprocalSquareMeter, -1, cReciprocalCubicMeter, -1, -1, -1, -1, cTesla, cTeslaMeter, cSiemens, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cFaradPerMeter, cReciprocalMeter, -1, cScalar, -1, -1, -1, -1, -1, cVoltPerMeter, cSecondPerMeter, -1, cSiemensPerMeter, -1, -1, cCoulombPerMeter, -1, -1, -1, -1, cKilogramPerSquareMeter, -1, -1, -1, cSecond, -1, -1, cMeter, -1, -1, cCoulombPerCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cSquareMeterPerSquareCoulomb, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cScalar, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cNewtonPerSquareCoulomb, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cHenryPerMeter, cHenryPerMeter, -1, cTeslaPerAmpere, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewtonSquareMeterPerSquareCoulomb, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareMeterPerSquareCoulomb, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cPascal, cScalar, cReciprocalSquareMeter, -1, -1, -1, -1, -1, -1, cMeterPerSquareSecond, cSquareHertz, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cNewtonSquareMeterPerSquareCoulomb, -1, -1, -1, -1, -1, -1, -1, -1, cNewtonPerSquareCoulomb, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cOhmMeter, -1, -1, cOhm, cHenry, -1, -1, -1, -1, cHenryPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareMeterPerSquareCoulomb, cSquareMeterPerSquareCoulomb, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeterPerSecond, -1, -1, -1, -1, cMeterPerSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cTeslaPerAmpere, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cHertz, -1, -1, -1, -1, cNewton, cSquareMeter, cScalar, -1, -1, -1, -1, -1, -1, cCubicMeterPerSquareSecond, cSquareMeterPerSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cOhmMeter, -1, cNewtonPerSquareCoulomb, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cVoltMeter, cVoltMeterPerSecond, -1, -1, -1, -1, -1, cVolt, -1, cVoltPerMeter, -1, -1, -1, -1, -1, -1, cOhmMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWeber, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeterPerAmpere, cNewtonSquareMeterPerSquareCoulomb, -1, -1, cMeter, -1, -1, -1, -1, -1, cCubicMeterPerSecond, cMeterPerSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cTesla, -1, cTeslaMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cAmpere, cSquareMeter, -1, -1, -1, -1, -1, cCoulomb, cScalar, cSecond, -1, -1, cWatt, cSquareMeterPerSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cVolt, cVoltPerMeter, -1, cTeslaMeter, cMeterPerAmpere, -1, -1, -1, -1, -1, -1, -1),
    (cVoltMeterPerSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewtonSquareMeterPerSquareCoulomb, -1, -1, -1, -1, -1, -1, -1, cVoltMeter, -1, -1, cVolt, cWeber, -1, -1, -1, -1, cTeslaMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeterPerSecond, -1, -1, -1, -1, -1, cCubicMeterPerSquareSecond, cMeterPerSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cVoltPerMeter, -1, -1, -1, -1, -1, cTesla, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareMeterPerSecond, -1, -1, -1, -1, cSquareMeterAmpere, cAmpere, cHertz, cScalar, -1, -1, -1, cSquareMeterPerSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, cNewtonPerSquareCoulomb, -1, -1, -1, -1, -1, -1, -1, cVoltMeter, -1, -1, -1, cVoltPerMeter, -1, -1, -1, -1, -1, -1, -1, -1),
    (cFaradPerMeter, cSiemensPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cFarad, -1, -1, -1, -1, -1, -1, cSiemens, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cReciprocalMeter, -1, cSecondPerMeter, cSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cScalar, -1, -1, -1, -1, -1, cFarad, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cAmperePerMeter, -1, -1, -1, -1, -1, -1, cAmperePerSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, cReciprocalMeter, -1, -1, -1, -1, -1, -1, -1, cCoulombPerMeter, -1, -1, cCoulombPerSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cAmpere, -1, -1, cSquareMeterAmpere, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSiemensPerMeter, -1, -1, -1, cVoltPerMeter, cVolt, -1, -1, -1, cTeslaMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCoulombPerKilogram, cCoulombPerCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSiemens, cHertz, -1, cMeterPerSecond, -1, -1, -1, -1, -1, -1, cScalar, -1, cReciprocalHenry, -1, -1, cAmpere, -1, -1, -1, -1, cPoiseuille, cReciprocalCubicMeter, -1, -1, cMeter, -1, -1, cSquareMeterPerSecond, -1, cCoulombPerMeter, cAmperePerSquareMeter, -1, -1, cCoulombPerCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1),
    (cMeterPerAmpere, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeterPerWatt, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cVolt, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cScalar, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cTeslaMeter, cVoltPerMeter, -1, -1, -1, -1, -1, cTesla, -1, -1, -1, -1, -1, -1, -1, -1, cHenryPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWeber, -1, -1, -1, -1, -1, -1, cVolt, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSecondPerMeter, -1, -1, cCoulombPerMeter, -1, -1, cMeter, cReciprocalMeter, cAmperePerMeter, -1, -1, -1, -1, -1, -1, -1, -1, cMeterPerAmpere, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCoulombPerSquareMeter, cSecond, cOhm, -1, cOhmMeter, -1, -1, -1, -1, cSquareSecondPerSquareMeter, -1, cHenry, cNewtonPerMeter, cScalar, -1, cAmpere, cWeber, -1, cVoltMeterPerSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cTesla, -1, -1, -1, -1, -1, -1, -1, -1, cMeterPerAmpere, -1, -1),
    (cTeslaPerAmpere, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cHenryPerMeter, -1, cHenry, -1, -1, -1, -1, -1, -1, cSquareMeterPerSquareCoulomb, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cReciprocalSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramPerSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, cScalar, cReciprocalMeter, cHenryPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cHenryPerMeter, -1, cNewtonPerSquareCoulomb, -1, -1, -1, -1, cTeslaPerAmpere, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cHenry, -1, -1, -1, -1, -1, -1, cOhm, cSquareMeterPerSquareCoulomb, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSecondPerMeter, -1, -1, cMeterPerAmpere, -1, cReciprocalMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramPerMeter, cSquareSecond, cSquareSecondPerSquareMeter, -1, -1, -1, -1, cTesla, -1, cMeter, cScalar, cHenry, -1, cNewtonSquareMeterPerSquareCoulomb, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cTeslaPerAmpere, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cReciprocalMeter, -1, -1, -1, -1, -1, -1, cReciprocalSquareMeter, cReciprocalSquareRootCubicMeter, cReciprocalCubicMeter, cReciprocalQuarticMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSecondPerMeter, -1, -1, -1, cSquareSecondPerSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cReciprocalSquareRootMeter, cScalar, cSquareRootMeter, cMeter, cSquareMeter, cCubicMeter, -1, -1, cHertz, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewtonPerSquareCoulomb, cSiemensPerMeter, -1, cOhm, -1, -1, -1, cHenryPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCubicMeterPerKilogram, -1, -1, cKilogramPerQuarticMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKelvinPerMeter, -1, -1, -1, -1, cReciprocalKelvin, -1, cMeterPerWatt, -1, -1, cKelvinPerWatt, cWattPerMeterPerKelvin, cWattPerSquareMeter, cWattPerSquareMeterPerKelvin, -1, cMeterKelvinPerWatt, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cFarad, -1, -1, -1, -1, -1, cAmperePerSquareMeter, -1, -1, cReciprocalHenry, cScalar, -1, cMeterPerSquareSecond, -1, -1, -1, -1, -1, -1, cMeterPerAmpere, -1, -1, -1, -1, cSecondPerMeter, cReciprocalSquareMeter, cReciprocalCubicMeter, cReciprocalQuarticMeter, -1, -1, -1, -1, cMeterPerWatt, -1, -1, -1, -1),
    (cSquareKilogramPerSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewtonPerMeter, cSquareHertz, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareKilogram, cSquareKilogram, -1, cSquareKilogramPerMeter, -1, -1, -1, -1, cSquareKilogramPerSquareMeter, -1, cPascal, cKilogramPerSecond, cPoiseuille, cReciprocalSquareMeter, -1, -1, -1, cSquareKilogramSquareMeterPerSquareSecond, -1, cSquareJouleSquareSecond, cNewtonPerCubicMeter, -1, -1, cNewton, cJoule, cNewtonSquareMeter, cKilogramPerMeter, cKilogramPerMeter, cSquareSecondPerSquareMeter, cKilogramMeter, cKilogramPerSquareMeter, cKilogramPerSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramSquareMeter, cKilogram, -1, cKilogramMeterPerSecond, -1, cNewtonCubicMeter, -1, -1, -1, -1, -1, cKilogramPerCubicMeter, cKilogramPerQuarticMeter, -1, cMeterPerSquareSecond, cSquareMeterPerSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cScalar, cSquareNewton, -1, cReciprocalQuarticMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramPerSquareMeter, -1, -1, -1, cKilogram, -1, -1),
    (cSquareSecondPerSquareMeter, -1, cReciprocalSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareSecond, -1, -1, -1, -1, cSecondPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cTeslaPerAmpere, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeterPerWatt, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cPoiseuille, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cHenryPerMeter, -1, -1, -1, cFarad, cFaradPerMeter, -1, -1, cScalar, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cSquareJoule, -1, -1, -1, -1, -1, -1, -1, -1, cSquareNewton, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareJouleSquareSecond, cSquareJouleSquareSecond, -1, -1, -1, -1, -1, -1, cSquareKilogramSquareMeterPerSquareSecond, -1, -1, -1, -1, cSquareMeterPerSquareSecond, -1, -1, -1, -1, -1, -1, -1, cWatt, -1, -1, -1, -1, cNewtonSquareMeter, cNewtonSquareMeter, cSquareMeter, -1, cJoule, cJoule, cKilogramSquareMeterPerSecond, -1, cSquareVolt, -1, -1, cSquareCoulomb, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewtonCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewton, cNewtonPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cScalar, cSquareHertz, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareNewton, -1, -1, cKilogramSquareMeterPerSecond, cJoule, -1, -1, -1, cNewtonCubicMeter, -1, -1),
    (cSquareJouleSquareSecond, -1, cSquareJoule, -1, -1, -1, -1, -1, -1, cSquareKilogramSquareMeterPerSquareSecond, -1, cSquareKilogramPerSquareSecond, -1, -1, cNewtonCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewtonSquareMeter, -1, -1, cSquareMeter, -1, -1, -1, -1, -1, -1, cJoule, cKilogramSquareMeterPerSecond, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramSquareMeter, cKilogramSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramMeter, cKilogram, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cQuarticMeter, -1, cSquareSecond, cScalar, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareKilogramSquareMeterPerSquareSecond, -1, -1, -1, cKilogramSquareMeter, -1, -1, -1, -1, -1, -1),
    (cCoulombPerKilogram, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCoulombPerCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cScalar, -1, -1, -1, -1, -1, -1, cCubicMeterPerKilogram, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cSquareMeterAmpere, -1, -1, -1, -1, -1, -1, -1, -1, cAmpere, cAmperePerMeter, cAmperePerSquareMeter, -1, -1, -1, -1, cSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCoulombMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCoulombPerKilogram, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareMeterPerSecond, -1, cMeterPerSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCoulombPerMeter, -1, cCoulomb, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCubicMeterPerSecond, -1, -1, -1, -1, -1, -1, -1, -1, cCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogramSquareMeterPerSecond, cScalar, -1, -1, cQuarticMeter, -1, -1, -1, -1, -1, -1, cAmpere, cAmperePerMeter, cCoulomb, -1, -1, -1, -1, -1, -1, -1, -1),
    (cLumenPerWatt, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cScalar, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cReciprocalMole, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cScalar, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cAmperePerSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cReciprocalSquareMeter, -1, -1, -1, -1, -1, -1, -1, cCoulombPerSquareMeter, -1, -1, cCoulombPerCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cAmperePerMeter, -1, cAmpere, -1, cSquareMeterAmpere, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cVoltPerMeter, cReciprocalHenry, -1, -1, cTesla, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSiemensPerMeter, -1, -1, cHertz, -1, -1, -1, -1, -1, -1, cReciprocalMeter, -1, -1, -1, -1, cAmperePerMeter, -1, -1, -1, -1, -1, cReciprocalQuarticMeter, -1, -1, cScalar, -1, -1, cMeterPerSecond, -1, cCoulombPerSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (cMolePerCubicMeter, cKatalPerCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cReciprocalCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMole, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cScalar, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSecond, -1),
    (cLux, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cReciprocalSquareMeter, cLuxSecond, -1, -1, cLumenSecondPerCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCandela, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cReciprocalSquareMeter, -1, cMeterPerSecond, cScalar, cHertz, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cLumenPerWatt, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWattPerSquareMeter, -1, -1, -1, cScalar, -1, -1, cLuxSecond, -1, -1, -1, -1, -1, -1, -1, cLumenPerWatt, -1, -1, -1, -1),
    (cCoulombPerCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCoulombPerSquareMeter, -1, cCoulombPerMeter, cCoulomb, cCoulombMeter, -1, -1, cAmperePerSquareMeter, -1, -1, cCoulombPerKilogram, -1, -1, -1, -1, -1, -1, -1, cReciprocalCubicMeter, -1, cReciprocalQuarticMeter, -1, -1, -1, -1, -1, cTesla, cSiemensPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cReciprocalSquareMeter, -1, cReciprocalMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCoulombPerSquareMeter, -1, -1, -1, -1, cKilogramPerCubicMeter, -1, -1, -1, cSecondPerMeter, cCoulombPerMole, -1, cScalar, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMolePerCubicMeter),
    (cGrayPerSecond, -1, -1, -1, -1, -1, -1, cMeterPerCubicSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareMeterPerSquareSecond, cSquareMeterPerSecond, cSquareMeterPerSecond, cMeterPerSquareSecond, cMeterPerSecond, cMeter, cMeterSecond, -1, -1, cHertz, cMeterPerQuarticSecond, -1, -1, cNewtonPerSquareKilogram, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cNewtonSquareMeterPerSquareKilogram, cSquareHertz, -1, -1, -1, cWattPerCubicMeter, -1, -1, -1, -1, cKilogramMeterPerSecond, -1, -1, -1, cPoiseuille, -1, -1, -1, -1, -1, -1, -1, -1, cCubicMeterPerKilogram, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cScalar, cSquareMeterPerSquareSecond, cMeterPerCubicSecond, -1, -1, cSquareHertz, -1, -1, -1, -1, cCubicMeterPerKilogram, -1, -1, -1),
    (cHertz, cSquareHertz, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cScalar, cSecond, cSecond, cReciprocalMeter, cSecondPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeterPerSecond, -1, cSquareMeterPerSecond, cCubicMeterPerSecond, -1, -1, -1, cMeterPerSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cReciprocalHenry, -1, cNewtonSquareMeterPerSquareCoulomb, cCoulombPerKilogram, -1, -1, cOhm, -1, -1, -1, -1, -1, cReciprocalMole, -1, -1, cReciprocalCubicMeter, -1, cReciprocalSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSiemensPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, cMeterPerSecond, -1, cGrayPerSecond, -1, -1, cTesla, -1, -1, cKatal, -1, -1, -1, -1, cSquareSecondPerSquareMeter, cScalar, -1, -1, -1, cReciprocalSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1),
    (cMeter, cMeterPerSecond, cMeterPerSquareSecond, cMeterPerCubicSecond, cMeterPerQuarticSecond, cMeterPerQuinticSecond, cMeterPerSexticSecond, cScalar, cSquareRootMeter, cReciprocalMeter, cReciprocalSquareMeter, cReciprocalCubicMeter, cReciprocalQuarticMeter, -1, -1, -1, cMeterPerAmpere, -1, -1, -1, -1, -1, -1, -1, cMeterSecond, -1, -1, cSecond, cSquareSecond, cCubicSecond, cQuarticSecond, cQuinticSecond, cSexticSecond, -1, cHertz, -1, -1, -1, -1, -1, cSquareMeter, -1, cCubicMeter, cQuarticMeter, cQuinticMeter, -1, -1, cSquareMeterPerSecond, -1, cCubicMeterPerKilogram, -1, -1, -1, -1, -1, -1, -1, cMeterPerWatt, -1, -1, -1, -1, -1, cNewtonSquareMeterPerSquareCoulomb, -1, cOhmMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSecondPerMeter, -1, -1, -1, cKilogramPerSquareMeter, cNewtonPerSquareKilogram, cSquareSecondPerSquareMeter, -1, -1, cKilogramSquareSecond, cSquareMeterPerSquareKilogram, -1, cSquareKilogramPerMeter, -1, cMeterKelvin, -1, -1, -1, cReciprocalKelvin, cSquareMeterKelvin, -1, -1, -1, cMeterKelvinPerWatt, -1, -1, cWatt, cWattPerKelvin, cKelvinPerMeter, -1, -1, -1, -1, -1, -1, -1, cSiemens, -1, -1, cSquareMeterPerSquareCoulomb, -1, cSquareCoulombPerMeter, -1, cFarad, -1, -1, -1, -1, cAmpere, -1, -1, -1, cSquareMeter, -1, cCubicMeterPerSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeterSecond, cScalar, cReciprocalMeter, cReciprocalSquareMeter, cSecondPerMeter, cMeterPerWatt, -1, -1, -1, -1, -1, -1, -1),
    (cSquareMeter, cSquareMeterPerSecond, cSquareMeterPerSquareSecond, cGrayPerSecond, -1, -1, -1, cMeter, -1, cScalar, cReciprocalMeter, cReciprocalSquareMeter, cReciprocalCubicMeter, cReciprocalQuarticMeter, -1, cSquareMeterPerSquareKilogram, -1, -1, cSquareMeterKelvin, -1, -1, -1, -1, -1, -1, -1, -1, cMeterSecond, -1, -1, -1, -1, -1, cSquareSecond, cMeterPerSecond, -1, -1, -1, -1, -1, cCubicMeter, -1, cQuarticMeter, cQuinticMeter, cSexticMeter, -1, -1, cCubicMeterPerSecond, cCubicMeterPerKilogram, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareMeterPerSquareCoulomb, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSecondPerMeter, -1, cSecond, -1, -1, -1, cKilogramPerMeter, -1, -1, -1, -1, -1, -1, -1, cSquareKilogram, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareCoulomb, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCubicSecond, -1, cMeter, cScalar, cReciprocalMeter, cSecond, -1, -1, -1, -1, -1, -1, -1, -1),
    (cCubicMeter, cCubicMeterPerSecond, cCubicMeterPerSquareSecond, -1, -1, -1, -1, cSquareMeter, -1, cMeter, cScalar, cReciprocalMeter, cReciprocalSquareMeter, cReciprocalCubicMeter, cCubicMeterPerKilogram, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareMeterPerSecond, -1, -1, -1, -1, -1, cQuarticMeter, -1, cQuinticMeter, cSexticMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSecond, -1, cMeterSecond, -1, -1, -1, cKilogram, cNewtonSquareMeterPerSquareKilogram, cSquareSecond, -1, -1, -1, -1, -1, -1, cKilogramSquareSecond, -1, -1, -1, -1, cSquareMeterKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeterKelvin, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareMeterAmpere, -1, -1, -1, cQuarticMeter, -1, -1, -1, -1, -1, cMeterPerAmpere, -1, -1, -1, -1, -1, -1, -1, -1, cSquareMeter, cMeter, cScalar, cMeterSecond, -1, -1, -1, -1, -1, -1, -1, -1),
    (cSquareMeterPerSecond, cSquareMeterPerSquareSecond, cGrayPerSecond, -1, -1, -1, -1, cMeterPerSecond, -1, cHertz, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareMeter, -1, -1, cMeter, cMeterSecond, -1, -1, -1, -1, cSecond, cMeterPerSquareSecond, -1, -1, -1, -1, -1, cCubicMeterPerSecond, -1, -1, -1, -1, -1, -1, cCubicMeterPerSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCoulombPerKilogram, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cReciprocalMeter, cCubicMeterPerKilogram, cScalar, -1, -1, -1, cPoiseuille, -1, cSecondPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCubicMeterPerSecond, -1, -1, -1, -1, cWeber, -1, -1, -1, -1, -1, -1, -1, cSquareSecond, cSquareMeter, cMeterPerSecond, cHertz, -1, cScalar, -1, -1, -1, -1, -1, -1, -1, -1),
    (cWatt, -1, -1, -1, -1, -1, -1, cWattPerMeter, -1, cWattPerSquareMeter, cWattPerCubicMeter, -1, -1, -1, cGrayPerSecond, -1, cVolt, cOhm, cWattPerKelvin, -1, -1, cWattPerQuarticKelvin, -1, -1, cJoule, cKilogramSquareMeterPerSecond, cKilogramSquareMeterPerSecond, cNewton, cKilogramMeterPerSecond, cKilogramMeter, -1, -1, -1, cKilogramPerSecond, -1, cMeterPerCubicSecond, cSquareMeterPerSquareSecond, cMeterPerSquareSecond, -1, -1, -1, -1, -1, -1, -1, -1, cSquareHertz, -1, -1, -1, -1, cMeterPerSecond, cMeterPerSecond, -1, cCubicMeterPerSecond, cHertz, cHertz, cScalar, -1, -1, -1, cAmpere, cSiemens, -1, cSquareAmpere, cSquareVolt, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cJoulePerMole, -1, cSquareMeterPerSecond, cPascal, cCubicMeterPerSquareSecond, cNewtonPerMeter, -1, -1, -1, -1, -1, cPoiseuille, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWattPerMeterPerKelvin, -1, cMeter, cSquareMeter, cCubicMeter, cKelvin, cMeterKelvin, -1, -1, -1, -1, -1, -1, cQuarticKelvin, -1, cKatal, -1, -1, -1, -1, cVoltMeterPerSecond, -1, -1, -1, -1, -1, cAmperePerMeter, cCoulombPerMeter, -1, cVoltMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKilogram, cJoule, cWattPerMeter, cWattPerSquareMeter, cWattPerCubicMeter, cNewtonPerMeter, cScalar, cHertz, cMeter, cSquareMeter, cCubicMeter, cSquareMeterPerSecond, -1, -1),
    (cJoule, cWatt, -1, -1, -1, -1, -1, cNewton, -1, cNewtonPerMeter, cPascal, cNewtonPerCubicMeter, -1, -1, cSquareMeterPerSquareSecond, -1, cWeber, cHenry, cJoulePerKelvin, -1, -1, -1, cJoulePerMole, -1, cKilogramSquareMeterPerSecond, cKilogramSquareMeter, cKilogramSquareMeter, cKilogramMeterPerSecond, cKilogramMeter, -1, -1, -1, -1, cKilogram, cWattPerMeter, cMeterPerSquareSecond, cSquareMeterPerSecond, cMeterPerSecond, -1, -1, cNewtonSquareMeter, -1, cNewtonCubicMeter, -1, -1, cSquareHertz, cHertz, -1, cCubicMeterPerSquareSecond, -1, -1, cMeter, cMeter, -1, cCubicMeter, cScalar, cScalar, cSecond, cVolt, -1, cVoltPerMeter, cCoulomb, cFarad, cSquareVolt, -1, -1, -1, cSquareMeterAmpere, cAmpere, cSquareAmpere, -1, -1, -1, -1, -1, -1, -1, cQuarticMeter, cSquareMeter, cPoiseuille, cCubicMeterPerSecond, cKilogramPerSecond, -1, -1, -1, -1, -1, cKilogramPerMeter, cReciprocalMeter, cReciprocalSquareMeter, -1, cNewtonSquareMeterPerSquareKilogram, -1, -1, cSquareKilogramPerMeter, -1, cJoulePerKilogramPerKelvin, cKelvin, cKilogramKelvin, -1, -1, cMeterSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMole, cJoulePerMolePerKelvin, cMoleKelvin, -1, cCoulombMeter, cVoltMeter, cNewtonSquareMeterPerSquareCoulomb, -1, -1, -1, cSquareCoulombPerMeter, cCoulombPerMeter, -1, -1, -1, -1, -1, -1, -1, cNewtonSquareMeter, -1, -1, -1, -1, -1, cTesla, -1, -1, -1, -1, -1, -1, -1, cKilogramSquareMeterPerSecond, cNewton, cNewtonPerMeter, cPascal, cKilogramPerSecond, cSecond, cScalar, cMeterSecond, -1, -1, cSquareMeter, -1, -1),
    (cWattPerMeter, -1, -1, -1, -1, -1, -1, cWattPerSquareMeter, -1, cWattPerCubicMeter, -1, -1, -1, -1, cMeterPerCubicSecond, -1, cVoltPerMeter, -1, cWattPerMeterPerKelvin, -1, -1, -1, -1, -1, cNewton, cKilogramMeterPerSecond, cKilogramMeterPerSecond, cNewtonPerMeter, cKilogramPerSecond, cKilogram, -1, cKilogramSquareSecond, -1, cPoiseuille, -1, -1, cMeterPerSquareSecond, cSquareHertz, -1, -1, cWatt, -1, -1, -1, -1, -1, -1, -1, cGrayPerSecond, -1, -1, cHertz, cHertz, -1, cSquareMeterPerSecond, -1, -1, cReciprocalMeter, -1, -1, -1, cAmperePerMeter, cSiemensPerMeter, -1, -1, -1, cSquareVolt, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCubicMeterPerSecond, cMeterPerSecond, cNewtonPerCubicMeter, cSquareMeterPerSquareSecond, cPascal, -1, -1, -1, -1, cMeterPerQuinticSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWattPerSquareMeterPerKelvin, cWattPerKelvin, cScalar, cMeter, cSquareMeter, cKelvinPerMeter, cKelvin, -1, -1, -1, -1, cMeterKelvin, -1, -1, -1, -1, -1, -1, -1, cAmpere, -1, -1, cVoltMeterPerSecond, -1, -1, -1, cAmperePerSquareMeter, cCoulombPerSquareMeter, -1, cVolt, -1, -1, -1, -1, cWatt, -1, -1, -1, -1, -1, -1, -1, -1, cVoltMeter, -1, -1, -1, cKilogramPerMeter, cNewton, cWattPerSquareMeter, cWattPerCubicMeter, -1, cPascal, cReciprocalMeter, -1, cScalar, cMeter, cSquareMeter, cMeterPerSecond, -1, -1),
    (cWattPerSquareMeter, -1, -1, -1, -1, -1, -1, cWattPerCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWattPerSquareMeterPerKelvin, -1, -1, -1, -1, -1, cNewtonPerMeter, cKilogramPerSecond, cKilogramPerSecond, cPascal, cPoiseuille, cKilogramPerMeter, -1, -1, -1, -1, -1, -1, cSquareHertz, -1, -1, -1, cWattPerMeter, -1, cWatt, -1, -1, -1, -1, -1, cMeterPerCubicSecond, cGrayPerSecond, -1, -1, -1, -1, cMeterPerSecond, -1, -1, cReciprocalSquareMeter, -1, -1, -1, cAmperePerSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSquareMeterPerSecond, cHertz, -1, cMeterPerSquareSecond, cNewtonPerCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWattPerMeterPerKelvin, cReciprocalMeter, cScalar, cMeter, -1, cKelvinPerMeter, -1, -1, -1, -1, cKelvin, -1, -1, -1, -1, -1, -1, -1, cAmperePerMeter, -1, -1, -1, -1, -1, -1, -1, cCoulombPerCubicMeter, -1, cVoltPerMeter, -1, -1, -1, -1, cWattPerMeter, -1, -1, -1, -1, -1, -1, -1, -1, cVolt, -1, -1, cVoltMeterPerSecond, cKilogramPerSquareMeter, cNewtonPerMeter, cWattPerCubicMeter, -1, -1, cNewtonPerCubicMeter, cReciprocalSquareMeter, -1, cReciprocalMeter, cScalar, cMeter, cHertz, -1, -1),
    (cWattPerCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cPascal, cPoiseuille, cPoiseuille, cNewtonPerCubicMeter, -1, cKilogramPerSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWattPerSquareMeter, -1, cWattPerMeter, cWatt, -1, -1, -1, -1, -1, cMeterPerCubicSecond, cGrayPerSecond, -1, -1, -1, cHertz, -1, -1, cReciprocalCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMeterPerSecond, -1, -1, cSquareHertz, -1, -1, -1, cCubicMeterPerSquareSecond, -1, -1, cKilogramPerQuarticMeterPerSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWattPerSquareMeterPerKelvin, cReciprocalSquareMeter, cReciprocalMeter, cScalar, -1, -1, -1, -1, -1, -1, cKelvinPerMeter, -1, -1, -1, cKatalPerCubicMeter, -1, -1, -1, cAmperePerSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cWattPerSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, cVoltPerMeter, -1, -1, -1, cKilogramPerCubicMeter, cPascal, -1, -1, -1, -1, cReciprocalCubicMeter, -1, cReciprocalSquareMeter, cReciprocalMeter, cScalar, -1, cJoulePerMole, -1),
    (cNewtonPerMeter, cWattPerSquareMeter, -1, -1, -1, -1, -1, cPascal, -1, cNewtonPerCubicMeter, -1, -1, -1, -1, cSquareHertz, -1, cTesla, cTeslaPerAmpere, -1, -1, -1, -1, -1, -1, cKilogramPerSecond, cKilogram, cKilogram, cPoiseuille, cKilogramPerMeter, -1, -1, -1, -1, cKilogramPerSquareMeter, cWattPerCubicMeter, -1, cHertz, -1, -1, -1, cNewton, -1, cJoule, cNewtonSquareMeter, cNewtonCubicMeter, -1, -1, cWattPerMeter, cMeterPerSquareSecond, cSquareMeterPerSquareSecond, cCubicMeterPerSquareSecond, cReciprocalMeter, cReciprocalMeter, -1, cMeter, cReciprocalSquareMeter, cReciprocalSquareMeter, -1, -1, -1, -1, cCoulombPerSquareMeter, -1, -1, -1, -1, -1, cAmpere, cAmperePerSquareMeter, -1, -1, -1, -1, -1, -1, -1, -1, cSquareMeter, cScalar, -1, cMeterPerSecond, -1, -1, -1, -1, -1, -1, cKilogramPerCubicMeter, cReciprocalCubicMeter, cReciprocalQuarticMeter, cSquareKilogramPerMeter, cNewtonPerSquareKilogram, -1, -1, -1, -1, -1, -1, -1, -1, -1, cSecondPerMeter, cSecond, cMeterSecond, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCoulombPerMeter, cVoltPerMeter, cNewtonPerSquareCoulomb, cVolt, -1, cSquareCoulombPerMeter, -1, cCoulombPerCubicMeter, -1, -1, cTeslaMeter, -1, cAmperePerMeter, cSquareAmpere, -1, cNewton, -1, -1, -1, -1, -1, -1, -1, -1, cWeber, -1, -1, cVoltMeter, -1, cKilogramPerSecond, cPascal, cNewtonPerCubicMeter, -1, -1, -1, cReciprocalSquareMeter, cSecondPerMeter, cSecond, cMeterSecond, cScalar, -1, -1),
    (cKatalPerCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cMolePerCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cKatal, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cReciprocalCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cHertz, -1, -1, -1, cMolePerCubicMeter, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cScalar, -1),
    (cCoulombPerMole, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cReciprocalMole, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cCoulomb, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, cScalar)
  );

const
  PowerTable : array[0..159] of
    record  Square, Cubic, Quartic, Quintic, Sextic: longint; end = (
    (Square: 0; Cubic: 0; Quartic: 0; Quintic: 0; Sextic: 0),
    (Square: 9; Cubic: 13; Quartic: 14; Quintic: 15; Sextic: 16),
    (Square: 14; Cubic: 16; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: 16; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: 26; Cubic: 31; Quartic: 37; Quintic: 38; Sextic: 39),
    (Square: 17; Cubic: -1; Quartic: 26; Quintic: -1; Sextic: 31),
    (Square: 37; Cubic: 39; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: 39; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: 47; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: 49; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: 53; Cubic: 54; Quartic: 55; Quintic: -1; Sextic: -1),
    (Square: 55; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: 61; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: 76; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: 249; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: 86; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: 88; Cubic: 90; Quartic: 91; Quintic: -1; Sextic: 92),
    (Square: 91; Cubic: 92; Quartic: 93; Quintic: -1; Sextic: -1),
    (Square: 92; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: 93; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: 256; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: 250; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: 194; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: 106; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: 106; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: 251; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: 251; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: 134; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: 140; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: 91; Cubic: 92; Quartic: 93; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: 61; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: 26; Cubic: 31; Quartic: 37; Quintic: 38; Sextic: 39),
    (Square: 37; Cubic: 39; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: 39; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: 251; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1)
  );

const
  RootTable : array[0..159] of
    record  Square, Cubic, Quartic, Quintic, Sextic: longint; end = (
    (Square: 0; Cubic: 0; Quartic: 0; Quintic: 0; Sextic: 0),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: 5; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: 5; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: 9; Cubic: -1; Quartic: 5; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: 5; Sextic: -1),
    (Square: 13; Cubic: 9; Quartic: -1; Quintic: -1; Sextic: 5),
    (Square: 25; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: 17; Cubic: -1; Quartic: 25; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: 17; Quartic: -1; Quintic: -1; Sextic: 25),
    (Square: 26; Cubic: -1; Quartic: 17; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: 17; Sextic: -1),
    (Square: 31; Cubic: 26; Quartic: -1; Quintic: -1; Sextic: 17),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: 40; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: 48; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: 50; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: 50; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: 53; Cubic: -1; Quartic: 50; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: 58; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: 58; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: 65; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: 84; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: 87; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: 87; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: 88; Cubic: -1; Quartic: 87; Quintic: -1; Sextic: -1),
    (Square: 90; Cubic: 88; Quartic: -1; Quintic: -1; Sextic: 87),
    (Square: 91; Cubic: -1; Quartic: 88; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: 102; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: 131; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: 137; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: 98; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: 87; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: 82; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: 97; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: 114; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: 95; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: 25; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: 17; Cubic: -1; Quartic: 25; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: 17; Quartic: -1; Quintic: -1; Sextic: 25),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1),
    (Square: -1; Cubic: -1; Quartic: -1; Quintic: -1; Sextic: -1)
  );

function GetSymbol(const ASymbol: string; const Prefixes: TPrefixes): string;
var
  PrefixCount: longint;
begin
  PrefixCount := Length(Prefixes);
  case PrefixCount of
    0:  result := ASymbol;
    1:  result := Format(ASymbol, [PrefixTable[Prefixes[0]].Symbol]);
    2:  result := Format(ASymbol, [PrefixTable[Prefixes[0]].Symbol, PrefixTable[Prefixes[1]].Symbol]);
    3:  result := Format(ASymbol, [PrefixTable[Prefixes[0]].Symbol, PrefixTable[Prefixes[1]].Symbol, PrefixTable[Prefixes[2]].Symbol]);
  else raise Exception.Create('Wrong number of prefixes.');
  end;
end;

function GetName(const AName: string; const Prefixes: TPrefixes): string;
var
  PrefixCount: longint;
begin
  PrefixCount := Length(Prefixes);
  case PrefixCount of
    0:  result := AName;
    1:  result := Format(AName, [PrefixTable[Prefixes[0]].Name]);
    2:  result := Format(AName, [PrefixTable[Prefixes[0]].Name, PrefixTable[Prefixes[1]].Name]);
    3:  result := Format(AName, [PrefixTable[Prefixes[0]].Name, PrefixTable[Prefixes[1]].Name, PrefixTable[Prefixes[2]].Name]);
  else raise Exception.Create('Wrong number of prefixes.');
  end;
end;

function GetValue(const AValue: double; const APrefixes, ABasePrefixes: TPrefixes; const ABaseExponents: TExponents): double;
var
  I: longint;
  Exponent: longint;
  PrefixCount: longint;
begin
  PrefixCount := Length(APrefixes);
  if PrefixCount = Length(ABasePrefixes) then
  begin
    Exponent := 0;
    for I := 0 to PrefixCount -1 do
      Inc(Exponent, PrefixTable[ABasePrefixes[I]].Exponent * ABaseExponents[I]);

    for I := 0 to PrefixCount -1 do
      Dec(Exponent, PrefixTable[APrefixes[I]].Exponent * ABaseExponents[I]);

    if Exponent <> 0 then
      result := AValue * IntPower(10, Exponent)
    else
      result := AValue;
  end else
    if PrefixCount = 0 then
      result := AValue
    else
      raise Exception.Create('Wrong number of prefixes.');
end;

{ TQuantity }

{$IFOPT D+}
class operator TQuantity.:=(const ASelf: double): TQuantity;
begin
  result.FUnitOfMeasurement := cScalar;
  result.FValue := ASelf;
end;

class operator TQuantity.:=(const ASelf: TQuantity): double;
begin
  if ASelf.FUnitOfMeasurement <> cScalar then
    raise Exception.Create('Assign operator (:=) has detected wrong unit of measurements.');
  result := ASelf.FValue;
end;

class operator TQuantity.+(const ASelf: TQuantity): TQuantity;
begin
  result.FUnitOfMeasurement := ASelf.FUnitOfMeasurement;
  result.FValue := ASelf.FValue;
end;

class operator TQuantity.-(const ASelf: TQuantity): TQuantity;
begin
  result.FUnitOfMeasurement := ASelf.FUnitOfMeasurement;
  result.FValue := -ASelf.FValue;
end;

class operator TQuantity.+(const ALeft, ARight: TQuantity): TQuantity;
begin
  if ALeft.FUnitOfMeasurement <> ARight.FUnitOfMeasurement then
    raise Exception.Create('Summing operator (+) has detected wrong unit of measurements.');
  result.FValue := ALeft.FValue + ARight.FValue;
end;

class operator TQuantity.-(const ALeft, ARight: TQuantity): TQuantity;
begin
  if ALeft.FUnitOfMeasurement <> ARight.FUnitOfMeasurement then
    raise Exception.Create('Subtracting operator (-) has detected wrong unit of measurements.');
  result.FValue := ALeft.FValue - ARight.FValue;
end;

class operator TQuantity.*(const ALeft, ARight: TQuantity): TQuantity;
begin
  result.FUnitOfMeasurement := MulTable[ALeft.FUnitOfMeasurement, ARight.FUnitOfMeasurement];
  result.FValue := ALeft.FValue * ARight.FValue;
end;

class operator TQuantity./(const ALeft, ARight: TQuantity): TQuantity;
begin
  result.FUnitOfMeasurement := DivTable[ALeft.FUnitOfMeasurement, ARight.FUnitOfMeasurement];
  result.FValue := ALeft.FValue / ARight.FValue;
end;

class operator TQuantity.*(const ALeft: double; const ARight: TQuantity): TQuantity;
begin
  result.FUnitOfMeasurement := ARight.FUnitOfMeasurement;
  result.FValue:= ALeft * ARight.FValue;
end;

class operator TQuantity./(const ALeft: double; const ARight: TQuantity): TQuantity;
begin
  result.FUnitOfMeasurement := DivTable[cScalar, ARight.FUnitOfMeasurement];
  result.FValue:= ALeft / ARight.FValue;
end;

class operator TQuantity.*(const ALeft: TQuantity; const ARight: double): TQuantity;
begin
  result.FUnitOfMeasurement := ALeft.FUnitOfMeasurement;
  result.FValue:= ALeft.FValue * ARight;
end;

class operator TQuantity./(const ALeft: TQuantity; const ARight: double): TQuantity;
begin
  result.FUnitOfMeasurement := ALeft.FUnitOfMeasurement;
  result.FValue:= ALeft.FValue / ARight;
end;

class operator TQuantity.=(const ALeft, ARight: TQuantity): boolean; inline;
begin
  if ALeft.FUnitOfMeasurement <> ARight.FUnitOfMeasurement then
    raise Exception.Create('Wrong units of measurements');
  result := ALeft.FValue = ARight.FValue;
end;

class operator TQuantity.<(const ALeft, ARight: TQuantity): boolean;
begin
  if ALeft.FUnitOfMeasurement <> ARight.FUnitOfMeasurement then
    raise Exception.Create('Wrong units of measurements');
  result := ALeft.FValue < ARight.FValue;
end;

class operator TQuantity.>(const ALeft, ARight: TQuantity): boolean;
begin
  if ALeft.FUnitOfMeasurement <> ARight.FUnitOfMeasurement then
    raise Exception.Create('Wrong units of measurements');
  result := ALeft.FValue > ARight.FValue;
end;

class operator TQuantity.<=(const ALeft, ARight: TQuantity): boolean;
begin
  if ALeft.FUnitOfMeasurement <> ARight.FUnitOfMeasurement then
    raise Exception.Create('Wrong units of measurements');
  result := ALeft.FValue <= ARight.FValue;
end;

class operator TQuantity.>=(const ALeft, ARight: TQuantity): boolean;
begin
  if ALeft.FUnitOfMeasurement <> ARight.FUnitOfMeasurement then
    raise Exception.Create('Wrong units of measurements');
  result := ALeft.FValue >= ARight.FValue;
end;

class operator TQuantity.<>(const ALeft, ARight: TQuantity): boolean;
begin
  if ALeft.FUnitOfMeasurement <> ARight.FUnitOfMeasurement then
    raise Exception.Create('Wrong units of measurements');
  result := ALeft.FValue <> ARight.FValue;
end;
{$ENDIF}

{ TUnit }

class operator TUnit<U>.*(const AValue: double; const ASelf: TUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, U.FUnitOfMeasurement];
{$ENDIF}
  result := AValue;
end;

class operator TUnit<U>./(const AValue: double; const ASelf: TUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, U.FUnitOfMeasurement];
{$ENDIF}
  result := AValue;
end;

{$IFOPT D+}
class operator TUnit<U>.*(const AValue: TQuantity; const ASelf: TUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, U.FUnitOfMeasurement];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

{$IFOPT D+}
class operator TUnit<U>./(const AValue: TQuantity; const ASelf: TUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, U.FUnitOfMeasurement];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

{ TFactoredUnit }

class operator TFactoredUnit<U>.*(const AValue: double; const ASelf: TFactoredUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, U.FUnitOfMeasurement];
{$ENDIF}
  result.FValue := AValue * U.FFactor;
end;

class operator TFactoredUnit<U>./(const AValue: double; const ASelf: TFactoredUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, U.FUnitOfMeasurement];
{$ENDIF}
  result := AValue * U.FFactor;
end;

{$IFOPT D+}
class operator TFactoredUnit<U>.*(const AValue: TQuantity; const ASelf: TFactoredUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, U.FUnitOfMeasurement];
  result.FValue := AValue.FValue * U.FFactor;
end;
{$ENDIF}

{$IFOPT D+}
class operator TFactoredUnit<U>./(const AValue: TQuantity; const ASelf: TFactoredUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, U.FUnitOfMeasurement];
  result.FValue := AValue.FValue * U.FFactor;
end;
{$ENDIF}

function ScalarToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cScalar then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsScalarSymbol, cScalarPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsScalarSymbol, cScalarPrefixes);
{$ENDIF}
end;

function ScalarToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cScalar then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cScalarPrefixes, cScalarExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cScalarPrefixes, cScalarExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsScalarSymbol, cScalarPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsScalarSymbol, APrefixes);
end;

function ScalarToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := ScalarToFloat(AQuantity, APrefixes);
  FactoredTol   := ScalarToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsScalarSymbol, cScalarPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsScalarSymbol, APrefixes);
  end;
end;

function ScalarToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cScalar then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsScalarName, cScalarPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsScalarPluralName, cScalarPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsScalarName, cScalarPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsScalarPluralName, cScalarPrefixes);
{$ENDIF}
end;

function ScalarToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cScalar then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsScalarName, cScalarPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsScalarPluralName, cScalarPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsScalarName, cScalarPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsScalarPluralName, cScalarPrefixes);
{$ENDIF}
end;

function ScalarToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := ScalarToFloat(AQuantity, APrefixes);
  FactoredTol   := ScalarToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsScalarSymbol, cScalarPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsScalarSymbol, APrefixes);
  end;
end;

function ScalarToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cScalar then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function ScalarToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cScalar then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cScalarPrefixes, cScalarExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cScalarPrefixes, cScalarExponents);
{$ENDIF}
end;

function RadianToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cScalar then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsRadianSymbol, cRadianPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsRadianSymbol, cRadianPrefixes);
{$ENDIF}
end;

function RadianToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cScalar then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cRadianPrefixes, cRadianExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cRadianPrefixes, cRadianExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsRadianSymbol, cRadianPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsRadianSymbol, APrefixes);
end;

function RadianToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := RadianToFloat(AQuantity, APrefixes);
  FactoredTol   := RadianToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsRadianSymbol, cRadianPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsRadianSymbol, APrefixes);
  end;
end;

function RadianToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cScalar then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cRadianFactor) + ' ' + GetName(rsRadianName, cRadianPrefixes)
  else
    result := FloatToStr(AValue.FValue / cRadianFactor) + ' ' + GetName(rsRadianPluralName, cRadianPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cRadianFactor) + ' ' + GetName(rsRadianName, cRadianPrefixes)
  else
    result := FloatToStr(AValue / cRadianFactor) + ' ' + GetName(rsRadianPluralName, cRadianPrefixes);
  result := '';
{$ENDIF}
end;

function RadianToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cScalar then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cRadianFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsRadianName, cRadianPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cRadianFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsRadianPluralName, cRadianPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cRadianFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsRadianName, cRadianPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cRadianFactor, rsRadianPluralName);
{$ENDIF}
end;

function RadianToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cScalar then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function RadianToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cScalar then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cRadianPrefixes, cRadianExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cRadianPrefixes, cRadianExponents);
{$ENDIF}
end;

function DegreeToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cScalar then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue / cDegreeFactor) + ' ' + GetSymbol(rsDegreeSymbol, cDegreePrefixes);
{$ENDIF}
  result := FloatToStr(AValue / cDegreeFactor) + ' ' + GetSymbol(rsDegreeSymbol, cDegreePrefixes);
end;

function DegreeToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cScalar then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue / cDegreeFactor, APrefixes, cDegreePrefixes, cDegreeExponents);
{$ELSE}
  FactoredValue := GetValue(AValue / cDegreeFactor, APrefixes, cDegreePrefixes, cDegreeExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsDegreeSymbol, cDegreePrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsDegreeSymbol, APrefixes);
end;

function cDegreeToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := DegreeToFloat(AQuantity / cDegreeFactor, APrefixes);
  FactoredTol   := DegreeToFloat(ATolerance / cDegreeFactor, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsDegreeSymbol, cDegreePrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsDegreeSymbol, APrefixes);
  end;
end;

function DegreeToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cScalar then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cDegreeFactor) + ' ' + GetName(rsDegreeName, cDegreePrefixes)
  else
    result := FloatToStr(AValue.FValue / cDegreeFactor) + ' ' + GetName(rsDegreePluralName, cDegreePrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cDegreeFactor) + ' ' + GetName(rsDegreeName, cDegreePrefixes)
  else
    result := FloatToStr(AValue / cDegreeFactor) + ' ' + GetName(rsDegreePluralName, cDegreePrefixes);
  result := '';
{$ENDIF}
end;

function DegreeToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cScalar then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cDegreeFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsDegreeName, cDegreePrefixes)
  else
    result := FloatToStrF(AValue.FValue / cDegreeFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsDegreePluralName, cDegreePrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cDegreeFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsDegreeName, cDegreePrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cDegreeFactor, rsDegreePluralName);
{$ENDIF}
end;

function DegreeToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cScalar then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue * cDegreeFactor;
{$ELSE}
  result := AValue * cDegreeFactor;
{$ENDIF}
end;

function DegreeToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cScalar then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue * cDegreeFactor, APrefixes, cDegreePrefixes, cDegreeExponents);
{$ELSE}
  result := GetValue(AValue * cDegreeFactor, APrefixes, cDegreePrefixes, cDegreeExponents);
{$ENDIF}
end;

function SteradianToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cScalar then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsSteradianSymbol, cSteradianPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsSteradianSymbol, cSteradianPrefixes);
{$ENDIF}
end;

function SteradianToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cScalar then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSteradianPrefixes, cSteradianExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSteradianPrefixes, cSteradianExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSteradianSymbol, cSteradianPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSteradianSymbol, APrefixes);
end;

function SteradianToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SteradianToFloat(AQuantity, APrefixes);
  FactoredTol   := SteradianToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSteradianSymbol, cSteradianPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsSteradianSymbol, APrefixes);
  end;
end;

function SteradianToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cScalar then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cSteradianFactor) + ' ' + GetName(rsSteradianName, cSteradianPrefixes)
  else
    result := FloatToStr(AValue.FValue / cSteradianFactor) + ' ' + GetName(rsSteradianPluralName, cSteradianPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cSteradianFactor) + ' ' + GetName(rsSteradianName, cSteradianPrefixes)
  else
    result := FloatToStr(AValue / cSteradianFactor) + ' ' + GetName(rsSteradianPluralName, cSteradianPrefixes);
  result := '';
{$ENDIF}
end;

function SteradianToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cScalar then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cSteradianFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSteradianName, cSteradianPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cSteradianFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSteradianPluralName, cSteradianPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cSteradianFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSteradianName, cSteradianPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cSteradianFactor, rsSteradianPluralName);
{$ENDIF}
end;

function SteradianToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cScalar then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function SteradianToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cScalar then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cSteradianPrefixes, cSteradianExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cSteradianPrefixes, cSteradianExponents);
{$ENDIF}
end;

function SquareDegreeToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cScalar then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue / cSquareDegreeFactor) + ' ' + GetSymbol(rsSquareDegreeSymbol, cSquareDegreePrefixes);
{$ENDIF}
  result := FloatToStr(AValue / cSquareDegreeFactor) + ' ' + GetSymbol(rsSquareDegreeSymbol, cSquareDegreePrefixes);
end;

function SquareDegreeToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cScalar then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue / cSquareDegreeFactor, APrefixes, cSquareDegreePrefixes, cSquareDegreeExponents);
{$ELSE}
  FactoredValue := GetValue(AValue / cSquareDegreeFactor, APrefixes, cSquareDegreePrefixes, cSquareDegreeExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareDegreeSymbol, cSquareDegreePrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareDegreeSymbol, APrefixes);
end;

function cSquareDegreeToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SquareDegreeToFloat(AQuantity / cSquareDegreeFactor, APrefixes);
  FactoredTol   := SquareDegreeToFloat(ATolerance / cSquareDegreeFactor, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareDegreeSymbol, cSquareDegreePrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsSquareDegreeSymbol, APrefixes);
  end;
end;

function SquareDegreeToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cScalar then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cSquareDegreeFactor) + ' ' + GetName(rsSquareDegreeName, cSquareDegreePrefixes)
  else
    result := FloatToStr(AValue.FValue / cSquareDegreeFactor) + ' ' + GetName(rsSquareDegreePluralName, cSquareDegreePrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cSquareDegreeFactor) + ' ' + GetName(rsSquareDegreeName, cSquareDegreePrefixes)
  else
    result := FloatToStr(AValue / cSquareDegreeFactor) + ' ' + GetName(rsSquareDegreePluralName, cSquareDegreePrefixes);
  result := '';
{$ENDIF}
end;

function SquareDegreeToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cScalar then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cSquareDegreeFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareDegreeName, cSquareDegreePrefixes)
  else
    result := FloatToStrF(AValue.FValue / cSquareDegreeFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareDegreePluralName, cSquareDegreePrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cSquareDegreeFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareDegreeName, cSquareDegreePrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cSquareDegreeFactor, rsSquareDegreePluralName);
{$ENDIF}
end;

function SquareDegreeToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cScalar then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue * cSquareDegreeFactor;
{$ELSE}
  result := AValue * cSquareDegreeFactor;
{$ENDIF}
end;

function SquareDegreeToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cScalar then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue * cSquareDegreeFactor, APrefixes, cSquareDegreePrefixes, cSquareDegreeExponents);
{$ELSE}
  result := GetValue(AValue * cSquareDegreeFactor, APrefixes, cSquareDegreePrefixes, cSquareDegreeExponents);
{$ENDIF}
end;

function SecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSecond then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsSecondSymbol, cSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsSecondSymbol, cSecondPrefixes);
{$ENDIF}
end;

function SecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSecond then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSecondPrefixes, cSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSecondPrefixes, cSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSecondSymbol, cSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSecondSymbol, APrefixes);
end;

function SecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SecondToFloat(AQuantity, APrefixes);
  FactoredTol   := SecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSecondSymbol, cSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsSecondSymbol, APrefixes);
  end;
end;

function SecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSecond then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsSecondName, cSecondPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsSecondPluralName, cSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsSecondName, cSecondPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsSecondPluralName, cSecondPrefixes);
{$ENDIF}
end;

function SecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSecond then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSecondName, cSecondPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSecondPluralName, cSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSecondName, cSecondPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSecondPluralName, cSecondPrefixes);
{$ENDIF}
end;

function SecondToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SecondToFloat(AQuantity, APrefixes);
  FactoredTol   := SecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSecondSymbol, cSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsSecondSymbol, APrefixes);
  end;
end;

function SecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSecond then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function SecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSecond then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cSecondPrefixes, cSecondExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cSecondPrefixes, cSecondExponents);
{$ENDIF}
end;

function DayToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSecond then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue / cDayFactor) + ' ' + GetSymbol(rsDaySymbol, cDayPrefixes);
{$ENDIF}
  result := FloatToStr(AValue / cDayFactor) + ' ' + GetSymbol(rsDaySymbol, cDayPrefixes);
end;

function DayToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSecond then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue / cDayFactor, APrefixes, cDayPrefixes, cDayExponents);
{$ELSE}
  FactoredValue := GetValue(AValue / cDayFactor, APrefixes, cDayPrefixes, cDayExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsDaySymbol, cDayPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsDaySymbol, APrefixes);
end;

function cDayToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := DayToFloat(AQuantity / cDayFactor, APrefixes);
  FactoredTol   := DayToFloat(ATolerance / cDayFactor, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsDaySymbol, cDayPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsDaySymbol, APrefixes);
  end;
end;

function DayToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSecond then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cDayFactor) + ' ' + GetName(rsDayName, cDayPrefixes)
  else
    result := FloatToStr(AValue.FValue / cDayFactor) + ' ' + GetName(rsDayPluralName, cDayPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cDayFactor) + ' ' + GetName(rsDayName, cDayPrefixes)
  else
    result := FloatToStr(AValue / cDayFactor) + ' ' + GetName(rsDayPluralName, cDayPrefixes);
  result := '';
{$ENDIF}
end;

function DayToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSecond then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cDayFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsDayName, cDayPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cDayFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsDayPluralName, cDayPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cDayFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsDayName, cDayPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cDayFactor, rsDayPluralName);
{$ENDIF}
end;

function DayToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSecond then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue * cDayFactor;
{$ELSE}
  result := AValue * cDayFactor;
{$ENDIF}
end;

function DayToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSecond then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue * cDayFactor, APrefixes, cDayPrefixes, cDayExponents);
{$ELSE}
  result := GetValue(AValue * cDayFactor, APrefixes, cDayPrefixes, cDayExponents);
{$ENDIF}
end;

function HourToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSecond then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue / cHourFactor) + ' ' + GetSymbol(rsHourSymbol, cHourPrefixes);
{$ENDIF}
  result := FloatToStr(AValue / cHourFactor) + ' ' + GetSymbol(rsHourSymbol, cHourPrefixes);
end;

function HourToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSecond then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue / cHourFactor, APrefixes, cHourPrefixes, cHourExponents);
{$ELSE}
  FactoredValue := GetValue(AValue / cHourFactor, APrefixes, cHourPrefixes, cHourExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsHourSymbol, cHourPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsHourSymbol, APrefixes);
end;

function cHourToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := HourToFloat(AQuantity / cHourFactor, APrefixes);
  FactoredTol   := HourToFloat(ATolerance / cHourFactor, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsHourSymbol, cHourPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsHourSymbol, APrefixes);
  end;
end;

function HourToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSecond then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cHourFactor) + ' ' + GetName(rsHourName, cHourPrefixes)
  else
    result := FloatToStr(AValue.FValue / cHourFactor) + ' ' + GetName(rsHourPluralName, cHourPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cHourFactor) + ' ' + GetName(rsHourName, cHourPrefixes)
  else
    result := FloatToStr(AValue / cHourFactor) + ' ' + GetName(rsHourPluralName, cHourPrefixes);
  result := '';
{$ENDIF}
end;

function HourToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSecond then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cHourFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsHourName, cHourPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cHourFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsHourPluralName, cHourPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cHourFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsHourName, cHourPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cHourFactor, rsHourPluralName);
{$ENDIF}
end;

function HourToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSecond then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue * cHourFactor;
{$ELSE}
  result := AValue * cHourFactor;
{$ENDIF}
end;

function HourToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSecond then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue * cHourFactor, APrefixes, cHourPrefixes, cHourExponents);
{$ELSE}
  result := GetValue(AValue * cHourFactor, APrefixes, cHourPrefixes, cHourExponents);
{$ENDIF}
end;

function MinuteToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSecond then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue / cMinuteFactor) + ' ' + GetSymbol(rsMinuteSymbol, cMinutePrefixes);
{$ENDIF}
  result := FloatToStr(AValue / cMinuteFactor) + ' ' + GetSymbol(rsMinuteSymbol, cMinutePrefixes);
end;

function MinuteToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSecond then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue / cMinuteFactor, APrefixes, cMinutePrefixes, cMinuteExponents);
{$ELSE}
  FactoredValue := GetValue(AValue / cMinuteFactor, APrefixes, cMinutePrefixes, cMinuteExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMinuteSymbol, cMinutePrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMinuteSymbol, APrefixes);
end;

function cMinuteToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := MinuteToFloat(AQuantity / cMinuteFactor, APrefixes);
  FactoredTol   := MinuteToFloat(ATolerance / cMinuteFactor, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMinuteSymbol, cMinutePrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsMinuteSymbol, APrefixes);
  end;
end;

function MinuteToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSecond then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cMinuteFactor) + ' ' + GetName(rsMinuteName, cMinutePrefixes)
  else
    result := FloatToStr(AValue.FValue / cMinuteFactor) + ' ' + GetName(rsMinutePluralName, cMinutePrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cMinuteFactor) + ' ' + GetName(rsMinuteName, cMinutePrefixes)
  else
    result := FloatToStr(AValue / cMinuteFactor) + ' ' + GetName(rsMinutePluralName, cMinutePrefixes);
  result := '';
{$ENDIF}
end;

function MinuteToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSecond then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cMinuteFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMinuteName, cMinutePrefixes)
  else
    result := FloatToStrF(AValue.FValue / cMinuteFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMinutePluralName, cMinutePrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cMinuteFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMinuteName, cMinutePrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cMinuteFactor, rsMinutePluralName);
{$ENDIF}
end;

function MinuteToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSecond then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue * cMinuteFactor;
{$ELSE}
  result := AValue * cMinuteFactor;
{$ENDIF}
end;

function MinuteToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSecond then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue * cMinuteFactor, APrefixes, cMinutePrefixes, cMinuteExponents);
{$ELSE}
  result := GetValue(AValue * cMinuteFactor, APrefixes, cMinutePrefixes, cMinuteExponents);
{$ENDIF}
end;

function SquareSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsSquareSecondSymbol, cSquareSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsSquareSecondSymbol, cSquareSecondPrefixes);
{$ENDIF}
end;

function SquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSquareSecondPrefixes, cSquareSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSquareSecondPrefixes, cSquareSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareSecondSymbol, cSquareSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareSecondSymbol, APrefixes);
end;

function SquareSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SquareSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := SquareSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareSecondSymbol, cSquareSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsSquareSecondSymbol, APrefixes);
  end;
end;

function SquareSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareSecond then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsSquareSecondName, cSquareSecondPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsSquareSecondPluralName, cSquareSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsSquareSecondName, cSquareSecondPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsSquareSecondPluralName, cSquareSecondPrefixes);
{$ENDIF}
end;

function SquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareSecond then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareSecondName, cSquareSecondPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareSecondPluralName, cSquareSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareSecondName, cSquareSecondPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareSecondPluralName, cSquareSecondPrefixes);
{$ENDIF}
end;

function SquareSecondToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SquareSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := SquareSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareSecondSymbol, cSquareSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsSquareSecondSymbol, APrefixes);
  end;
end;

function SquareSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function SquareSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cSquareSecondPrefixes, cSquareSecondExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cSquareSecondPrefixes, cSquareSecondExponents);
{$ENDIF}
end;

function SquareDayToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue / cSquareDayFactor) + ' ' + GetSymbol(rsSquareDaySymbol, cSquareDayPrefixes);
{$ENDIF}
  result := FloatToStr(AValue / cSquareDayFactor) + ' ' + GetSymbol(rsSquareDaySymbol, cSquareDayPrefixes);
end;

function SquareDayToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue / cSquareDayFactor, APrefixes, cSquareDayPrefixes, cSquareDayExponents);
{$ELSE}
  FactoredValue := GetValue(AValue / cSquareDayFactor, APrefixes, cSquareDayPrefixes, cSquareDayExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareDaySymbol, cSquareDayPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareDaySymbol, APrefixes);
end;

function cSquareDayToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SquareDayToFloat(AQuantity / cSquareDayFactor, APrefixes);
  FactoredTol   := SquareDayToFloat(ATolerance / cSquareDayFactor, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareDaySymbol, cSquareDayPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsSquareDaySymbol, APrefixes);
  end;
end;

function SquareDayToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cSquareDayFactor) + ' ' + GetName(rsSquareDayName, cSquareDayPrefixes)
  else
    result := FloatToStr(AValue.FValue / cSquareDayFactor) + ' ' + GetName(rsSquareDayPluralName, cSquareDayPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cSquareDayFactor) + ' ' + GetName(rsSquareDayName, cSquareDayPrefixes)
  else
    result := FloatToStr(AValue / cSquareDayFactor) + ' ' + GetName(rsSquareDayPluralName, cSquareDayPrefixes);
  result := '';
{$ENDIF}
end;

function SquareDayToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cSquareDayFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareDayName, cSquareDayPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cSquareDayFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareDayPluralName, cSquareDayPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cSquareDayFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareDayName, cSquareDayPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cSquareDayFactor, rsSquareDayPluralName);
{$ENDIF}
end;

function SquareDayToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue * cSquareDayFactor;
{$ELSE}
  result := AValue * cSquareDayFactor;
{$ENDIF}
end;

function SquareDayToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue * cSquareDayFactor, APrefixes, cSquareDayPrefixes, cSquareDayExponents);
{$ELSE}
  result := GetValue(AValue * cSquareDayFactor, APrefixes, cSquareDayPrefixes, cSquareDayExponents);
{$ENDIF}
end;

function SquareHourToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue / cSquareHourFactor) + ' ' + GetSymbol(rsSquareHourSymbol, cSquareHourPrefixes);
{$ENDIF}
  result := FloatToStr(AValue / cSquareHourFactor) + ' ' + GetSymbol(rsSquareHourSymbol, cSquareHourPrefixes);
end;

function SquareHourToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue / cSquareHourFactor, APrefixes, cSquareHourPrefixes, cSquareHourExponents);
{$ELSE}
  FactoredValue := GetValue(AValue / cSquareHourFactor, APrefixes, cSquareHourPrefixes, cSquareHourExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareHourSymbol, cSquareHourPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareHourSymbol, APrefixes);
end;

function cSquareHourToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SquareHourToFloat(AQuantity / cSquareHourFactor, APrefixes);
  FactoredTol   := SquareHourToFloat(ATolerance / cSquareHourFactor, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareHourSymbol, cSquareHourPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsSquareHourSymbol, APrefixes);
  end;
end;

function SquareHourToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cSquareHourFactor) + ' ' + GetName(rsSquareHourName, cSquareHourPrefixes)
  else
    result := FloatToStr(AValue.FValue / cSquareHourFactor) + ' ' + GetName(rsSquareHourPluralName, cSquareHourPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cSquareHourFactor) + ' ' + GetName(rsSquareHourName, cSquareHourPrefixes)
  else
    result := FloatToStr(AValue / cSquareHourFactor) + ' ' + GetName(rsSquareHourPluralName, cSquareHourPrefixes);
  result := '';
{$ENDIF}
end;

function SquareHourToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cSquareHourFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareHourName, cSquareHourPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cSquareHourFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareHourPluralName, cSquareHourPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cSquareHourFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareHourName, cSquareHourPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cSquareHourFactor, rsSquareHourPluralName);
{$ENDIF}
end;

function SquareHourToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue * cSquareHourFactor;
{$ELSE}
  result := AValue * cSquareHourFactor;
{$ENDIF}
end;

function SquareHourToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue * cSquareHourFactor, APrefixes, cSquareHourPrefixes, cSquareHourExponents);
{$ELSE}
  result := GetValue(AValue * cSquareHourFactor, APrefixes, cSquareHourPrefixes, cSquareHourExponents);
{$ENDIF}
end;

function SquareMinuteToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue / cSquareMinuteFactor) + ' ' + GetSymbol(rsSquareMinuteSymbol, cSquareMinutePrefixes);
{$ENDIF}
  result := FloatToStr(AValue / cSquareMinuteFactor) + ' ' + GetSymbol(rsSquareMinuteSymbol, cSquareMinutePrefixes);
end;

function SquareMinuteToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue / cSquareMinuteFactor, APrefixes, cSquareMinutePrefixes, cSquareMinuteExponents);
{$ELSE}
  FactoredValue := GetValue(AValue / cSquareMinuteFactor, APrefixes, cSquareMinutePrefixes, cSquareMinuteExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareMinuteSymbol, cSquareMinutePrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareMinuteSymbol, APrefixes);
end;

function cSquareMinuteToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SquareMinuteToFloat(AQuantity / cSquareMinuteFactor, APrefixes);
  FactoredTol   := SquareMinuteToFloat(ATolerance / cSquareMinuteFactor, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareMinuteSymbol, cSquareMinutePrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsSquareMinuteSymbol, APrefixes);
  end;
end;

function SquareMinuteToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cSquareMinuteFactor) + ' ' + GetName(rsSquareMinuteName, cSquareMinutePrefixes)
  else
    result := FloatToStr(AValue.FValue / cSquareMinuteFactor) + ' ' + GetName(rsSquareMinutePluralName, cSquareMinutePrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cSquareMinuteFactor) + ' ' + GetName(rsSquareMinuteName, cSquareMinutePrefixes)
  else
    result := FloatToStr(AValue / cSquareMinuteFactor) + ' ' + GetName(rsSquareMinutePluralName, cSquareMinutePrefixes);
  result := '';
{$ENDIF}
end;

function SquareMinuteToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cSquareMinuteFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareMinuteName, cSquareMinutePrefixes)
  else
    result := FloatToStrF(AValue.FValue / cSquareMinuteFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareMinutePluralName, cSquareMinutePrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cSquareMinuteFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareMinuteName, cSquareMinutePrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cSquareMinuteFactor, rsSquareMinutePluralName);
{$ENDIF}
end;

function SquareMinuteToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue * cSquareMinuteFactor;
{$ELSE}
  result := AValue * cSquareMinuteFactor;
{$ENDIF}
end;

function SquareMinuteToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue * cSquareMinuteFactor, APrefixes, cSquareMinutePrefixes, cSquareMinuteExponents);
{$ELSE}
  result := GetValue(AValue * cSquareMinuteFactor, APrefixes, cSquareMinutePrefixes, cSquareMinuteExponents);
{$ENDIF}
end;

function CubicSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicSecond then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsCubicSecondSymbol, cCubicSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsCubicSecondSymbol, cCubicSecondPrefixes);
{$ENDIF}
end;

function CubicSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicSecond then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cCubicSecondPrefixes, cCubicSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cCubicSecondPrefixes, cCubicSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCubicSecondSymbol, cCubicSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCubicSecondSymbol, APrefixes);
end;

function CubicSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := CubicSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := CubicSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCubicSecondSymbol, cCubicSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsCubicSecondSymbol, APrefixes);
  end;
end;

function CubicSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicSecond then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsCubicSecondName, cCubicSecondPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsCubicSecondPluralName, cCubicSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsCubicSecondName, cCubicSecondPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsCubicSecondPluralName, cCubicSecondPrefixes);
{$ENDIF}
end;

function CubicSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicSecond then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCubicSecondName, cCubicSecondPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCubicSecondPluralName, cCubicSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCubicSecondName, cCubicSecondPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCubicSecondPluralName, cCubicSecondPrefixes);
{$ENDIF}
end;

function CubicSecondToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := CubicSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := CubicSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCubicSecondSymbol, cCubicSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsCubicSecondSymbol, APrefixes);
  end;
end;

function CubicSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicSecond then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function CubicSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicSecond then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cCubicSecondPrefixes, cCubicSecondExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cCubicSecondPrefixes, cCubicSecondExponents);
{$ENDIF}
end;

function QuarticSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cQuarticSecond then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsQuarticSecondSymbol, cQuarticSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsQuarticSecondSymbol, cQuarticSecondPrefixes);
{$ENDIF}
end;

function QuarticSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cQuarticSecond then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cQuarticSecondPrefixes, cQuarticSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cQuarticSecondPrefixes, cQuarticSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsQuarticSecondSymbol, cQuarticSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsQuarticSecondSymbol, APrefixes);
end;

function QuarticSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := QuarticSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := QuarticSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsQuarticSecondSymbol, cQuarticSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsQuarticSecondSymbol, APrefixes);
  end;
end;

function QuarticSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cQuarticSecond then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsQuarticSecondName, cQuarticSecondPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsQuarticSecondPluralName, cQuarticSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsQuarticSecondName, cQuarticSecondPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsQuarticSecondPluralName, cQuarticSecondPrefixes);
{$ENDIF}
end;

function QuarticSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cQuarticSecond then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsQuarticSecondName, cQuarticSecondPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsQuarticSecondPluralName, cQuarticSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsQuarticSecondName, cQuarticSecondPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsQuarticSecondPluralName, cQuarticSecondPrefixes);
{$ENDIF}
end;

function QuarticSecondToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := QuarticSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := QuarticSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsQuarticSecondSymbol, cQuarticSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsQuarticSecondSymbol, APrefixes);
  end;
end;

function QuarticSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cQuarticSecond then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function QuarticSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cQuarticSecond then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cQuarticSecondPrefixes, cQuarticSecondExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cQuarticSecondPrefixes, cQuarticSecondExponents);
{$ENDIF}
end;

function QuinticSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cQuinticSecond then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsQuinticSecondSymbol, cQuinticSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsQuinticSecondSymbol, cQuinticSecondPrefixes);
{$ENDIF}
end;

function QuinticSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cQuinticSecond then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cQuinticSecondPrefixes, cQuinticSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cQuinticSecondPrefixes, cQuinticSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsQuinticSecondSymbol, cQuinticSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsQuinticSecondSymbol, APrefixes);
end;

function QuinticSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := QuinticSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := QuinticSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsQuinticSecondSymbol, cQuinticSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsQuinticSecondSymbol, APrefixes);
  end;
end;

function QuinticSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cQuinticSecond then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsQuinticSecondName, cQuinticSecondPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsQuinticSecondPluralName, cQuinticSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsQuinticSecondName, cQuinticSecondPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsQuinticSecondPluralName, cQuinticSecondPrefixes);
{$ENDIF}
end;

function QuinticSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cQuinticSecond then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsQuinticSecondName, cQuinticSecondPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsQuinticSecondPluralName, cQuinticSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsQuinticSecondName, cQuinticSecondPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsQuinticSecondPluralName, cQuinticSecondPrefixes);
{$ENDIF}
end;

function QuinticSecondToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := QuinticSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := QuinticSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsQuinticSecondSymbol, cQuinticSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsQuinticSecondSymbol, APrefixes);
  end;
end;

function QuinticSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cQuinticSecond then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function QuinticSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cQuinticSecond then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cQuinticSecondPrefixes, cQuinticSecondExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cQuinticSecondPrefixes, cQuinticSecondExponents);
{$ENDIF}
end;

function SexticSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSexticSecond then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsSexticSecondSymbol, cSexticSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsSexticSecondSymbol, cSexticSecondPrefixes);
{$ENDIF}
end;

function SexticSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSexticSecond then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSexticSecondPrefixes, cSexticSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSexticSecondPrefixes, cSexticSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSexticSecondSymbol, cSexticSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSexticSecondSymbol, APrefixes);
end;

function SexticSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SexticSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := SexticSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSexticSecondSymbol, cSexticSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsSexticSecondSymbol, APrefixes);
  end;
end;

function SexticSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSexticSecond then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsSexticSecondName, cSexticSecondPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsSexticSecondPluralName, cSexticSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsSexticSecondName, cSexticSecondPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsSexticSecondPluralName, cSexticSecondPrefixes);
{$ENDIF}
end;

function SexticSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSexticSecond then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSexticSecondName, cSexticSecondPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSexticSecondPluralName, cSexticSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSexticSecondName, cSexticSecondPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSexticSecondPluralName, cSexticSecondPrefixes);
{$ENDIF}
end;

function SexticSecondToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SexticSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := SexticSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSexticSecondSymbol, cSexticSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsSexticSecondSymbol, APrefixes);
  end;
end;

function SexticSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSexticSecond then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function SexticSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSexticSecond then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cSexticSecondPrefixes, cSexticSecondExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cSexticSecondPrefixes, cSexticSecondExponents);
{$ENDIF}
end;

function MeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsMeterSymbol, cMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsMeterSymbol, cMeterPrefixes);
{$ENDIF}
end;

function MeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cMeterPrefixes, cMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cMeterPrefixes, cMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterSymbol, cMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterSymbol, APrefixes);
end;

function MeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := MeterToFloat(AQuantity, APrefixes);
  FactoredTol   := MeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterSymbol, cMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsMeterSymbol, APrefixes);
  end;
end;

function MeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsMeterName, cMeterPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsMeterPluralName, cMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsMeterName, cMeterPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsMeterPluralName, cMeterPrefixes);
{$ENDIF}
end;

function MeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMeterName, cMeterPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMeterPluralName, cMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMeterName, cMeterPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMeterPluralName, cMeterPrefixes);
{$ENDIF}
end;

function MeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := MeterToFloat(AQuantity, APrefixes);
  FactoredTol   := MeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMeterSymbol, cMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsMeterSymbol, APrefixes);
  end;
end;

function MeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function MeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cMeterPrefixes, cMeterExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cMeterPrefixes, cMeterExponents);
{$ENDIF}
end;

function AstronomicalToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue / cAstronomicalFactor) + ' ' + GetSymbol(rsAstronomicalSymbol, cAstronomicalPrefixes);
{$ENDIF}
  result := FloatToStr(AValue / cAstronomicalFactor) + ' ' + GetSymbol(rsAstronomicalSymbol, cAstronomicalPrefixes);
end;

function AstronomicalToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue / cAstronomicalFactor, APrefixes, cAstronomicalPrefixes, cAstronomicalExponents);
{$ELSE}
  FactoredValue := GetValue(AValue / cAstronomicalFactor, APrefixes, cAstronomicalPrefixes, cAstronomicalExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsAstronomicalSymbol, cAstronomicalPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsAstronomicalSymbol, APrefixes);
end;

function cAstronomicalToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := AstronomicalToFloat(AQuantity / cAstronomicalFactor, APrefixes);
  FactoredTol   := AstronomicalToFloat(ATolerance / cAstronomicalFactor, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsAstronomicalSymbol, cAstronomicalPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsAstronomicalSymbol, APrefixes);
  end;
end;

function AstronomicalToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cAstronomicalFactor) + ' ' + GetName(rsAstronomicalName, cAstronomicalPrefixes)
  else
    result := FloatToStr(AValue.FValue / cAstronomicalFactor) + ' ' + GetName(rsAstronomicalPluralName, cAstronomicalPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cAstronomicalFactor) + ' ' + GetName(rsAstronomicalName, cAstronomicalPrefixes)
  else
    result := FloatToStr(AValue / cAstronomicalFactor) + ' ' + GetName(rsAstronomicalPluralName, cAstronomicalPrefixes);
  result := '';
{$ENDIF}
end;

function AstronomicalToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cAstronomicalFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsAstronomicalName, cAstronomicalPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cAstronomicalFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsAstronomicalPluralName, cAstronomicalPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cAstronomicalFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsAstronomicalName, cAstronomicalPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cAstronomicalFactor, rsAstronomicalPluralName);
{$ENDIF}
end;

function AstronomicalToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue * cAstronomicalFactor;
{$ELSE}
  result := AValue * cAstronomicalFactor;
{$ENDIF}
end;

function AstronomicalToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue * cAstronomicalFactor, APrefixes, cAstronomicalPrefixes, cAstronomicalExponents);
{$ELSE}
  result := GetValue(AValue * cAstronomicalFactor, APrefixes, cAstronomicalPrefixes, cAstronomicalExponents);
{$ENDIF}
end;

function InchToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue / cInchFactor) + ' ' + GetSymbol(rsInchSymbol, cInchPrefixes);
{$ENDIF}
  result := FloatToStr(AValue / cInchFactor) + ' ' + GetSymbol(rsInchSymbol, cInchPrefixes);
end;

function InchToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue / cInchFactor, APrefixes, cInchPrefixes, cInchExponents);
{$ELSE}
  FactoredValue := GetValue(AValue / cInchFactor, APrefixes, cInchPrefixes, cInchExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsInchSymbol, cInchPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsInchSymbol, APrefixes);
end;

function cInchToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := InchToFloat(AQuantity / cInchFactor, APrefixes);
  FactoredTol   := InchToFloat(ATolerance / cInchFactor, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsInchSymbol, cInchPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsInchSymbol, APrefixes);
  end;
end;

function InchToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cInchFactor) + ' ' + GetName(rsInchName, cInchPrefixes)
  else
    result := FloatToStr(AValue.FValue / cInchFactor) + ' ' + GetName(rsInchPluralName, cInchPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cInchFactor) + ' ' + GetName(rsInchName, cInchPrefixes)
  else
    result := FloatToStr(AValue / cInchFactor) + ' ' + GetName(rsInchPluralName, cInchPrefixes);
  result := '';
{$ENDIF}
end;

function InchToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cInchFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsInchName, cInchPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cInchFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsInchPluralName, cInchPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cInchFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsInchName, cInchPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cInchFactor, rsInchPluralName);
{$ENDIF}
end;

function InchToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue * cInchFactor;
{$ELSE}
  result := AValue * cInchFactor;
{$ENDIF}
end;

function InchToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue * cInchFactor, APrefixes, cInchPrefixes, cInchExponents);
{$ELSE}
  result := GetValue(AValue * cInchFactor, APrefixes, cInchPrefixes, cInchExponents);
{$ENDIF}
end;

function FootToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue / cFootFactor) + ' ' + GetSymbol(rsFootSymbol, cFootPrefixes);
{$ENDIF}
  result := FloatToStr(AValue / cFootFactor) + ' ' + GetSymbol(rsFootSymbol, cFootPrefixes);
end;

function FootToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue / cFootFactor, APrefixes, cFootPrefixes, cFootExponents);
{$ELSE}
  FactoredValue := GetValue(AValue / cFootFactor, APrefixes, cFootPrefixes, cFootExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsFootSymbol, cFootPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsFootSymbol, APrefixes);
end;

function cFootToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := FootToFloat(AQuantity / cFootFactor, APrefixes);
  FactoredTol   := FootToFloat(ATolerance / cFootFactor, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsFootSymbol, cFootPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsFootSymbol, APrefixes);
  end;
end;

function FootToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cFootFactor) + ' ' + GetName(rsFootName, cFootPrefixes)
  else
    result := FloatToStr(AValue.FValue / cFootFactor) + ' ' + GetName(rsFootPluralName, cFootPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cFootFactor) + ' ' + GetName(rsFootName, cFootPrefixes)
  else
    result := FloatToStr(AValue / cFootFactor) + ' ' + GetName(rsFootPluralName, cFootPrefixes);
  result := '';
{$ENDIF}
end;

function FootToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cFootFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsFootName, cFootPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cFootFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsFootPluralName, cFootPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cFootFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsFootName, cFootPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cFootFactor, rsFootPluralName);
{$ENDIF}
end;

function FootToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue * cFootFactor;
{$ELSE}
  result := AValue * cFootFactor;
{$ENDIF}
end;

function FootToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue * cFootFactor, APrefixes, cFootPrefixes, cFootExponents);
{$ELSE}
  result := GetValue(AValue * cFootFactor, APrefixes, cFootPrefixes, cFootExponents);
{$ENDIF}
end;

function YardToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue / cYardFactor) + ' ' + GetSymbol(rsYardSymbol, cYardPrefixes);
{$ENDIF}
  result := FloatToStr(AValue / cYardFactor) + ' ' + GetSymbol(rsYardSymbol, cYardPrefixes);
end;

function YardToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue / cYardFactor, APrefixes, cYardPrefixes, cYardExponents);
{$ELSE}
  FactoredValue := GetValue(AValue / cYardFactor, APrefixes, cYardPrefixes, cYardExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsYardSymbol, cYardPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsYardSymbol, APrefixes);
end;

function cYardToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := YardToFloat(AQuantity / cYardFactor, APrefixes);
  FactoredTol   := YardToFloat(ATolerance / cYardFactor, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsYardSymbol, cYardPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsYardSymbol, APrefixes);
  end;
end;

function YardToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cYardFactor) + ' ' + GetName(rsYardName, cYardPrefixes)
  else
    result := FloatToStr(AValue.FValue / cYardFactor) + ' ' + GetName(rsYardPluralName, cYardPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cYardFactor) + ' ' + GetName(rsYardName, cYardPrefixes)
  else
    result := FloatToStr(AValue / cYardFactor) + ' ' + GetName(rsYardPluralName, cYardPrefixes);
  result := '';
{$ENDIF}
end;

function YardToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cYardFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsYardName, cYardPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cYardFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsYardPluralName, cYardPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cYardFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsYardName, cYardPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cYardFactor, rsYardPluralName);
{$ENDIF}
end;

function YardToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue * cYardFactor;
{$ELSE}
  result := AValue * cYardFactor;
{$ENDIF}
end;

function YardToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue * cYardFactor, APrefixes, cYardPrefixes, cYardExponents);
{$ELSE}
  result := GetValue(AValue * cYardFactor, APrefixes, cYardPrefixes, cYardExponents);
{$ENDIF}
end;

function MileToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue / cMileFactor) + ' ' + GetSymbol(rsMileSymbol, cMilePrefixes);
{$ENDIF}
  result := FloatToStr(AValue / cMileFactor) + ' ' + GetSymbol(rsMileSymbol, cMilePrefixes);
end;

function MileToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue / cMileFactor, APrefixes, cMilePrefixes, cMileExponents);
{$ELSE}
  FactoredValue := GetValue(AValue / cMileFactor, APrefixes, cMilePrefixes, cMileExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMileSymbol, cMilePrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMileSymbol, APrefixes);
end;

function cMileToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := MileToFloat(AQuantity / cMileFactor, APrefixes);
  FactoredTol   := MileToFloat(ATolerance / cMileFactor, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMileSymbol, cMilePrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsMileSymbol, APrefixes);
  end;
end;

function MileToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cMileFactor) + ' ' + GetName(rsMileName, cMilePrefixes)
  else
    result := FloatToStr(AValue.FValue / cMileFactor) + ' ' + GetName(rsMilePluralName, cMilePrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cMileFactor) + ' ' + GetName(rsMileName, cMilePrefixes)
  else
    result := FloatToStr(AValue / cMileFactor) + ' ' + GetName(rsMilePluralName, cMilePrefixes);
  result := '';
{$ENDIF}
end;

function MileToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cMileFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMileName, cMilePrefixes)
  else
    result := FloatToStrF(AValue.FValue / cMileFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMilePluralName, cMilePrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cMileFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMileName, cMilePrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cMileFactor, rsMilePluralName);
{$ENDIF}
end;

function MileToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue * cMileFactor;
{$ELSE}
  result := AValue * cMileFactor;
{$ENDIF}
end;

function MileToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue * cMileFactor, APrefixes, cMilePrefixes, cMileExponents);
{$ELSE}
  result := GetValue(AValue * cMileFactor, APrefixes, cMilePrefixes, cMileExponents);
{$ENDIF}
end;

function NauticalMileToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue / cNauticalMileFactor) + ' ' + GetSymbol(rsNauticalMileSymbol, cNauticalMilePrefixes);
{$ENDIF}
  result := FloatToStr(AValue / cNauticalMileFactor) + ' ' + GetSymbol(rsNauticalMileSymbol, cNauticalMilePrefixes);
end;

function NauticalMileToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue / cNauticalMileFactor, APrefixes, cNauticalMilePrefixes, cNauticalMileExponents);
{$ELSE}
  FactoredValue := GetValue(AValue / cNauticalMileFactor, APrefixes, cNauticalMilePrefixes, cNauticalMileExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNauticalMileSymbol, cNauticalMilePrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNauticalMileSymbol, APrefixes);
end;

function cNauticalMileToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := NauticalMileToFloat(AQuantity / cNauticalMileFactor, APrefixes);
  FactoredTol   := NauticalMileToFloat(ATolerance / cNauticalMileFactor, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNauticalMileSymbol, cNauticalMilePrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsNauticalMileSymbol, APrefixes);
  end;
end;

function NauticalMileToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cNauticalMileFactor) + ' ' + GetName(rsNauticalMileName, cNauticalMilePrefixes)
  else
    result := FloatToStr(AValue.FValue / cNauticalMileFactor) + ' ' + GetName(rsNauticalMilePluralName, cNauticalMilePrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cNauticalMileFactor) + ' ' + GetName(rsNauticalMileName, cNauticalMilePrefixes)
  else
    result := FloatToStr(AValue / cNauticalMileFactor) + ' ' + GetName(rsNauticalMilePluralName, cNauticalMilePrefixes);
  result := '';
{$ENDIF}
end;

function NauticalMileToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cNauticalMileFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNauticalMileName, cNauticalMilePrefixes)
  else
    result := FloatToStrF(AValue.FValue / cNauticalMileFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNauticalMilePluralName, cNauticalMilePrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cNauticalMileFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNauticalMileName, cNauticalMilePrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cNauticalMileFactor, rsNauticalMilePluralName);
{$ENDIF}
end;

function NauticalMileToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue * cNauticalMileFactor;
{$ELSE}
  result := AValue * cNauticalMileFactor;
{$ENDIF}
end;

function NauticalMileToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue * cNauticalMileFactor, APrefixes, cNauticalMilePrefixes, cNauticalMileExponents);
{$ELSE}
  result := GetValue(AValue * cNauticalMileFactor, APrefixes, cNauticalMilePrefixes, cNauticalMileExponents);
{$ENDIF}
end;

function AngstromToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue / cAngstromFactor) + ' ' + GetSymbol(rsAngstromSymbol, cAngstromPrefixes);
{$ENDIF}
  result := FloatToStr(AValue / cAngstromFactor) + ' ' + GetSymbol(rsAngstromSymbol, cAngstromPrefixes);
end;

function AngstromToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue / cAngstromFactor, APrefixes, cAngstromPrefixes, cAngstromExponents);
{$ELSE}
  FactoredValue := GetValue(AValue / cAngstromFactor, APrefixes, cAngstromPrefixes, cAngstromExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsAngstromSymbol, cAngstromPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsAngstromSymbol, APrefixes);
end;

function cAngstromToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := AngstromToFloat(AQuantity / cAngstromFactor, APrefixes);
  FactoredTol   := AngstromToFloat(ATolerance / cAngstromFactor, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsAngstromSymbol, cAngstromPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsAngstromSymbol, APrefixes);
  end;
end;

function AngstromToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cAngstromFactor) + ' ' + GetName(rsAngstromName, cAngstromPrefixes)
  else
    result := FloatToStr(AValue.FValue / cAngstromFactor) + ' ' + GetName(rsAngstromPluralName, cAngstromPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cAngstromFactor) + ' ' + GetName(rsAngstromName, cAngstromPrefixes)
  else
    result := FloatToStr(AValue / cAngstromFactor) + ' ' + GetName(rsAngstromPluralName, cAngstromPrefixes);
  result := '';
{$ENDIF}
end;

function AngstromToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cAngstromFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsAngstromName, cAngstromPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cAngstromFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsAngstromPluralName, cAngstromPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cAngstromFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsAngstromName, cAngstromPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cAngstromFactor, rsAngstromPluralName);
{$ENDIF}
end;

function AngstromToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue * cAngstromFactor;
{$ELSE}
  result := AValue * cAngstromFactor;
{$ENDIF}
end;

function AngstromToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue * cAngstromFactor, APrefixes, cAngstromPrefixes, cAngstromExponents);
{$ELSE}
  result := GetValue(AValue * cAngstromFactor, APrefixes, cAngstromPrefixes, cAngstromExponents);
{$ENDIF}
end;

function SquareRootMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareRootMeter then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsSquareRootMeterSymbol, cSquareRootMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsSquareRootMeterSymbol, cSquareRootMeterPrefixes);
{$ENDIF}
end;

function SquareRootMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareRootMeter then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSquareRootMeterPrefixes, cSquareRootMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSquareRootMeterPrefixes, cSquareRootMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareRootMeterSymbol, cSquareRootMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareRootMeterSymbol, APrefixes);
end;

function SquareRootMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SquareRootMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := SquareRootMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareRootMeterSymbol, cSquareRootMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsSquareRootMeterSymbol, APrefixes);
  end;
end;

function SquareRootMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareRootMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsSquareRootMeterName, cSquareRootMeterPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsSquareRootMeterPluralName, cSquareRootMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsSquareRootMeterName, cSquareRootMeterPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsSquareRootMeterPluralName, cSquareRootMeterPrefixes);
{$ENDIF}
end;

function SquareRootMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareRootMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareRootMeterName, cSquareRootMeterPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareRootMeterPluralName, cSquareRootMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareRootMeterName, cSquareRootMeterPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareRootMeterPluralName, cSquareRootMeterPrefixes);
{$ENDIF}
end;

function SquareRootMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SquareRootMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := SquareRootMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareRootMeterSymbol, cSquareRootMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsSquareRootMeterSymbol, APrefixes);
  end;
end;

function SquareRootMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareRootMeter then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function SquareRootMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareRootMeter then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cSquareRootMeterPrefixes, cSquareRootMeterExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cSquareRootMeterPrefixes, cSquareRootMeterExponents);
{$ENDIF}
end;

function SquareMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeter then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsSquareMeterSymbol, cSquareMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsSquareMeterSymbol, cSquareMeterPrefixes);
{$ENDIF}
end;

function SquareMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeter then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSquareMeterPrefixes, cSquareMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSquareMeterPrefixes, cSquareMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareMeterSymbol, cSquareMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareMeterSymbol, APrefixes);
end;

function SquareMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SquareMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := SquareMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareMeterSymbol, cSquareMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsSquareMeterSymbol, APrefixes);
  end;
end;

function SquareMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsSquareMeterName, cSquareMeterPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsSquareMeterPluralName, cSquareMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsSquareMeterName, cSquareMeterPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsSquareMeterPluralName, cSquareMeterPrefixes);
{$ENDIF}
end;

function SquareMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareMeterName, cSquareMeterPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareMeterPluralName, cSquareMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareMeterName, cSquareMeterPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareMeterPluralName, cSquareMeterPrefixes);
{$ENDIF}
end;

function SquareMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SquareMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := SquareMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareMeterSymbol, cSquareMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsSquareMeterSymbol, APrefixes);
  end;
end;

function SquareMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeter then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function SquareMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeter then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cSquareMeterPrefixes, cSquareMeterExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cSquareMeterPrefixes, cSquareMeterExponents);
{$ENDIF}
end;

function SquareInchToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeter then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue / cSquareInchFactor) + ' ' + GetSymbol(rsSquareInchSymbol, cSquareInchPrefixes);
{$ENDIF}
  result := FloatToStr(AValue / cSquareInchFactor) + ' ' + GetSymbol(rsSquareInchSymbol, cSquareInchPrefixes);
end;

function SquareInchToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeter then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue / cSquareInchFactor, APrefixes, cSquareInchPrefixes, cSquareInchExponents);
{$ELSE}
  FactoredValue := GetValue(AValue / cSquareInchFactor, APrefixes, cSquareInchPrefixes, cSquareInchExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareInchSymbol, cSquareInchPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareInchSymbol, APrefixes);
end;

function cSquareInchToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SquareInchToFloat(AQuantity / cSquareInchFactor, APrefixes);
  FactoredTol   := SquareInchToFloat(ATolerance / cSquareInchFactor, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareInchSymbol, cSquareInchPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsSquareInchSymbol, APrefixes);
  end;
end;

function SquareInchToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeter then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cSquareInchFactor) + ' ' + GetName(rsSquareInchName, cSquareInchPrefixes)
  else
    result := FloatToStr(AValue.FValue / cSquareInchFactor) + ' ' + GetName(rsSquareInchPluralName, cSquareInchPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cSquareInchFactor) + ' ' + GetName(rsSquareInchName, cSquareInchPrefixes)
  else
    result := FloatToStr(AValue / cSquareInchFactor) + ' ' + GetName(rsSquareInchPluralName, cSquareInchPrefixes);
  result := '';
{$ENDIF}
end;

function SquareInchToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeter then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cSquareInchFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareInchName, cSquareInchPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cSquareInchFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareInchPluralName, cSquareInchPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cSquareInchFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareInchName, cSquareInchPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cSquareInchFactor, rsSquareInchPluralName);
{$ENDIF}
end;

function SquareInchToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeter then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue * cSquareInchFactor;
{$ELSE}
  result := AValue * cSquareInchFactor;
{$ENDIF}
end;

function SquareInchToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeter then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue * cSquareInchFactor, APrefixes, cSquareInchPrefixes, cSquareInchExponents);
{$ELSE}
  result := GetValue(AValue * cSquareInchFactor, APrefixes, cSquareInchPrefixes, cSquareInchExponents);
{$ENDIF}
end;

function SquareFootToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeter then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue / cSquareFootFactor) + ' ' + GetSymbol(rsSquareFootSymbol, cSquareFootPrefixes);
{$ENDIF}
  result := FloatToStr(AValue / cSquareFootFactor) + ' ' + GetSymbol(rsSquareFootSymbol, cSquareFootPrefixes);
end;

function SquareFootToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeter then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue / cSquareFootFactor, APrefixes, cSquareFootPrefixes, cSquareFootExponents);
{$ELSE}
  FactoredValue := GetValue(AValue / cSquareFootFactor, APrefixes, cSquareFootPrefixes, cSquareFootExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareFootSymbol, cSquareFootPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareFootSymbol, APrefixes);
end;

function cSquareFootToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SquareFootToFloat(AQuantity / cSquareFootFactor, APrefixes);
  FactoredTol   := SquareFootToFloat(ATolerance / cSquareFootFactor, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareFootSymbol, cSquareFootPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsSquareFootSymbol, APrefixes);
  end;
end;

function SquareFootToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeter then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cSquareFootFactor) + ' ' + GetName(rsSquareFootName, cSquareFootPrefixes)
  else
    result := FloatToStr(AValue.FValue / cSquareFootFactor) + ' ' + GetName(rsSquareFootPluralName, cSquareFootPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cSquareFootFactor) + ' ' + GetName(rsSquareFootName, cSquareFootPrefixes)
  else
    result := FloatToStr(AValue / cSquareFootFactor) + ' ' + GetName(rsSquareFootPluralName, cSquareFootPrefixes);
  result := '';
{$ENDIF}
end;

function SquareFootToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeter then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cSquareFootFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareFootName, cSquareFootPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cSquareFootFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareFootPluralName, cSquareFootPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cSquareFootFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareFootName, cSquareFootPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cSquareFootFactor, rsSquareFootPluralName);
{$ENDIF}
end;

function SquareFootToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeter then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue * cSquareFootFactor;
{$ELSE}
  result := AValue * cSquareFootFactor;
{$ENDIF}
end;

function SquareFootToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeter then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue * cSquareFootFactor, APrefixes, cSquareFootPrefixes, cSquareFootExponents);
{$ELSE}
  result := GetValue(AValue * cSquareFootFactor, APrefixes, cSquareFootPrefixes, cSquareFootExponents);
{$ENDIF}
end;

function SquareYardToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeter then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue / cSquareYardFactor) + ' ' + GetSymbol(rsSquareYardSymbol, cSquareYardPrefixes);
{$ENDIF}
  result := FloatToStr(AValue / cSquareYardFactor) + ' ' + GetSymbol(rsSquareYardSymbol, cSquareYardPrefixes);
end;

function SquareYardToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeter then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue / cSquareYardFactor, APrefixes, cSquareYardPrefixes, cSquareYardExponents);
{$ELSE}
  FactoredValue := GetValue(AValue / cSquareYardFactor, APrefixes, cSquareYardPrefixes, cSquareYardExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareYardSymbol, cSquareYardPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareYardSymbol, APrefixes);
end;

function cSquareYardToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SquareYardToFloat(AQuantity / cSquareYardFactor, APrefixes);
  FactoredTol   := SquareYardToFloat(ATolerance / cSquareYardFactor, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareYardSymbol, cSquareYardPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsSquareYardSymbol, APrefixes);
  end;
end;

function SquareYardToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeter then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cSquareYardFactor) + ' ' + GetName(rsSquareYardName, cSquareYardPrefixes)
  else
    result := FloatToStr(AValue.FValue / cSquareYardFactor) + ' ' + GetName(rsSquareYardPluralName, cSquareYardPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cSquareYardFactor) + ' ' + GetName(rsSquareYardName, cSquareYardPrefixes)
  else
    result := FloatToStr(AValue / cSquareYardFactor) + ' ' + GetName(rsSquareYardPluralName, cSquareYardPrefixes);
  result := '';
{$ENDIF}
end;

function SquareYardToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeter then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cSquareYardFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareYardName, cSquareYardPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cSquareYardFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareYardPluralName, cSquareYardPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cSquareYardFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareYardName, cSquareYardPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cSquareYardFactor, rsSquareYardPluralName);
{$ENDIF}
end;

function SquareYardToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeter then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue * cSquareYardFactor;
{$ELSE}
  result := AValue * cSquareYardFactor;
{$ENDIF}
end;

function SquareYardToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeter then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue * cSquareYardFactor, APrefixes, cSquareYardPrefixes, cSquareYardExponents);
{$ELSE}
  result := GetValue(AValue * cSquareYardFactor, APrefixes, cSquareYardPrefixes, cSquareYardExponents);
{$ENDIF}
end;

function SquareMileToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeter then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue / cSquareMileFactor) + ' ' + GetSymbol(rsSquareMileSymbol, cSquareMilePrefixes);
{$ENDIF}
  result := FloatToStr(AValue / cSquareMileFactor) + ' ' + GetSymbol(rsSquareMileSymbol, cSquareMilePrefixes);
end;

function SquareMileToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeter then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue / cSquareMileFactor, APrefixes, cSquareMilePrefixes, cSquareMileExponents);
{$ELSE}
  FactoredValue := GetValue(AValue / cSquareMileFactor, APrefixes, cSquareMilePrefixes, cSquareMileExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareMileSymbol, cSquareMilePrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareMileSymbol, APrefixes);
end;

function cSquareMileToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SquareMileToFloat(AQuantity / cSquareMileFactor, APrefixes);
  FactoredTol   := SquareMileToFloat(ATolerance / cSquareMileFactor, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareMileSymbol, cSquareMilePrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsSquareMileSymbol, APrefixes);
  end;
end;

function SquareMileToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeter then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cSquareMileFactor) + ' ' + GetName(rsSquareMileName, cSquareMilePrefixes)
  else
    result := FloatToStr(AValue.FValue / cSquareMileFactor) + ' ' + GetName(rsSquareMilePluralName, cSquareMilePrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cSquareMileFactor) + ' ' + GetName(rsSquareMileName, cSquareMilePrefixes)
  else
    result := FloatToStr(AValue / cSquareMileFactor) + ' ' + GetName(rsSquareMilePluralName, cSquareMilePrefixes);
  result := '';
{$ENDIF}
end;

function SquareMileToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeter then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cSquareMileFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareMileName, cSquareMilePrefixes)
  else
    result := FloatToStrF(AValue.FValue / cSquareMileFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareMilePluralName, cSquareMilePrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cSquareMileFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareMileName, cSquareMilePrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cSquareMileFactor, rsSquareMilePluralName);
{$ENDIF}
end;

function SquareMileToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeter then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue * cSquareMileFactor;
{$ELSE}
  result := AValue * cSquareMileFactor;
{$ENDIF}
end;

function SquareMileToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeter then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue * cSquareMileFactor, APrefixes, cSquareMilePrefixes, cSquareMileExponents);
{$ELSE}
  result := GetValue(AValue * cSquareMileFactor, APrefixes, cSquareMilePrefixes, cSquareMileExponents);
{$ENDIF}
end;

function CubicMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsCubicMeterSymbol, cCubicMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsCubicMeterSymbol, cCubicMeterPrefixes);
{$ENDIF}
end;

function CubicMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cCubicMeterPrefixes, cCubicMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cCubicMeterPrefixes, cCubicMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCubicMeterSymbol, cCubicMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCubicMeterSymbol, APrefixes);
end;

function CubicMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := CubicMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := CubicMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCubicMeterSymbol, cCubicMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsCubicMeterSymbol, APrefixes);
  end;
end;

function CubicMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsCubicMeterName, cCubicMeterPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsCubicMeterPluralName, cCubicMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsCubicMeterName, cCubicMeterPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsCubicMeterPluralName, cCubicMeterPrefixes);
{$ENDIF}
end;

function CubicMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCubicMeterName, cCubicMeterPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCubicMeterPluralName, cCubicMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCubicMeterName, cCubicMeterPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCubicMeterPluralName, cCubicMeterPrefixes);
{$ENDIF}
end;

function CubicMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := CubicMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := CubicMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCubicMeterSymbol, cCubicMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsCubicMeterSymbol, APrefixes);
  end;
end;

function CubicMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function CubicMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cCubicMeterPrefixes, cCubicMeterExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cCubicMeterPrefixes, cCubicMeterExponents);
{$ENDIF}
end;

function CubicInchToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue / cCubicInchFactor) + ' ' + GetSymbol(rsCubicInchSymbol, cCubicInchPrefixes);
{$ENDIF}
  result := FloatToStr(AValue / cCubicInchFactor) + ' ' + GetSymbol(rsCubicInchSymbol, cCubicInchPrefixes);
end;

function CubicInchToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue / cCubicInchFactor, APrefixes, cCubicInchPrefixes, cCubicInchExponents);
{$ELSE}
  FactoredValue := GetValue(AValue / cCubicInchFactor, APrefixes, cCubicInchPrefixes, cCubicInchExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCubicInchSymbol, cCubicInchPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCubicInchSymbol, APrefixes);
end;

function cCubicInchToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := CubicInchToFloat(AQuantity / cCubicInchFactor, APrefixes);
  FactoredTol   := CubicInchToFloat(ATolerance / cCubicInchFactor, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCubicInchSymbol, cCubicInchPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsCubicInchSymbol, APrefixes);
  end;
end;

function CubicInchToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cCubicInchFactor) + ' ' + GetName(rsCubicInchName, cCubicInchPrefixes)
  else
    result := FloatToStr(AValue.FValue / cCubicInchFactor) + ' ' + GetName(rsCubicInchPluralName, cCubicInchPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cCubicInchFactor) + ' ' + GetName(rsCubicInchName, cCubicInchPrefixes)
  else
    result := FloatToStr(AValue / cCubicInchFactor) + ' ' + GetName(rsCubicInchPluralName, cCubicInchPrefixes);
  result := '';
{$ENDIF}
end;

function CubicInchToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cCubicInchFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCubicInchName, cCubicInchPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cCubicInchFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCubicInchPluralName, cCubicInchPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cCubicInchFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCubicInchName, cCubicInchPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cCubicInchFactor, rsCubicInchPluralName);
{$ENDIF}
end;

function CubicInchToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue * cCubicInchFactor;
{$ELSE}
  result := AValue * cCubicInchFactor;
{$ENDIF}
end;

function CubicInchToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue * cCubicInchFactor, APrefixes, cCubicInchPrefixes, cCubicInchExponents);
{$ELSE}
  result := GetValue(AValue * cCubicInchFactor, APrefixes, cCubicInchPrefixes, cCubicInchExponents);
{$ENDIF}
end;

function CubicFootToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue / cCubicFootFactor) + ' ' + GetSymbol(rsCubicFootSymbol, cCubicFootPrefixes);
{$ENDIF}
  result := FloatToStr(AValue / cCubicFootFactor) + ' ' + GetSymbol(rsCubicFootSymbol, cCubicFootPrefixes);
end;

function CubicFootToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue / cCubicFootFactor, APrefixes, cCubicFootPrefixes, cCubicFootExponents);
{$ELSE}
  FactoredValue := GetValue(AValue / cCubicFootFactor, APrefixes, cCubicFootPrefixes, cCubicFootExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCubicFootSymbol, cCubicFootPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCubicFootSymbol, APrefixes);
end;

function cCubicFootToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := CubicFootToFloat(AQuantity / cCubicFootFactor, APrefixes);
  FactoredTol   := CubicFootToFloat(ATolerance / cCubicFootFactor, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCubicFootSymbol, cCubicFootPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsCubicFootSymbol, APrefixes);
  end;
end;

function CubicFootToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cCubicFootFactor) + ' ' + GetName(rsCubicFootName, cCubicFootPrefixes)
  else
    result := FloatToStr(AValue.FValue / cCubicFootFactor) + ' ' + GetName(rsCubicFootPluralName, cCubicFootPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cCubicFootFactor) + ' ' + GetName(rsCubicFootName, cCubicFootPrefixes)
  else
    result := FloatToStr(AValue / cCubicFootFactor) + ' ' + GetName(rsCubicFootPluralName, cCubicFootPrefixes);
  result := '';
{$ENDIF}
end;

function CubicFootToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cCubicFootFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCubicFootName, cCubicFootPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cCubicFootFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCubicFootPluralName, cCubicFootPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cCubicFootFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCubicFootName, cCubicFootPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cCubicFootFactor, rsCubicFootPluralName);
{$ENDIF}
end;

function CubicFootToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue * cCubicFootFactor;
{$ELSE}
  result := AValue * cCubicFootFactor;
{$ENDIF}
end;

function CubicFootToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue * cCubicFootFactor, APrefixes, cCubicFootPrefixes, cCubicFootExponents);
{$ELSE}
  result := GetValue(AValue * cCubicFootFactor, APrefixes, cCubicFootPrefixes, cCubicFootExponents);
{$ENDIF}
end;

function CubicYardToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue / cCubicYardFactor) + ' ' + GetSymbol(rsCubicYardSymbol, cCubicYardPrefixes);
{$ENDIF}
  result := FloatToStr(AValue / cCubicYardFactor) + ' ' + GetSymbol(rsCubicYardSymbol, cCubicYardPrefixes);
end;

function CubicYardToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue / cCubicYardFactor, APrefixes, cCubicYardPrefixes, cCubicYardExponents);
{$ELSE}
  FactoredValue := GetValue(AValue / cCubicYardFactor, APrefixes, cCubicYardPrefixes, cCubicYardExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCubicYardSymbol, cCubicYardPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCubicYardSymbol, APrefixes);
end;

function cCubicYardToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := CubicYardToFloat(AQuantity / cCubicYardFactor, APrefixes);
  FactoredTol   := CubicYardToFloat(ATolerance / cCubicYardFactor, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCubicYardSymbol, cCubicYardPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsCubicYardSymbol, APrefixes);
  end;
end;

function CubicYardToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cCubicYardFactor) + ' ' + GetName(rsCubicYardName, cCubicYardPrefixes)
  else
    result := FloatToStr(AValue.FValue / cCubicYardFactor) + ' ' + GetName(rsCubicYardPluralName, cCubicYardPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cCubicYardFactor) + ' ' + GetName(rsCubicYardName, cCubicYardPrefixes)
  else
    result := FloatToStr(AValue / cCubicYardFactor) + ' ' + GetName(rsCubicYardPluralName, cCubicYardPrefixes);
  result := '';
{$ENDIF}
end;

function CubicYardToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cCubicYardFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCubicYardName, cCubicYardPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cCubicYardFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCubicYardPluralName, cCubicYardPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cCubicYardFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCubicYardName, cCubicYardPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cCubicYardFactor, rsCubicYardPluralName);
{$ENDIF}
end;

function CubicYardToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue * cCubicYardFactor;
{$ELSE}
  result := AValue * cCubicYardFactor;
{$ENDIF}
end;

function CubicYardToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue * cCubicYardFactor, APrefixes, cCubicYardPrefixes, cCubicYardExponents);
{$ELSE}
  result := GetValue(AValue * cCubicYardFactor, APrefixes, cCubicYardPrefixes, cCubicYardExponents);
{$ENDIF}
end;

function LitreToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue / cLitreFactor) + ' ' + GetSymbol(rsLitreSymbol, cLitrePrefixes);
{$ENDIF}
  result := FloatToStr(AValue / cLitreFactor) + ' ' + GetSymbol(rsLitreSymbol, cLitrePrefixes);
end;

function LitreToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue / cLitreFactor, APrefixes, cLitrePrefixes, cLitreExponents);
{$ELSE}
  FactoredValue := GetValue(AValue / cLitreFactor, APrefixes, cLitrePrefixes, cLitreExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsLitreSymbol, cLitrePrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsLitreSymbol, APrefixes);
end;

function cLitreToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := LitreToFloat(AQuantity / cLitreFactor, APrefixes);
  FactoredTol   := LitreToFloat(ATolerance / cLitreFactor, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsLitreSymbol, cLitrePrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsLitreSymbol, APrefixes);
  end;
end;

function LitreToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cLitreFactor) + ' ' + GetName(rsLitreName, cLitrePrefixes)
  else
    result := FloatToStr(AValue.FValue / cLitreFactor) + ' ' + GetName(rsLitrePluralName, cLitrePrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cLitreFactor) + ' ' + GetName(rsLitreName, cLitrePrefixes)
  else
    result := FloatToStr(AValue / cLitreFactor) + ' ' + GetName(rsLitrePluralName, cLitrePrefixes);
  result := '';
{$ENDIF}
end;

function LitreToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cLitreFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsLitreName, cLitrePrefixes)
  else
    result := FloatToStrF(AValue.FValue / cLitreFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsLitrePluralName, cLitrePrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cLitreFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsLitreName, cLitrePrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cLitreFactor, rsLitrePluralName);
{$ENDIF}
end;

function LitreToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue * cLitreFactor;
{$ELSE}
  result := AValue * cLitreFactor;
{$ENDIF}
end;

function LitreToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue * cLitreFactor, APrefixes, cLitrePrefixes, cLitreExponents);
{$ELSE}
  result := GetValue(AValue * cLitreFactor, APrefixes, cLitrePrefixes, cLitreExponents);
{$ENDIF}
end;

function GallonToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue / cGallonFactor) + ' ' + GetSymbol(rsGallonSymbol, cGallonPrefixes);
{$ENDIF}
  result := FloatToStr(AValue / cGallonFactor) + ' ' + GetSymbol(rsGallonSymbol, cGallonPrefixes);
end;

function GallonToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue / cGallonFactor, APrefixes, cGallonPrefixes, cGallonExponents);
{$ELSE}
  FactoredValue := GetValue(AValue / cGallonFactor, APrefixes, cGallonPrefixes, cGallonExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsGallonSymbol, cGallonPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsGallonSymbol, APrefixes);
end;

function cGallonToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := GallonToFloat(AQuantity / cGallonFactor, APrefixes);
  FactoredTol   := GallonToFloat(ATolerance / cGallonFactor, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsGallonSymbol, cGallonPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsGallonSymbol, APrefixes);
  end;
end;

function GallonToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cGallonFactor) + ' ' + GetName(rsGallonName, cGallonPrefixes)
  else
    result := FloatToStr(AValue.FValue / cGallonFactor) + ' ' + GetName(rsGallonPluralName, cGallonPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cGallonFactor) + ' ' + GetName(rsGallonName, cGallonPrefixes)
  else
    result := FloatToStr(AValue / cGallonFactor) + ' ' + GetName(rsGallonPluralName, cGallonPrefixes);
  result := '';
{$ENDIF}
end;

function GallonToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cGallonFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsGallonName, cGallonPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cGallonFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsGallonPluralName, cGallonPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cGallonFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsGallonName, cGallonPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cGallonFactor, rsGallonPluralName);
{$ENDIF}
end;

function GallonToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue * cGallonFactor;
{$ELSE}
  result := AValue * cGallonFactor;
{$ENDIF}
end;

function GallonToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue * cGallonFactor, APrefixes, cGallonPrefixes, cGallonExponents);
{$ELSE}
  result := GetValue(AValue * cGallonFactor, APrefixes, cGallonPrefixes, cGallonExponents);
{$ENDIF}
end;

function QuarticMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cQuarticMeter then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsQuarticMeterSymbol, cQuarticMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsQuarticMeterSymbol, cQuarticMeterPrefixes);
{$ENDIF}
end;

function QuarticMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cQuarticMeter then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cQuarticMeterPrefixes, cQuarticMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cQuarticMeterPrefixes, cQuarticMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsQuarticMeterSymbol, cQuarticMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsQuarticMeterSymbol, APrefixes);
end;

function QuarticMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := QuarticMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := QuarticMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsQuarticMeterSymbol, cQuarticMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsQuarticMeterSymbol, APrefixes);
  end;
end;

function QuarticMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cQuarticMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsQuarticMeterName, cQuarticMeterPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsQuarticMeterPluralName, cQuarticMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsQuarticMeterName, cQuarticMeterPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsQuarticMeterPluralName, cQuarticMeterPrefixes);
{$ENDIF}
end;

function QuarticMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cQuarticMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsQuarticMeterName, cQuarticMeterPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsQuarticMeterPluralName, cQuarticMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsQuarticMeterName, cQuarticMeterPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsQuarticMeterPluralName, cQuarticMeterPrefixes);
{$ENDIF}
end;

function QuarticMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := QuarticMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := QuarticMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsQuarticMeterSymbol, cQuarticMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsQuarticMeterSymbol, APrefixes);
  end;
end;

function QuarticMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cQuarticMeter then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function QuarticMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cQuarticMeter then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cQuarticMeterPrefixes, cQuarticMeterExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cQuarticMeterPrefixes, cQuarticMeterExponents);
{$ENDIF}
end;

function QuinticMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cQuinticMeter then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsQuinticMeterSymbol, cQuinticMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsQuinticMeterSymbol, cQuinticMeterPrefixes);
{$ENDIF}
end;

function QuinticMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cQuinticMeter then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cQuinticMeterPrefixes, cQuinticMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cQuinticMeterPrefixes, cQuinticMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsQuinticMeterSymbol, cQuinticMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsQuinticMeterSymbol, APrefixes);
end;

function QuinticMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := QuinticMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := QuinticMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsQuinticMeterSymbol, cQuinticMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsQuinticMeterSymbol, APrefixes);
  end;
end;

function QuinticMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cQuinticMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsQuinticMeterName, cQuinticMeterPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsQuinticMeterPluralName, cQuinticMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsQuinticMeterName, cQuinticMeterPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsQuinticMeterPluralName, cQuinticMeterPrefixes);
{$ENDIF}
end;

function QuinticMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cQuinticMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsQuinticMeterName, cQuinticMeterPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsQuinticMeterPluralName, cQuinticMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsQuinticMeterName, cQuinticMeterPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsQuinticMeterPluralName, cQuinticMeterPrefixes);
{$ENDIF}
end;

function QuinticMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := QuinticMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := QuinticMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsQuinticMeterSymbol, cQuinticMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsQuinticMeterSymbol, APrefixes);
  end;
end;

function QuinticMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cQuinticMeter then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function QuinticMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cQuinticMeter then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cQuinticMeterPrefixes, cQuinticMeterExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cQuinticMeterPrefixes, cQuinticMeterExponents);
{$ENDIF}
end;

function SexticMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSexticMeter then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsSexticMeterSymbol, cSexticMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsSexticMeterSymbol, cSexticMeterPrefixes);
{$ENDIF}
end;

function SexticMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSexticMeter then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSexticMeterPrefixes, cSexticMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSexticMeterPrefixes, cSexticMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSexticMeterSymbol, cSexticMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSexticMeterSymbol, APrefixes);
end;

function SexticMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SexticMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := SexticMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSexticMeterSymbol, cSexticMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsSexticMeterSymbol, APrefixes);
  end;
end;

function SexticMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSexticMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsSexticMeterName, cSexticMeterPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsSexticMeterPluralName, cSexticMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsSexticMeterName, cSexticMeterPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsSexticMeterPluralName, cSexticMeterPrefixes);
{$ENDIF}
end;

function SexticMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSexticMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSexticMeterName, cSexticMeterPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSexticMeterPluralName, cSexticMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSexticMeterName, cSexticMeterPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSexticMeterPluralName, cSexticMeterPrefixes);
{$ENDIF}
end;

function SexticMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SexticMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := SexticMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSexticMeterSymbol, cSexticMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsSexticMeterSymbol, APrefixes);
  end;
end;

function SexticMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSexticMeter then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function SexticMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSexticMeter then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cSexticMeterPrefixes, cSexticMeterExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cSexticMeterPrefixes, cSexticMeterExponents);
{$ENDIF}
end;

function KilogramToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogram then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsKilogramSymbol, cKilogramPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsKilogramSymbol, cKilogramPrefixes);
{$ENDIF}
end;

function KilogramToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogram then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cKilogramPrefixes, cKilogramExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cKilogramPrefixes, cKilogramExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramSymbol, cKilogramPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramSymbol, APrefixes);
end;

function KilogramToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := KilogramToFloat(AQuantity, APrefixes);
  FactoredTol   := KilogramToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramSymbol, cKilogramPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsKilogramSymbol, APrefixes);
  end;
end;

function KilogramToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogram then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsKilogramName, cKilogramPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsKilogramPluralName, cKilogramPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsKilogramName, cKilogramPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsKilogramPluralName, cKilogramPrefixes);
{$ENDIF}
end;

function KilogramToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogram then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramName, cKilogramPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramPluralName, cKilogramPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramName, cKilogramPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramPluralName, cKilogramPrefixes);
{$ENDIF}
end;

function KilogramToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := KilogramToFloat(AQuantity, APrefixes);
  FactoredTol   := KilogramToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramSymbol, cKilogramPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsKilogramSymbol, APrefixes);
  end;
end;

function KilogramToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogram then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function KilogramToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogram then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cKilogramPrefixes, cKilogramExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cKilogramPrefixes, cKilogramExponents);
{$ENDIF}
end;

function TonneToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogram then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue / cTonneFactor) + ' ' + GetSymbol(rsTonneSymbol, cTonnePrefixes);
{$ENDIF}
  result := FloatToStr(AValue / cTonneFactor) + ' ' + GetSymbol(rsTonneSymbol, cTonnePrefixes);
end;

function TonneToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogram then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue / cTonneFactor, APrefixes, cTonnePrefixes, cTonneExponents);
{$ELSE}
  FactoredValue := GetValue(AValue / cTonneFactor, APrefixes, cTonnePrefixes, cTonneExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsTonneSymbol, cTonnePrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsTonneSymbol, APrefixes);
end;

function cTonneToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := TonneToFloat(AQuantity / cTonneFactor, APrefixes);
  FactoredTol   := TonneToFloat(ATolerance / cTonneFactor, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsTonneSymbol, cTonnePrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsTonneSymbol, APrefixes);
  end;
end;

function TonneToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogram then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cTonneFactor) + ' ' + GetName(rsTonneName, cTonnePrefixes)
  else
    result := FloatToStr(AValue.FValue / cTonneFactor) + ' ' + GetName(rsTonnePluralName, cTonnePrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cTonneFactor) + ' ' + GetName(rsTonneName, cTonnePrefixes)
  else
    result := FloatToStr(AValue / cTonneFactor) + ' ' + GetName(rsTonnePluralName, cTonnePrefixes);
  result := '';
{$ENDIF}
end;

function TonneToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogram then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cTonneFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsTonneName, cTonnePrefixes)
  else
    result := FloatToStrF(AValue.FValue / cTonneFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsTonnePluralName, cTonnePrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cTonneFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsTonneName, cTonnePrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cTonneFactor, rsTonnePluralName);
{$ENDIF}
end;

function TonneToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogram then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue * cTonneFactor;
{$ELSE}
  result := AValue * cTonneFactor;
{$ENDIF}
end;

function TonneToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogram then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue * cTonneFactor, APrefixes, cTonnePrefixes, cTonneExponents);
{$ELSE}
  result := GetValue(AValue * cTonneFactor, APrefixes, cTonnePrefixes, cTonneExponents);
{$ENDIF}
end;

function PoundToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogram then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue / cPoundFactor) + ' ' + GetSymbol(rsPoundSymbol, cPoundPrefixes);
{$ENDIF}
  result := FloatToStr(AValue / cPoundFactor) + ' ' + GetSymbol(rsPoundSymbol, cPoundPrefixes);
end;

function PoundToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogram then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue / cPoundFactor, APrefixes, cPoundPrefixes, cPoundExponents);
{$ELSE}
  FactoredValue := GetValue(AValue / cPoundFactor, APrefixes, cPoundPrefixes, cPoundExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsPoundSymbol, cPoundPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsPoundSymbol, APrefixes);
end;

function cPoundToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := PoundToFloat(AQuantity / cPoundFactor, APrefixes);
  FactoredTol   := PoundToFloat(ATolerance / cPoundFactor, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsPoundSymbol, cPoundPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsPoundSymbol, APrefixes);
  end;
end;

function PoundToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogram then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cPoundFactor) + ' ' + GetName(rsPoundName, cPoundPrefixes)
  else
    result := FloatToStr(AValue.FValue / cPoundFactor) + ' ' + GetName(rsPoundPluralName, cPoundPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cPoundFactor) + ' ' + GetName(rsPoundName, cPoundPrefixes)
  else
    result := FloatToStr(AValue / cPoundFactor) + ' ' + GetName(rsPoundPluralName, cPoundPrefixes);
  result := '';
{$ENDIF}
end;

function PoundToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogram then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cPoundFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsPoundName, cPoundPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cPoundFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsPoundPluralName, cPoundPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cPoundFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsPoundName, cPoundPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cPoundFactor, rsPoundPluralName);
{$ENDIF}
end;

function PoundToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogram then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue * cPoundFactor;
{$ELSE}
  result := AValue * cPoundFactor;
{$ENDIF}
end;

function PoundToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogram then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue * cPoundFactor, APrefixes, cPoundPrefixes, cPoundExponents);
{$ELSE}
  result := GetValue(AValue * cPoundFactor, APrefixes, cPoundPrefixes, cPoundExponents);
{$ENDIF}
end;

function OunceToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogram then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue / cOunceFactor) + ' ' + GetSymbol(rsOunceSymbol, cOuncePrefixes);
{$ENDIF}
  result := FloatToStr(AValue / cOunceFactor) + ' ' + GetSymbol(rsOunceSymbol, cOuncePrefixes);
end;

function OunceToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogram then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue / cOunceFactor, APrefixes, cOuncePrefixes, cOunceExponents);
{$ELSE}
  FactoredValue := GetValue(AValue / cOunceFactor, APrefixes, cOuncePrefixes, cOunceExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsOunceSymbol, cOuncePrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsOunceSymbol, APrefixes);
end;

function cOunceToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := OunceToFloat(AQuantity / cOunceFactor, APrefixes);
  FactoredTol   := OunceToFloat(ATolerance / cOunceFactor, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsOunceSymbol, cOuncePrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsOunceSymbol, APrefixes);
  end;
end;

function OunceToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogram then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cOunceFactor) + ' ' + GetName(rsOunceName, cOuncePrefixes)
  else
    result := FloatToStr(AValue.FValue / cOunceFactor) + ' ' + GetName(rsOuncePluralName, cOuncePrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cOunceFactor) + ' ' + GetName(rsOunceName, cOuncePrefixes)
  else
    result := FloatToStr(AValue / cOunceFactor) + ' ' + GetName(rsOuncePluralName, cOuncePrefixes);
  result := '';
{$ENDIF}
end;

function OunceToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogram then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cOunceFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsOunceName, cOuncePrefixes)
  else
    result := FloatToStrF(AValue.FValue / cOunceFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsOuncePluralName, cOuncePrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cOunceFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsOunceName, cOuncePrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cOunceFactor, rsOuncePluralName);
{$ENDIF}
end;

function OunceToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogram then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue * cOunceFactor;
{$ELSE}
  result := AValue * cOunceFactor;
{$ENDIF}
end;

function OunceToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogram then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue * cOunceFactor, APrefixes, cOuncePrefixes, cOunceExponents);
{$ELSE}
  result := GetValue(AValue * cOunceFactor, APrefixes, cOuncePrefixes, cOunceExponents);
{$ENDIF}
end;

function StoneToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogram then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue / cStoneFactor) + ' ' + GetSymbol(rsStoneSymbol, cStonePrefixes);
{$ENDIF}
  result := FloatToStr(AValue / cStoneFactor) + ' ' + GetSymbol(rsStoneSymbol, cStonePrefixes);
end;

function StoneToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogram then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue / cStoneFactor, APrefixes, cStonePrefixes, cStoneExponents);
{$ELSE}
  FactoredValue := GetValue(AValue / cStoneFactor, APrefixes, cStonePrefixes, cStoneExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsStoneSymbol, cStonePrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsStoneSymbol, APrefixes);
end;

function cStoneToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := StoneToFloat(AQuantity / cStoneFactor, APrefixes);
  FactoredTol   := StoneToFloat(ATolerance / cStoneFactor, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsStoneSymbol, cStonePrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsStoneSymbol, APrefixes);
  end;
end;

function StoneToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogram then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cStoneFactor) + ' ' + GetName(rsStoneName, cStonePrefixes)
  else
    result := FloatToStr(AValue.FValue / cStoneFactor) + ' ' + GetName(rsStonePluralName, cStonePrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cStoneFactor) + ' ' + GetName(rsStoneName, cStonePrefixes)
  else
    result := FloatToStr(AValue / cStoneFactor) + ' ' + GetName(rsStonePluralName, cStonePrefixes);
  result := '';
{$ENDIF}
end;

function StoneToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogram then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cStoneFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsStoneName, cStonePrefixes)
  else
    result := FloatToStrF(AValue.FValue / cStoneFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsStonePluralName, cStonePrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cStoneFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsStoneName, cStonePrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cStoneFactor, rsStonePluralName);
{$ENDIF}
end;

function StoneToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogram then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue * cStoneFactor;
{$ELSE}
  result := AValue * cStoneFactor;
{$ENDIF}
end;

function StoneToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogram then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue * cStoneFactor, APrefixes, cStonePrefixes, cStoneExponents);
{$ELSE}
  result := GetValue(AValue * cStoneFactor, APrefixes, cStonePrefixes, cStoneExponents);
{$ENDIF}
end;

function TonToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogram then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue / cTonFactor) + ' ' + GetSymbol(rsTonSymbol, cTonPrefixes);
{$ENDIF}
  result := FloatToStr(AValue / cTonFactor) + ' ' + GetSymbol(rsTonSymbol, cTonPrefixes);
end;

function TonToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogram then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue / cTonFactor, APrefixes, cTonPrefixes, cTonExponents);
{$ELSE}
  FactoredValue := GetValue(AValue / cTonFactor, APrefixes, cTonPrefixes, cTonExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsTonSymbol, cTonPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsTonSymbol, APrefixes);
end;

function cTonToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := TonToFloat(AQuantity / cTonFactor, APrefixes);
  FactoredTol   := TonToFloat(ATolerance / cTonFactor, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsTonSymbol, cTonPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsTonSymbol, APrefixes);
  end;
end;

function TonToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogram then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cTonFactor) + ' ' + GetName(rsTonName, cTonPrefixes)
  else
    result := FloatToStr(AValue.FValue / cTonFactor) + ' ' + GetName(rsTonPluralName, cTonPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cTonFactor) + ' ' + GetName(rsTonName, cTonPrefixes)
  else
    result := FloatToStr(AValue / cTonFactor) + ' ' + GetName(rsTonPluralName, cTonPrefixes);
  result := '';
{$ENDIF}
end;

function TonToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogram then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cTonFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsTonName, cTonPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cTonFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsTonPluralName, cTonPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cTonFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsTonName, cTonPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cTonFactor, rsTonPluralName);
{$ENDIF}
end;

function TonToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogram then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue * cTonFactor;
{$ELSE}
  result := AValue * cTonFactor;
{$ENDIF}
end;

function TonToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogram then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue * cTonFactor, APrefixes, cTonPrefixes, cTonExponents);
{$ELSE}
  result := GetValue(AValue * cTonFactor, APrefixes, cTonPrefixes, cTonExponents);
{$ENDIF}
end;

function ElectronvoltPerSquareSpeedOfLightToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogram then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue / cElectronvoltPerSquareSpeedOfLightFactor) + ' ' + GetSymbol(rsElectronvoltPerSquareSpeedOfLightSymbol, cElectronvoltPerSquareSpeedOfLightPrefixes);
{$ENDIF}
  result := FloatToStr(AValue / cElectronvoltPerSquareSpeedOfLightFactor) + ' ' + GetSymbol(rsElectronvoltPerSquareSpeedOfLightSymbol, cElectronvoltPerSquareSpeedOfLightPrefixes);
end;

function ElectronvoltPerSquareSpeedOfLightToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogram then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue / cElectronvoltPerSquareSpeedOfLightFactor, APrefixes, cElectronvoltPerSquareSpeedOfLightPrefixes, cElectronvoltPerSquareSpeedOfLightExponents);
{$ELSE}
  FactoredValue := GetValue(AValue / cElectronvoltPerSquareSpeedOfLightFactor, APrefixes, cElectronvoltPerSquareSpeedOfLightPrefixes, cElectronvoltPerSquareSpeedOfLightExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsElectronvoltPerSquareSpeedOfLightSymbol, cElectronvoltPerSquareSpeedOfLightPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsElectronvoltPerSquareSpeedOfLightSymbol, APrefixes);
end;

function cElectronvoltPerSquareSpeedOfLightToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := ElectronvoltPerSquareSpeedOfLightToFloat(AQuantity / cElectronvoltPerSquareSpeedOfLightFactor, APrefixes);
  FactoredTol   := ElectronvoltPerSquareSpeedOfLightToFloat(ATolerance / cElectronvoltPerSquareSpeedOfLightFactor, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsElectronvoltPerSquareSpeedOfLightSymbol, cElectronvoltPerSquareSpeedOfLightPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsElectronvoltPerSquareSpeedOfLightSymbol, APrefixes);
  end;
end;

function ElectronvoltPerSquareSpeedOfLightToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogram then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cElectronvoltPerSquareSpeedOfLightFactor) + ' ' + GetName(rsElectronvoltPerSquareSpeedOfLightName, cElectronvoltPerSquareSpeedOfLightPrefixes)
  else
    result := FloatToStr(AValue.FValue / cElectronvoltPerSquareSpeedOfLightFactor) + ' ' + GetName(rsElectronvoltPerSquareSpeedOfLightPluralName, cElectronvoltPerSquareSpeedOfLightPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cElectronvoltPerSquareSpeedOfLightFactor) + ' ' + GetName(rsElectronvoltPerSquareSpeedOfLightName, cElectronvoltPerSquareSpeedOfLightPrefixes)
  else
    result := FloatToStr(AValue / cElectronvoltPerSquareSpeedOfLightFactor) + ' ' + GetName(rsElectronvoltPerSquareSpeedOfLightPluralName, cElectronvoltPerSquareSpeedOfLightPrefixes);
  result := '';
{$ENDIF}
end;

function ElectronvoltPerSquareSpeedOfLightToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogram then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cElectronvoltPerSquareSpeedOfLightFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsElectronvoltPerSquareSpeedOfLightName, cElectronvoltPerSquareSpeedOfLightPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cElectronvoltPerSquareSpeedOfLightFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsElectronvoltPerSquareSpeedOfLightPluralName, cElectronvoltPerSquareSpeedOfLightPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cElectronvoltPerSquareSpeedOfLightFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsElectronvoltPerSquareSpeedOfLightName, cElectronvoltPerSquareSpeedOfLightPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cElectronvoltPerSquareSpeedOfLightFactor, rsElectronvoltPerSquareSpeedOfLightPluralName);
{$ENDIF}
end;

function ElectronvoltPerSquareSpeedOfLightToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogram then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue * cElectronvoltPerSquareSpeedOfLightFactor;
{$ELSE}
  result := AValue * cElectronvoltPerSquareSpeedOfLightFactor;
{$ENDIF}
end;

function ElectronvoltPerSquareSpeedOfLightToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogram then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue * cElectronvoltPerSquareSpeedOfLightFactor, APrefixes, cElectronvoltPerSquareSpeedOfLightPrefixes, cElectronvoltPerSquareSpeedOfLightExponents);
{$ELSE}
  result := GetValue(AValue * cElectronvoltPerSquareSpeedOfLightFactor, APrefixes, cElectronvoltPerSquareSpeedOfLightPrefixes, cElectronvoltPerSquareSpeedOfLightExponents);
{$ENDIF}
end;

function SquareKilogramToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareKilogram then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsSquareKilogramSymbol, cSquareKilogramPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsSquareKilogramSymbol, cSquareKilogramPrefixes);
{$ENDIF}
end;

function SquareKilogramToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareKilogram then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSquareKilogramPrefixes, cSquareKilogramExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSquareKilogramPrefixes, cSquareKilogramExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareKilogramSymbol, cSquareKilogramPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareKilogramSymbol, APrefixes);
end;

function SquareKilogramToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SquareKilogramToFloat(AQuantity, APrefixes);
  FactoredTol   := SquareKilogramToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareKilogramSymbol, cSquareKilogramPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsSquareKilogramSymbol, APrefixes);
  end;
end;

function SquareKilogramToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareKilogram then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsSquareKilogramName, cSquareKilogramPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsSquareKilogramPluralName, cSquareKilogramPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsSquareKilogramName, cSquareKilogramPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsSquareKilogramPluralName, cSquareKilogramPrefixes);
{$ENDIF}
end;

function SquareKilogramToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareKilogram then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareKilogramName, cSquareKilogramPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareKilogramPluralName, cSquareKilogramPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareKilogramName, cSquareKilogramPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareKilogramPluralName, cSquareKilogramPrefixes);
{$ENDIF}
end;

function SquareKilogramToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SquareKilogramToFloat(AQuantity, APrefixes);
  FactoredTol   := SquareKilogramToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareKilogramSymbol, cSquareKilogramPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsSquareKilogramSymbol, APrefixes);
  end;
end;

function SquareKilogramToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareKilogram then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function SquareKilogramToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareKilogram then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cSquareKilogramPrefixes, cSquareKilogramExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cSquareKilogramPrefixes, cSquareKilogramExponents);
{$ENDIF}
end;

function AmpereToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cAmpere then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsAmpereSymbol, cAmperePrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsAmpereSymbol, cAmperePrefixes);
{$ENDIF}
end;

function AmpereToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cAmpere then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cAmperePrefixes, cAmpereExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cAmperePrefixes, cAmpereExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsAmpereSymbol, cAmperePrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsAmpereSymbol, APrefixes);
end;

function AmpereToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := AmpereToFloat(AQuantity, APrefixes);
  FactoredTol   := AmpereToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsAmpereSymbol, cAmperePrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsAmpereSymbol, APrefixes);
  end;
end;

function AmpereToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cAmpere then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsAmpereName, cAmperePrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsAmperePluralName, cAmperePrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsAmpereName, cAmperePrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsAmperePluralName, cAmperePrefixes);
{$ENDIF}
end;

function AmpereToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cAmpere then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsAmpereName, cAmperePrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsAmperePluralName, cAmperePrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsAmpereName, cAmperePrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsAmperePluralName, cAmperePrefixes);
{$ENDIF}
end;

function AmpereToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := AmpereToFloat(AQuantity, APrefixes);
  FactoredTol   := AmpereToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsAmpereSymbol, cAmperePrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsAmpereSymbol, APrefixes);
  end;
end;

function AmpereToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cAmpere then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function AmpereToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cAmpere then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cAmperePrefixes, cAmpereExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cAmperePrefixes, cAmpereExponents);
{$ENDIF}
end;

function SquareAmpereToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareAmpere then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsSquareAmpereSymbol, cSquareAmperePrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsSquareAmpereSymbol, cSquareAmperePrefixes);
{$ENDIF}
end;

function SquareAmpereToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareAmpere then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSquareAmperePrefixes, cSquareAmpereExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSquareAmperePrefixes, cSquareAmpereExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareAmpereSymbol, cSquareAmperePrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareAmpereSymbol, APrefixes);
end;

function SquareAmpereToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SquareAmpereToFloat(AQuantity, APrefixes);
  FactoredTol   := SquareAmpereToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareAmpereSymbol, cSquareAmperePrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsSquareAmpereSymbol, APrefixes);
  end;
end;

function SquareAmpereToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareAmpere then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsSquareAmpereName, cSquareAmperePrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsSquareAmperePluralName, cSquareAmperePrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsSquareAmpereName, cSquareAmperePrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsSquareAmperePluralName, cSquareAmperePrefixes);
{$ENDIF}
end;

function SquareAmpereToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareAmpere then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareAmpereName, cSquareAmperePrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareAmperePluralName, cSquareAmperePrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareAmpereName, cSquareAmperePrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareAmperePluralName, cSquareAmperePrefixes);
{$ENDIF}
end;

function SquareAmpereToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SquareAmpereToFloat(AQuantity, APrefixes);
  FactoredTol   := SquareAmpereToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareAmpereSymbol, cSquareAmperePrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsSquareAmpereSymbol, APrefixes);
  end;
end;

function SquareAmpereToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareAmpere then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function SquareAmpereToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareAmpere then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cSquareAmperePrefixes, cSquareAmpereExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cSquareAmperePrefixes, cSquareAmpereExponents);
{$ENDIF}
end;

function KelvinToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKelvin then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsKelvinSymbol, cKelvinPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsKelvinSymbol, cKelvinPrefixes);
{$ENDIF}
end;

function KelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKelvin then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cKelvinPrefixes, cKelvinExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cKelvinPrefixes, cKelvinExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKelvinSymbol, cKelvinPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKelvinSymbol, APrefixes);
end;

function KelvinToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := KelvinToFloat(AQuantity, APrefixes);
  FactoredTol   := KelvinToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKelvinSymbol, cKelvinPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsKelvinSymbol, APrefixes);
  end;
end;

function KelvinToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKelvin then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsKelvinName, cKelvinPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsKelvinPluralName, cKelvinPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsKelvinName, cKelvinPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsKelvinPluralName, cKelvinPrefixes);
{$ENDIF}
end;

function KelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKelvin then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKelvinName, cKelvinPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKelvinPluralName, cKelvinPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKelvinName, cKelvinPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKelvinPluralName, cKelvinPrefixes);
{$ENDIF}
end;

function KelvinToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := KelvinToFloat(AQuantity, APrefixes);
  FactoredTol   := KelvinToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKelvinSymbol, cKelvinPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsKelvinSymbol, APrefixes);
  end;
end;

function KelvinToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKelvin then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function KelvinToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKelvin then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cKelvinPrefixes, cKelvinExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cKelvinPrefixes, cKelvinExponents);
{$ENDIF}
end;

function SquareKelvinToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareKelvin then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsSquareKelvinSymbol, cSquareKelvinPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsSquareKelvinSymbol, cSquareKelvinPrefixes);
{$ENDIF}
end;

function SquareKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareKelvin then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSquareKelvinPrefixes, cSquareKelvinExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSquareKelvinPrefixes, cSquareKelvinExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareKelvinSymbol, cSquareKelvinPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareKelvinSymbol, APrefixes);
end;

function SquareKelvinToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SquareKelvinToFloat(AQuantity, APrefixes);
  FactoredTol   := SquareKelvinToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareKelvinSymbol, cSquareKelvinPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsSquareKelvinSymbol, APrefixes);
  end;
end;

function SquareKelvinToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareKelvin then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsSquareKelvinName, cSquareKelvinPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsSquareKelvinPluralName, cSquareKelvinPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsSquareKelvinName, cSquareKelvinPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsSquareKelvinPluralName, cSquareKelvinPrefixes);
{$ENDIF}
end;

function SquareKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareKelvin then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareKelvinName, cSquareKelvinPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareKelvinPluralName, cSquareKelvinPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareKelvinName, cSquareKelvinPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareKelvinPluralName, cSquareKelvinPrefixes);
{$ENDIF}
end;

function SquareKelvinToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SquareKelvinToFloat(AQuantity, APrefixes);
  FactoredTol   := SquareKelvinToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareKelvinSymbol, cSquareKelvinPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsSquareKelvinSymbol, APrefixes);
  end;
end;

function SquareKelvinToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareKelvin then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function SquareKelvinToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareKelvin then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cSquareKelvinPrefixes, cSquareKelvinExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cSquareKelvinPrefixes, cSquareKelvinExponents);
{$ENDIF}
end;

function CubicKelvinToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicKelvin then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsCubicKelvinSymbol, cCubicKelvinPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsCubicKelvinSymbol, cCubicKelvinPrefixes);
{$ENDIF}
end;

function CubicKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicKelvin then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cCubicKelvinPrefixes, cCubicKelvinExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cCubicKelvinPrefixes, cCubicKelvinExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCubicKelvinSymbol, cCubicKelvinPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCubicKelvinSymbol, APrefixes);
end;

function CubicKelvinToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := CubicKelvinToFloat(AQuantity, APrefixes);
  FactoredTol   := CubicKelvinToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCubicKelvinSymbol, cCubicKelvinPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsCubicKelvinSymbol, APrefixes);
  end;
end;

function CubicKelvinToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicKelvin then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsCubicKelvinName, cCubicKelvinPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsCubicKelvinPluralName, cCubicKelvinPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsCubicKelvinName, cCubicKelvinPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsCubicKelvinPluralName, cCubicKelvinPrefixes);
{$ENDIF}
end;

function CubicKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicKelvin then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCubicKelvinName, cCubicKelvinPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCubicKelvinPluralName, cCubicKelvinPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCubicKelvinName, cCubicKelvinPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCubicKelvinPluralName, cCubicKelvinPrefixes);
{$ENDIF}
end;

function CubicKelvinToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := CubicKelvinToFloat(AQuantity, APrefixes);
  FactoredTol   := CubicKelvinToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCubicKelvinSymbol, cCubicKelvinPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsCubicKelvinSymbol, APrefixes);
  end;
end;

function CubicKelvinToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicKelvin then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function CubicKelvinToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicKelvin then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cCubicKelvinPrefixes, cCubicKelvinExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cCubicKelvinPrefixes, cCubicKelvinExponents);
{$ENDIF}
end;

function QuarticKelvinToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cQuarticKelvin then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsQuarticKelvinSymbol, cQuarticKelvinPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsQuarticKelvinSymbol, cQuarticKelvinPrefixes);
{$ENDIF}
end;

function QuarticKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cQuarticKelvin then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cQuarticKelvinPrefixes, cQuarticKelvinExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cQuarticKelvinPrefixes, cQuarticKelvinExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsQuarticKelvinSymbol, cQuarticKelvinPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsQuarticKelvinSymbol, APrefixes);
end;

function QuarticKelvinToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := QuarticKelvinToFloat(AQuantity, APrefixes);
  FactoredTol   := QuarticKelvinToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsQuarticKelvinSymbol, cQuarticKelvinPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsQuarticKelvinSymbol, APrefixes);
  end;
end;

function QuarticKelvinToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cQuarticKelvin then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsQuarticKelvinName, cQuarticKelvinPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsQuarticKelvinPluralName, cQuarticKelvinPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsQuarticKelvinName, cQuarticKelvinPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsQuarticKelvinPluralName, cQuarticKelvinPrefixes);
{$ENDIF}
end;

function QuarticKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cQuarticKelvin then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsQuarticKelvinName, cQuarticKelvinPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsQuarticKelvinPluralName, cQuarticKelvinPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsQuarticKelvinName, cQuarticKelvinPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsQuarticKelvinPluralName, cQuarticKelvinPrefixes);
{$ENDIF}
end;

function QuarticKelvinToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := QuarticKelvinToFloat(AQuantity, APrefixes);
  FactoredTol   := QuarticKelvinToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsQuarticKelvinSymbol, cQuarticKelvinPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsQuarticKelvinSymbol, APrefixes);
  end;
end;

function QuarticKelvinToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cQuarticKelvin then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function QuarticKelvinToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cQuarticKelvin then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cQuarticKelvinPrefixes, cQuarticKelvinExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cQuarticKelvinPrefixes, cQuarticKelvinExponents);
{$ENDIF}
end;

function MoleToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMole then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsMoleSymbol, cMolePrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsMoleSymbol, cMolePrefixes);
{$ENDIF}
end;

function MoleToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMole then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cMolePrefixes, cMoleExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cMolePrefixes, cMoleExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMoleSymbol, cMolePrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMoleSymbol, APrefixes);
end;

function MoleToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := MoleToFloat(AQuantity, APrefixes);
  FactoredTol   := MoleToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMoleSymbol, cMolePrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsMoleSymbol, APrefixes);
  end;
end;

function MoleToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMole then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsMoleName, cMolePrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsMolePluralName, cMolePrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsMoleName, cMolePrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsMolePluralName, cMolePrefixes);
{$ENDIF}
end;

function MoleToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMole then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMoleName, cMolePrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMolePluralName, cMolePrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMoleName, cMolePrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMolePluralName, cMolePrefixes);
{$ENDIF}
end;

function MoleToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := MoleToFloat(AQuantity, APrefixes);
  FactoredTol   := MoleToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMoleSymbol, cMolePrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsMoleSymbol, APrefixes);
  end;
end;

function MoleToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMole then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function MoleToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMole then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cMolePrefixes, cMoleExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cMolePrefixes, cMoleExponents);
{$ENDIF}
end;

function CandelaToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCandela then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsCandelaSymbol, cCandelaPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsCandelaSymbol, cCandelaPrefixes);
{$ENDIF}
end;

function CandelaToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCandela then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cCandelaPrefixes, cCandelaExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cCandelaPrefixes, cCandelaExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCandelaSymbol, cCandelaPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCandelaSymbol, APrefixes);
end;

function CandelaToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := CandelaToFloat(AQuantity, APrefixes);
  FactoredTol   := CandelaToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCandelaSymbol, cCandelaPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsCandelaSymbol, APrefixes);
  end;
end;

function CandelaToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCandela then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsCandelaName, cCandelaPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsCandelaPluralName, cCandelaPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsCandelaName, cCandelaPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsCandelaPluralName, cCandelaPrefixes);
{$ENDIF}
end;

function CandelaToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCandela then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCandelaName, cCandelaPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCandelaPluralName, cCandelaPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCandelaName, cCandelaPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCandelaPluralName, cCandelaPrefixes);
{$ENDIF}
end;

function CandelaToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := CandelaToFloat(AQuantity, APrefixes);
  FactoredTol   := CandelaToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCandelaSymbol, cCandelaPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsCandelaSymbol, APrefixes);
  end;
end;

function CandelaToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCandela then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function CandelaToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCandela then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cCandelaPrefixes, cCandelaExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cCandelaPrefixes, cCandelaExponents);
{$ENDIF}
end;

function HertzToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHertz then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsHertzSymbol, cHertzPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsHertzSymbol, cHertzPrefixes);
{$ENDIF}
end;

function HertzToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHertz then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cHertzPrefixes, cHertzExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cHertzPrefixes, cHertzExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsHertzSymbol, cHertzPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsHertzSymbol, APrefixes);
end;

function HertzToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := HertzToFloat(AQuantity, APrefixes);
  FactoredTol   := HertzToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsHertzSymbol, cHertzPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsHertzSymbol, APrefixes);
  end;
end;

function HertzToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHertz then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsHertzName, cHertzPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsHertzPluralName, cHertzPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsHertzName, cHertzPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsHertzPluralName, cHertzPrefixes);
{$ENDIF}
end;

function HertzToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHertz then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsHertzName, cHertzPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsHertzPluralName, cHertzPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsHertzName, cHertzPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsHertzPluralName, cHertzPrefixes);
{$ENDIF}
end;

function HertzToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := HertzToFloat(AQuantity, APrefixes);
  FactoredTol   := HertzToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsHertzSymbol, cHertzPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsHertzSymbol, APrefixes);
  end;
end;

function HertzToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHertz then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function HertzToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHertz then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cHertzPrefixes, cHertzExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cHertzPrefixes, cHertzExponents);
{$ENDIF}
end;

function ReciprocalSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHertz then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsReciprocalSecondSymbol, cReciprocalSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsReciprocalSecondSymbol, cReciprocalSecondPrefixes);
{$ENDIF}
end;

function ReciprocalSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHertz then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cReciprocalSecondPrefixes, cReciprocalSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cReciprocalSecondPrefixes, cReciprocalSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsReciprocalSecondSymbol, cReciprocalSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsReciprocalSecondSymbol, APrefixes);
end;

function ReciprocalSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := ReciprocalSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := ReciprocalSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsReciprocalSecondSymbol, cReciprocalSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsReciprocalSecondSymbol, APrefixes);
  end;
end;

function ReciprocalSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHertz then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cReciprocalSecondFactor) + ' ' + GetName(rsReciprocalSecondName, cReciprocalSecondPrefixes)
  else
    result := FloatToStr(AValue.FValue / cReciprocalSecondFactor) + ' ' + GetName(rsReciprocalSecondPluralName, cReciprocalSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cReciprocalSecondFactor) + ' ' + GetName(rsReciprocalSecondName, cReciprocalSecondPrefixes)
  else
    result := FloatToStr(AValue / cReciprocalSecondFactor) + ' ' + GetName(rsReciprocalSecondPluralName, cReciprocalSecondPrefixes);
  result := '';
{$ENDIF}
end;

function ReciprocalSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHertz then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cReciprocalSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsReciprocalSecondName, cReciprocalSecondPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cReciprocalSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsReciprocalSecondPluralName, cReciprocalSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cReciprocalSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsReciprocalSecondName, cReciprocalSecondPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cReciprocalSecondFactor, rsReciprocalSecondPluralName);
{$ENDIF}
end;

function ReciprocalSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHertz then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function ReciprocalSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHertz then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cReciprocalSecondPrefixes, cReciprocalSecondExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cReciprocalSecondPrefixes, cReciprocalSecondExponents);
{$ENDIF}
end;

function RadianPerSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHertz then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsRadianPerSecondSymbol, cRadianPerSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsRadianPerSecondSymbol, cRadianPerSecondPrefixes);
{$ENDIF}
end;

function RadianPerSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHertz then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cRadianPerSecondPrefixes, cRadianPerSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cRadianPerSecondPrefixes, cRadianPerSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsRadianPerSecondSymbol, cRadianPerSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsRadianPerSecondSymbol, APrefixes);
end;

function RadianPerSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := RadianPerSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := RadianPerSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsRadianPerSecondSymbol, cRadianPerSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsRadianPerSecondSymbol, APrefixes);
  end;
end;

function RadianPerSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHertz then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cRadianPerSecondFactor) + ' ' + GetName(rsRadianPerSecondName, cRadianPerSecondPrefixes)
  else
    result := FloatToStr(AValue.FValue / cRadianPerSecondFactor) + ' ' + GetName(rsRadianPerSecondPluralName, cRadianPerSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cRadianPerSecondFactor) + ' ' + GetName(rsRadianPerSecondName, cRadianPerSecondPrefixes)
  else
    result := FloatToStr(AValue / cRadianPerSecondFactor) + ' ' + GetName(rsRadianPerSecondPluralName, cRadianPerSecondPrefixes);
  result := '';
{$ENDIF}
end;

function RadianPerSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHertz then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cRadianPerSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsRadianPerSecondName, cRadianPerSecondPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cRadianPerSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsRadianPerSecondPluralName, cRadianPerSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cRadianPerSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsRadianPerSecondName, cRadianPerSecondPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cRadianPerSecondFactor, rsRadianPerSecondPluralName);
{$ENDIF}
end;

function RadianPerSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHertz then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function RadianPerSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHertz then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cRadianPerSecondPrefixes, cRadianPerSecondExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cRadianPerSecondPrefixes, cRadianPerSecondExponents);
{$ENDIF}
end;

function SquareHertzToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareHertz then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsSquareHertzSymbol, cSquareHertzPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsSquareHertzSymbol, cSquareHertzPrefixes);
{$ENDIF}
end;

function SquareHertzToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareHertz then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSquareHertzPrefixes, cSquareHertzExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSquareHertzPrefixes, cSquareHertzExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareHertzSymbol, cSquareHertzPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareHertzSymbol, APrefixes);
end;

function SquareHertzToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SquareHertzToFloat(AQuantity, APrefixes);
  FactoredTol   := SquareHertzToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareHertzSymbol, cSquareHertzPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsSquareHertzSymbol, APrefixes);
  end;
end;

function SquareHertzToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareHertz then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsSquareHertzName, cSquareHertzPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsSquareHertzPluralName, cSquareHertzPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsSquareHertzName, cSquareHertzPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsSquareHertzPluralName, cSquareHertzPrefixes);
{$ENDIF}
end;

function SquareHertzToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareHertz then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareHertzName, cSquareHertzPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareHertzPluralName, cSquareHertzPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareHertzName, cSquareHertzPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareHertzPluralName, cSquareHertzPrefixes);
{$ENDIF}
end;

function SquareHertzToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SquareHertzToFloat(AQuantity, APrefixes);
  FactoredTol   := SquareHertzToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareHertzSymbol, cSquareHertzPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsSquareHertzSymbol, APrefixes);
  end;
end;

function SquareHertzToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareHertz then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function SquareHertzToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareHertz then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cSquareHertzPrefixes, cSquareHertzExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cSquareHertzPrefixes, cSquareHertzExponents);
{$ENDIF}
end;

function ReciprocalSquareSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareHertz then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsReciprocalSquareSecondSymbol, cReciprocalSquareSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsReciprocalSquareSecondSymbol, cReciprocalSquareSecondPrefixes);
{$ENDIF}
end;

function ReciprocalSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareHertz then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cReciprocalSquareSecondPrefixes, cReciprocalSquareSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cReciprocalSquareSecondPrefixes, cReciprocalSquareSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsReciprocalSquareSecondSymbol, cReciprocalSquareSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsReciprocalSquareSecondSymbol, APrefixes);
end;

function ReciprocalSquareSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := ReciprocalSquareSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := ReciprocalSquareSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsReciprocalSquareSecondSymbol, cReciprocalSquareSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsReciprocalSquareSecondSymbol, APrefixes);
  end;
end;

function ReciprocalSquareSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareHertz then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cReciprocalSquareSecondFactor) + ' ' + GetName(rsReciprocalSquareSecondName, cReciprocalSquareSecondPrefixes)
  else
    result := FloatToStr(AValue.FValue / cReciprocalSquareSecondFactor) + ' ' + GetName(rsReciprocalSquareSecondPluralName, cReciprocalSquareSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cReciprocalSquareSecondFactor) + ' ' + GetName(rsReciprocalSquareSecondName, cReciprocalSquareSecondPrefixes)
  else
    result := FloatToStr(AValue / cReciprocalSquareSecondFactor) + ' ' + GetName(rsReciprocalSquareSecondPluralName, cReciprocalSquareSecondPrefixes);
  result := '';
{$ENDIF}
end;

function ReciprocalSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareHertz then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cReciprocalSquareSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsReciprocalSquareSecondName, cReciprocalSquareSecondPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cReciprocalSquareSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsReciprocalSquareSecondPluralName, cReciprocalSquareSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cReciprocalSquareSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsReciprocalSquareSecondName, cReciprocalSquareSecondPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cReciprocalSquareSecondFactor, rsReciprocalSquareSecondPluralName);
{$ENDIF}
end;

function ReciprocalSquareSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareHertz then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function ReciprocalSquareSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareHertz then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cReciprocalSquareSecondPrefixes, cReciprocalSquareSecondExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cReciprocalSquareSecondPrefixes, cReciprocalSquareSecondExponents);
{$ENDIF}
end;

function RadianPerSquareSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareHertz then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsRadianPerSquareSecondSymbol, cRadianPerSquareSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsRadianPerSquareSecondSymbol, cRadianPerSquareSecondPrefixes);
{$ENDIF}
end;

function RadianPerSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareHertz then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cRadianPerSquareSecondPrefixes, cRadianPerSquareSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cRadianPerSquareSecondPrefixes, cRadianPerSquareSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsRadianPerSquareSecondSymbol, cRadianPerSquareSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsRadianPerSquareSecondSymbol, APrefixes);
end;

function RadianPerSquareSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := RadianPerSquareSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := RadianPerSquareSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsRadianPerSquareSecondSymbol, cRadianPerSquareSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsRadianPerSquareSecondSymbol, APrefixes);
  end;
end;

function RadianPerSquareSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareHertz then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cRadianPerSquareSecondFactor) + ' ' + GetName(rsRadianPerSquareSecondName, cRadianPerSquareSecondPrefixes)
  else
    result := FloatToStr(AValue.FValue / cRadianPerSquareSecondFactor) + ' ' + GetName(rsRadianPerSquareSecondPluralName, cRadianPerSquareSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cRadianPerSquareSecondFactor) + ' ' + GetName(rsRadianPerSquareSecondName, cRadianPerSquareSecondPrefixes)
  else
    result := FloatToStr(AValue / cRadianPerSquareSecondFactor) + ' ' + GetName(rsRadianPerSquareSecondPluralName, cRadianPerSquareSecondPrefixes);
  result := '';
{$ENDIF}
end;

function RadianPerSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareHertz then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cRadianPerSquareSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsRadianPerSquareSecondName, cRadianPerSquareSecondPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cRadianPerSquareSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsRadianPerSquareSecondPluralName, cRadianPerSquareSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cRadianPerSquareSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsRadianPerSquareSecondName, cRadianPerSquareSecondPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cRadianPerSquareSecondFactor, rsRadianPerSquareSecondPluralName);
{$ENDIF}
end;

function RadianPerSquareSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareHertz then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function RadianPerSquareSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareHertz then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cRadianPerSquareSecondPrefixes, cRadianPerSquareSecondExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cRadianPerSquareSecondPrefixes, cRadianPerSquareSecondExponents);
{$ENDIF}
end;

function SteradianPerSquareSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSteradianPerSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsSteradianPerSquareSecondSymbol, cSteradianPerSquareSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsSteradianPerSquareSecondSymbol, cSteradianPerSquareSecondPrefixes);
{$ENDIF}
end;

function SteradianPerSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSteradianPerSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSteradianPerSquareSecondPrefixes, cSteradianPerSquareSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSteradianPerSquareSecondPrefixes, cSteradianPerSquareSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSteradianPerSquareSecondSymbol, cSteradianPerSquareSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSteradianPerSquareSecondSymbol, APrefixes);
end;

function SteradianPerSquareSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SteradianPerSquareSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := SteradianPerSquareSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSteradianPerSquareSecondSymbol, cSteradianPerSquareSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsSteradianPerSquareSecondSymbol, APrefixes);
  end;
end;

function SteradianPerSquareSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSteradianPerSquareSecond then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsSteradianPerSquareSecondName, cSteradianPerSquareSecondPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsSteradianPerSquareSecondPluralName, cSteradianPerSquareSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsSteradianPerSquareSecondName, cSteradianPerSquareSecondPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsSteradianPerSquareSecondPluralName, cSteradianPerSquareSecondPrefixes);
{$ENDIF}
end;

function SteradianPerSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSteradianPerSquareSecond then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSteradianPerSquareSecondName, cSteradianPerSquareSecondPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSteradianPerSquareSecondPluralName, cSteradianPerSquareSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSteradianPerSquareSecondName, cSteradianPerSquareSecondPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSteradianPerSquareSecondPluralName, cSteradianPerSquareSecondPrefixes);
{$ENDIF}
end;

function SteradianPerSquareSecondToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SteradianPerSquareSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := SteradianPerSquareSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSteradianPerSquareSecondSymbol, cSteradianPerSquareSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsSteradianPerSquareSecondSymbol, APrefixes);
  end;
end;

function SteradianPerSquareSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSteradianPerSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function SteradianPerSquareSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSteradianPerSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cSteradianPerSquareSecondPrefixes, cSteradianPerSquareSecondExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cSteradianPerSquareSecondPrefixes, cSteradianPerSquareSecondExponents);
{$ENDIF}
end;

function MeterPerSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsMeterPerSecondSymbol, cMeterPerSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsMeterPerSecondSymbol, cMeterPerSecondPrefixes);
{$ENDIF}
end;

function MeterPerSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cMeterPerSecondPrefixes, cMeterPerSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cMeterPerSecondPrefixes, cMeterPerSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterPerSecondSymbol, cMeterPerSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterPerSecondSymbol, APrefixes);
end;

function MeterPerSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := MeterPerSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := MeterPerSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterPerSecondSymbol, cMeterPerSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsMeterPerSecondSymbol, APrefixes);
  end;
end;

function MeterPerSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsMeterPerSecondName, cMeterPerSecondPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsMeterPerSecondPluralName, cMeterPerSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsMeterPerSecondName, cMeterPerSecondPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsMeterPerSecondPluralName, cMeterPerSecondPrefixes);
{$ENDIF}
end;

function MeterPerSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMeterPerSecondName, cMeterPerSecondPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMeterPerSecondPluralName, cMeterPerSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMeterPerSecondName, cMeterPerSecondPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMeterPerSecondPluralName, cMeterPerSecondPrefixes);
{$ENDIF}
end;

function MeterPerSecondToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := MeterPerSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := MeterPerSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMeterPerSecondSymbol, cMeterPerSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsMeterPerSecondSymbol, APrefixes);
  end;
end;

function MeterPerSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function MeterPerSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cMeterPerSecondPrefixes, cMeterPerSecondExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cMeterPerSecondPrefixes, cMeterPerSecondExponents);
{$ENDIF}
end;

function MeterPerHourToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue / cMeterPerHourFactor) + ' ' + GetSymbol(rsMeterPerHourSymbol, cMeterPerHourPrefixes);
{$ENDIF}
  result := FloatToStr(AValue / cMeterPerHourFactor) + ' ' + GetSymbol(rsMeterPerHourSymbol, cMeterPerHourPrefixes);
end;

function MeterPerHourToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue / cMeterPerHourFactor, APrefixes, cMeterPerHourPrefixes, cMeterPerHourExponents);
{$ELSE}
  FactoredValue := GetValue(AValue / cMeterPerHourFactor, APrefixes, cMeterPerHourPrefixes, cMeterPerHourExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterPerHourSymbol, cMeterPerHourPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterPerHourSymbol, APrefixes);
end;

function cMeterPerHourToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := MeterPerHourToFloat(AQuantity / cMeterPerHourFactor, APrefixes);
  FactoredTol   := MeterPerHourToFloat(ATolerance / cMeterPerHourFactor, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterPerHourSymbol, cMeterPerHourPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsMeterPerHourSymbol, APrefixes);
  end;
end;

function MeterPerHourToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cMeterPerHourFactor) + ' ' + GetName(rsMeterPerHourName, cMeterPerHourPrefixes)
  else
    result := FloatToStr(AValue.FValue / cMeterPerHourFactor) + ' ' + GetName(rsMeterPerHourPluralName, cMeterPerHourPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cMeterPerHourFactor) + ' ' + GetName(rsMeterPerHourName, cMeterPerHourPrefixes)
  else
    result := FloatToStr(AValue / cMeterPerHourFactor) + ' ' + GetName(rsMeterPerHourPluralName, cMeterPerHourPrefixes);
  result := '';
{$ENDIF}
end;

function MeterPerHourToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cMeterPerHourFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMeterPerHourName, cMeterPerHourPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cMeterPerHourFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMeterPerHourPluralName, cMeterPerHourPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cMeterPerHourFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMeterPerHourName, cMeterPerHourPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cMeterPerHourFactor, rsMeterPerHourPluralName);
{$ENDIF}
end;

function MeterPerHourToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue * cMeterPerHourFactor;
{$ELSE}
  result := AValue * cMeterPerHourFactor;
{$ENDIF}
end;

function MeterPerHourToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue * cMeterPerHourFactor, APrefixes, cMeterPerHourPrefixes, cMeterPerHourExponents);
{$ELSE}
  result := GetValue(AValue * cMeterPerHourFactor, APrefixes, cMeterPerHourPrefixes, cMeterPerHourExponents);
{$ENDIF}
end;

function MilePerHourToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue / cMilePerHourFactor) + ' ' + GetSymbol(rsMilePerHourSymbol, cMilePerHourPrefixes);
{$ENDIF}
  result := FloatToStr(AValue / cMilePerHourFactor) + ' ' + GetSymbol(rsMilePerHourSymbol, cMilePerHourPrefixes);
end;

function MilePerHourToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue / cMilePerHourFactor, APrefixes, cMilePerHourPrefixes, cMilePerHourExponents);
{$ELSE}
  FactoredValue := GetValue(AValue / cMilePerHourFactor, APrefixes, cMilePerHourPrefixes, cMilePerHourExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMilePerHourSymbol, cMilePerHourPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMilePerHourSymbol, APrefixes);
end;

function cMilePerHourToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := MilePerHourToFloat(AQuantity / cMilePerHourFactor, APrefixes);
  FactoredTol   := MilePerHourToFloat(ATolerance / cMilePerHourFactor, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMilePerHourSymbol, cMilePerHourPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsMilePerHourSymbol, APrefixes);
  end;
end;

function MilePerHourToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cMilePerHourFactor) + ' ' + GetName(rsMilePerHourName, cMilePerHourPrefixes)
  else
    result := FloatToStr(AValue.FValue / cMilePerHourFactor) + ' ' + GetName(rsMilePerHourPluralName, cMilePerHourPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cMilePerHourFactor) + ' ' + GetName(rsMilePerHourName, cMilePerHourPrefixes)
  else
    result := FloatToStr(AValue / cMilePerHourFactor) + ' ' + GetName(rsMilePerHourPluralName, cMilePerHourPrefixes);
  result := '';
{$ENDIF}
end;

function MilePerHourToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cMilePerHourFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMilePerHourName, cMilePerHourPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cMilePerHourFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMilePerHourPluralName, cMilePerHourPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cMilePerHourFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMilePerHourName, cMilePerHourPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cMilePerHourFactor, rsMilePerHourPluralName);
{$ENDIF}
end;

function MilePerHourToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue * cMilePerHourFactor;
{$ELSE}
  result := AValue * cMilePerHourFactor;
{$ENDIF}
end;

function MilePerHourToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue * cMilePerHourFactor, APrefixes, cMilePerHourPrefixes, cMilePerHourExponents);
{$ELSE}
  result := GetValue(AValue * cMilePerHourFactor, APrefixes, cMilePerHourPrefixes, cMilePerHourExponents);
{$ENDIF}
end;

function NauticalMilePerHourToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue / cNauticalMilePerHourFactor) + ' ' + GetSymbol(rsNauticalMilePerHourSymbol, cNauticalMilePerHourPrefixes);
{$ENDIF}
  result := FloatToStr(AValue / cNauticalMilePerHourFactor) + ' ' + GetSymbol(rsNauticalMilePerHourSymbol, cNauticalMilePerHourPrefixes);
end;

function NauticalMilePerHourToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue / cNauticalMilePerHourFactor, APrefixes, cNauticalMilePerHourPrefixes, cNauticalMilePerHourExponents);
{$ELSE}
  FactoredValue := GetValue(AValue / cNauticalMilePerHourFactor, APrefixes, cNauticalMilePerHourPrefixes, cNauticalMilePerHourExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNauticalMilePerHourSymbol, cNauticalMilePerHourPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNauticalMilePerHourSymbol, APrefixes);
end;

function cNauticalMilePerHourToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := NauticalMilePerHourToFloat(AQuantity / cNauticalMilePerHourFactor, APrefixes);
  FactoredTol   := NauticalMilePerHourToFloat(ATolerance / cNauticalMilePerHourFactor, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNauticalMilePerHourSymbol, cNauticalMilePerHourPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsNauticalMilePerHourSymbol, APrefixes);
  end;
end;

function NauticalMilePerHourToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cNauticalMilePerHourFactor) + ' ' + GetName(rsNauticalMilePerHourName, cNauticalMilePerHourPrefixes)
  else
    result := FloatToStr(AValue.FValue / cNauticalMilePerHourFactor) + ' ' + GetName(rsNauticalMilePerHourPluralName, cNauticalMilePerHourPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cNauticalMilePerHourFactor) + ' ' + GetName(rsNauticalMilePerHourName, cNauticalMilePerHourPrefixes)
  else
    result := FloatToStr(AValue / cNauticalMilePerHourFactor) + ' ' + GetName(rsNauticalMilePerHourPluralName, cNauticalMilePerHourPrefixes);
  result := '';
{$ENDIF}
end;

function NauticalMilePerHourToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cNauticalMilePerHourFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNauticalMilePerHourName, cNauticalMilePerHourPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cNauticalMilePerHourFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNauticalMilePerHourPluralName, cNauticalMilePerHourPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cNauticalMilePerHourFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNauticalMilePerHourName, cNauticalMilePerHourPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cNauticalMilePerHourFactor, rsNauticalMilePerHourPluralName);
{$ENDIF}
end;

function NauticalMilePerHourToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue * cNauticalMilePerHourFactor;
{$ELSE}
  result := AValue * cNauticalMilePerHourFactor;
{$ENDIF}
end;

function NauticalMilePerHourToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue * cNauticalMilePerHourFactor, APrefixes, cNauticalMilePerHourPrefixes, cNauticalMilePerHourExponents);
{$ELSE}
  result := GetValue(AValue * cNauticalMilePerHourFactor, APrefixes, cNauticalMilePerHourPrefixes, cNauticalMilePerHourExponents);
{$ENDIF}
end;

function MeterPerSquareSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsMeterPerSquareSecondSymbol, cMeterPerSquareSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsMeterPerSquareSecondSymbol, cMeterPerSquareSecondPrefixes);
{$ENDIF}
end;

function MeterPerSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cMeterPerSquareSecondPrefixes, cMeterPerSquareSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cMeterPerSquareSecondPrefixes, cMeterPerSquareSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterPerSquareSecondSymbol, cMeterPerSquareSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterPerSquareSecondSymbol, APrefixes);
end;

function MeterPerSquareSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := MeterPerSquareSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := MeterPerSquareSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterPerSquareSecondSymbol, cMeterPerSquareSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsMeterPerSquareSecondSymbol, APrefixes);
  end;
end;

function MeterPerSquareSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSquareSecond then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsMeterPerSquareSecondName, cMeterPerSquareSecondPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsMeterPerSquareSecondPluralName, cMeterPerSquareSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsMeterPerSquareSecondName, cMeterPerSquareSecondPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsMeterPerSquareSecondPluralName, cMeterPerSquareSecondPrefixes);
{$ENDIF}
end;

function MeterPerSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSquareSecond then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMeterPerSquareSecondName, cMeterPerSquareSecondPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMeterPerSquareSecondPluralName, cMeterPerSquareSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMeterPerSquareSecondName, cMeterPerSquareSecondPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMeterPerSquareSecondPluralName, cMeterPerSquareSecondPrefixes);
{$ENDIF}
end;

function MeterPerSquareSecondToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := MeterPerSquareSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := MeterPerSquareSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMeterPerSquareSecondSymbol, cMeterPerSquareSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsMeterPerSquareSecondSymbol, APrefixes);
  end;
end;

function MeterPerSquareSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function MeterPerSquareSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cMeterPerSquareSecondPrefixes, cMeterPerSquareSecondExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cMeterPerSquareSecondPrefixes, cMeterPerSquareSecondExponents);
{$ENDIF}
end;

function MeterPerSecondPerSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsMeterPerSecondPerSecondSymbol, cMeterPerSecondPerSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsMeterPerSecondPerSecondSymbol, cMeterPerSecondPerSecondPrefixes);
{$ENDIF}
end;

function MeterPerSecondPerSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cMeterPerSecondPerSecondPrefixes, cMeterPerSecondPerSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cMeterPerSecondPerSecondPrefixes, cMeterPerSecondPerSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterPerSecondPerSecondSymbol, cMeterPerSecondPerSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterPerSecondPerSecondSymbol, APrefixes);
end;

function MeterPerSecondPerSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := MeterPerSecondPerSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := MeterPerSecondPerSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterPerSecondPerSecondSymbol, cMeterPerSecondPerSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsMeterPerSecondPerSecondSymbol, APrefixes);
  end;
end;

function MeterPerSecondPerSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cMeterPerSecondPerSecondFactor) + ' ' + GetName(rsMeterPerSecondPerSecondName, cMeterPerSecondPerSecondPrefixes)
  else
    result := FloatToStr(AValue.FValue / cMeterPerSecondPerSecondFactor) + ' ' + GetName(rsMeterPerSecondPerSecondPluralName, cMeterPerSecondPerSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cMeterPerSecondPerSecondFactor) + ' ' + GetName(rsMeterPerSecondPerSecondName, cMeterPerSecondPerSecondPrefixes)
  else
    result := FloatToStr(AValue / cMeterPerSecondPerSecondFactor) + ' ' + GetName(rsMeterPerSecondPerSecondPluralName, cMeterPerSecondPerSecondPrefixes);
  result := '';
{$ENDIF}
end;

function MeterPerSecondPerSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cMeterPerSecondPerSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMeterPerSecondPerSecondName, cMeterPerSecondPerSecondPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cMeterPerSecondPerSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMeterPerSecondPerSecondPluralName, cMeterPerSecondPerSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cMeterPerSecondPerSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMeterPerSecondPerSecondName, cMeterPerSecondPerSecondPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cMeterPerSecondPerSecondFactor, rsMeterPerSecondPerSecondPluralName);
{$ENDIF}
end;

function MeterPerSecondPerSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function MeterPerSecondPerSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cMeterPerSecondPerSecondPrefixes, cMeterPerSecondPerSecondExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cMeterPerSecondPerSecondPrefixes, cMeterPerSecondPerSecondExponents);
{$ENDIF}
end;

function MeterPerHourPerSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue / cMeterPerHourPerSecondFactor) + ' ' + GetSymbol(rsMeterPerHourPerSecondSymbol, cMeterPerHourPerSecondPrefixes);
{$ENDIF}
  result := FloatToStr(AValue / cMeterPerHourPerSecondFactor) + ' ' + GetSymbol(rsMeterPerHourPerSecondSymbol, cMeterPerHourPerSecondPrefixes);
end;

function MeterPerHourPerSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue / cMeterPerHourPerSecondFactor, APrefixes, cMeterPerHourPerSecondPrefixes, cMeterPerHourPerSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue / cMeterPerHourPerSecondFactor, APrefixes, cMeterPerHourPerSecondPrefixes, cMeterPerHourPerSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterPerHourPerSecondSymbol, cMeterPerHourPerSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterPerHourPerSecondSymbol, APrefixes);
end;

function cMeterPerHourPerSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := MeterPerHourPerSecondToFloat(AQuantity / cMeterPerHourPerSecondFactor, APrefixes);
  FactoredTol   := MeterPerHourPerSecondToFloat(ATolerance / cMeterPerHourPerSecondFactor, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterPerHourPerSecondSymbol, cMeterPerHourPerSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsMeterPerHourPerSecondSymbol, APrefixes);
  end;
end;

function MeterPerHourPerSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cMeterPerHourPerSecondFactor) + ' ' + GetName(rsMeterPerHourPerSecondName, cMeterPerHourPerSecondPrefixes)
  else
    result := FloatToStr(AValue.FValue / cMeterPerHourPerSecondFactor) + ' ' + GetName(rsMeterPerHourPerSecondPluralName, cMeterPerHourPerSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cMeterPerHourPerSecondFactor) + ' ' + GetName(rsMeterPerHourPerSecondName, cMeterPerHourPerSecondPrefixes)
  else
    result := FloatToStr(AValue / cMeterPerHourPerSecondFactor) + ' ' + GetName(rsMeterPerHourPerSecondPluralName, cMeterPerHourPerSecondPrefixes);
  result := '';
{$ENDIF}
end;

function MeterPerHourPerSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cMeterPerHourPerSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMeterPerHourPerSecondName, cMeterPerHourPerSecondPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cMeterPerHourPerSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMeterPerHourPerSecondPluralName, cMeterPerHourPerSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cMeterPerHourPerSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMeterPerHourPerSecondName, cMeterPerHourPerSecondPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cMeterPerHourPerSecondFactor, rsMeterPerHourPerSecondPluralName);
{$ENDIF}
end;

function MeterPerHourPerSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue * cMeterPerHourPerSecondFactor;
{$ELSE}
  result := AValue * cMeterPerHourPerSecondFactor;
{$ENDIF}
end;

function MeterPerHourPerSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue * cMeterPerHourPerSecondFactor, APrefixes, cMeterPerHourPerSecondPrefixes, cMeterPerHourPerSecondExponents);
{$ELSE}
  result := GetValue(AValue * cMeterPerHourPerSecondFactor, APrefixes, cMeterPerHourPerSecondPrefixes, cMeterPerHourPerSecondExponents);
{$ENDIF}
end;

function MeterPerCubicSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerCubicSecond then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsMeterPerCubicSecondSymbol, cMeterPerCubicSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsMeterPerCubicSecondSymbol, cMeterPerCubicSecondPrefixes);
{$ENDIF}
end;

function MeterPerCubicSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerCubicSecond then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cMeterPerCubicSecondPrefixes, cMeterPerCubicSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cMeterPerCubicSecondPrefixes, cMeterPerCubicSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterPerCubicSecondSymbol, cMeterPerCubicSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterPerCubicSecondSymbol, APrefixes);
end;

function MeterPerCubicSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := MeterPerCubicSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := MeterPerCubicSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterPerCubicSecondSymbol, cMeterPerCubicSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsMeterPerCubicSecondSymbol, APrefixes);
  end;
end;

function MeterPerCubicSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerCubicSecond then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsMeterPerCubicSecondName, cMeterPerCubicSecondPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsMeterPerCubicSecondPluralName, cMeterPerCubicSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsMeterPerCubicSecondName, cMeterPerCubicSecondPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsMeterPerCubicSecondPluralName, cMeterPerCubicSecondPrefixes);
{$ENDIF}
end;

function MeterPerCubicSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerCubicSecond then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMeterPerCubicSecondName, cMeterPerCubicSecondPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMeterPerCubicSecondPluralName, cMeterPerCubicSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMeterPerCubicSecondName, cMeterPerCubicSecondPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMeterPerCubicSecondPluralName, cMeterPerCubicSecondPrefixes);
{$ENDIF}
end;

function MeterPerCubicSecondToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := MeterPerCubicSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := MeterPerCubicSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMeterPerCubicSecondSymbol, cMeterPerCubicSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsMeterPerCubicSecondSymbol, APrefixes);
  end;
end;

function MeterPerCubicSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerCubicSecond then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function MeterPerCubicSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerCubicSecond then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cMeterPerCubicSecondPrefixes, cMeterPerCubicSecondExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cMeterPerCubicSecondPrefixes, cMeterPerCubicSecondExponents);
{$ENDIF}
end;

function MeterPerQuarticSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerQuarticSecond then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsMeterPerQuarticSecondSymbol, cMeterPerQuarticSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsMeterPerQuarticSecondSymbol, cMeterPerQuarticSecondPrefixes);
{$ENDIF}
end;

function MeterPerQuarticSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerQuarticSecond then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cMeterPerQuarticSecondPrefixes, cMeterPerQuarticSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cMeterPerQuarticSecondPrefixes, cMeterPerQuarticSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterPerQuarticSecondSymbol, cMeterPerQuarticSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterPerQuarticSecondSymbol, APrefixes);
end;

function MeterPerQuarticSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := MeterPerQuarticSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := MeterPerQuarticSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterPerQuarticSecondSymbol, cMeterPerQuarticSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsMeterPerQuarticSecondSymbol, APrefixes);
  end;
end;

function MeterPerQuarticSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerQuarticSecond then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsMeterPerQuarticSecondName, cMeterPerQuarticSecondPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsMeterPerQuarticSecondPluralName, cMeterPerQuarticSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsMeterPerQuarticSecondName, cMeterPerQuarticSecondPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsMeterPerQuarticSecondPluralName, cMeterPerQuarticSecondPrefixes);
{$ENDIF}
end;

function MeterPerQuarticSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerQuarticSecond then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMeterPerQuarticSecondName, cMeterPerQuarticSecondPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMeterPerQuarticSecondPluralName, cMeterPerQuarticSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMeterPerQuarticSecondName, cMeterPerQuarticSecondPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMeterPerQuarticSecondPluralName, cMeterPerQuarticSecondPrefixes);
{$ENDIF}
end;

function MeterPerQuarticSecondToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := MeterPerQuarticSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := MeterPerQuarticSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMeterPerQuarticSecondSymbol, cMeterPerQuarticSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsMeterPerQuarticSecondSymbol, APrefixes);
  end;
end;

function MeterPerQuarticSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerQuarticSecond then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function MeterPerQuarticSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerQuarticSecond then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cMeterPerQuarticSecondPrefixes, cMeterPerQuarticSecondExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cMeterPerQuarticSecondPrefixes, cMeterPerQuarticSecondExponents);
{$ENDIF}
end;

function MeterPerQuinticSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerQuinticSecond then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsMeterPerQuinticSecondSymbol, cMeterPerQuinticSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsMeterPerQuinticSecondSymbol, cMeterPerQuinticSecondPrefixes);
{$ENDIF}
end;

function MeterPerQuinticSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerQuinticSecond then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cMeterPerQuinticSecondPrefixes, cMeterPerQuinticSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cMeterPerQuinticSecondPrefixes, cMeterPerQuinticSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterPerQuinticSecondSymbol, cMeterPerQuinticSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterPerQuinticSecondSymbol, APrefixes);
end;

function MeterPerQuinticSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := MeterPerQuinticSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := MeterPerQuinticSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterPerQuinticSecondSymbol, cMeterPerQuinticSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsMeterPerQuinticSecondSymbol, APrefixes);
  end;
end;

function MeterPerQuinticSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerQuinticSecond then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsMeterPerQuinticSecondName, cMeterPerQuinticSecondPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsMeterPerQuinticSecondPluralName, cMeterPerQuinticSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsMeterPerQuinticSecondName, cMeterPerQuinticSecondPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsMeterPerQuinticSecondPluralName, cMeterPerQuinticSecondPrefixes);
{$ENDIF}
end;

function MeterPerQuinticSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerQuinticSecond then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMeterPerQuinticSecondName, cMeterPerQuinticSecondPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMeterPerQuinticSecondPluralName, cMeterPerQuinticSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMeterPerQuinticSecondName, cMeterPerQuinticSecondPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMeterPerQuinticSecondPluralName, cMeterPerQuinticSecondPrefixes);
{$ENDIF}
end;

function MeterPerQuinticSecondToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := MeterPerQuinticSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := MeterPerQuinticSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMeterPerQuinticSecondSymbol, cMeterPerQuinticSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsMeterPerQuinticSecondSymbol, APrefixes);
  end;
end;

function MeterPerQuinticSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerQuinticSecond then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function MeterPerQuinticSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerQuinticSecond then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cMeterPerQuinticSecondPrefixes, cMeterPerQuinticSecondExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cMeterPerQuinticSecondPrefixes, cMeterPerQuinticSecondExponents);
{$ENDIF}
end;

function MeterPerSexticSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSexticSecond then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsMeterPerSexticSecondSymbol, cMeterPerSexticSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsMeterPerSexticSecondSymbol, cMeterPerSexticSecondPrefixes);
{$ENDIF}
end;

function MeterPerSexticSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSexticSecond then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cMeterPerSexticSecondPrefixes, cMeterPerSexticSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cMeterPerSexticSecondPrefixes, cMeterPerSexticSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterPerSexticSecondSymbol, cMeterPerSexticSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterPerSexticSecondSymbol, APrefixes);
end;

function MeterPerSexticSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := MeterPerSexticSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := MeterPerSexticSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterPerSexticSecondSymbol, cMeterPerSexticSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsMeterPerSexticSecondSymbol, APrefixes);
  end;
end;

function MeterPerSexticSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSexticSecond then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsMeterPerSexticSecondName, cMeterPerSexticSecondPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsMeterPerSexticSecondPluralName, cMeterPerSexticSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsMeterPerSexticSecondName, cMeterPerSexticSecondPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsMeterPerSexticSecondPluralName, cMeterPerSexticSecondPrefixes);
{$ENDIF}
end;

function MeterPerSexticSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSexticSecond then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMeterPerSexticSecondName, cMeterPerSexticSecondPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMeterPerSexticSecondPluralName, cMeterPerSexticSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMeterPerSexticSecondName, cMeterPerSexticSecondPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMeterPerSexticSecondPluralName, cMeterPerSexticSecondPrefixes);
{$ENDIF}
end;

function MeterPerSexticSecondToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := MeterPerSexticSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := MeterPerSexticSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMeterPerSexticSecondSymbol, cMeterPerSexticSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsMeterPerSexticSecondSymbol, APrefixes);
  end;
end;

function MeterPerSexticSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSexticSecond then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function MeterPerSexticSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSexticSecond then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cMeterPerSexticSecondPrefixes, cMeterPerSexticSecondExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cMeterPerSexticSecondPrefixes, cMeterPerSexticSecondExponents);
{$ENDIF}
end;

function SquareMeterPerSquareSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterPerSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsSquareMeterPerSquareSecondSymbol, cSquareMeterPerSquareSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsSquareMeterPerSquareSecondSymbol, cSquareMeterPerSquareSecondPrefixes);
{$ENDIF}
end;

function SquareMeterPerSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterPerSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSquareMeterPerSquareSecondPrefixes, cSquareMeterPerSquareSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSquareMeterPerSquareSecondPrefixes, cSquareMeterPerSquareSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareMeterPerSquareSecondSymbol, cSquareMeterPerSquareSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareMeterPerSquareSecondSymbol, APrefixes);
end;

function SquareMeterPerSquareSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SquareMeterPerSquareSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := SquareMeterPerSquareSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareMeterPerSquareSecondSymbol, cSquareMeterPerSquareSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsSquareMeterPerSquareSecondSymbol, APrefixes);
  end;
end;

function SquareMeterPerSquareSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterPerSquareSecond then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsSquareMeterPerSquareSecondName, cSquareMeterPerSquareSecondPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsSquareMeterPerSquareSecondPluralName, cSquareMeterPerSquareSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsSquareMeterPerSquareSecondName, cSquareMeterPerSquareSecondPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsSquareMeterPerSquareSecondPluralName, cSquareMeterPerSquareSecondPrefixes);
{$ENDIF}
end;

function SquareMeterPerSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterPerSquareSecond then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareMeterPerSquareSecondName, cSquareMeterPerSquareSecondPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareMeterPerSquareSecondPluralName, cSquareMeterPerSquareSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareMeterPerSquareSecondName, cSquareMeterPerSquareSecondPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareMeterPerSquareSecondPluralName, cSquareMeterPerSquareSecondPrefixes);
{$ENDIF}
end;

function SquareMeterPerSquareSecondToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SquareMeterPerSquareSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := SquareMeterPerSquareSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareMeterPerSquareSecondSymbol, cSquareMeterPerSquareSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsSquareMeterPerSquareSecondSymbol, APrefixes);
  end;
end;

function SquareMeterPerSquareSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterPerSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function SquareMeterPerSquareSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterPerSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cSquareMeterPerSquareSecondPrefixes, cSquareMeterPerSquareSecondExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cSquareMeterPerSquareSecondPrefixes, cSquareMeterPerSquareSecondExponents);
{$ENDIF}
end;

function JoulePerKilogramToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterPerSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsJoulePerKilogramSymbol, cJoulePerKilogramPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsJoulePerKilogramSymbol, cJoulePerKilogramPrefixes);
{$ENDIF}
end;

function JoulePerKilogramToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterPerSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cJoulePerKilogramPrefixes, cJoulePerKilogramExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cJoulePerKilogramPrefixes, cJoulePerKilogramExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsJoulePerKilogramSymbol, cJoulePerKilogramPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsJoulePerKilogramSymbol, APrefixes);
end;

function JoulePerKilogramToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := JoulePerKilogramToFloat(AQuantity, APrefixes);
  FactoredTol   := JoulePerKilogramToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsJoulePerKilogramSymbol, cJoulePerKilogramPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsJoulePerKilogramSymbol, APrefixes);
  end;
end;

function JoulePerKilogramToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterPerSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cJoulePerKilogramFactor) + ' ' + GetName(rsJoulePerKilogramName, cJoulePerKilogramPrefixes)
  else
    result := FloatToStr(AValue.FValue / cJoulePerKilogramFactor) + ' ' + GetName(rsJoulePerKilogramPluralName, cJoulePerKilogramPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cJoulePerKilogramFactor) + ' ' + GetName(rsJoulePerKilogramName, cJoulePerKilogramPrefixes)
  else
    result := FloatToStr(AValue / cJoulePerKilogramFactor) + ' ' + GetName(rsJoulePerKilogramPluralName, cJoulePerKilogramPrefixes);
  result := '';
{$ENDIF}
end;

function JoulePerKilogramToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterPerSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cJoulePerKilogramFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsJoulePerKilogramName, cJoulePerKilogramPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cJoulePerKilogramFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsJoulePerKilogramPluralName, cJoulePerKilogramPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cJoulePerKilogramFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsJoulePerKilogramName, cJoulePerKilogramPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cJoulePerKilogramFactor, rsJoulePerKilogramPluralName);
{$ENDIF}
end;

function JoulePerKilogramToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterPerSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function JoulePerKilogramToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterPerSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cJoulePerKilogramPrefixes, cJoulePerKilogramExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cJoulePerKilogramPrefixes, cJoulePerKilogramExponents);
{$ENDIF}
end;

function GrayToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterPerSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsGraySymbol, cGrayPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsGraySymbol, cGrayPrefixes);
{$ENDIF}
end;

function GrayToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterPerSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cGrayPrefixes, cGrayExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cGrayPrefixes, cGrayExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsGraySymbol, cGrayPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsGraySymbol, APrefixes);
end;

function GrayToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := GrayToFloat(AQuantity, APrefixes);
  FactoredTol   := GrayToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsGraySymbol, cGrayPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsGraySymbol, APrefixes);
  end;
end;

function GrayToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterPerSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cGrayFactor) + ' ' + GetName(rsGrayName, cGrayPrefixes)
  else
    result := FloatToStr(AValue.FValue / cGrayFactor) + ' ' + GetName(rsGrayPluralName, cGrayPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cGrayFactor) + ' ' + GetName(rsGrayName, cGrayPrefixes)
  else
    result := FloatToStr(AValue / cGrayFactor) + ' ' + GetName(rsGrayPluralName, cGrayPrefixes);
  result := '';
{$ENDIF}
end;

function GrayToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterPerSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cGrayFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsGrayName, cGrayPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cGrayFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsGrayPluralName, cGrayPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cGrayFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsGrayName, cGrayPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cGrayFactor, rsGrayPluralName);
{$ENDIF}
end;

function GrayToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterPerSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function GrayToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterPerSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cGrayPrefixes, cGrayExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cGrayPrefixes, cGrayExponents);
{$ENDIF}
end;

function SievertToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterPerSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsSievertSymbol, cSievertPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsSievertSymbol, cSievertPrefixes);
{$ENDIF}
end;

function SievertToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterPerSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSievertPrefixes, cSievertExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSievertPrefixes, cSievertExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSievertSymbol, cSievertPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSievertSymbol, APrefixes);
end;

function SievertToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SievertToFloat(AQuantity, APrefixes);
  FactoredTol   := SievertToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSievertSymbol, cSievertPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsSievertSymbol, APrefixes);
  end;
end;

function SievertToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterPerSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cSievertFactor) + ' ' + GetName(rsSievertName, cSievertPrefixes)
  else
    result := FloatToStr(AValue.FValue / cSievertFactor) + ' ' + GetName(rsSievertPluralName, cSievertPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cSievertFactor) + ' ' + GetName(rsSievertName, cSievertPrefixes)
  else
    result := FloatToStr(AValue / cSievertFactor) + ' ' + GetName(rsSievertPluralName, cSievertPrefixes);
  result := '';
{$ENDIF}
end;

function SievertToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterPerSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cSievertFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSievertName, cSievertPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cSievertFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSievertPluralName, cSievertPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cSievertFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSievertName, cSievertPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cSievertFactor, rsSievertPluralName);
{$ENDIF}
end;

function SievertToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterPerSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function SievertToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterPerSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cSievertPrefixes, cSievertExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cSievertPrefixes, cSievertExponents);
{$ENDIF}
end;

function MeterSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterSecond then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsMeterSecondSymbol, cMeterSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsMeterSecondSymbol, cMeterSecondPrefixes);
{$ENDIF}
end;

function MeterSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterSecond then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cMeterSecondPrefixes, cMeterSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cMeterSecondPrefixes, cMeterSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterSecondSymbol, cMeterSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterSecondSymbol, APrefixes);
end;

function MeterSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := MeterSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := MeterSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterSecondSymbol, cMeterSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsMeterSecondSymbol, APrefixes);
  end;
end;

function MeterSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterSecond then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsMeterSecondName, cMeterSecondPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsMeterSecondPluralName, cMeterSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsMeterSecondName, cMeterSecondPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsMeterSecondPluralName, cMeterSecondPrefixes);
{$ENDIF}
end;

function MeterSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterSecond then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMeterSecondName, cMeterSecondPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMeterSecondPluralName, cMeterSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMeterSecondName, cMeterSecondPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMeterSecondPluralName, cMeterSecondPrefixes);
{$ENDIF}
end;

function MeterSecondToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := MeterSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := MeterSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMeterSecondSymbol, cMeterSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsMeterSecondSymbol, APrefixes);
  end;
end;

function MeterSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterSecond then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function MeterSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterSecond then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cMeterSecondPrefixes, cMeterSecondExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cMeterSecondPrefixes, cMeterSecondExponents);
{$ENDIF}
end;

function KilogramMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramMeter then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsKilogramMeterSymbol, cKilogramMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsKilogramMeterSymbol, cKilogramMeterPrefixes);
{$ENDIF}
end;

function KilogramMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramMeter then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cKilogramMeterPrefixes, cKilogramMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cKilogramMeterPrefixes, cKilogramMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramMeterSymbol, cKilogramMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramMeterSymbol, APrefixes);
end;

function KilogramMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := KilogramMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := KilogramMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramMeterSymbol, cKilogramMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsKilogramMeterSymbol, APrefixes);
  end;
end;

function KilogramMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsKilogramMeterName, cKilogramMeterPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsKilogramMeterPluralName, cKilogramMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsKilogramMeterName, cKilogramMeterPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsKilogramMeterPluralName, cKilogramMeterPrefixes);
{$ENDIF}
end;

function KilogramMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramMeterName, cKilogramMeterPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramMeterPluralName, cKilogramMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramMeterName, cKilogramMeterPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramMeterPluralName, cKilogramMeterPrefixes);
{$ENDIF}
end;

function KilogramMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := KilogramMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := KilogramMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramMeterSymbol, cKilogramMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsKilogramMeterSymbol, APrefixes);
  end;
end;

function KilogramMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramMeter then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function KilogramMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramMeter then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cKilogramMeterPrefixes, cKilogramMeterExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cKilogramMeterPrefixes, cKilogramMeterExponents);
{$ENDIF}
end;

function KilogramPerSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerSecond then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsKilogramPerSecondSymbol, cKilogramPerSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsKilogramPerSecondSymbol, cKilogramPerSecondPrefixes);
{$ENDIF}
end;

function KilogramPerSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerSecond then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cKilogramPerSecondPrefixes, cKilogramPerSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cKilogramPerSecondPrefixes, cKilogramPerSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramPerSecondSymbol, cKilogramPerSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramPerSecondSymbol, APrefixes);
end;

function KilogramPerSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := KilogramPerSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := KilogramPerSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramPerSecondSymbol, cKilogramPerSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsKilogramPerSecondSymbol, APrefixes);
  end;
end;

function KilogramPerSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerSecond then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsKilogramPerSecondName, cKilogramPerSecondPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsKilogramPerSecondPluralName, cKilogramPerSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsKilogramPerSecondName, cKilogramPerSecondPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsKilogramPerSecondPluralName, cKilogramPerSecondPrefixes);
{$ENDIF}
end;

function KilogramPerSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerSecond then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramPerSecondName, cKilogramPerSecondPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramPerSecondPluralName, cKilogramPerSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramPerSecondName, cKilogramPerSecondPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramPerSecondPluralName, cKilogramPerSecondPrefixes);
{$ENDIF}
end;

function KilogramPerSecondToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := KilogramPerSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := KilogramPerSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramPerSecondSymbol, cKilogramPerSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsKilogramPerSecondSymbol, APrefixes);
  end;
end;

function KilogramPerSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerSecond then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function KilogramPerSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerSecond then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cKilogramPerSecondPrefixes, cKilogramPerSecondExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cKilogramPerSecondPrefixes, cKilogramPerSecondExponents);
{$ENDIF}
end;

function JoulePerSquareMeterPerHertzToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerSecond then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsJoulePerSquareMeterPerHertzSymbol, cJoulePerSquareMeterPerHertzPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsJoulePerSquareMeterPerHertzSymbol, cJoulePerSquareMeterPerHertzPrefixes);
{$ENDIF}
end;

function JoulePerSquareMeterPerHertzToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerSecond then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cJoulePerSquareMeterPerHertzPrefixes, cJoulePerSquareMeterPerHertzExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cJoulePerSquareMeterPerHertzPrefixes, cJoulePerSquareMeterPerHertzExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsJoulePerSquareMeterPerHertzSymbol, cJoulePerSquareMeterPerHertzPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsJoulePerSquareMeterPerHertzSymbol, APrefixes);
end;

function JoulePerSquareMeterPerHertzToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := JoulePerSquareMeterPerHertzToFloat(AQuantity, APrefixes);
  FactoredTol   := JoulePerSquareMeterPerHertzToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsJoulePerSquareMeterPerHertzSymbol, cJoulePerSquareMeterPerHertzPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsJoulePerSquareMeterPerHertzSymbol, APrefixes);
  end;
end;

function JoulePerSquareMeterPerHertzToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerSecond then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cJoulePerSquareMeterPerHertzFactor) + ' ' + GetName(rsJoulePerSquareMeterPerHertzName, cJoulePerSquareMeterPerHertzPrefixes)
  else
    result := FloatToStr(AValue.FValue / cJoulePerSquareMeterPerHertzFactor) + ' ' + GetName(rsJoulePerSquareMeterPerHertzPluralName, cJoulePerSquareMeterPerHertzPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cJoulePerSquareMeterPerHertzFactor) + ' ' + GetName(rsJoulePerSquareMeterPerHertzName, cJoulePerSquareMeterPerHertzPrefixes)
  else
    result := FloatToStr(AValue / cJoulePerSquareMeterPerHertzFactor) + ' ' + GetName(rsJoulePerSquareMeterPerHertzPluralName, cJoulePerSquareMeterPerHertzPrefixes);
  result := '';
{$ENDIF}
end;

function JoulePerSquareMeterPerHertzToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerSecond then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cJoulePerSquareMeterPerHertzFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsJoulePerSquareMeterPerHertzName, cJoulePerSquareMeterPerHertzPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cJoulePerSquareMeterPerHertzFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsJoulePerSquareMeterPerHertzPluralName, cJoulePerSquareMeterPerHertzPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cJoulePerSquareMeterPerHertzFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsJoulePerSquareMeterPerHertzName, cJoulePerSquareMeterPerHertzPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cJoulePerSquareMeterPerHertzFactor, rsJoulePerSquareMeterPerHertzPluralName);
{$ENDIF}
end;

function JoulePerSquareMeterPerHertzToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerSecond then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function JoulePerSquareMeterPerHertzToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerSecond then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cJoulePerSquareMeterPerHertzPrefixes, cJoulePerSquareMeterPerHertzExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cJoulePerSquareMeterPerHertzPrefixes, cJoulePerSquareMeterPerHertzExponents);
{$ENDIF}
end;

function KilogramMeterPerSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsKilogramMeterPerSecondSymbol, cKilogramMeterPerSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsKilogramMeterPerSecondSymbol, cKilogramMeterPerSecondPrefixes);
{$ENDIF}
end;

function KilogramMeterPerSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cKilogramMeterPerSecondPrefixes, cKilogramMeterPerSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cKilogramMeterPerSecondPrefixes, cKilogramMeterPerSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramMeterPerSecondSymbol, cKilogramMeterPerSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramMeterPerSecondSymbol, APrefixes);
end;

function KilogramMeterPerSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := KilogramMeterPerSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := KilogramMeterPerSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramMeterPerSecondSymbol, cKilogramMeterPerSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsKilogramMeterPerSecondSymbol, APrefixes);
  end;
end;

function KilogramMeterPerSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsKilogramMeterPerSecondName, cKilogramMeterPerSecondPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsKilogramMeterPerSecondPluralName, cKilogramMeterPerSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsKilogramMeterPerSecondName, cKilogramMeterPerSecondPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsKilogramMeterPerSecondPluralName, cKilogramMeterPerSecondPrefixes);
{$ENDIF}
end;

function KilogramMeterPerSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramMeterPerSecondName, cKilogramMeterPerSecondPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramMeterPerSecondPluralName, cKilogramMeterPerSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramMeterPerSecondName, cKilogramMeterPerSecondPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramMeterPerSecondPluralName, cKilogramMeterPerSecondPrefixes);
{$ENDIF}
end;

function KilogramMeterPerSecondToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := KilogramMeterPerSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := KilogramMeterPerSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramMeterPerSecondSymbol, cKilogramMeterPerSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsKilogramMeterPerSecondSymbol, APrefixes);
  end;
end;

function KilogramMeterPerSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function KilogramMeterPerSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cKilogramMeterPerSecondPrefixes, cKilogramMeterPerSecondExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cKilogramMeterPerSecondPrefixes, cKilogramMeterPerSecondExponents);
{$ENDIF}
end;

function NewtonSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsNewtonSecondSymbol, cNewtonSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsNewtonSecondSymbol, cNewtonSecondPrefixes);
{$ENDIF}
end;

function NewtonSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cNewtonSecondPrefixes, cNewtonSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cNewtonSecondPrefixes, cNewtonSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonSecondSymbol, cNewtonSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonSecondSymbol, APrefixes);
end;

function NewtonSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := NewtonSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := NewtonSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonSecondSymbol, cNewtonSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsNewtonSecondSymbol, APrefixes);
  end;
end;

function NewtonSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cNewtonSecondFactor) + ' ' + GetName(rsNewtonSecondName, cNewtonSecondPrefixes)
  else
    result := FloatToStr(AValue.FValue / cNewtonSecondFactor) + ' ' + GetName(rsNewtonSecondPluralName, cNewtonSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cNewtonSecondFactor) + ' ' + GetName(rsNewtonSecondName, cNewtonSecondPrefixes)
  else
    result := FloatToStr(AValue / cNewtonSecondFactor) + ' ' + GetName(rsNewtonSecondPluralName, cNewtonSecondPrefixes);
  result := '';
{$ENDIF}
end;

function NewtonSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cNewtonSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNewtonSecondName, cNewtonSecondPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cNewtonSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNewtonSecondPluralName, cNewtonSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cNewtonSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNewtonSecondName, cNewtonSecondPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cNewtonSecondFactor, rsNewtonSecondPluralName);
{$ENDIF}
end;

function NewtonSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function NewtonSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cNewtonSecondPrefixes, cNewtonSecondExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cNewtonSecondPrefixes, cNewtonSecondExponents);
{$ENDIF}
end;

function SquareKilogramSquareMeterPerSquareSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareKilogramSquareMeterPerSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsSquareKilogramSquareMeterPerSquareSecondSymbol, cSquareKilogramSquareMeterPerSquareSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsSquareKilogramSquareMeterPerSquareSecondSymbol, cSquareKilogramSquareMeterPerSquareSecondPrefixes);
{$ENDIF}
end;

function SquareKilogramSquareMeterPerSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareKilogramSquareMeterPerSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSquareKilogramSquareMeterPerSquareSecondPrefixes, cSquareKilogramSquareMeterPerSquareSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSquareKilogramSquareMeterPerSquareSecondPrefixes, cSquareKilogramSquareMeterPerSquareSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareKilogramSquareMeterPerSquareSecondSymbol, cSquareKilogramSquareMeterPerSquareSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareKilogramSquareMeterPerSquareSecondSymbol, APrefixes);
end;

function SquareKilogramSquareMeterPerSquareSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SquareKilogramSquareMeterPerSquareSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := SquareKilogramSquareMeterPerSquareSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareKilogramSquareMeterPerSquareSecondSymbol, cSquareKilogramSquareMeterPerSquareSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsSquareKilogramSquareMeterPerSquareSecondSymbol, APrefixes);
  end;
end;

function SquareKilogramSquareMeterPerSquareSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareKilogramSquareMeterPerSquareSecond then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsSquareKilogramSquareMeterPerSquareSecondName, cSquareKilogramSquareMeterPerSquareSecondPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsSquareKilogramSquareMeterPerSquareSecondPluralName, cSquareKilogramSquareMeterPerSquareSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsSquareKilogramSquareMeterPerSquareSecondName, cSquareKilogramSquareMeterPerSquareSecondPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsSquareKilogramSquareMeterPerSquareSecondPluralName, cSquareKilogramSquareMeterPerSquareSecondPrefixes);
{$ENDIF}
end;

function SquareKilogramSquareMeterPerSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareKilogramSquareMeterPerSquareSecond then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareKilogramSquareMeterPerSquareSecondName, cSquareKilogramSquareMeterPerSquareSecondPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareKilogramSquareMeterPerSquareSecondPluralName, cSquareKilogramSquareMeterPerSquareSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareKilogramSquareMeterPerSquareSecondName, cSquareKilogramSquareMeterPerSquareSecondPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareKilogramSquareMeterPerSquareSecondPluralName, cSquareKilogramSquareMeterPerSquareSecondPrefixes);
{$ENDIF}
end;

function SquareKilogramSquareMeterPerSquareSecondToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SquareKilogramSquareMeterPerSquareSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := SquareKilogramSquareMeterPerSquareSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareKilogramSquareMeterPerSquareSecondSymbol, cSquareKilogramSquareMeterPerSquareSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsSquareKilogramSquareMeterPerSquareSecondSymbol, APrefixes);
  end;
end;

function SquareKilogramSquareMeterPerSquareSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareKilogramSquareMeterPerSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function SquareKilogramSquareMeterPerSquareSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareKilogramSquareMeterPerSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cSquareKilogramSquareMeterPerSquareSecondPrefixes, cSquareKilogramSquareMeterPerSquareSecondExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cSquareKilogramSquareMeterPerSquareSecondPrefixes, cSquareKilogramSquareMeterPerSquareSecondExponents);
{$ENDIF}
end;

function ReciprocalSquareRootMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalSquareRootMeter then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsReciprocalSquareRootMeterSymbol, cReciprocalSquareRootMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsReciprocalSquareRootMeterSymbol, cReciprocalSquareRootMeterPrefixes);
{$ENDIF}
end;

function ReciprocalSquareRootMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalSquareRootMeter then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cReciprocalSquareRootMeterPrefixes, cReciprocalSquareRootMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cReciprocalSquareRootMeterPrefixes, cReciprocalSquareRootMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsReciprocalSquareRootMeterSymbol, cReciprocalSquareRootMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsReciprocalSquareRootMeterSymbol, APrefixes);
end;

function ReciprocalSquareRootMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := ReciprocalSquareRootMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := ReciprocalSquareRootMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsReciprocalSquareRootMeterSymbol, cReciprocalSquareRootMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsReciprocalSquareRootMeterSymbol, APrefixes);
  end;
end;

function ReciprocalSquareRootMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalSquareRootMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsReciprocalSquareRootMeterName, cReciprocalSquareRootMeterPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsReciprocalSquareRootMeterPluralName, cReciprocalSquareRootMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsReciprocalSquareRootMeterName, cReciprocalSquareRootMeterPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsReciprocalSquareRootMeterPluralName, cReciprocalSquareRootMeterPrefixes);
{$ENDIF}
end;

function ReciprocalSquareRootMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalSquareRootMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsReciprocalSquareRootMeterName, cReciprocalSquareRootMeterPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsReciprocalSquareRootMeterPluralName, cReciprocalSquareRootMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsReciprocalSquareRootMeterName, cReciprocalSquareRootMeterPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsReciprocalSquareRootMeterPluralName, cReciprocalSquareRootMeterPrefixes);
{$ENDIF}
end;

function ReciprocalSquareRootMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := ReciprocalSquareRootMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := ReciprocalSquareRootMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsReciprocalSquareRootMeterSymbol, cReciprocalSquareRootMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsReciprocalSquareRootMeterSymbol, APrefixes);
  end;
end;

function ReciprocalSquareRootMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalSquareRootMeter then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function ReciprocalSquareRootMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalSquareRootMeter then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cReciprocalSquareRootMeterPrefixes, cReciprocalSquareRootMeterExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cReciprocalSquareRootMeterPrefixes, cReciprocalSquareRootMeterExponents);
{$ENDIF}
end;

function ReciprocalMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalMeter then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsReciprocalMeterSymbol, cReciprocalMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsReciprocalMeterSymbol, cReciprocalMeterPrefixes);
{$ENDIF}
end;

function ReciprocalMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalMeter then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cReciprocalMeterPrefixes, cReciprocalMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cReciprocalMeterPrefixes, cReciprocalMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsReciprocalMeterSymbol, cReciprocalMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsReciprocalMeterSymbol, APrefixes);
end;

function ReciprocalMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := ReciprocalMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := ReciprocalMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsReciprocalMeterSymbol, cReciprocalMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsReciprocalMeterSymbol, APrefixes);
  end;
end;

function ReciprocalMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsReciprocalMeterName, cReciprocalMeterPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsReciprocalMeterPluralName, cReciprocalMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsReciprocalMeterName, cReciprocalMeterPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsReciprocalMeterPluralName, cReciprocalMeterPrefixes);
{$ENDIF}
end;

function ReciprocalMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsReciprocalMeterName, cReciprocalMeterPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsReciprocalMeterPluralName, cReciprocalMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsReciprocalMeterName, cReciprocalMeterPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsReciprocalMeterPluralName, cReciprocalMeterPrefixes);
{$ENDIF}
end;

function ReciprocalMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := ReciprocalMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := ReciprocalMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsReciprocalMeterSymbol, cReciprocalMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsReciprocalMeterSymbol, APrefixes);
  end;
end;

function ReciprocalMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalMeter then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function ReciprocalMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalMeter then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cReciprocalMeterPrefixes, cReciprocalMeterExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cReciprocalMeterPrefixes, cReciprocalMeterExponents);
{$ENDIF}
end;

function DioptreToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalMeter then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsDioptreSymbol, cDioptrePrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsDioptreSymbol, cDioptrePrefixes);
{$ENDIF}
end;

function DioptreToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalMeter then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cDioptrePrefixes, cDioptreExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cDioptrePrefixes, cDioptreExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsDioptreSymbol, cDioptrePrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsDioptreSymbol, APrefixes);
end;

function DioptreToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := DioptreToFloat(AQuantity, APrefixes);
  FactoredTol   := DioptreToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsDioptreSymbol, cDioptrePrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsDioptreSymbol, APrefixes);
  end;
end;

function DioptreToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalMeter then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cDioptreFactor) + ' ' + GetName(rsDioptreName, cDioptrePrefixes)
  else
    result := FloatToStr(AValue.FValue / cDioptreFactor) + ' ' + GetName(rsDioptrePluralName, cDioptrePrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cDioptreFactor) + ' ' + GetName(rsDioptreName, cDioptrePrefixes)
  else
    result := FloatToStr(AValue / cDioptreFactor) + ' ' + GetName(rsDioptrePluralName, cDioptrePrefixes);
  result := '';
{$ENDIF}
end;

function DioptreToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalMeter then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cDioptreFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsDioptreName, cDioptrePrefixes)
  else
    result := FloatToStrF(AValue.FValue / cDioptreFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsDioptrePluralName, cDioptrePrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cDioptreFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsDioptreName, cDioptrePrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cDioptreFactor, rsDioptrePluralName);
{$ENDIF}
end;

function DioptreToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalMeter then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function DioptreToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalMeter then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cDioptrePrefixes, cDioptreExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cDioptrePrefixes, cDioptreExponents);
{$ENDIF}
end;

function ReciprocalSquareRootCubicMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalSquareRootCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsReciprocalSquareRootCubicMeterSymbol, cReciprocalSquareRootCubicMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsReciprocalSquareRootCubicMeterSymbol, cReciprocalSquareRootCubicMeterPrefixes);
{$ENDIF}
end;

function ReciprocalSquareRootCubicMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalSquareRootCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cReciprocalSquareRootCubicMeterPrefixes, cReciprocalSquareRootCubicMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cReciprocalSquareRootCubicMeterPrefixes, cReciprocalSquareRootCubicMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsReciprocalSquareRootCubicMeterSymbol, cReciprocalSquareRootCubicMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsReciprocalSquareRootCubicMeterSymbol, APrefixes);
end;

function ReciprocalSquareRootCubicMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := ReciprocalSquareRootCubicMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := ReciprocalSquareRootCubicMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsReciprocalSquareRootCubicMeterSymbol, cReciprocalSquareRootCubicMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsReciprocalSquareRootCubicMeterSymbol, APrefixes);
  end;
end;

function ReciprocalSquareRootCubicMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalSquareRootCubicMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsReciprocalSquareRootCubicMeterName, cReciprocalSquareRootCubicMeterPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsReciprocalSquareRootCubicMeterPluralName, cReciprocalSquareRootCubicMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsReciprocalSquareRootCubicMeterName, cReciprocalSquareRootCubicMeterPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsReciprocalSquareRootCubicMeterPluralName, cReciprocalSquareRootCubicMeterPrefixes);
{$ENDIF}
end;

function ReciprocalSquareRootCubicMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalSquareRootCubicMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsReciprocalSquareRootCubicMeterName, cReciprocalSquareRootCubicMeterPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsReciprocalSquareRootCubicMeterPluralName, cReciprocalSquareRootCubicMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsReciprocalSquareRootCubicMeterName, cReciprocalSquareRootCubicMeterPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsReciprocalSquareRootCubicMeterPluralName, cReciprocalSquareRootCubicMeterPrefixes);
{$ENDIF}
end;

function ReciprocalSquareRootCubicMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := ReciprocalSquareRootCubicMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := ReciprocalSquareRootCubicMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsReciprocalSquareRootCubicMeterSymbol, cReciprocalSquareRootCubicMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsReciprocalSquareRootCubicMeterSymbol, APrefixes);
  end;
end;

function ReciprocalSquareRootCubicMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalSquareRootCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function ReciprocalSquareRootCubicMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalSquareRootCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cReciprocalSquareRootCubicMeterPrefixes, cReciprocalSquareRootCubicMeterExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cReciprocalSquareRootCubicMeterPrefixes, cReciprocalSquareRootCubicMeterExponents);
{$ENDIF}
end;

function ReciprocalSquareMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalSquareMeter then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsReciprocalSquareMeterSymbol, cReciprocalSquareMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsReciprocalSquareMeterSymbol, cReciprocalSquareMeterPrefixes);
{$ENDIF}
end;

function ReciprocalSquareMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalSquareMeter then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cReciprocalSquareMeterPrefixes, cReciprocalSquareMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cReciprocalSquareMeterPrefixes, cReciprocalSquareMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsReciprocalSquareMeterSymbol, cReciprocalSquareMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsReciprocalSquareMeterSymbol, APrefixes);
end;

function ReciprocalSquareMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := ReciprocalSquareMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := ReciprocalSquareMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsReciprocalSquareMeterSymbol, cReciprocalSquareMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsReciprocalSquareMeterSymbol, APrefixes);
  end;
end;

function ReciprocalSquareMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalSquareMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsReciprocalSquareMeterName, cReciprocalSquareMeterPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsReciprocalSquareMeterPluralName, cReciprocalSquareMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsReciprocalSquareMeterName, cReciprocalSquareMeterPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsReciprocalSquareMeterPluralName, cReciprocalSquareMeterPrefixes);
{$ENDIF}
end;

function ReciprocalSquareMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalSquareMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsReciprocalSquareMeterName, cReciprocalSquareMeterPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsReciprocalSquareMeterPluralName, cReciprocalSquareMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsReciprocalSquareMeterName, cReciprocalSquareMeterPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsReciprocalSquareMeterPluralName, cReciprocalSquareMeterPrefixes);
{$ENDIF}
end;

function ReciprocalSquareMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := ReciprocalSquareMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := ReciprocalSquareMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsReciprocalSquareMeterSymbol, cReciprocalSquareMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsReciprocalSquareMeterSymbol, APrefixes);
  end;
end;

function ReciprocalSquareMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalSquareMeter then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function ReciprocalSquareMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalSquareMeter then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cReciprocalSquareMeterPrefixes, cReciprocalSquareMeterExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cReciprocalSquareMeterPrefixes, cReciprocalSquareMeterExponents);
{$ENDIF}
end;

function ReciprocalCubicMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsReciprocalCubicMeterSymbol, cReciprocalCubicMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsReciprocalCubicMeterSymbol, cReciprocalCubicMeterPrefixes);
{$ENDIF}
end;

function ReciprocalCubicMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cReciprocalCubicMeterPrefixes, cReciprocalCubicMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cReciprocalCubicMeterPrefixes, cReciprocalCubicMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsReciprocalCubicMeterSymbol, cReciprocalCubicMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsReciprocalCubicMeterSymbol, APrefixes);
end;

function ReciprocalCubicMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := ReciprocalCubicMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := ReciprocalCubicMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsReciprocalCubicMeterSymbol, cReciprocalCubicMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsReciprocalCubicMeterSymbol, APrefixes);
  end;
end;

function ReciprocalCubicMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalCubicMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsReciprocalCubicMeterName, cReciprocalCubicMeterPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsReciprocalCubicMeterPluralName, cReciprocalCubicMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsReciprocalCubicMeterName, cReciprocalCubicMeterPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsReciprocalCubicMeterPluralName, cReciprocalCubicMeterPrefixes);
{$ENDIF}
end;

function ReciprocalCubicMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalCubicMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsReciprocalCubicMeterName, cReciprocalCubicMeterPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsReciprocalCubicMeterPluralName, cReciprocalCubicMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsReciprocalCubicMeterName, cReciprocalCubicMeterPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsReciprocalCubicMeterPluralName, cReciprocalCubicMeterPrefixes);
{$ENDIF}
end;

function ReciprocalCubicMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := ReciprocalCubicMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := ReciprocalCubicMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsReciprocalCubicMeterSymbol, cReciprocalCubicMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsReciprocalCubicMeterSymbol, APrefixes);
  end;
end;

function ReciprocalCubicMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function ReciprocalCubicMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cReciprocalCubicMeterPrefixes, cReciprocalCubicMeterExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cReciprocalCubicMeterPrefixes, cReciprocalCubicMeterExponents);
{$ENDIF}
end;

function ReciprocalQuarticMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalQuarticMeter then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsReciprocalQuarticMeterSymbol, cReciprocalQuarticMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsReciprocalQuarticMeterSymbol, cReciprocalQuarticMeterPrefixes);
{$ENDIF}
end;

function ReciprocalQuarticMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalQuarticMeter then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cReciprocalQuarticMeterPrefixes, cReciprocalQuarticMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cReciprocalQuarticMeterPrefixes, cReciprocalQuarticMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsReciprocalQuarticMeterSymbol, cReciprocalQuarticMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsReciprocalQuarticMeterSymbol, APrefixes);
end;

function ReciprocalQuarticMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := ReciprocalQuarticMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := ReciprocalQuarticMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsReciprocalQuarticMeterSymbol, cReciprocalQuarticMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsReciprocalQuarticMeterSymbol, APrefixes);
  end;
end;

function ReciprocalQuarticMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalQuarticMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsReciprocalQuarticMeterName, cReciprocalQuarticMeterPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsReciprocalQuarticMeterPluralName, cReciprocalQuarticMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsReciprocalQuarticMeterName, cReciprocalQuarticMeterPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsReciprocalQuarticMeterPluralName, cReciprocalQuarticMeterPrefixes);
{$ENDIF}
end;

function ReciprocalQuarticMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalQuarticMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsReciprocalQuarticMeterName, cReciprocalQuarticMeterPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsReciprocalQuarticMeterPluralName, cReciprocalQuarticMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsReciprocalQuarticMeterName, cReciprocalQuarticMeterPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsReciprocalQuarticMeterPluralName, cReciprocalQuarticMeterPrefixes);
{$ENDIF}
end;

function ReciprocalQuarticMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := ReciprocalQuarticMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := ReciprocalQuarticMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsReciprocalQuarticMeterSymbol, cReciprocalQuarticMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsReciprocalQuarticMeterSymbol, APrefixes);
  end;
end;

function ReciprocalQuarticMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalQuarticMeter then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function ReciprocalQuarticMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalQuarticMeter then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cReciprocalQuarticMeterPrefixes, cReciprocalQuarticMeterExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cReciprocalQuarticMeterPrefixes, cReciprocalQuarticMeterExponents);
{$ENDIF}
end;

function KilogramSquareMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareMeter then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsKilogramSquareMeterSymbol, cKilogramSquareMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsKilogramSquareMeterSymbol, cKilogramSquareMeterPrefixes);
{$ENDIF}
end;

function KilogramSquareMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareMeter then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cKilogramSquareMeterPrefixes, cKilogramSquareMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cKilogramSquareMeterPrefixes, cKilogramSquareMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramSquareMeterSymbol, cKilogramSquareMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramSquareMeterSymbol, APrefixes);
end;

function KilogramSquareMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := KilogramSquareMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := KilogramSquareMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramSquareMeterSymbol, cKilogramSquareMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsKilogramSquareMeterSymbol, APrefixes);
  end;
end;

function KilogramSquareMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsKilogramSquareMeterName, cKilogramSquareMeterPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsKilogramSquareMeterPluralName, cKilogramSquareMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsKilogramSquareMeterName, cKilogramSquareMeterPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsKilogramSquareMeterPluralName, cKilogramSquareMeterPrefixes);
{$ENDIF}
end;

function KilogramSquareMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramSquareMeterName, cKilogramSquareMeterPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramSquareMeterPluralName, cKilogramSquareMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramSquareMeterName, cKilogramSquareMeterPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramSquareMeterPluralName, cKilogramSquareMeterPrefixes);
{$ENDIF}
end;

function KilogramSquareMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := KilogramSquareMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := KilogramSquareMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramSquareMeterSymbol, cKilogramSquareMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsKilogramSquareMeterSymbol, APrefixes);
  end;
end;

function KilogramSquareMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareMeter then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function KilogramSquareMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareMeter then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cKilogramSquareMeterPrefixes, cKilogramSquareMeterExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cKilogramSquareMeterPrefixes, cKilogramSquareMeterExponents);
{$ENDIF}
end;

function KilogramSquareMeterPerSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsKilogramSquareMeterPerSecondSymbol, cKilogramSquareMeterPerSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsKilogramSquareMeterPerSecondSymbol, cKilogramSquareMeterPerSecondPrefixes);
{$ENDIF}
end;

function KilogramSquareMeterPerSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cKilogramSquareMeterPerSecondPrefixes, cKilogramSquareMeterPerSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cKilogramSquareMeterPerSecondPrefixes, cKilogramSquareMeterPerSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramSquareMeterPerSecondSymbol, cKilogramSquareMeterPerSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramSquareMeterPerSecondSymbol, APrefixes);
end;

function KilogramSquareMeterPerSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := KilogramSquareMeterPerSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := KilogramSquareMeterPerSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramSquareMeterPerSecondSymbol, cKilogramSquareMeterPerSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsKilogramSquareMeterPerSecondSymbol, APrefixes);
  end;
end;

function KilogramSquareMeterPerSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsKilogramSquareMeterPerSecondName, cKilogramSquareMeterPerSecondPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsKilogramSquareMeterPerSecondPluralName, cKilogramSquareMeterPerSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsKilogramSquareMeterPerSecondName, cKilogramSquareMeterPerSecondPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsKilogramSquareMeterPerSecondPluralName, cKilogramSquareMeterPerSecondPrefixes);
{$ENDIF}
end;

function KilogramSquareMeterPerSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramSquareMeterPerSecondName, cKilogramSquareMeterPerSecondPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramSquareMeterPerSecondPluralName, cKilogramSquareMeterPerSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramSquareMeterPerSecondName, cKilogramSquareMeterPerSecondPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramSquareMeterPerSecondPluralName, cKilogramSquareMeterPerSecondPrefixes);
{$ENDIF}
end;

function KilogramSquareMeterPerSecondToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := KilogramSquareMeterPerSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := KilogramSquareMeterPerSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramSquareMeterPerSecondSymbol, cKilogramSquareMeterPerSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsKilogramSquareMeterPerSecondSymbol, APrefixes);
  end;
end;

function KilogramSquareMeterPerSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function KilogramSquareMeterPerSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cKilogramSquareMeterPerSecondPrefixes, cKilogramSquareMeterPerSecondExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cKilogramSquareMeterPerSecondPrefixes, cKilogramSquareMeterPerSecondExponents);
{$ENDIF}
end;

function NewtonMeterSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsNewtonMeterSecondSymbol, cNewtonMeterSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsNewtonMeterSecondSymbol, cNewtonMeterSecondPrefixes);
{$ENDIF}
end;

function NewtonMeterSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cNewtonMeterSecondPrefixes, cNewtonMeterSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cNewtonMeterSecondPrefixes, cNewtonMeterSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonMeterSecondSymbol, cNewtonMeterSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonMeterSecondSymbol, APrefixes);
end;

function NewtonMeterSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := NewtonMeterSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := NewtonMeterSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonMeterSecondSymbol, cNewtonMeterSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsNewtonMeterSecondSymbol, APrefixes);
  end;
end;

function NewtonMeterSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cNewtonMeterSecondFactor) + ' ' + GetName(rsNewtonMeterSecondName, cNewtonMeterSecondPrefixes)
  else
    result := FloatToStr(AValue.FValue / cNewtonMeterSecondFactor) + ' ' + GetName(rsNewtonMeterSecondPluralName, cNewtonMeterSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cNewtonMeterSecondFactor) + ' ' + GetName(rsNewtonMeterSecondName, cNewtonMeterSecondPrefixes)
  else
    result := FloatToStr(AValue / cNewtonMeterSecondFactor) + ' ' + GetName(rsNewtonMeterSecondPluralName, cNewtonMeterSecondPrefixes);
  result := '';
{$ENDIF}
end;

function NewtonMeterSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cNewtonMeterSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNewtonMeterSecondName, cNewtonMeterSecondPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cNewtonMeterSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNewtonMeterSecondPluralName, cNewtonMeterSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cNewtonMeterSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNewtonMeterSecondName, cNewtonMeterSecondPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cNewtonMeterSecondFactor, rsNewtonMeterSecondPluralName);
{$ENDIF}
end;

function NewtonMeterSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function NewtonMeterSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cNewtonMeterSecondPrefixes, cNewtonMeterSecondExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cNewtonMeterSecondPrefixes, cNewtonMeterSecondExponents);
{$ENDIF}
end;

function SecondPerMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSecondPerMeter then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsSecondPerMeterSymbol, cSecondPerMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsSecondPerMeterSymbol, cSecondPerMeterPrefixes);
{$ENDIF}
end;

function SecondPerMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSecondPerMeter then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSecondPerMeterPrefixes, cSecondPerMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSecondPerMeterPrefixes, cSecondPerMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSecondPerMeterSymbol, cSecondPerMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSecondPerMeterSymbol, APrefixes);
end;

function SecondPerMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SecondPerMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := SecondPerMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSecondPerMeterSymbol, cSecondPerMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsSecondPerMeterSymbol, APrefixes);
  end;
end;

function SecondPerMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSecondPerMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsSecondPerMeterName, cSecondPerMeterPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsSecondPerMeterPluralName, cSecondPerMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsSecondPerMeterName, cSecondPerMeterPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsSecondPerMeterPluralName, cSecondPerMeterPrefixes);
{$ENDIF}
end;

function SecondPerMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSecondPerMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSecondPerMeterName, cSecondPerMeterPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSecondPerMeterPluralName, cSecondPerMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSecondPerMeterName, cSecondPerMeterPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSecondPerMeterPluralName, cSecondPerMeterPrefixes);
{$ENDIF}
end;

function SecondPerMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SecondPerMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := SecondPerMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSecondPerMeterSymbol, cSecondPerMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsSecondPerMeterSymbol, APrefixes);
  end;
end;

function SecondPerMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSecondPerMeter then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function SecondPerMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSecondPerMeter then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cSecondPerMeterPrefixes, cSecondPerMeterExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cSecondPerMeterPrefixes, cSecondPerMeterExponents);
{$ENDIF}
end;

function KilogramPerMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerMeter then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsKilogramPerMeterSymbol, cKilogramPerMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsKilogramPerMeterSymbol, cKilogramPerMeterPrefixes);
{$ENDIF}
end;

function KilogramPerMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerMeter then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cKilogramPerMeterPrefixes, cKilogramPerMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cKilogramPerMeterPrefixes, cKilogramPerMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramPerMeterSymbol, cKilogramPerMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramPerMeterSymbol, APrefixes);
end;

function KilogramPerMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := KilogramPerMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := KilogramPerMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramPerMeterSymbol, cKilogramPerMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsKilogramPerMeterSymbol, APrefixes);
  end;
end;

function KilogramPerMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsKilogramPerMeterName, cKilogramPerMeterPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsKilogramPerMeterPluralName, cKilogramPerMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsKilogramPerMeterName, cKilogramPerMeterPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsKilogramPerMeterPluralName, cKilogramPerMeterPrefixes);
{$ENDIF}
end;

function KilogramPerMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramPerMeterName, cKilogramPerMeterPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramPerMeterPluralName, cKilogramPerMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramPerMeterName, cKilogramPerMeterPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramPerMeterPluralName, cKilogramPerMeterPrefixes);
{$ENDIF}
end;

function KilogramPerMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := KilogramPerMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := KilogramPerMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramPerMeterSymbol, cKilogramPerMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsKilogramPerMeterSymbol, APrefixes);
  end;
end;

function KilogramPerMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerMeter then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function KilogramPerMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerMeter then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cKilogramPerMeterPrefixes, cKilogramPerMeterExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cKilogramPerMeterPrefixes, cKilogramPerMeterExponents);
{$ENDIF}
end;

function KilogramPerSquareMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerSquareMeter then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsKilogramPerSquareMeterSymbol, cKilogramPerSquareMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsKilogramPerSquareMeterSymbol, cKilogramPerSquareMeterPrefixes);
{$ENDIF}
end;

function KilogramPerSquareMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerSquareMeter then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cKilogramPerSquareMeterPrefixes, cKilogramPerSquareMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cKilogramPerSquareMeterPrefixes, cKilogramPerSquareMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramPerSquareMeterSymbol, cKilogramPerSquareMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramPerSquareMeterSymbol, APrefixes);
end;

function KilogramPerSquareMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := KilogramPerSquareMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := KilogramPerSquareMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramPerSquareMeterSymbol, cKilogramPerSquareMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsKilogramPerSquareMeterSymbol, APrefixes);
  end;
end;

function KilogramPerSquareMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerSquareMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsKilogramPerSquareMeterName, cKilogramPerSquareMeterPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsKilogramPerSquareMeterPluralName, cKilogramPerSquareMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsKilogramPerSquareMeterName, cKilogramPerSquareMeterPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsKilogramPerSquareMeterPluralName, cKilogramPerSquareMeterPrefixes);
{$ENDIF}
end;

function KilogramPerSquareMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerSquareMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramPerSquareMeterName, cKilogramPerSquareMeterPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramPerSquareMeterPluralName, cKilogramPerSquareMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramPerSquareMeterName, cKilogramPerSquareMeterPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramPerSquareMeterPluralName, cKilogramPerSquareMeterPrefixes);
{$ENDIF}
end;

function KilogramPerSquareMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := KilogramPerSquareMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := KilogramPerSquareMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramPerSquareMeterSymbol, cKilogramPerSquareMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsKilogramPerSquareMeterSymbol, APrefixes);
  end;
end;

function KilogramPerSquareMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerSquareMeter then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function KilogramPerSquareMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerSquareMeter then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cKilogramPerSquareMeterPrefixes, cKilogramPerSquareMeterExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cKilogramPerSquareMeterPrefixes, cKilogramPerSquareMeterExponents);
{$ENDIF}
end;

function KilogramPerCubicMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsKilogramPerCubicMeterSymbol, cKilogramPerCubicMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsKilogramPerCubicMeterSymbol, cKilogramPerCubicMeterPrefixes);
{$ENDIF}
end;

function KilogramPerCubicMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cKilogramPerCubicMeterPrefixes, cKilogramPerCubicMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cKilogramPerCubicMeterPrefixes, cKilogramPerCubicMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramPerCubicMeterSymbol, cKilogramPerCubicMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramPerCubicMeterSymbol, APrefixes);
end;

function KilogramPerCubicMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := KilogramPerCubicMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := KilogramPerCubicMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramPerCubicMeterSymbol, cKilogramPerCubicMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsKilogramPerCubicMeterSymbol, APrefixes);
  end;
end;

function KilogramPerCubicMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerCubicMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsKilogramPerCubicMeterName, cKilogramPerCubicMeterPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsKilogramPerCubicMeterPluralName, cKilogramPerCubicMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsKilogramPerCubicMeterName, cKilogramPerCubicMeterPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsKilogramPerCubicMeterPluralName, cKilogramPerCubicMeterPrefixes);
{$ENDIF}
end;

function KilogramPerCubicMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerCubicMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramPerCubicMeterName, cKilogramPerCubicMeterPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramPerCubicMeterPluralName, cKilogramPerCubicMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramPerCubicMeterName, cKilogramPerCubicMeterPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramPerCubicMeterPluralName, cKilogramPerCubicMeterPrefixes);
{$ENDIF}
end;

function KilogramPerCubicMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := KilogramPerCubicMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := KilogramPerCubicMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramPerCubicMeterSymbol, cKilogramPerCubicMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsKilogramPerCubicMeterSymbol, APrefixes);
  end;
end;

function KilogramPerCubicMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function KilogramPerCubicMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cKilogramPerCubicMeterPrefixes, cKilogramPerCubicMeterExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cKilogramPerCubicMeterPrefixes, cKilogramPerCubicMeterExponents);
{$ENDIF}
end;

function PoundPerCubicInchToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue / cPoundPerCubicInchFactor) + ' ' + GetSymbol(rsPoundPerCubicInchSymbol, cPoundPerCubicInchPrefixes);
{$ENDIF}
  result := FloatToStr(AValue / cPoundPerCubicInchFactor) + ' ' + GetSymbol(rsPoundPerCubicInchSymbol, cPoundPerCubicInchPrefixes);
end;

function PoundPerCubicInchToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue / cPoundPerCubicInchFactor, APrefixes, cPoundPerCubicInchPrefixes, cPoundPerCubicInchExponents);
{$ELSE}
  FactoredValue := GetValue(AValue / cPoundPerCubicInchFactor, APrefixes, cPoundPerCubicInchPrefixes, cPoundPerCubicInchExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsPoundPerCubicInchSymbol, cPoundPerCubicInchPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsPoundPerCubicInchSymbol, APrefixes);
end;

function cPoundPerCubicInchToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := PoundPerCubicInchToFloat(AQuantity / cPoundPerCubicInchFactor, APrefixes);
  FactoredTol   := PoundPerCubicInchToFloat(ATolerance / cPoundPerCubicInchFactor, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsPoundPerCubicInchSymbol, cPoundPerCubicInchPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsPoundPerCubicInchSymbol, APrefixes);
  end;
end;

function PoundPerCubicInchToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cPoundPerCubicInchFactor) + ' ' + GetName(rsPoundPerCubicInchName, cPoundPerCubicInchPrefixes)
  else
    result := FloatToStr(AValue.FValue / cPoundPerCubicInchFactor) + ' ' + GetName(rsPoundPerCubicInchPluralName, cPoundPerCubicInchPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cPoundPerCubicInchFactor) + ' ' + GetName(rsPoundPerCubicInchName, cPoundPerCubicInchPrefixes)
  else
    result := FloatToStr(AValue / cPoundPerCubicInchFactor) + ' ' + GetName(rsPoundPerCubicInchPluralName, cPoundPerCubicInchPrefixes);
  result := '';
{$ENDIF}
end;

function PoundPerCubicInchToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cPoundPerCubicInchFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsPoundPerCubicInchName, cPoundPerCubicInchPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cPoundPerCubicInchFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsPoundPerCubicInchPluralName, cPoundPerCubicInchPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cPoundPerCubicInchFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsPoundPerCubicInchName, cPoundPerCubicInchPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cPoundPerCubicInchFactor, rsPoundPerCubicInchPluralName);
{$ENDIF}
end;

function PoundPerCubicInchToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue * cPoundPerCubicInchFactor;
{$ELSE}
  result := AValue * cPoundPerCubicInchFactor;
{$ENDIF}
end;

function PoundPerCubicInchToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue * cPoundPerCubicInchFactor, APrefixes, cPoundPerCubicInchPrefixes, cPoundPerCubicInchExponents);
{$ELSE}
  result := GetValue(AValue * cPoundPerCubicInchFactor, APrefixes, cPoundPerCubicInchPrefixes, cPoundPerCubicInchExponents);
{$ENDIF}
end;

function NewtonToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewton then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsNewtonSymbol, cNewtonPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsNewtonSymbol, cNewtonPrefixes);
{$ENDIF}
end;

function NewtonToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewton then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cNewtonPrefixes, cNewtonExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cNewtonPrefixes, cNewtonExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonSymbol, cNewtonPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonSymbol, APrefixes);
end;

function NewtonToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := NewtonToFloat(AQuantity, APrefixes);
  FactoredTol   := NewtonToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonSymbol, cNewtonPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsNewtonSymbol, APrefixes);
  end;
end;

function NewtonToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewton then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsNewtonName, cNewtonPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsNewtonPluralName, cNewtonPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsNewtonName, cNewtonPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsNewtonPluralName, cNewtonPrefixes);
{$ENDIF}
end;

function NewtonToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewton then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNewtonName, cNewtonPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNewtonPluralName, cNewtonPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNewtonName, cNewtonPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNewtonPluralName, cNewtonPrefixes);
{$ENDIF}
end;

function NewtonToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := NewtonToFloat(AQuantity, APrefixes);
  FactoredTol   := NewtonToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNewtonSymbol, cNewtonPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsNewtonSymbol, APrefixes);
  end;
end;

function NewtonToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewton then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function NewtonToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewton then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cNewtonPrefixes, cNewtonExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cNewtonPrefixes, cNewtonExponents);
{$ENDIF}
end;

function PoundForceToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewton then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue / cPoundForceFactor) + ' ' + GetSymbol(rsPoundForceSymbol, cPoundForcePrefixes);
{$ENDIF}
  result := FloatToStr(AValue / cPoundForceFactor) + ' ' + GetSymbol(rsPoundForceSymbol, cPoundForcePrefixes);
end;

function PoundForceToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewton then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue / cPoundForceFactor, APrefixes, cPoundForcePrefixes, cPoundForceExponents);
{$ELSE}
  FactoredValue := GetValue(AValue / cPoundForceFactor, APrefixes, cPoundForcePrefixes, cPoundForceExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsPoundForceSymbol, cPoundForcePrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsPoundForceSymbol, APrefixes);
end;

function cPoundForceToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := PoundForceToFloat(AQuantity / cPoundForceFactor, APrefixes);
  FactoredTol   := PoundForceToFloat(ATolerance / cPoundForceFactor, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsPoundForceSymbol, cPoundForcePrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsPoundForceSymbol, APrefixes);
  end;
end;

function PoundForceToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewton then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cPoundForceFactor) + ' ' + GetName(rsPoundForceName, cPoundForcePrefixes)
  else
    result := FloatToStr(AValue.FValue / cPoundForceFactor) + ' ' + GetName(rsPoundForcePluralName, cPoundForcePrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cPoundForceFactor) + ' ' + GetName(rsPoundForceName, cPoundForcePrefixes)
  else
    result := FloatToStr(AValue / cPoundForceFactor) + ' ' + GetName(rsPoundForcePluralName, cPoundForcePrefixes);
  result := '';
{$ENDIF}
end;

function PoundForceToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewton then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cPoundForceFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsPoundForceName, cPoundForcePrefixes)
  else
    result := FloatToStrF(AValue.FValue / cPoundForceFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsPoundForcePluralName, cPoundForcePrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cPoundForceFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsPoundForceName, cPoundForcePrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cPoundForceFactor, rsPoundForcePluralName);
{$ENDIF}
end;

function PoundForceToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewton then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue * cPoundForceFactor;
{$ELSE}
  result := AValue * cPoundForceFactor;
{$ENDIF}
end;

function PoundForceToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewton then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue * cPoundForceFactor, APrefixes, cPoundForcePrefixes, cPoundForceExponents);
{$ELSE}
  result := GetValue(AValue * cPoundForceFactor, APrefixes, cPoundForcePrefixes, cPoundForceExponents);
{$ENDIF}
end;

function KilogramMeterPerSquareSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewton then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsKilogramMeterPerSquareSecondSymbol, cKilogramMeterPerSquareSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsKilogramMeterPerSquareSecondSymbol, cKilogramMeterPerSquareSecondPrefixes);
{$ENDIF}
end;

function KilogramMeterPerSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewton then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cKilogramMeterPerSquareSecondPrefixes, cKilogramMeterPerSquareSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cKilogramMeterPerSquareSecondPrefixes, cKilogramMeterPerSquareSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramMeterPerSquareSecondSymbol, cKilogramMeterPerSquareSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramMeterPerSquareSecondSymbol, APrefixes);
end;

function KilogramMeterPerSquareSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := KilogramMeterPerSquareSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := KilogramMeterPerSquareSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramMeterPerSquareSecondSymbol, cKilogramMeterPerSquareSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsKilogramMeterPerSquareSecondSymbol, APrefixes);
  end;
end;

function KilogramMeterPerSquareSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewton then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cKilogramMeterPerSquareSecondFactor) + ' ' + GetName(rsKilogramMeterPerSquareSecondName, cKilogramMeterPerSquareSecondPrefixes)
  else
    result := FloatToStr(AValue.FValue / cKilogramMeterPerSquareSecondFactor) + ' ' + GetName(rsKilogramMeterPerSquareSecondPluralName, cKilogramMeterPerSquareSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cKilogramMeterPerSquareSecondFactor) + ' ' + GetName(rsKilogramMeterPerSquareSecondName, cKilogramMeterPerSquareSecondPrefixes)
  else
    result := FloatToStr(AValue / cKilogramMeterPerSquareSecondFactor) + ' ' + GetName(rsKilogramMeterPerSquareSecondPluralName, cKilogramMeterPerSquareSecondPrefixes);
  result := '';
{$ENDIF}
end;

function KilogramMeterPerSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewton then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cKilogramMeterPerSquareSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramMeterPerSquareSecondName, cKilogramMeterPerSquareSecondPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cKilogramMeterPerSquareSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramMeterPerSquareSecondPluralName, cKilogramMeterPerSquareSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cKilogramMeterPerSquareSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramMeterPerSquareSecondName, cKilogramMeterPerSquareSecondPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cKilogramMeterPerSquareSecondFactor, rsKilogramMeterPerSquareSecondPluralName);
{$ENDIF}
end;

function KilogramMeterPerSquareSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewton then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function KilogramMeterPerSquareSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewton then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cKilogramMeterPerSquareSecondPrefixes, cKilogramMeterPerSquareSecondExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cKilogramMeterPerSquareSecondPrefixes, cKilogramMeterPerSquareSecondExponents);
{$ENDIF}
end;

function NewtonRadianToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonRadian then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsNewtonRadianSymbol, cNewtonRadianPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsNewtonRadianSymbol, cNewtonRadianPrefixes);
{$ENDIF}
end;

function NewtonRadianToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonRadian then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cNewtonRadianPrefixes, cNewtonRadianExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cNewtonRadianPrefixes, cNewtonRadianExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonRadianSymbol, cNewtonRadianPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonRadianSymbol, APrefixes);
end;

function NewtonRadianToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := NewtonRadianToFloat(AQuantity, APrefixes);
  FactoredTol   := NewtonRadianToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonRadianSymbol, cNewtonRadianPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsNewtonRadianSymbol, APrefixes);
  end;
end;

function NewtonRadianToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonRadian then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsNewtonRadianName, cNewtonRadianPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsNewtonRadianPluralName, cNewtonRadianPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsNewtonRadianName, cNewtonRadianPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsNewtonRadianPluralName, cNewtonRadianPrefixes);
{$ENDIF}
end;

function NewtonRadianToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonRadian then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNewtonRadianName, cNewtonRadianPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNewtonRadianPluralName, cNewtonRadianPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNewtonRadianName, cNewtonRadianPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNewtonRadianPluralName, cNewtonRadianPrefixes);
{$ENDIF}
end;

function NewtonRadianToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := NewtonRadianToFloat(AQuantity, APrefixes);
  FactoredTol   := NewtonRadianToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNewtonRadianSymbol, cNewtonRadianPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsNewtonRadianSymbol, APrefixes);
  end;
end;

function NewtonRadianToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonRadian then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function NewtonRadianToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonRadian then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cNewtonRadianPrefixes, cNewtonRadianExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cNewtonRadianPrefixes, cNewtonRadianExponents);
{$ENDIF}
end;

function SquareNewtonToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareNewton then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsSquareNewtonSymbol, cSquareNewtonPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsSquareNewtonSymbol, cSquareNewtonPrefixes);
{$ENDIF}
end;

function SquareNewtonToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareNewton then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSquareNewtonPrefixes, cSquareNewtonExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSquareNewtonPrefixes, cSquareNewtonExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareNewtonSymbol, cSquareNewtonPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareNewtonSymbol, APrefixes);
end;

function SquareNewtonToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SquareNewtonToFloat(AQuantity, APrefixes);
  FactoredTol   := SquareNewtonToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareNewtonSymbol, cSquareNewtonPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsSquareNewtonSymbol, APrefixes);
  end;
end;

function SquareNewtonToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareNewton then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsSquareNewtonName, cSquareNewtonPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsSquareNewtonPluralName, cSquareNewtonPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsSquareNewtonName, cSquareNewtonPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsSquareNewtonPluralName, cSquareNewtonPrefixes);
{$ENDIF}
end;

function SquareNewtonToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareNewton then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareNewtonName, cSquareNewtonPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareNewtonPluralName, cSquareNewtonPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareNewtonName, cSquareNewtonPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareNewtonPluralName, cSquareNewtonPrefixes);
{$ENDIF}
end;

function SquareNewtonToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SquareNewtonToFloat(AQuantity, APrefixes);
  FactoredTol   := SquareNewtonToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareNewtonSymbol, cSquareNewtonPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsSquareNewtonSymbol, APrefixes);
  end;
end;

function SquareNewtonToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareNewton then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function SquareNewtonToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareNewton then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cSquareNewtonPrefixes, cSquareNewtonExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cSquareNewtonPrefixes, cSquareNewtonExponents);
{$ENDIF}
end;

function SquareKilogramSquareMeterPerQuarticSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareNewton then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsSquareKilogramSquareMeterPerQuarticSecondSymbol, cSquareKilogramSquareMeterPerQuarticSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsSquareKilogramSquareMeterPerQuarticSecondSymbol, cSquareKilogramSquareMeterPerQuarticSecondPrefixes);
{$ENDIF}
end;

function SquareKilogramSquareMeterPerQuarticSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareNewton then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSquareKilogramSquareMeterPerQuarticSecondPrefixes, cSquareKilogramSquareMeterPerQuarticSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSquareKilogramSquareMeterPerQuarticSecondPrefixes, cSquareKilogramSquareMeterPerQuarticSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareKilogramSquareMeterPerQuarticSecondSymbol, cSquareKilogramSquareMeterPerQuarticSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareKilogramSquareMeterPerQuarticSecondSymbol, APrefixes);
end;

function SquareKilogramSquareMeterPerQuarticSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SquareKilogramSquareMeterPerQuarticSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := SquareKilogramSquareMeterPerQuarticSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareKilogramSquareMeterPerQuarticSecondSymbol, cSquareKilogramSquareMeterPerQuarticSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsSquareKilogramSquareMeterPerQuarticSecondSymbol, APrefixes);
  end;
end;

function SquareKilogramSquareMeterPerQuarticSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareNewton then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cSquareKilogramSquareMeterPerQuarticSecondFactor) + ' ' + GetName(rsSquareKilogramSquareMeterPerQuarticSecondName, cSquareKilogramSquareMeterPerQuarticSecondPrefixes)
  else
    result := FloatToStr(AValue.FValue / cSquareKilogramSquareMeterPerQuarticSecondFactor) + ' ' + GetName(rsSquareKilogramSquareMeterPerQuarticSecondPluralName, cSquareKilogramSquareMeterPerQuarticSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cSquareKilogramSquareMeterPerQuarticSecondFactor) + ' ' + GetName(rsSquareKilogramSquareMeterPerQuarticSecondName, cSquareKilogramSquareMeterPerQuarticSecondPrefixes)
  else
    result := FloatToStr(AValue / cSquareKilogramSquareMeterPerQuarticSecondFactor) + ' ' + GetName(rsSquareKilogramSquareMeterPerQuarticSecondPluralName, cSquareKilogramSquareMeterPerQuarticSecondPrefixes);
  result := '';
{$ENDIF}
end;

function SquareKilogramSquareMeterPerQuarticSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareNewton then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cSquareKilogramSquareMeterPerQuarticSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareKilogramSquareMeterPerQuarticSecondName, cSquareKilogramSquareMeterPerQuarticSecondPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cSquareKilogramSquareMeterPerQuarticSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareKilogramSquareMeterPerQuarticSecondPluralName, cSquareKilogramSquareMeterPerQuarticSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cSquareKilogramSquareMeterPerQuarticSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareKilogramSquareMeterPerQuarticSecondName, cSquareKilogramSquareMeterPerQuarticSecondPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cSquareKilogramSquareMeterPerQuarticSecondFactor, rsSquareKilogramSquareMeterPerQuarticSecondPluralName);
{$ENDIF}
end;

function SquareKilogramSquareMeterPerQuarticSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareNewton then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function SquareKilogramSquareMeterPerQuarticSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareNewton then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cSquareKilogramSquareMeterPerQuarticSecondPrefixes, cSquareKilogramSquareMeterPerQuarticSecondExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cSquareKilogramSquareMeterPerQuarticSecondPrefixes, cSquareKilogramSquareMeterPerQuarticSecondExponents);
{$ENDIF}
end;

function PascalToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPascal then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsPascalSymbol, cPascalPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsPascalSymbol, cPascalPrefixes);
{$ENDIF}
end;

function PascalToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPascal then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cPascalPrefixes, cPascalExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cPascalPrefixes, cPascalExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsPascalSymbol, cPascalPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsPascalSymbol, APrefixes);
end;

function PascalToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := PascalToFloat(AQuantity, APrefixes);
  FactoredTol   := PascalToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsPascalSymbol, cPascalPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsPascalSymbol, APrefixes);
  end;
end;

function PascalToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPascal then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsPascalName, cPascalPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsPascalPluralName, cPascalPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsPascalName, cPascalPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsPascalPluralName, cPascalPrefixes);
{$ENDIF}
end;

function PascalToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPascal then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsPascalName, cPascalPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsPascalPluralName, cPascalPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsPascalName, cPascalPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsPascalPluralName, cPascalPrefixes);
{$ENDIF}
end;

function PascalToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := PascalToFloat(AQuantity, APrefixes);
  FactoredTol   := PascalToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsPascalSymbol, cPascalPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsPascalSymbol, APrefixes);
  end;
end;

function PascalToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPascal then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function PascalToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPascal then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cPascalPrefixes, cPascalExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cPascalPrefixes, cPascalExponents);
{$ENDIF}
end;

function NewtonPerSquareMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPascal then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsNewtonPerSquareMeterSymbol, cNewtonPerSquareMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsNewtonPerSquareMeterSymbol, cNewtonPerSquareMeterPrefixes);
{$ENDIF}
end;

function NewtonPerSquareMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPascal then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cNewtonPerSquareMeterPrefixes, cNewtonPerSquareMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cNewtonPerSquareMeterPrefixes, cNewtonPerSquareMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonPerSquareMeterSymbol, cNewtonPerSquareMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonPerSquareMeterSymbol, APrefixes);
end;

function NewtonPerSquareMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := NewtonPerSquareMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := NewtonPerSquareMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonPerSquareMeterSymbol, cNewtonPerSquareMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsNewtonPerSquareMeterSymbol, APrefixes);
  end;
end;

function NewtonPerSquareMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPascal then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cNewtonPerSquareMeterFactor) + ' ' + GetName(rsNewtonPerSquareMeterName, cNewtonPerSquareMeterPrefixes)
  else
    result := FloatToStr(AValue.FValue / cNewtonPerSquareMeterFactor) + ' ' + GetName(rsNewtonPerSquareMeterPluralName, cNewtonPerSquareMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cNewtonPerSquareMeterFactor) + ' ' + GetName(rsNewtonPerSquareMeterName, cNewtonPerSquareMeterPrefixes)
  else
    result := FloatToStr(AValue / cNewtonPerSquareMeterFactor) + ' ' + GetName(rsNewtonPerSquareMeterPluralName, cNewtonPerSquareMeterPrefixes);
  result := '';
{$ENDIF}
end;

function NewtonPerSquareMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPascal then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cNewtonPerSquareMeterFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNewtonPerSquareMeterName, cNewtonPerSquareMeterPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cNewtonPerSquareMeterFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNewtonPerSquareMeterPluralName, cNewtonPerSquareMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cNewtonPerSquareMeterFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNewtonPerSquareMeterName, cNewtonPerSquareMeterPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cNewtonPerSquareMeterFactor, rsNewtonPerSquareMeterPluralName);
{$ENDIF}
end;

function NewtonPerSquareMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPascal then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function NewtonPerSquareMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPascal then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cNewtonPerSquareMeterPrefixes, cNewtonPerSquareMeterExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cNewtonPerSquareMeterPrefixes, cNewtonPerSquareMeterExponents);
{$ENDIF}
end;

function BarToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPascal then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue / cBarFactor) + ' ' + GetSymbol(rsBarSymbol, cBarPrefixes);
{$ENDIF}
  result := FloatToStr(AValue / cBarFactor) + ' ' + GetSymbol(rsBarSymbol, cBarPrefixes);
end;

function BarToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPascal then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue / cBarFactor, APrefixes, cBarPrefixes, cBarExponents);
{$ELSE}
  FactoredValue := GetValue(AValue / cBarFactor, APrefixes, cBarPrefixes, cBarExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsBarSymbol, cBarPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsBarSymbol, APrefixes);
end;

function cBarToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := BarToFloat(AQuantity / cBarFactor, APrefixes);
  FactoredTol   := BarToFloat(ATolerance / cBarFactor, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsBarSymbol, cBarPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsBarSymbol, APrefixes);
  end;
end;

function BarToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPascal then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cBarFactor) + ' ' + GetName(rsBarName, cBarPrefixes)
  else
    result := FloatToStr(AValue.FValue / cBarFactor) + ' ' + GetName(rsBarPluralName, cBarPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cBarFactor) + ' ' + GetName(rsBarName, cBarPrefixes)
  else
    result := FloatToStr(AValue / cBarFactor) + ' ' + GetName(rsBarPluralName, cBarPrefixes);
  result := '';
{$ENDIF}
end;

function BarToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPascal then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cBarFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsBarName, cBarPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cBarFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsBarPluralName, cBarPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cBarFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsBarName, cBarPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cBarFactor, rsBarPluralName);
{$ENDIF}
end;

function BarToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPascal then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue * cBarFactor;
{$ELSE}
  result := AValue * cBarFactor;
{$ENDIF}
end;

function BarToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPascal then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue * cBarFactor, APrefixes, cBarPrefixes, cBarExponents);
{$ELSE}
  result := GetValue(AValue * cBarFactor, APrefixes, cBarPrefixes, cBarExponents);
{$ENDIF}
end;

function PoundPerSquareInchToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPascal then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue / cPoundPerSquareInchFactor) + ' ' + GetSymbol(rsPoundPerSquareInchSymbol, cPoundPerSquareInchPrefixes);
{$ENDIF}
  result := FloatToStr(AValue / cPoundPerSquareInchFactor) + ' ' + GetSymbol(rsPoundPerSquareInchSymbol, cPoundPerSquareInchPrefixes);
end;

function PoundPerSquareInchToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPascal then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue / cPoundPerSquareInchFactor, APrefixes, cPoundPerSquareInchPrefixes, cPoundPerSquareInchExponents);
{$ELSE}
  FactoredValue := GetValue(AValue / cPoundPerSquareInchFactor, APrefixes, cPoundPerSquareInchPrefixes, cPoundPerSquareInchExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsPoundPerSquareInchSymbol, cPoundPerSquareInchPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsPoundPerSquareInchSymbol, APrefixes);
end;

function cPoundPerSquareInchToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := PoundPerSquareInchToFloat(AQuantity / cPoundPerSquareInchFactor, APrefixes);
  FactoredTol   := PoundPerSquareInchToFloat(ATolerance / cPoundPerSquareInchFactor, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsPoundPerSquareInchSymbol, cPoundPerSquareInchPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsPoundPerSquareInchSymbol, APrefixes);
  end;
end;

function PoundPerSquareInchToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPascal then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cPoundPerSquareInchFactor) + ' ' + GetName(rsPoundPerSquareInchName, cPoundPerSquareInchPrefixes)
  else
    result := FloatToStr(AValue.FValue / cPoundPerSquareInchFactor) + ' ' + GetName(rsPoundPerSquareInchPluralName, cPoundPerSquareInchPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cPoundPerSquareInchFactor) + ' ' + GetName(rsPoundPerSquareInchName, cPoundPerSquareInchPrefixes)
  else
    result := FloatToStr(AValue / cPoundPerSquareInchFactor) + ' ' + GetName(rsPoundPerSquareInchPluralName, cPoundPerSquareInchPrefixes);
  result := '';
{$ENDIF}
end;

function PoundPerSquareInchToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPascal then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cPoundPerSquareInchFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsPoundPerSquareInchName, cPoundPerSquareInchPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cPoundPerSquareInchFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsPoundPerSquareInchPluralName, cPoundPerSquareInchPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cPoundPerSquareInchFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsPoundPerSquareInchName, cPoundPerSquareInchPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cPoundPerSquareInchFactor, rsPoundPerSquareInchPluralName);
{$ENDIF}
end;

function PoundPerSquareInchToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPascal then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue * cPoundPerSquareInchFactor;
{$ELSE}
  result := AValue * cPoundPerSquareInchFactor;
{$ENDIF}
end;

function PoundPerSquareInchToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPascal then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue * cPoundPerSquareInchFactor, APrefixes, cPoundPerSquareInchPrefixes, cPoundPerSquareInchExponents);
{$ELSE}
  result := GetValue(AValue * cPoundPerSquareInchFactor, APrefixes, cPoundPerSquareInchPrefixes, cPoundPerSquareInchExponents);
{$ENDIF}
end;

function JoulePerCubicMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPascal then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsJoulePerCubicMeterSymbol, cJoulePerCubicMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsJoulePerCubicMeterSymbol, cJoulePerCubicMeterPrefixes);
{$ENDIF}
end;

function JoulePerCubicMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPascal then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cJoulePerCubicMeterPrefixes, cJoulePerCubicMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cJoulePerCubicMeterPrefixes, cJoulePerCubicMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsJoulePerCubicMeterSymbol, cJoulePerCubicMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsJoulePerCubicMeterSymbol, APrefixes);
end;

function JoulePerCubicMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := JoulePerCubicMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := JoulePerCubicMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsJoulePerCubicMeterSymbol, cJoulePerCubicMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsJoulePerCubicMeterSymbol, APrefixes);
  end;
end;

function JoulePerCubicMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPascal then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cJoulePerCubicMeterFactor) + ' ' + GetName(rsJoulePerCubicMeterName, cJoulePerCubicMeterPrefixes)
  else
    result := FloatToStr(AValue.FValue / cJoulePerCubicMeterFactor) + ' ' + GetName(rsJoulePerCubicMeterPluralName, cJoulePerCubicMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cJoulePerCubicMeterFactor) + ' ' + GetName(rsJoulePerCubicMeterName, cJoulePerCubicMeterPrefixes)
  else
    result := FloatToStr(AValue / cJoulePerCubicMeterFactor) + ' ' + GetName(rsJoulePerCubicMeterPluralName, cJoulePerCubicMeterPrefixes);
  result := '';
{$ENDIF}
end;

function JoulePerCubicMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPascal then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cJoulePerCubicMeterFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsJoulePerCubicMeterName, cJoulePerCubicMeterPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cJoulePerCubicMeterFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsJoulePerCubicMeterPluralName, cJoulePerCubicMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cJoulePerCubicMeterFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsJoulePerCubicMeterName, cJoulePerCubicMeterPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cJoulePerCubicMeterFactor, rsJoulePerCubicMeterPluralName);
{$ENDIF}
end;

function JoulePerCubicMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPascal then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function JoulePerCubicMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPascal then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cJoulePerCubicMeterPrefixes, cJoulePerCubicMeterExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cJoulePerCubicMeterPrefixes, cJoulePerCubicMeterExponents);
{$ENDIF}
end;

function KilogramPerMeterPerSquareSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPascal then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsKilogramPerMeterPerSquareSecondSymbol, cKilogramPerMeterPerSquareSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsKilogramPerMeterPerSquareSecondSymbol, cKilogramPerMeterPerSquareSecondPrefixes);
{$ENDIF}
end;

function KilogramPerMeterPerSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPascal then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cKilogramPerMeterPerSquareSecondPrefixes, cKilogramPerMeterPerSquareSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cKilogramPerMeterPerSquareSecondPrefixes, cKilogramPerMeterPerSquareSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramPerMeterPerSquareSecondSymbol, cKilogramPerMeterPerSquareSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramPerMeterPerSquareSecondSymbol, APrefixes);
end;

function KilogramPerMeterPerSquareSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := KilogramPerMeterPerSquareSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := KilogramPerMeterPerSquareSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramPerMeterPerSquareSecondSymbol, cKilogramPerMeterPerSquareSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsKilogramPerMeterPerSquareSecondSymbol, APrefixes);
  end;
end;

function KilogramPerMeterPerSquareSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPascal then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cKilogramPerMeterPerSquareSecondFactor) + ' ' + GetName(rsKilogramPerMeterPerSquareSecondName, cKilogramPerMeterPerSquareSecondPrefixes)
  else
    result := FloatToStr(AValue.FValue / cKilogramPerMeterPerSquareSecondFactor) + ' ' + GetName(rsKilogramPerMeterPerSquareSecondPluralName, cKilogramPerMeterPerSquareSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cKilogramPerMeterPerSquareSecondFactor) + ' ' + GetName(rsKilogramPerMeterPerSquareSecondName, cKilogramPerMeterPerSquareSecondPrefixes)
  else
    result := FloatToStr(AValue / cKilogramPerMeterPerSquareSecondFactor) + ' ' + GetName(rsKilogramPerMeterPerSquareSecondPluralName, cKilogramPerMeterPerSquareSecondPrefixes);
  result := '';
{$ENDIF}
end;

function KilogramPerMeterPerSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPascal then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cKilogramPerMeterPerSquareSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramPerMeterPerSquareSecondName, cKilogramPerMeterPerSquareSecondPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cKilogramPerMeterPerSquareSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramPerMeterPerSquareSecondPluralName, cKilogramPerMeterPerSquareSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cKilogramPerMeterPerSquareSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramPerMeterPerSquareSecondName, cKilogramPerMeterPerSquareSecondPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cKilogramPerMeterPerSquareSecondFactor, rsKilogramPerMeterPerSquareSecondPluralName);
{$ENDIF}
end;

function KilogramPerMeterPerSquareSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPascal then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function KilogramPerMeterPerSquareSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPascal then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cKilogramPerMeterPerSquareSecondPrefixes, cKilogramPerMeterPerSquareSecondExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cKilogramPerMeterPerSquareSecondPrefixes, cKilogramPerMeterPerSquareSecondExponents);
{$ENDIF}
end;

function JouleToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsJouleSymbol, cJoulePrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsJouleSymbol, cJoulePrefixes);
{$ENDIF}
end;

function JouleToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cJoulePrefixes, cJouleExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cJoulePrefixes, cJouleExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsJouleSymbol, cJoulePrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsJouleSymbol, APrefixes);
end;

function JouleToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := JouleToFloat(AQuantity, APrefixes);
  FactoredTol   := JouleToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsJouleSymbol, cJoulePrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsJouleSymbol, APrefixes);
  end;
end;

function JouleToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsJouleName, cJoulePrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsJoulePluralName, cJoulePrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsJouleName, cJoulePrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsJoulePluralName, cJoulePrefixes);
{$ENDIF}
end;

function JouleToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsJouleName, cJoulePrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsJoulePluralName, cJoulePrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsJouleName, cJoulePrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsJoulePluralName, cJoulePrefixes);
{$ENDIF}
end;

function JouleToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := JouleToFloat(AQuantity, APrefixes);
  FactoredTol   := JouleToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsJouleSymbol, cJoulePrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsJouleSymbol, APrefixes);
  end;
end;

function JouleToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function JouleToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cJoulePrefixes, cJouleExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cJoulePrefixes, cJouleExponents);
{$ENDIF}
end;

function WattHourToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue / cWattHourFactor) + ' ' + GetSymbol(rsWattHourSymbol, cWattHourPrefixes);
{$ENDIF}
  result := FloatToStr(AValue / cWattHourFactor) + ' ' + GetSymbol(rsWattHourSymbol, cWattHourPrefixes);
end;

function WattHourToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue / cWattHourFactor, APrefixes, cWattHourPrefixes, cWattHourExponents);
{$ELSE}
  FactoredValue := GetValue(AValue / cWattHourFactor, APrefixes, cWattHourPrefixes, cWattHourExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattHourSymbol, cWattHourPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattHourSymbol, APrefixes);
end;

function cWattHourToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := WattHourToFloat(AQuantity / cWattHourFactor, APrefixes);
  FactoredTol   := WattHourToFloat(ATolerance / cWattHourFactor, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattHourSymbol, cWattHourPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsWattHourSymbol, APrefixes);
  end;
end;

function WattHourToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cWattHourFactor) + ' ' + GetName(rsWattHourName, cWattHourPrefixes)
  else
    result := FloatToStr(AValue.FValue / cWattHourFactor) + ' ' + GetName(rsWattHourPluralName, cWattHourPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cWattHourFactor) + ' ' + GetName(rsWattHourName, cWattHourPrefixes)
  else
    result := FloatToStr(AValue / cWattHourFactor) + ' ' + GetName(rsWattHourPluralName, cWattHourPrefixes);
  result := '';
{$ENDIF}
end;

function WattHourToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cWattHourFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattHourName, cWattHourPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cWattHourFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattHourPluralName, cWattHourPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cWattHourFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattHourName, cWattHourPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cWattHourFactor, rsWattHourPluralName);
{$ENDIF}
end;

function WattHourToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue * cWattHourFactor;
{$ELSE}
  result := AValue * cWattHourFactor;
{$ENDIF}
end;

function WattHourToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue * cWattHourFactor, APrefixes, cWattHourPrefixes, cWattHourExponents);
{$ELSE}
  result := GetValue(AValue * cWattHourFactor, APrefixes, cWattHourPrefixes, cWattHourExponents);
{$ENDIF}
end;

function WattSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsWattSecondSymbol, cWattSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsWattSecondSymbol, cWattSecondPrefixes);
{$ENDIF}
end;

function WattSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cWattSecondPrefixes, cWattSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cWattSecondPrefixes, cWattSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattSecondSymbol, cWattSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattSecondSymbol, APrefixes);
end;

function WattSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := WattSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := WattSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattSecondSymbol, cWattSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsWattSecondSymbol, APrefixes);
  end;
end;

function WattSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cWattSecondFactor) + ' ' + GetName(rsWattSecondName, cWattSecondPrefixes)
  else
    result := FloatToStr(AValue.FValue / cWattSecondFactor) + ' ' + GetName(rsWattSecondPluralName, cWattSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cWattSecondFactor) + ' ' + GetName(rsWattSecondName, cWattSecondPrefixes)
  else
    result := FloatToStr(AValue / cWattSecondFactor) + ' ' + GetName(rsWattSecondPluralName, cWattSecondPrefixes);
  result := '';
{$ENDIF}
end;

function WattSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cWattSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattSecondName, cWattSecondPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cWattSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattSecondPluralName, cWattSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cWattSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattSecondName, cWattSecondPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cWattSecondFactor, rsWattSecondPluralName);
{$ENDIF}
end;

function WattSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function WattSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cWattSecondPrefixes, cWattSecondExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cWattSecondPrefixes, cWattSecondExponents);
{$ENDIF}
end;

function WattPerHertzToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsWattPerHertzSymbol, cWattPerHertzPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsWattPerHertzSymbol, cWattPerHertzPrefixes);
{$ENDIF}
end;

function WattPerHertzToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cWattPerHertzPrefixes, cWattPerHertzExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cWattPerHertzPrefixes, cWattPerHertzExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattPerHertzSymbol, cWattPerHertzPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattPerHertzSymbol, APrefixes);
end;

function WattPerHertzToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := WattPerHertzToFloat(AQuantity, APrefixes);
  FactoredTol   := WattPerHertzToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattPerHertzSymbol, cWattPerHertzPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsWattPerHertzSymbol, APrefixes);
  end;
end;

function WattPerHertzToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cWattPerHertzFactor) + ' ' + GetName(rsWattPerHertzName, cWattPerHertzPrefixes)
  else
    result := FloatToStr(AValue.FValue / cWattPerHertzFactor) + ' ' + GetName(rsWattPerHertzPluralName, cWattPerHertzPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cWattPerHertzFactor) + ' ' + GetName(rsWattPerHertzName, cWattPerHertzPrefixes)
  else
    result := FloatToStr(AValue / cWattPerHertzFactor) + ' ' + GetName(rsWattPerHertzPluralName, cWattPerHertzPrefixes);
  result := '';
{$ENDIF}
end;

function WattPerHertzToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cWattPerHertzFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattPerHertzName, cWattPerHertzPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cWattPerHertzFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattPerHertzPluralName, cWattPerHertzPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cWattPerHertzFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattPerHertzName, cWattPerHertzPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cWattPerHertzFactor, rsWattPerHertzPluralName);
{$ENDIF}
end;

function WattPerHertzToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function WattPerHertzToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cWattPerHertzPrefixes, cWattPerHertzExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cWattPerHertzPrefixes, cWattPerHertzExponents);
{$ENDIF}
end;

function ElectronvoltToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue / cElectronvoltFactor) + ' ' + GetSymbol(rsElectronvoltSymbol, cElectronvoltPrefixes);
{$ENDIF}
  result := FloatToStr(AValue / cElectronvoltFactor) + ' ' + GetSymbol(rsElectronvoltSymbol, cElectronvoltPrefixes);
end;

function ElectronvoltToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue / cElectronvoltFactor, APrefixes, cElectronvoltPrefixes, cElectronvoltExponents);
{$ELSE}
  FactoredValue := GetValue(AValue / cElectronvoltFactor, APrefixes, cElectronvoltPrefixes, cElectronvoltExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsElectronvoltSymbol, cElectronvoltPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsElectronvoltSymbol, APrefixes);
end;

function cElectronvoltToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := ElectronvoltToFloat(AQuantity / cElectronvoltFactor, APrefixes);
  FactoredTol   := ElectronvoltToFloat(ATolerance / cElectronvoltFactor, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsElectronvoltSymbol, cElectronvoltPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsElectronvoltSymbol, APrefixes);
  end;
end;

function ElectronvoltToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cElectronvoltFactor) + ' ' + GetName(rsElectronvoltName, cElectronvoltPrefixes)
  else
    result := FloatToStr(AValue.FValue / cElectronvoltFactor) + ' ' + GetName(rsElectronvoltPluralName, cElectronvoltPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cElectronvoltFactor) + ' ' + GetName(rsElectronvoltName, cElectronvoltPrefixes)
  else
    result := FloatToStr(AValue / cElectronvoltFactor) + ' ' + GetName(rsElectronvoltPluralName, cElectronvoltPrefixes);
  result := '';
{$ENDIF}
end;

function ElectronvoltToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cElectronvoltFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsElectronvoltName, cElectronvoltPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cElectronvoltFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsElectronvoltPluralName, cElectronvoltPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cElectronvoltFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsElectronvoltName, cElectronvoltPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cElectronvoltFactor, rsElectronvoltPluralName);
{$ENDIF}
end;

function ElectronvoltToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue * cElectronvoltFactor;
{$ELSE}
  result := AValue * cElectronvoltFactor;
{$ENDIF}
end;

function ElectronvoltToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue * cElectronvoltFactor, APrefixes, cElectronvoltPrefixes, cElectronvoltExponents);
{$ELSE}
  result := GetValue(AValue * cElectronvoltFactor, APrefixes, cElectronvoltPrefixes, cElectronvoltExponents);
{$ENDIF}
end;

function NewtonMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsNewtonMeterSymbol, cNewtonMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsNewtonMeterSymbol, cNewtonMeterPrefixes);
{$ENDIF}
end;

function NewtonMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cNewtonMeterPrefixes, cNewtonMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cNewtonMeterPrefixes, cNewtonMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonMeterSymbol, cNewtonMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonMeterSymbol, APrefixes);
end;

function NewtonMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := NewtonMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := NewtonMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonMeterSymbol, cNewtonMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsNewtonMeterSymbol, APrefixes);
  end;
end;

function NewtonMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cNewtonMeterFactor) + ' ' + GetName(rsNewtonMeterName, cNewtonMeterPrefixes)
  else
    result := FloatToStr(AValue.FValue / cNewtonMeterFactor) + ' ' + GetName(rsNewtonMeterPluralName, cNewtonMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cNewtonMeterFactor) + ' ' + GetName(rsNewtonMeterName, cNewtonMeterPrefixes)
  else
    result := FloatToStr(AValue / cNewtonMeterFactor) + ' ' + GetName(rsNewtonMeterPluralName, cNewtonMeterPrefixes);
  result := '';
{$ENDIF}
end;

function NewtonMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cNewtonMeterFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNewtonMeterName, cNewtonMeterPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cNewtonMeterFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNewtonMeterPluralName, cNewtonMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cNewtonMeterFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNewtonMeterName, cNewtonMeterPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cNewtonMeterFactor, rsNewtonMeterPluralName);
{$ENDIF}
end;

function NewtonMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function NewtonMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cNewtonMeterPrefixes, cNewtonMeterExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cNewtonMeterPrefixes, cNewtonMeterExponents);
{$ENDIF}
end;

function PoundForceInchToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue / cPoundForceInchFactor) + ' ' + GetSymbol(rsPoundForceInchSymbol, cPoundForceInchPrefixes);
{$ENDIF}
  result := FloatToStr(AValue / cPoundForceInchFactor) + ' ' + GetSymbol(rsPoundForceInchSymbol, cPoundForceInchPrefixes);
end;

function PoundForceInchToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue / cPoundForceInchFactor, APrefixes, cPoundForceInchPrefixes, cPoundForceInchExponents);
{$ELSE}
  FactoredValue := GetValue(AValue / cPoundForceInchFactor, APrefixes, cPoundForceInchPrefixes, cPoundForceInchExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsPoundForceInchSymbol, cPoundForceInchPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsPoundForceInchSymbol, APrefixes);
end;

function cPoundForceInchToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := PoundForceInchToFloat(AQuantity / cPoundForceInchFactor, APrefixes);
  FactoredTol   := PoundForceInchToFloat(ATolerance / cPoundForceInchFactor, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsPoundForceInchSymbol, cPoundForceInchPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsPoundForceInchSymbol, APrefixes);
  end;
end;

function PoundForceInchToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cPoundForceInchFactor) + ' ' + GetName(rsPoundForceInchName, cPoundForceInchPrefixes)
  else
    result := FloatToStr(AValue.FValue / cPoundForceInchFactor) + ' ' + GetName(rsPoundForceInchPluralName, cPoundForceInchPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cPoundForceInchFactor) + ' ' + GetName(rsPoundForceInchName, cPoundForceInchPrefixes)
  else
    result := FloatToStr(AValue / cPoundForceInchFactor) + ' ' + GetName(rsPoundForceInchPluralName, cPoundForceInchPrefixes);
  result := '';
{$ENDIF}
end;

function PoundForceInchToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cPoundForceInchFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsPoundForceInchName, cPoundForceInchPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cPoundForceInchFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsPoundForceInchPluralName, cPoundForceInchPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cPoundForceInchFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsPoundForceInchName, cPoundForceInchPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cPoundForceInchFactor, rsPoundForceInchPluralName);
{$ENDIF}
end;

function PoundForceInchToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue * cPoundForceInchFactor;
{$ELSE}
  result := AValue * cPoundForceInchFactor;
{$ENDIF}
end;

function PoundForceInchToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue * cPoundForceInchFactor, APrefixes, cPoundForceInchPrefixes, cPoundForceInchExponents);
{$ELSE}
  result := GetValue(AValue * cPoundForceInchFactor, APrefixes, cPoundForceInchPrefixes, cPoundForceInchExponents);
{$ENDIF}
end;

function RydbergToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue / cRydbergFactor) + ' ' + GetSymbol(rsRydbergSymbol, cRydbergPrefixes);
{$ENDIF}
  result := FloatToStr(AValue / cRydbergFactor) + ' ' + GetSymbol(rsRydbergSymbol, cRydbergPrefixes);
end;

function RydbergToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue / cRydbergFactor, APrefixes, cRydbergPrefixes, cRydbergExponents);
{$ELSE}
  FactoredValue := GetValue(AValue / cRydbergFactor, APrefixes, cRydbergPrefixes, cRydbergExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsRydbergSymbol, cRydbergPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsRydbergSymbol, APrefixes);
end;

function cRydbergToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := RydbergToFloat(AQuantity / cRydbergFactor, APrefixes);
  FactoredTol   := RydbergToFloat(ATolerance / cRydbergFactor, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsRydbergSymbol, cRydbergPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsRydbergSymbol, APrefixes);
  end;
end;

function RydbergToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cRydbergFactor) + ' ' + GetName(rsRydbergName, cRydbergPrefixes)
  else
    result := FloatToStr(AValue.FValue / cRydbergFactor) + ' ' + GetName(rsRydbergPluralName, cRydbergPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cRydbergFactor) + ' ' + GetName(rsRydbergName, cRydbergPrefixes)
  else
    result := FloatToStr(AValue / cRydbergFactor) + ' ' + GetName(rsRydbergPluralName, cRydbergPrefixes);
  result := '';
{$ENDIF}
end;

function RydbergToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cRydbergFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsRydbergName, cRydbergPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cRydbergFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsRydbergPluralName, cRydbergPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cRydbergFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsRydbergName, cRydbergPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cRydbergFactor, rsRydbergPluralName);
{$ENDIF}
end;

function RydbergToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue * cRydbergFactor;
{$ELSE}
  result := AValue * cRydbergFactor;
{$ENDIF}
end;

function RydbergToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue * cRydbergFactor, APrefixes, cRydbergPrefixes, cRydbergExponents);
{$ELSE}
  result := GetValue(AValue * cRydbergFactor, APrefixes, cRydbergPrefixes, cRydbergExponents);
{$ENDIF}
end;

function CalorieToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue / cCalorieFactor) + ' ' + GetSymbol(rsCalorieSymbol, cCaloriePrefixes);
{$ENDIF}
  result := FloatToStr(AValue / cCalorieFactor) + ' ' + GetSymbol(rsCalorieSymbol, cCaloriePrefixes);
end;

function CalorieToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue / cCalorieFactor, APrefixes, cCaloriePrefixes, cCalorieExponents);
{$ELSE}
  FactoredValue := GetValue(AValue / cCalorieFactor, APrefixes, cCaloriePrefixes, cCalorieExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCalorieSymbol, cCaloriePrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCalorieSymbol, APrefixes);
end;

function cCalorieToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := CalorieToFloat(AQuantity / cCalorieFactor, APrefixes);
  FactoredTol   := CalorieToFloat(ATolerance / cCalorieFactor, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCalorieSymbol, cCaloriePrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsCalorieSymbol, APrefixes);
  end;
end;

function CalorieToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cCalorieFactor) + ' ' + GetName(rsCalorieName, cCaloriePrefixes)
  else
    result := FloatToStr(AValue.FValue / cCalorieFactor) + ' ' + GetName(rsCaloriePluralName, cCaloriePrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cCalorieFactor) + ' ' + GetName(rsCalorieName, cCaloriePrefixes)
  else
    result := FloatToStr(AValue / cCalorieFactor) + ' ' + GetName(rsCaloriePluralName, cCaloriePrefixes);
  result := '';
{$ENDIF}
end;

function CalorieToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cCalorieFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCalorieName, cCaloriePrefixes)
  else
    result := FloatToStrF(AValue.FValue / cCalorieFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCaloriePluralName, cCaloriePrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cCalorieFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCalorieName, cCaloriePrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cCalorieFactor, rsCaloriePluralName);
{$ENDIF}
end;

function CalorieToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue * cCalorieFactor;
{$ELSE}
  result := AValue * cCalorieFactor;
{$ENDIF}
end;

function CalorieToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue * cCalorieFactor, APrefixes, cCaloriePrefixes, cCalorieExponents);
{$ELSE}
  result := GetValue(AValue * cCalorieFactor, APrefixes, cCaloriePrefixes, cCalorieExponents);
{$ENDIF}
end;

function KilogramSquareMeterPerSquareSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsKilogramSquareMeterPerSquareSecondSymbol, cKilogramSquareMeterPerSquareSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsKilogramSquareMeterPerSquareSecondSymbol, cKilogramSquareMeterPerSquareSecondPrefixes);
{$ENDIF}
end;

function KilogramSquareMeterPerSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cKilogramSquareMeterPerSquareSecondPrefixes, cKilogramSquareMeterPerSquareSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cKilogramSquareMeterPerSquareSecondPrefixes, cKilogramSquareMeterPerSquareSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramSquareMeterPerSquareSecondSymbol, cKilogramSquareMeterPerSquareSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramSquareMeterPerSquareSecondSymbol, APrefixes);
end;

function KilogramSquareMeterPerSquareSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := KilogramSquareMeterPerSquareSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := KilogramSquareMeterPerSquareSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramSquareMeterPerSquareSecondSymbol, cKilogramSquareMeterPerSquareSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsKilogramSquareMeterPerSquareSecondSymbol, APrefixes);
  end;
end;

function KilogramSquareMeterPerSquareSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cKilogramSquareMeterPerSquareSecondFactor) + ' ' + GetName(rsKilogramSquareMeterPerSquareSecondName, cKilogramSquareMeterPerSquareSecondPrefixes)
  else
    result := FloatToStr(AValue.FValue / cKilogramSquareMeterPerSquareSecondFactor) + ' ' + GetName(rsKilogramSquareMeterPerSquareSecondPluralName, cKilogramSquareMeterPerSquareSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cKilogramSquareMeterPerSquareSecondFactor) + ' ' + GetName(rsKilogramSquareMeterPerSquareSecondName, cKilogramSquareMeterPerSquareSecondPrefixes)
  else
    result := FloatToStr(AValue / cKilogramSquareMeterPerSquareSecondFactor) + ' ' + GetName(rsKilogramSquareMeterPerSquareSecondPluralName, cKilogramSquareMeterPerSquareSecondPrefixes);
  result := '';
{$ENDIF}
end;

function KilogramSquareMeterPerSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cKilogramSquareMeterPerSquareSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramSquareMeterPerSquareSecondName, cKilogramSquareMeterPerSquareSecondPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cKilogramSquareMeterPerSquareSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramSquareMeterPerSquareSecondPluralName, cKilogramSquareMeterPerSquareSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cKilogramSquareMeterPerSquareSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramSquareMeterPerSquareSecondName, cKilogramSquareMeterPerSquareSecondPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cKilogramSquareMeterPerSquareSecondFactor, rsKilogramSquareMeterPerSquareSecondPluralName);
{$ENDIF}
end;

function KilogramSquareMeterPerSquareSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function KilogramSquareMeterPerSquareSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cKilogramSquareMeterPerSquareSecondPrefixes, cKilogramSquareMeterPerSquareSecondExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cKilogramSquareMeterPerSquareSecondPrefixes, cKilogramSquareMeterPerSquareSecondExponents);
{$ENDIF}
end;

function JoulePerRadianToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerRadian then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsJoulePerRadianSymbol, cJoulePerRadianPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsJoulePerRadianSymbol, cJoulePerRadianPrefixes);
{$ENDIF}
end;

function JoulePerRadianToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerRadian then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cJoulePerRadianPrefixes, cJoulePerRadianExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cJoulePerRadianPrefixes, cJoulePerRadianExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsJoulePerRadianSymbol, cJoulePerRadianPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsJoulePerRadianSymbol, APrefixes);
end;

function JoulePerRadianToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := JoulePerRadianToFloat(AQuantity, APrefixes);
  FactoredTol   := JoulePerRadianToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsJoulePerRadianSymbol, cJoulePerRadianPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsJoulePerRadianSymbol, APrefixes);
  end;
end;

function JoulePerRadianToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerRadian then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsJoulePerRadianName, cJoulePerRadianPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsJoulePerRadianPluralName, cJoulePerRadianPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsJoulePerRadianName, cJoulePerRadianPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsJoulePerRadianPluralName, cJoulePerRadianPrefixes);
{$ENDIF}
end;

function JoulePerRadianToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerRadian then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsJoulePerRadianName, cJoulePerRadianPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsJoulePerRadianPluralName, cJoulePerRadianPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsJoulePerRadianName, cJoulePerRadianPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsJoulePerRadianPluralName, cJoulePerRadianPrefixes);
{$ENDIF}
end;

function JoulePerRadianToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := JoulePerRadianToFloat(AQuantity, APrefixes);
  FactoredTol   := JoulePerRadianToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsJoulePerRadianSymbol, cJoulePerRadianPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsJoulePerRadianSymbol, APrefixes);
  end;
end;

function JoulePerRadianToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerRadian then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function JoulePerRadianToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerRadian then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cJoulePerRadianPrefixes, cJoulePerRadianExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cJoulePerRadianPrefixes, cJoulePerRadianExponents);
{$ENDIF}
end;

function JoulePerDegreeToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerRadian then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue / cJoulePerDegreeFactor) + ' ' + GetSymbol(rsJoulePerDegreeSymbol, cJoulePerDegreePrefixes);
{$ENDIF}
  result := FloatToStr(AValue / cJoulePerDegreeFactor) + ' ' + GetSymbol(rsJoulePerDegreeSymbol, cJoulePerDegreePrefixes);
end;

function JoulePerDegreeToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerRadian then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue / cJoulePerDegreeFactor, APrefixes, cJoulePerDegreePrefixes, cJoulePerDegreeExponents);
{$ELSE}
  FactoredValue := GetValue(AValue / cJoulePerDegreeFactor, APrefixes, cJoulePerDegreePrefixes, cJoulePerDegreeExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsJoulePerDegreeSymbol, cJoulePerDegreePrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsJoulePerDegreeSymbol, APrefixes);
end;

function cJoulePerDegreeToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := JoulePerDegreeToFloat(AQuantity / cJoulePerDegreeFactor, APrefixes);
  FactoredTol   := JoulePerDegreeToFloat(ATolerance / cJoulePerDegreeFactor, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsJoulePerDegreeSymbol, cJoulePerDegreePrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsJoulePerDegreeSymbol, APrefixes);
  end;
end;

function JoulePerDegreeToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerRadian then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cJoulePerDegreeFactor) + ' ' + GetName(rsJoulePerDegreeName, cJoulePerDegreePrefixes)
  else
    result := FloatToStr(AValue.FValue / cJoulePerDegreeFactor) + ' ' + GetName(rsJoulePerDegreePluralName, cJoulePerDegreePrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cJoulePerDegreeFactor) + ' ' + GetName(rsJoulePerDegreeName, cJoulePerDegreePrefixes)
  else
    result := FloatToStr(AValue / cJoulePerDegreeFactor) + ' ' + GetName(rsJoulePerDegreePluralName, cJoulePerDegreePrefixes);
  result := '';
{$ENDIF}
end;

function JoulePerDegreeToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerRadian then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cJoulePerDegreeFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsJoulePerDegreeName, cJoulePerDegreePrefixes)
  else
    result := FloatToStrF(AValue.FValue / cJoulePerDegreeFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsJoulePerDegreePluralName, cJoulePerDegreePrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cJoulePerDegreeFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsJoulePerDegreeName, cJoulePerDegreePrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cJoulePerDegreeFactor, rsJoulePerDegreePluralName);
{$ENDIF}
end;

function JoulePerDegreeToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerRadian then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue * cJoulePerDegreeFactor;
{$ELSE}
  result := AValue * cJoulePerDegreeFactor;
{$ENDIF}
end;

function JoulePerDegreeToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerRadian then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue * cJoulePerDegreeFactor, APrefixes, cJoulePerDegreePrefixes, cJoulePerDegreeExponents);
{$ELSE}
  result := GetValue(AValue * cJoulePerDegreeFactor, APrefixes, cJoulePerDegreePrefixes, cJoulePerDegreeExponents);
{$ENDIF}
end;

function NewtonMeterPerRadianToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerRadian then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsNewtonMeterPerRadianSymbol, cNewtonMeterPerRadianPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsNewtonMeterPerRadianSymbol, cNewtonMeterPerRadianPrefixes);
{$ENDIF}
end;

function NewtonMeterPerRadianToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerRadian then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cNewtonMeterPerRadianPrefixes, cNewtonMeterPerRadianExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cNewtonMeterPerRadianPrefixes, cNewtonMeterPerRadianExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonMeterPerRadianSymbol, cNewtonMeterPerRadianPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonMeterPerRadianSymbol, APrefixes);
end;

function NewtonMeterPerRadianToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := NewtonMeterPerRadianToFloat(AQuantity, APrefixes);
  FactoredTol   := NewtonMeterPerRadianToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonMeterPerRadianSymbol, cNewtonMeterPerRadianPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsNewtonMeterPerRadianSymbol, APrefixes);
  end;
end;

function NewtonMeterPerRadianToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerRadian then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cNewtonMeterPerRadianFactor) + ' ' + GetName(rsNewtonMeterPerRadianName, cNewtonMeterPerRadianPrefixes)
  else
    result := FloatToStr(AValue.FValue / cNewtonMeterPerRadianFactor) + ' ' + GetName(rsNewtonMeterPerRadianPluralName, cNewtonMeterPerRadianPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cNewtonMeterPerRadianFactor) + ' ' + GetName(rsNewtonMeterPerRadianName, cNewtonMeterPerRadianPrefixes)
  else
    result := FloatToStr(AValue / cNewtonMeterPerRadianFactor) + ' ' + GetName(rsNewtonMeterPerRadianPluralName, cNewtonMeterPerRadianPrefixes);
  result := '';
{$ENDIF}
end;

function NewtonMeterPerRadianToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerRadian then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cNewtonMeterPerRadianFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNewtonMeterPerRadianName, cNewtonMeterPerRadianPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cNewtonMeterPerRadianFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNewtonMeterPerRadianPluralName, cNewtonMeterPerRadianPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cNewtonMeterPerRadianFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNewtonMeterPerRadianName, cNewtonMeterPerRadianPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cNewtonMeterPerRadianFactor, rsNewtonMeterPerRadianPluralName);
{$ENDIF}
end;

function NewtonMeterPerRadianToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerRadian then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function NewtonMeterPerRadianToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerRadian then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cNewtonMeterPerRadianPrefixes, cNewtonMeterPerRadianExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cNewtonMeterPerRadianPrefixes, cNewtonMeterPerRadianExponents);
{$ENDIF}
end;

function NewtonMeterPerDegreeToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerRadian then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue / cNewtonMeterPerDegreeFactor) + ' ' + GetSymbol(rsNewtonMeterPerDegreeSymbol, cNewtonMeterPerDegreePrefixes);
{$ENDIF}
  result := FloatToStr(AValue / cNewtonMeterPerDegreeFactor) + ' ' + GetSymbol(rsNewtonMeterPerDegreeSymbol, cNewtonMeterPerDegreePrefixes);
end;

function NewtonMeterPerDegreeToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerRadian then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue / cNewtonMeterPerDegreeFactor, APrefixes, cNewtonMeterPerDegreePrefixes, cNewtonMeterPerDegreeExponents);
{$ELSE}
  FactoredValue := GetValue(AValue / cNewtonMeterPerDegreeFactor, APrefixes, cNewtonMeterPerDegreePrefixes, cNewtonMeterPerDegreeExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonMeterPerDegreeSymbol, cNewtonMeterPerDegreePrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonMeterPerDegreeSymbol, APrefixes);
end;

function cNewtonMeterPerDegreeToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := NewtonMeterPerDegreeToFloat(AQuantity / cNewtonMeterPerDegreeFactor, APrefixes);
  FactoredTol   := NewtonMeterPerDegreeToFloat(ATolerance / cNewtonMeterPerDegreeFactor, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonMeterPerDegreeSymbol, cNewtonMeterPerDegreePrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsNewtonMeterPerDegreeSymbol, APrefixes);
  end;
end;

function NewtonMeterPerDegreeToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerRadian then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cNewtonMeterPerDegreeFactor) + ' ' + GetName(rsNewtonMeterPerDegreeName, cNewtonMeterPerDegreePrefixes)
  else
    result := FloatToStr(AValue.FValue / cNewtonMeterPerDegreeFactor) + ' ' + GetName(rsNewtonMeterPerDegreePluralName, cNewtonMeterPerDegreePrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cNewtonMeterPerDegreeFactor) + ' ' + GetName(rsNewtonMeterPerDegreeName, cNewtonMeterPerDegreePrefixes)
  else
    result := FloatToStr(AValue / cNewtonMeterPerDegreeFactor) + ' ' + GetName(rsNewtonMeterPerDegreePluralName, cNewtonMeterPerDegreePrefixes);
  result := '';
{$ENDIF}
end;

function NewtonMeterPerDegreeToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerRadian then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cNewtonMeterPerDegreeFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNewtonMeterPerDegreeName, cNewtonMeterPerDegreePrefixes)
  else
    result := FloatToStrF(AValue.FValue / cNewtonMeterPerDegreeFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNewtonMeterPerDegreePluralName, cNewtonMeterPerDegreePrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cNewtonMeterPerDegreeFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNewtonMeterPerDegreeName, cNewtonMeterPerDegreePrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cNewtonMeterPerDegreeFactor, rsNewtonMeterPerDegreePluralName);
{$ENDIF}
end;

function NewtonMeterPerDegreeToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerRadian then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue * cNewtonMeterPerDegreeFactor;
{$ELSE}
  result := AValue * cNewtonMeterPerDegreeFactor;
{$ENDIF}
end;

function NewtonMeterPerDegreeToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerRadian then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue * cNewtonMeterPerDegreeFactor, APrefixes, cNewtonMeterPerDegreePrefixes, cNewtonMeterPerDegreeExponents);
{$ELSE}
  result := GetValue(AValue * cNewtonMeterPerDegreeFactor, APrefixes, cNewtonMeterPerDegreePrefixes, cNewtonMeterPerDegreeExponents);
{$ENDIF}
end;

function KilogramSquareMeterPerSquareSecondPerRadianToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerRadian then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsKilogramSquareMeterPerSquareSecondPerRadianSymbol, cKilogramSquareMeterPerSquareSecondPerRadianPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsKilogramSquareMeterPerSquareSecondPerRadianSymbol, cKilogramSquareMeterPerSquareSecondPerRadianPrefixes);
{$ENDIF}
end;

function KilogramSquareMeterPerSquareSecondPerRadianToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerRadian then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cKilogramSquareMeterPerSquareSecondPerRadianPrefixes, cKilogramSquareMeterPerSquareSecondPerRadianExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cKilogramSquareMeterPerSquareSecondPerRadianPrefixes, cKilogramSquareMeterPerSquareSecondPerRadianExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramSquareMeterPerSquareSecondPerRadianSymbol, cKilogramSquareMeterPerSquareSecondPerRadianPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramSquareMeterPerSquareSecondPerRadianSymbol, APrefixes);
end;

function KilogramSquareMeterPerSquareSecondPerRadianToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := KilogramSquareMeterPerSquareSecondPerRadianToFloat(AQuantity, APrefixes);
  FactoredTol   := KilogramSquareMeterPerSquareSecondPerRadianToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramSquareMeterPerSquareSecondPerRadianSymbol, cKilogramSquareMeterPerSquareSecondPerRadianPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsKilogramSquareMeterPerSquareSecondPerRadianSymbol, APrefixes);
  end;
end;

function KilogramSquareMeterPerSquareSecondPerRadianToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerRadian then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cKilogramSquareMeterPerSquareSecondPerRadianFactor) + ' ' + GetName(rsKilogramSquareMeterPerSquareSecondPerRadianName, cKilogramSquareMeterPerSquareSecondPerRadianPrefixes)
  else
    result := FloatToStr(AValue.FValue / cKilogramSquareMeterPerSquareSecondPerRadianFactor) + ' ' + GetName(rsKilogramSquareMeterPerSquareSecondPerRadianPluralName, cKilogramSquareMeterPerSquareSecondPerRadianPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cKilogramSquareMeterPerSquareSecondPerRadianFactor) + ' ' + GetName(rsKilogramSquareMeterPerSquareSecondPerRadianName, cKilogramSquareMeterPerSquareSecondPerRadianPrefixes)
  else
    result := FloatToStr(AValue / cKilogramSquareMeterPerSquareSecondPerRadianFactor) + ' ' + GetName(rsKilogramSquareMeterPerSquareSecondPerRadianPluralName, cKilogramSquareMeterPerSquareSecondPerRadianPrefixes);
  result := '';
{$ENDIF}
end;

function KilogramSquareMeterPerSquareSecondPerRadianToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerRadian then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cKilogramSquareMeterPerSquareSecondPerRadianFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramSquareMeterPerSquareSecondPerRadianName, cKilogramSquareMeterPerSquareSecondPerRadianPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cKilogramSquareMeterPerSquareSecondPerRadianFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramSquareMeterPerSquareSecondPerRadianPluralName, cKilogramSquareMeterPerSquareSecondPerRadianPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cKilogramSquareMeterPerSquareSecondPerRadianFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramSquareMeterPerSquareSecondPerRadianName, cKilogramSquareMeterPerSquareSecondPerRadianPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cKilogramSquareMeterPerSquareSecondPerRadianFactor, rsKilogramSquareMeterPerSquareSecondPerRadianPluralName);
{$ENDIF}
end;

function KilogramSquareMeterPerSquareSecondPerRadianToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerRadian then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function KilogramSquareMeterPerSquareSecondPerRadianToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerRadian then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cKilogramSquareMeterPerSquareSecondPerRadianPrefixes, cKilogramSquareMeterPerSquareSecondPerRadianExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cKilogramSquareMeterPerSquareSecondPerRadianPrefixes, cKilogramSquareMeterPerSquareSecondPerRadianExponents);
{$ENDIF}
end;

function WattToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWatt then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsWattSymbol, cWattPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsWattSymbol, cWattPrefixes);
{$ENDIF}
end;

function WattToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWatt then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cWattPrefixes, cWattExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cWattPrefixes, cWattExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattSymbol, cWattPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattSymbol, APrefixes);
end;

function WattToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := WattToFloat(AQuantity, APrefixes);
  FactoredTol   := WattToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattSymbol, cWattPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsWattSymbol, APrefixes);
  end;
end;

function WattToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWatt then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsWattName, cWattPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsWattPluralName, cWattPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsWattName, cWattPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsWattPluralName, cWattPrefixes);
{$ENDIF}
end;

function WattToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWatt then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattName, cWattPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattPluralName, cWattPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattName, cWattPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattPluralName, cWattPrefixes);
{$ENDIF}
end;

function WattToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := WattToFloat(AQuantity, APrefixes);
  FactoredTol   := WattToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattSymbol, cWattPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsWattSymbol, APrefixes);
  end;
end;

function WattToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWatt then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function WattToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWatt then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cWattPrefixes, cWattExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cWattPrefixes, cWattExponents);
{$ENDIF}
end;

function KilogramSquareMeterPerCubicSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWatt then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsKilogramSquareMeterPerCubicSecondSymbol, cKilogramSquareMeterPerCubicSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsKilogramSquareMeterPerCubicSecondSymbol, cKilogramSquareMeterPerCubicSecondPrefixes);
{$ENDIF}
end;

function KilogramSquareMeterPerCubicSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWatt then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cKilogramSquareMeterPerCubicSecondPrefixes, cKilogramSquareMeterPerCubicSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cKilogramSquareMeterPerCubicSecondPrefixes, cKilogramSquareMeterPerCubicSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramSquareMeterPerCubicSecondSymbol, cKilogramSquareMeterPerCubicSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramSquareMeterPerCubicSecondSymbol, APrefixes);
end;

function KilogramSquareMeterPerCubicSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := KilogramSquareMeterPerCubicSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := KilogramSquareMeterPerCubicSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramSquareMeterPerCubicSecondSymbol, cKilogramSquareMeterPerCubicSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsKilogramSquareMeterPerCubicSecondSymbol, APrefixes);
  end;
end;

function KilogramSquareMeterPerCubicSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWatt then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cKilogramSquareMeterPerCubicSecondFactor) + ' ' + GetName(rsKilogramSquareMeterPerCubicSecondName, cKilogramSquareMeterPerCubicSecondPrefixes)
  else
    result := FloatToStr(AValue.FValue / cKilogramSquareMeterPerCubicSecondFactor) + ' ' + GetName(rsKilogramSquareMeterPerCubicSecondPluralName, cKilogramSquareMeterPerCubicSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cKilogramSquareMeterPerCubicSecondFactor) + ' ' + GetName(rsKilogramSquareMeterPerCubicSecondName, cKilogramSquareMeterPerCubicSecondPrefixes)
  else
    result := FloatToStr(AValue / cKilogramSquareMeterPerCubicSecondFactor) + ' ' + GetName(rsKilogramSquareMeterPerCubicSecondPluralName, cKilogramSquareMeterPerCubicSecondPrefixes);
  result := '';
{$ENDIF}
end;

function KilogramSquareMeterPerCubicSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWatt then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cKilogramSquareMeterPerCubicSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramSquareMeterPerCubicSecondName, cKilogramSquareMeterPerCubicSecondPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cKilogramSquareMeterPerCubicSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramSquareMeterPerCubicSecondPluralName, cKilogramSquareMeterPerCubicSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cKilogramSquareMeterPerCubicSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramSquareMeterPerCubicSecondName, cKilogramSquareMeterPerCubicSecondPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cKilogramSquareMeterPerCubicSecondFactor, rsKilogramSquareMeterPerCubicSecondPluralName);
{$ENDIF}
end;

function KilogramSquareMeterPerCubicSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWatt then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function KilogramSquareMeterPerCubicSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWatt then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cKilogramSquareMeterPerCubicSecondPrefixes, cKilogramSquareMeterPerCubicSecondExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cKilogramSquareMeterPerCubicSecondPrefixes, cKilogramSquareMeterPerCubicSecondExponents);
{$ENDIF}
end;

function CoulombToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulomb then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsCoulombSymbol, cCoulombPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsCoulombSymbol, cCoulombPrefixes);
{$ENDIF}
end;

function CoulombToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulomb then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cCoulombPrefixes, cCoulombExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cCoulombPrefixes, cCoulombExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCoulombSymbol, cCoulombPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCoulombSymbol, APrefixes);
end;

function CoulombToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := CoulombToFloat(AQuantity, APrefixes);
  FactoredTol   := CoulombToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCoulombSymbol, cCoulombPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsCoulombSymbol, APrefixes);
  end;
end;

function CoulombToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulomb then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsCoulombName, cCoulombPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsCoulombPluralName, cCoulombPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsCoulombName, cCoulombPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsCoulombPluralName, cCoulombPrefixes);
{$ENDIF}
end;

function CoulombToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulomb then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCoulombName, cCoulombPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCoulombPluralName, cCoulombPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCoulombName, cCoulombPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCoulombPluralName, cCoulombPrefixes);
{$ENDIF}
end;

function CoulombToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := CoulombToFloat(AQuantity, APrefixes);
  FactoredTol   := CoulombToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCoulombSymbol, cCoulombPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsCoulombSymbol, APrefixes);
  end;
end;

function CoulombToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulomb then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function CoulombToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulomb then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cCoulombPrefixes, cCoulombExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cCoulombPrefixes, cCoulombExponents);
{$ENDIF}
end;

function AmpereHourToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulomb then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue / cAmpereHourFactor) + ' ' + GetSymbol(rsAmpereHourSymbol, cAmpereHourPrefixes);
{$ENDIF}
  result := FloatToStr(AValue / cAmpereHourFactor) + ' ' + GetSymbol(rsAmpereHourSymbol, cAmpereHourPrefixes);
end;

function AmpereHourToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulomb then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue / cAmpereHourFactor, APrefixes, cAmpereHourPrefixes, cAmpereHourExponents);
{$ELSE}
  FactoredValue := GetValue(AValue / cAmpereHourFactor, APrefixes, cAmpereHourPrefixes, cAmpereHourExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsAmpereHourSymbol, cAmpereHourPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsAmpereHourSymbol, APrefixes);
end;

function cAmpereHourToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := AmpereHourToFloat(AQuantity / cAmpereHourFactor, APrefixes);
  FactoredTol   := AmpereHourToFloat(ATolerance / cAmpereHourFactor, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsAmpereHourSymbol, cAmpereHourPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsAmpereHourSymbol, APrefixes);
  end;
end;

function AmpereHourToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulomb then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cAmpereHourFactor) + ' ' + GetName(rsAmpereHourName, cAmpereHourPrefixes)
  else
    result := FloatToStr(AValue.FValue / cAmpereHourFactor) + ' ' + GetName(rsAmpereHourPluralName, cAmpereHourPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cAmpereHourFactor) + ' ' + GetName(rsAmpereHourName, cAmpereHourPrefixes)
  else
    result := FloatToStr(AValue / cAmpereHourFactor) + ' ' + GetName(rsAmpereHourPluralName, cAmpereHourPrefixes);
  result := '';
{$ENDIF}
end;

function AmpereHourToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulomb then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cAmpereHourFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsAmpereHourName, cAmpereHourPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cAmpereHourFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsAmpereHourPluralName, cAmpereHourPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cAmpereHourFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsAmpereHourName, cAmpereHourPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cAmpereHourFactor, rsAmpereHourPluralName);
{$ENDIF}
end;

function AmpereHourToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulomb then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue * cAmpereHourFactor;
{$ELSE}
  result := AValue * cAmpereHourFactor;
{$ENDIF}
end;

function AmpereHourToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulomb then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue * cAmpereHourFactor, APrefixes, cAmpereHourPrefixes, cAmpereHourExponents);
{$ELSE}
  result := GetValue(AValue * cAmpereHourFactor, APrefixes, cAmpereHourPrefixes, cAmpereHourExponents);
{$ENDIF}
end;

function AmpereSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulomb then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsAmpereSecondSymbol, cAmpereSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsAmpereSecondSymbol, cAmpereSecondPrefixes);
{$ENDIF}
end;

function AmpereSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulomb then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cAmpereSecondPrefixes, cAmpereSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cAmpereSecondPrefixes, cAmpereSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsAmpereSecondSymbol, cAmpereSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsAmpereSecondSymbol, APrefixes);
end;

function AmpereSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := AmpereSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := AmpereSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsAmpereSecondSymbol, cAmpereSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsAmpereSecondSymbol, APrefixes);
  end;
end;

function AmpereSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulomb then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cAmpereSecondFactor) + ' ' + GetName(rsAmpereSecondName, cAmpereSecondPrefixes)
  else
    result := FloatToStr(AValue.FValue / cAmpereSecondFactor) + ' ' + GetName(rsAmpereSecondPluralName, cAmpereSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cAmpereSecondFactor) + ' ' + GetName(rsAmpereSecondName, cAmpereSecondPrefixes)
  else
    result := FloatToStr(AValue / cAmpereSecondFactor) + ' ' + GetName(rsAmpereSecondPluralName, cAmpereSecondPrefixes);
  result := '';
{$ENDIF}
end;

function AmpereSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulomb then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cAmpereSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsAmpereSecondName, cAmpereSecondPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cAmpereSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsAmpereSecondPluralName, cAmpereSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cAmpereSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsAmpereSecondName, cAmpereSecondPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cAmpereSecondFactor, rsAmpereSecondPluralName);
{$ENDIF}
end;

function AmpereSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulomb then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function AmpereSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulomb then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cAmpereSecondPrefixes, cAmpereSecondExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cAmpereSecondPrefixes, cAmpereSecondExponents);
{$ENDIF}
end;

function SquareCoulombToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareCoulomb then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsSquareCoulombSymbol, cSquareCoulombPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsSquareCoulombSymbol, cSquareCoulombPrefixes);
{$ENDIF}
end;

function SquareCoulombToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareCoulomb then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSquareCoulombPrefixes, cSquareCoulombExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSquareCoulombPrefixes, cSquareCoulombExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareCoulombSymbol, cSquareCoulombPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareCoulombSymbol, APrefixes);
end;

function SquareCoulombToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SquareCoulombToFloat(AQuantity, APrefixes);
  FactoredTol   := SquareCoulombToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareCoulombSymbol, cSquareCoulombPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsSquareCoulombSymbol, APrefixes);
  end;
end;

function SquareCoulombToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareCoulomb then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsSquareCoulombName, cSquareCoulombPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsSquareCoulombPluralName, cSquareCoulombPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsSquareCoulombName, cSquareCoulombPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsSquareCoulombPluralName, cSquareCoulombPrefixes);
{$ENDIF}
end;

function SquareCoulombToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareCoulomb then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareCoulombName, cSquareCoulombPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareCoulombPluralName, cSquareCoulombPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareCoulombName, cSquareCoulombPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareCoulombPluralName, cSquareCoulombPrefixes);
{$ENDIF}
end;

function SquareCoulombToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SquareCoulombToFloat(AQuantity, APrefixes);
  FactoredTol   := SquareCoulombToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareCoulombSymbol, cSquareCoulombPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsSquareCoulombSymbol, APrefixes);
  end;
end;

function SquareCoulombToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareCoulomb then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function SquareCoulombToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareCoulomb then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cSquareCoulombPrefixes, cSquareCoulombExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cSquareCoulombPrefixes, cSquareCoulombExponents);
{$ENDIF}
end;

function SquareAmpereSquareSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareCoulomb then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsSquareAmpereSquareSecondSymbol, cSquareAmpereSquareSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsSquareAmpereSquareSecondSymbol, cSquareAmpereSquareSecondPrefixes);
{$ENDIF}
end;

function SquareAmpereSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareCoulomb then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSquareAmpereSquareSecondPrefixes, cSquareAmpereSquareSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSquareAmpereSquareSecondPrefixes, cSquareAmpereSquareSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareAmpereSquareSecondSymbol, cSquareAmpereSquareSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareAmpereSquareSecondSymbol, APrefixes);
end;

function SquareAmpereSquareSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SquareAmpereSquareSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := SquareAmpereSquareSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareAmpereSquareSecondSymbol, cSquareAmpereSquareSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsSquareAmpereSquareSecondSymbol, APrefixes);
  end;
end;

function SquareAmpereSquareSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareCoulomb then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cSquareAmpereSquareSecondFactor) + ' ' + GetName(rsSquareAmpereSquareSecondName, cSquareAmpereSquareSecondPrefixes)
  else
    result := FloatToStr(AValue.FValue / cSquareAmpereSquareSecondFactor) + ' ' + GetName(rsSquareAmpereSquareSecondPluralName, cSquareAmpereSquareSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cSquareAmpereSquareSecondFactor) + ' ' + GetName(rsSquareAmpereSquareSecondName, cSquareAmpereSquareSecondPrefixes)
  else
    result := FloatToStr(AValue / cSquareAmpereSquareSecondFactor) + ' ' + GetName(rsSquareAmpereSquareSecondPluralName, cSquareAmpereSquareSecondPrefixes);
  result := '';
{$ENDIF}
end;

function SquareAmpereSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareCoulomb then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cSquareAmpereSquareSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareAmpereSquareSecondName, cSquareAmpereSquareSecondPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cSquareAmpereSquareSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareAmpereSquareSecondPluralName, cSquareAmpereSquareSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cSquareAmpereSquareSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareAmpereSquareSecondName, cSquareAmpereSquareSecondPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cSquareAmpereSquareSecondFactor, rsSquareAmpereSquareSecondPluralName);
{$ENDIF}
end;

function SquareAmpereSquareSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareCoulomb then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function SquareAmpereSquareSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareCoulomb then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cSquareAmpereSquareSecondPrefixes, cSquareAmpereSquareSecondExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cSquareAmpereSquareSecondPrefixes, cSquareAmpereSquareSecondExponents);
{$ENDIF}
end;

function CoulombMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulombMeter then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsCoulombMeterSymbol, cCoulombMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsCoulombMeterSymbol, cCoulombMeterPrefixes);
{$ENDIF}
end;

function CoulombMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulombMeter then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cCoulombMeterPrefixes, cCoulombMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cCoulombMeterPrefixes, cCoulombMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCoulombMeterSymbol, cCoulombMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCoulombMeterSymbol, APrefixes);
end;

function CoulombMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := CoulombMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := CoulombMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCoulombMeterSymbol, cCoulombMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsCoulombMeterSymbol, APrefixes);
  end;
end;

function CoulombMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulombMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsCoulombMeterName, cCoulombMeterPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsCoulombMeterPluralName, cCoulombMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsCoulombMeterName, cCoulombMeterPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsCoulombMeterPluralName, cCoulombMeterPrefixes);
{$ENDIF}
end;

function CoulombMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulombMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCoulombMeterName, cCoulombMeterPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCoulombMeterPluralName, cCoulombMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCoulombMeterName, cCoulombMeterPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCoulombMeterPluralName, cCoulombMeterPrefixes);
{$ENDIF}
end;

function CoulombMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := CoulombMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := CoulombMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCoulombMeterSymbol, cCoulombMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsCoulombMeterSymbol, APrefixes);
  end;
end;

function CoulombMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulombMeter then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function CoulombMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulombMeter then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cCoulombMeterPrefixes, cCoulombMeterExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cCoulombMeterPrefixes, cCoulombMeterExponents);
{$ENDIF}
end;

function VoltToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVolt then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsVoltSymbol, cVoltPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsVoltSymbol, cVoltPrefixes);
{$ENDIF}
end;

function VoltToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVolt then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cVoltPrefixes, cVoltExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cVoltPrefixes, cVoltExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsVoltSymbol, cVoltPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsVoltSymbol, APrefixes);
end;

function VoltToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := VoltToFloat(AQuantity, APrefixes);
  FactoredTol   := VoltToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsVoltSymbol, cVoltPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsVoltSymbol, APrefixes);
  end;
end;

function VoltToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVolt then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsVoltName, cVoltPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsVoltPluralName, cVoltPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsVoltName, cVoltPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsVoltPluralName, cVoltPrefixes);
{$ENDIF}
end;

function VoltToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVolt then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsVoltName, cVoltPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsVoltPluralName, cVoltPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsVoltName, cVoltPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsVoltPluralName, cVoltPrefixes);
{$ENDIF}
end;

function VoltToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := VoltToFloat(AQuantity, APrefixes);
  FactoredTol   := VoltToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsVoltSymbol, cVoltPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsVoltSymbol, APrefixes);
  end;
end;

function VoltToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVolt then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function VoltToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVolt then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cVoltPrefixes, cVoltExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cVoltPrefixes, cVoltExponents);
{$ENDIF}
end;

function JoulePerCoulombToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVolt then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsJoulePerCoulombSymbol, cJoulePerCoulombPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsJoulePerCoulombSymbol, cJoulePerCoulombPrefixes);
{$ENDIF}
end;

function JoulePerCoulombToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVolt then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cJoulePerCoulombPrefixes, cJoulePerCoulombExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cJoulePerCoulombPrefixes, cJoulePerCoulombExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsJoulePerCoulombSymbol, cJoulePerCoulombPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsJoulePerCoulombSymbol, APrefixes);
end;

function JoulePerCoulombToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := JoulePerCoulombToFloat(AQuantity, APrefixes);
  FactoredTol   := JoulePerCoulombToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsJoulePerCoulombSymbol, cJoulePerCoulombPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsJoulePerCoulombSymbol, APrefixes);
  end;
end;

function JoulePerCoulombToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVolt then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cJoulePerCoulombFactor) + ' ' + GetName(rsJoulePerCoulombName, cJoulePerCoulombPrefixes)
  else
    result := FloatToStr(AValue.FValue / cJoulePerCoulombFactor) + ' ' + GetName(rsJoulePerCoulombPluralName, cJoulePerCoulombPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cJoulePerCoulombFactor) + ' ' + GetName(rsJoulePerCoulombName, cJoulePerCoulombPrefixes)
  else
    result := FloatToStr(AValue / cJoulePerCoulombFactor) + ' ' + GetName(rsJoulePerCoulombPluralName, cJoulePerCoulombPrefixes);
  result := '';
{$ENDIF}
end;

function JoulePerCoulombToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVolt then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cJoulePerCoulombFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsJoulePerCoulombName, cJoulePerCoulombPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cJoulePerCoulombFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsJoulePerCoulombPluralName, cJoulePerCoulombPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cJoulePerCoulombFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsJoulePerCoulombName, cJoulePerCoulombPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cJoulePerCoulombFactor, rsJoulePerCoulombPluralName);
{$ENDIF}
end;

function JoulePerCoulombToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVolt then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function JoulePerCoulombToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVolt then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cJoulePerCoulombPrefixes, cJoulePerCoulombExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cJoulePerCoulombPrefixes, cJoulePerCoulombExponents);
{$ENDIF}
end;

function KilogramSquareMeterPerAmperePerCubicSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVolt then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsKilogramSquareMeterPerAmperePerCubicSecondSymbol, cKilogramSquareMeterPerAmperePerCubicSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsKilogramSquareMeterPerAmperePerCubicSecondSymbol, cKilogramSquareMeterPerAmperePerCubicSecondPrefixes);
{$ENDIF}
end;

function KilogramSquareMeterPerAmperePerCubicSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVolt then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cKilogramSquareMeterPerAmperePerCubicSecondPrefixes, cKilogramSquareMeterPerAmperePerCubicSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cKilogramSquareMeterPerAmperePerCubicSecondPrefixes, cKilogramSquareMeterPerAmperePerCubicSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramSquareMeterPerAmperePerCubicSecondSymbol, cKilogramSquareMeterPerAmperePerCubicSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramSquareMeterPerAmperePerCubicSecondSymbol, APrefixes);
end;

function KilogramSquareMeterPerAmperePerCubicSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := KilogramSquareMeterPerAmperePerCubicSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := KilogramSquareMeterPerAmperePerCubicSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramSquareMeterPerAmperePerCubicSecondSymbol, cKilogramSquareMeterPerAmperePerCubicSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsKilogramSquareMeterPerAmperePerCubicSecondSymbol, APrefixes);
  end;
end;

function KilogramSquareMeterPerAmperePerCubicSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVolt then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cKilogramSquareMeterPerAmperePerCubicSecondFactor) + ' ' + GetName(rsKilogramSquareMeterPerAmperePerCubicSecondName, cKilogramSquareMeterPerAmperePerCubicSecondPrefixes)
  else
    result := FloatToStr(AValue.FValue / cKilogramSquareMeterPerAmperePerCubicSecondFactor) + ' ' + GetName(rsKilogramSquareMeterPerAmperePerCubicSecondPluralName, cKilogramSquareMeterPerAmperePerCubicSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cKilogramSquareMeterPerAmperePerCubicSecondFactor) + ' ' + GetName(rsKilogramSquareMeterPerAmperePerCubicSecondName, cKilogramSquareMeterPerAmperePerCubicSecondPrefixes)
  else
    result := FloatToStr(AValue / cKilogramSquareMeterPerAmperePerCubicSecondFactor) + ' ' + GetName(rsKilogramSquareMeterPerAmperePerCubicSecondPluralName, cKilogramSquareMeterPerAmperePerCubicSecondPrefixes);
  result := '';
{$ENDIF}
end;

function KilogramSquareMeterPerAmperePerCubicSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVolt then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cKilogramSquareMeterPerAmperePerCubicSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramSquareMeterPerAmperePerCubicSecondName, cKilogramSquareMeterPerAmperePerCubicSecondPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cKilogramSquareMeterPerAmperePerCubicSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramSquareMeterPerAmperePerCubicSecondPluralName, cKilogramSquareMeterPerAmperePerCubicSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cKilogramSquareMeterPerAmperePerCubicSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramSquareMeterPerAmperePerCubicSecondName, cKilogramSquareMeterPerAmperePerCubicSecondPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cKilogramSquareMeterPerAmperePerCubicSecondFactor, rsKilogramSquareMeterPerAmperePerCubicSecondPluralName);
{$ENDIF}
end;

function KilogramSquareMeterPerAmperePerCubicSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVolt then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function KilogramSquareMeterPerAmperePerCubicSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVolt then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cKilogramSquareMeterPerAmperePerCubicSecondPrefixes, cKilogramSquareMeterPerAmperePerCubicSecondExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cKilogramSquareMeterPerAmperePerCubicSecondPrefixes, cKilogramSquareMeterPerAmperePerCubicSecondExponents);
{$ENDIF}
end;

function SquareVoltToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareVolt then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsSquareVoltSymbol, cSquareVoltPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsSquareVoltSymbol, cSquareVoltPrefixes);
{$ENDIF}
end;

function SquareVoltToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareVolt then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSquareVoltPrefixes, cSquareVoltExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSquareVoltPrefixes, cSquareVoltExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareVoltSymbol, cSquareVoltPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareVoltSymbol, APrefixes);
end;

function SquareVoltToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SquareVoltToFloat(AQuantity, APrefixes);
  FactoredTol   := SquareVoltToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareVoltSymbol, cSquareVoltPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsSquareVoltSymbol, APrefixes);
  end;
end;

function SquareVoltToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareVolt then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsSquareVoltName, cSquareVoltPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsSquareVoltPluralName, cSquareVoltPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsSquareVoltName, cSquareVoltPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsSquareVoltPluralName, cSquareVoltPrefixes);
{$ENDIF}
end;

function SquareVoltToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareVolt then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareVoltName, cSquareVoltPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareVoltPluralName, cSquareVoltPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareVoltName, cSquareVoltPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareVoltPluralName, cSquareVoltPrefixes);
{$ENDIF}
end;

function SquareVoltToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SquareVoltToFloat(AQuantity, APrefixes);
  FactoredTol   := SquareVoltToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareVoltSymbol, cSquareVoltPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsSquareVoltSymbol, APrefixes);
  end;
end;

function SquareVoltToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareVolt then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function SquareVoltToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareVolt then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cSquareVoltPrefixes, cSquareVoltExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cSquareVoltPrefixes, cSquareVoltExponents);
{$ENDIF}
end;

function SquareKilogramQuarticMeterPerSquareAmperePerSexticSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareVolt then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsSquareKilogramQuarticMeterPerSquareAmperePerSexticSecondSymbol, cSquareKilogramQuarticMeterPerSquareAmperePerSexticSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsSquareKilogramQuarticMeterPerSquareAmperePerSexticSecondSymbol, cSquareKilogramQuarticMeterPerSquareAmperePerSexticSecondPrefixes);
{$ENDIF}
end;

function SquareKilogramQuarticMeterPerSquareAmperePerSexticSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareVolt then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSquareKilogramQuarticMeterPerSquareAmperePerSexticSecondPrefixes, cSquareKilogramQuarticMeterPerSquareAmperePerSexticSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSquareKilogramQuarticMeterPerSquareAmperePerSexticSecondPrefixes, cSquareKilogramQuarticMeterPerSquareAmperePerSexticSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareKilogramQuarticMeterPerSquareAmperePerSexticSecondSymbol, cSquareKilogramQuarticMeterPerSquareAmperePerSexticSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareKilogramQuarticMeterPerSquareAmperePerSexticSecondSymbol, APrefixes);
end;

function SquareKilogramQuarticMeterPerSquareAmperePerSexticSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SquareKilogramQuarticMeterPerSquareAmperePerSexticSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := SquareKilogramQuarticMeterPerSquareAmperePerSexticSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareKilogramQuarticMeterPerSquareAmperePerSexticSecondSymbol, cSquareKilogramQuarticMeterPerSquareAmperePerSexticSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsSquareKilogramQuarticMeterPerSquareAmperePerSexticSecondSymbol, APrefixes);
  end;
end;

function SquareKilogramQuarticMeterPerSquareAmperePerSexticSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareVolt then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cSquareKilogramQuarticMeterPerSquareAmperePerSexticSecondFactor) + ' ' + GetName(rsSquareKilogramQuarticMeterPerSquareAmperePerSexticSecondName, cSquareKilogramQuarticMeterPerSquareAmperePerSexticSecondPrefixes)
  else
    result := FloatToStr(AValue.FValue / cSquareKilogramQuarticMeterPerSquareAmperePerSexticSecondFactor) + ' ' + GetName(rsSquareKilogramQuarticMeterPerSquareAmperePerSexticSecondPluralName, cSquareKilogramQuarticMeterPerSquareAmperePerSexticSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cSquareKilogramQuarticMeterPerSquareAmperePerSexticSecondFactor) + ' ' + GetName(rsSquareKilogramQuarticMeterPerSquareAmperePerSexticSecondName, cSquareKilogramQuarticMeterPerSquareAmperePerSexticSecondPrefixes)
  else
    result := FloatToStr(AValue / cSquareKilogramQuarticMeterPerSquareAmperePerSexticSecondFactor) + ' ' + GetName(rsSquareKilogramQuarticMeterPerSquareAmperePerSexticSecondPluralName, cSquareKilogramQuarticMeterPerSquareAmperePerSexticSecondPrefixes);
  result := '';
{$ENDIF}
end;

function SquareKilogramQuarticMeterPerSquareAmperePerSexticSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareVolt then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cSquareKilogramQuarticMeterPerSquareAmperePerSexticSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareKilogramQuarticMeterPerSquareAmperePerSexticSecondName, cSquareKilogramQuarticMeterPerSquareAmperePerSexticSecondPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cSquareKilogramQuarticMeterPerSquareAmperePerSexticSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareKilogramQuarticMeterPerSquareAmperePerSexticSecondPluralName, cSquareKilogramQuarticMeterPerSquareAmperePerSexticSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cSquareKilogramQuarticMeterPerSquareAmperePerSexticSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareKilogramQuarticMeterPerSquareAmperePerSexticSecondName, cSquareKilogramQuarticMeterPerSquareAmperePerSexticSecondPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cSquareKilogramQuarticMeterPerSquareAmperePerSexticSecondFactor, rsSquareKilogramQuarticMeterPerSquareAmperePerSexticSecondPluralName);
{$ENDIF}
end;

function SquareKilogramQuarticMeterPerSquareAmperePerSexticSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareVolt then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function SquareKilogramQuarticMeterPerSquareAmperePerSexticSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareVolt then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cSquareKilogramQuarticMeterPerSquareAmperePerSexticSecondPrefixes, cSquareKilogramQuarticMeterPerSquareAmperePerSexticSecondExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cSquareKilogramQuarticMeterPerSquareAmperePerSexticSecondPrefixes, cSquareKilogramQuarticMeterPerSquareAmperePerSexticSecondExponents);
{$ENDIF}
end;

function FaradToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cFarad then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsFaradSymbol, cFaradPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsFaradSymbol, cFaradPrefixes);
{$ENDIF}
end;

function FaradToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cFarad then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cFaradPrefixes, cFaradExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cFaradPrefixes, cFaradExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsFaradSymbol, cFaradPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsFaradSymbol, APrefixes);
end;

function FaradToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := FaradToFloat(AQuantity, APrefixes);
  FactoredTol   := FaradToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsFaradSymbol, cFaradPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsFaradSymbol, APrefixes);
  end;
end;

function FaradToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cFarad then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsFaradName, cFaradPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsFaradPluralName, cFaradPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsFaradName, cFaradPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsFaradPluralName, cFaradPrefixes);
{$ENDIF}
end;

function FaradToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cFarad then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsFaradName, cFaradPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsFaradPluralName, cFaradPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsFaradName, cFaradPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsFaradPluralName, cFaradPrefixes);
{$ENDIF}
end;

function FaradToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := FaradToFloat(AQuantity, APrefixes);
  FactoredTol   := FaradToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsFaradSymbol, cFaradPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsFaradSymbol, APrefixes);
  end;
end;

function FaradToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cFarad then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function FaradToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cFarad then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cFaradPrefixes, cFaradExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cFaradPrefixes, cFaradExponents);
{$ENDIF}
end;

function CoulombPerVoltToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cFarad then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsCoulombPerVoltSymbol, cCoulombPerVoltPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsCoulombPerVoltSymbol, cCoulombPerVoltPrefixes);
{$ENDIF}
end;

function CoulombPerVoltToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cFarad then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cCoulombPerVoltPrefixes, cCoulombPerVoltExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cCoulombPerVoltPrefixes, cCoulombPerVoltExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCoulombPerVoltSymbol, cCoulombPerVoltPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCoulombPerVoltSymbol, APrefixes);
end;

function CoulombPerVoltToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := CoulombPerVoltToFloat(AQuantity, APrefixes);
  FactoredTol   := CoulombPerVoltToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCoulombPerVoltSymbol, cCoulombPerVoltPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsCoulombPerVoltSymbol, APrefixes);
  end;
end;

function CoulombPerVoltToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cFarad then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cCoulombPerVoltFactor) + ' ' + GetName(rsCoulombPerVoltName, cCoulombPerVoltPrefixes)
  else
    result := FloatToStr(AValue.FValue / cCoulombPerVoltFactor) + ' ' + GetName(rsCoulombPerVoltPluralName, cCoulombPerVoltPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cCoulombPerVoltFactor) + ' ' + GetName(rsCoulombPerVoltName, cCoulombPerVoltPrefixes)
  else
    result := FloatToStr(AValue / cCoulombPerVoltFactor) + ' ' + GetName(rsCoulombPerVoltPluralName, cCoulombPerVoltPrefixes);
  result := '';
{$ENDIF}
end;

function CoulombPerVoltToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cFarad then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cCoulombPerVoltFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCoulombPerVoltName, cCoulombPerVoltPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cCoulombPerVoltFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCoulombPerVoltPluralName, cCoulombPerVoltPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cCoulombPerVoltFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCoulombPerVoltName, cCoulombPerVoltPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cCoulombPerVoltFactor, rsCoulombPerVoltPluralName);
{$ENDIF}
end;

function CoulombPerVoltToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cFarad then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function CoulombPerVoltToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cFarad then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cCoulombPerVoltPrefixes, cCoulombPerVoltExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cCoulombPerVoltPrefixes, cCoulombPerVoltExponents);
{$ENDIF}
end;

function SquareAmpereQuarticSecondPerKilogramPerSquareMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cFarad then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsSquareAmpereQuarticSecondPerKilogramPerSquareMeterSymbol, cSquareAmpereQuarticSecondPerKilogramPerSquareMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsSquareAmpereQuarticSecondPerKilogramPerSquareMeterSymbol, cSquareAmpereQuarticSecondPerKilogramPerSquareMeterPrefixes);
{$ENDIF}
end;

function SquareAmpereQuarticSecondPerKilogramPerSquareMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cFarad then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSquareAmpereQuarticSecondPerKilogramPerSquareMeterPrefixes, cSquareAmpereQuarticSecondPerKilogramPerSquareMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSquareAmpereQuarticSecondPerKilogramPerSquareMeterPrefixes, cSquareAmpereQuarticSecondPerKilogramPerSquareMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareAmpereQuarticSecondPerKilogramPerSquareMeterSymbol, cSquareAmpereQuarticSecondPerKilogramPerSquareMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareAmpereQuarticSecondPerKilogramPerSquareMeterSymbol, APrefixes);
end;

function SquareAmpereQuarticSecondPerKilogramPerSquareMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SquareAmpereQuarticSecondPerKilogramPerSquareMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := SquareAmpereQuarticSecondPerKilogramPerSquareMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareAmpereQuarticSecondPerKilogramPerSquareMeterSymbol, cSquareAmpereQuarticSecondPerKilogramPerSquareMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsSquareAmpereQuarticSecondPerKilogramPerSquareMeterSymbol, APrefixes);
  end;
end;

function SquareAmpereQuarticSecondPerKilogramPerSquareMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cFarad then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cSquareAmpereQuarticSecondPerKilogramPerSquareMeterFactor) + ' ' + GetName(rsSquareAmpereQuarticSecondPerKilogramPerSquareMeterName, cSquareAmpereQuarticSecondPerKilogramPerSquareMeterPrefixes)
  else
    result := FloatToStr(AValue.FValue / cSquareAmpereQuarticSecondPerKilogramPerSquareMeterFactor) + ' ' + GetName(rsSquareAmpereQuarticSecondPerKilogramPerSquareMeterPluralName, cSquareAmpereQuarticSecondPerKilogramPerSquareMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cSquareAmpereQuarticSecondPerKilogramPerSquareMeterFactor) + ' ' + GetName(rsSquareAmpereQuarticSecondPerKilogramPerSquareMeterName, cSquareAmpereQuarticSecondPerKilogramPerSquareMeterPrefixes)
  else
    result := FloatToStr(AValue / cSquareAmpereQuarticSecondPerKilogramPerSquareMeterFactor) + ' ' + GetName(rsSquareAmpereQuarticSecondPerKilogramPerSquareMeterPluralName, cSquareAmpereQuarticSecondPerKilogramPerSquareMeterPrefixes);
  result := '';
{$ENDIF}
end;

function SquareAmpereQuarticSecondPerKilogramPerSquareMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cFarad then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cSquareAmpereQuarticSecondPerKilogramPerSquareMeterFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareAmpereQuarticSecondPerKilogramPerSquareMeterName, cSquareAmpereQuarticSecondPerKilogramPerSquareMeterPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cSquareAmpereQuarticSecondPerKilogramPerSquareMeterFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareAmpereQuarticSecondPerKilogramPerSquareMeterPluralName, cSquareAmpereQuarticSecondPerKilogramPerSquareMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cSquareAmpereQuarticSecondPerKilogramPerSquareMeterFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareAmpereQuarticSecondPerKilogramPerSquareMeterName, cSquareAmpereQuarticSecondPerKilogramPerSquareMeterPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cSquareAmpereQuarticSecondPerKilogramPerSquareMeterFactor, rsSquareAmpereQuarticSecondPerKilogramPerSquareMeterPluralName);
{$ENDIF}
end;

function SquareAmpereQuarticSecondPerKilogramPerSquareMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cFarad then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function SquareAmpereQuarticSecondPerKilogramPerSquareMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cFarad then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cSquareAmpereQuarticSecondPerKilogramPerSquareMeterPrefixes, cSquareAmpereQuarticSecondPerKilogramPerSquareMeterExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cSquareAmpereQuarticSecondPerKilogramPerSquareMeterPrefixes, cSquareAmpereQuarticSecondPerKilogramPerSquareMeterExponents);
{$ENDIF}
end;

function OhmToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cOhm then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsOhmSymbol, cOhmPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsOhmSymbol, cOhmPrefixes);
{$ENDIF}
end;

function OhmToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cOhm then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cOhmPrefixes, cOhmExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cOhmPrefixes, cOhmExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsOhmSymbol, cOhmPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsOhmSymbol, APrefixes);
end;

function OhmToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := OhmToFloat(AQuantity, APrefixes);
  FactoredTol   := OhmToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsOhmSymbol, cOhmPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsOhmSymbol, APrefixes);
  end;
end;

function OhmToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cOhm then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsOhmName, cOhmPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsOhmPluralName, cOhmPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsOhmName, cOhmPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsOhmPluralName, cOhmPrefixes);
{$ENDIF}
end;

function OhmToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cOhm then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsOhmName, cOhmPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsOhmPluralName, cOhmPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsOhmName, cOhmPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsOhmPluralName, cOhmPrefixes);
{$ENDIF}
end;

function OhmToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := OhmToFloat(AQuantity, APrefixes);
  FactoredTol   := OhmToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsOhmSymbol, cOhmPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsOhmSymbol, APrefixes);
  end;
end;

function OhmToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cOhm then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function OhmToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cOhm then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cOhmPrefixes, cOhmExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cOhmPrefixes, cOhmExponents);
{$ENDIF}
end;

function KilogramSquareMeterPerSquareAmperePerCubicSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cOhm then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsKilogramSquareMeterPerSquareAmperePerCubicSecondSymbol, cKilogramSquareMeterPerSquareAmperePerCubicSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsKilogramSquareMeterPerSquareAmperePerCubicSecondSymbol, cKilogramSquareMeterPerSquareAmperePerCubicSecondPrefixes);
{$ENDIF}
end;

function KilogramSquareMeterPerSquareAmperePerCubicSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cOhm then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cKilogramSquareMeterPerSquareAmperePerCubicSecondPrefixes, cKilogramSquareMeterPerSquareAmperePerCubicSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cKilogramSquareMeterPerSquareAmperePerCubicSecondPrefixes, cKilogramSquareMeterPerSquareAmperePerCubicSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramSquareMeterPerSquareAmperePerCubicSecondSymbol, cKilogramSquareMeterPerSquareAmperePerCubicSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramSquareMeterPerSquareAmperePerCubicSecondSymbol, APrefixes);
end;

function KilogramSquareMeterPerSquareAmperePerCubicSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := KilogramSquareMeterPerSquareAmperePerCubicSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := KilogramSquareMeterPerSquareAmperePerCubicSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramSquareMeterPerSquareAmperePerCubicSecondSymbol, cKilogramSquareMeterPerSquareAmperePerCubicSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsKilogramSquareMeterPerSquareAmperePerCubicSecondSymbol, APrefixes);
  end;
end;

function KilogramSquareMeterPerSquareAmperePerCubicSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cOhm then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cKilogramSquareMeterPerSquareAmperePerCubicSecondFactor) + ' ' + GetName(rsKilogramSquareMeterPerSquareAmperePerCubicSecondName, cKilogramSquareMeterPerSquareAmperePerCubicSecondPrefixes)
  else
    result := FloatToStr(AValue.FValue / cKilogramSquareMeterPerSquareAmperePerCubicSecondFactor) + ' ' + GetName(rsKilogramSquareMeterPerSquareAmperePerCubicSecondPluralName, cKilogramSquareMeterPerSquareAmperePerCubicSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cKilogramSquareMeterPerSquareAmperePerCubicSecondFactor) + ' ' + GetName(rsKilogramSquareMeterPerSquareAmperePerCubicSecondName, cKilogramSquareMeterPerSquareAmperePerCubicSecondPrefixes)
  else
    result := FloatToStr(AValue / cKilogramSquareMeterPerSquareAmperePerCubicSecondFactor) + ' ' + GetName(rsKilogramSquareMeterPerSquareAmperePerCubicSecondPluralName, cKilogramSquareMeterPerSquareAmperePerCubicSecondPrefixes);
  result := '';
{$ENDIF}
end;

function KilogramSquareMeterPerSquareAmperePerCubicSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cOhm then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cKilogramSquareMeterPerSquareAmperePerCubicSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramSquareMeterPerSquareAmperePerCubicSecondName, cKilogramSquareMeterPerSquareAmperePerCubicSecondPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cKilogramSquareMeterPerSquareAmperePerCubicSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramSquareMeterPerSquareAmperePerCubicSecondPluralName, cKilogramSquareMeterPerSquareAmperePerCubicSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cKilogramSquareMeterPerSquareAmperePerCubicSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramSquareMeterPerSquareAmperePerCubicSecondName, cKilogramSquareMeterPerSquareAmperePerCubicSecondPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cKilogramSquareMeterPerSquareAmperePerCubicSecondFactor, rsKilogramSquareMeterPerSquareAmperePerCubicSecondPluralName);
{$ENDIF}
end;

function KilogramSquareMeterPerSquareAmperePerCubicSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cOhm then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function KilogramSquareMeterPerSquareAmperePerCubicSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cOhm then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cKilogramSquareMeterPerSquareAmperePerCubicSecondPrefixes, cKilogramSquareMeterPerSquareAmperePerCubicSecondExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cKilogramSquareMeterPerSquareAmperePerCubicSecondPrefixes, cKilogramSquareMeterPerSquareAmperePerCubicSecondExponents);
{$ENDIF}
end;

function SiemensToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSiemens then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsSiemensSymbol, cSiemensPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsSiemensSymbol, cSiemensPrefixes);
{$ENDIF}
end;

function SiemensToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSiemens then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSiemensPrefixes, cSiemensExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSiemensPrefixes, cSiemensExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSiemensSymbol, cSiemensPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSiemensSymbol, APrefixes);
end;

function SiemensToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SiemensToFloat(AQuantity, APrefixes);
  FactoredTol   := SiemensToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSiemensSymbol, cSiemensPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsSiemensSymbol, APrefixes);
  end;
end;

function SiemensToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSiemens then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsSiemensName, cSiemensPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsSiemensPluralName, cSiemensPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsSiemensName, cSiemensPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsSiemensPluralName, cSiemensPrefixes);
{$ENDIF}
end;

function SiemensToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSiemens then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSiemensName, cSiemensPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSiemensPluralName, cSiemensPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSiemensName, cSiemensPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSiemensPluralName, cSiemensPrefixes);
{$ENDIF}
end;

function SiemensToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SiemensToFloat(AQuantity, APrefixes);
  FactoredTol   := SiemensToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSiemensSymbol, cSiemensPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsSiemensSymbol, APrefixes);
  end;
end;

function SiemensToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSiemens then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function SiemensToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSiemens then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cSiemensPrefixes, cSiemensExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cSiemensPrefixes, cSiemensExponents);
{$ENDIF}
end;

function SquareAmpereCubicSecondPerKilogramPerSquareMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSiemens then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsSquareAmpereCubicSecondPerKilogramPerSquareMeterSymbol, cSquareAmpereCubicSecondPerKilogramPerSquareMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsSquareAmpereCubicSecondPerKilogramPerSquareMeterSymbol, cSquareAmpereCubicSecondPerKilogramPerSquareMeterPrefixes);
{$ENDIF}
end;

function SquareAmpereCubicSecondPerKilogramPerSquareMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSiemens then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSquareAmpereCubicSecondPerKilogramPerSquareMeterPrefixes, cSquareAmpereCubicSecondPerKilogramPerSquareMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSquareAmpereCubicSecondPerKilogramPerSquareMeterPrefixes, cSquareAmpereCubicSecondPerKilogramPerSquareMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareAmpereCubicSecondPerKilogramPerSquareMeterSymbol, cSquareAmpereCubicSecondPerKilogramPerSquareMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareAmpereCubicSecondPerKilogramPerSquareMeterSymbol, APrefixes);
end;

function SquareAmpereCubicSecondPerKilogramPerSquareMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SquareAmpereCubicSecondPerKilogramPerSquareMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := SquareAmpereCubicSecondPerKilogramPerSquareMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareAmpereCubicSecondPerKilogramPerSquareMeterSymbol, cSquareAmpereCubicSecondPerKilogramPerSquareMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsSquareAmpereCubicSecondPerKilogramPerSquareMeterSymbol, APrefixes);
  end;
end;

function SquareAmpereCubicSecondPerKilogramPerSquareMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSiemens then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cSquareAmpereCubicSecondPerKilogramPerSquareMeterFactor) + ' ' + GetName(rsSquareAmpereCubicSecondPerKilogramPerSquareMeterName, cSquareAmpereCubicSecondPerKilogramPerSquareMeterPrefixes)
  else
    result := FloatToStr(AValue.FValue / cSquareAmpereCubicSecondPerKilogramPerSquareMeterFactor) + ' ' + GetName(rsSquareAmpereCubicSecondPerKilogramPerSquareMeterPluralName, cSquareAmpereCubicSecondPerKilogramPerSquareMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cSquareAmpereCubicSecondPerKilogramPerSquareMeterFactor) + ' ' + GetName(rsSquareAmpereCubicSecondPerKilogramPerSquareMeterName, cSquareAmpereCubicSecondPerKilogramPerSquareMeterPrefixes)
  else
    result := FloatToStr(AValue / cSquareAmpereCubicSecondPerKilogramPerSquareMeterFactor) + ' ' + GetName(rsSquareAmpereCubicSecondPerKilogramPerSquareMeterPluralName, cSquareAmpereCubicSecondPerKilogramPerSquareMeterPrefixes);
  result := '';
{$ENDIF}
end;

function SquareAmpereCubicSecondPerKilogramPerSquareMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSiemens then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cSquareAmpereCubicSecondPerKilogramPerSquareMeterFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareAmpereCubicSecondPerKilogramPerSquareMeterName, cSquareAmpereCubicSecondPerKilogramPerSquareMeterPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cSquareAmpereCubicSecondPerKilogramPerSquareMeterFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareAmpereCubicSecondPerKilogramPerSquareMeterPluralName, cSquareAmpereCubicSecondPerKilogramPerSquareMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cSquareAmpereCubicSecondPerKilogramPerSquareMeterFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareAmpereCubicSecondPerKilogramPerSquareMeterName, cSquareAmpereCubicSecondPerKilogramPerSquareMeterPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cSquareAmpereCubicSecondPerKilogramPerSquareMeterFactor, rsSquareAmpereCubicSecondPerKilogramPerSquareMeterPluralName);
{$ENDIF}
end;

function SquareAmpereCubicSecondPerKilogramPerSquareMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSiemens then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function SquareAmpereCubicSecondPerKilogramPerSquareMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSiemens then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cSquareAmpereCubicSecondPerKilogramPerSquareMeterPrefixes, cSquareAmpereCubicSecondPerKilogramPerSquareMeterExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cSquareAmpereCubicSecondPerKilogramPerSquareMeterPrefixes, cSquareAmpereCubicSecondPerKilogramPerSquareMeterExponents);
{$ENDIF}
end;

function SiemensPerMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSiemensPerMeter then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsSiemensPerMeterSymbol, cSiemensPerMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsSiemensPerMeterSymbol, cSiemensPerMeterPrefixes);
{$ENDIF}
end;

function SiemensPerMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSiemensPerMeter then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSiemensPerMeterPrefixes, cSiemensPerMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSiemensPerMeterPrefixes, cSiemensPerMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSiemensPerMeterSymbol, cSiemensPerMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSiemensPerMeterSymbol, APrefixes);
end;

function SiemensPerMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SiemensPerMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := SiemensPerMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSiemensPerMeterSymbol, cSiemensPerMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsSiemensPerMeterSymbol, APrefixes);
  end;
end;

function SiemensPerMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSiemensPerMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsSiemensPerMeterName, cSiemensPerMeterPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsSiemensPerMeterPluralName, cSiemensPerMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsSiemensPerMeterName, cSiemensPerMeterPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsSiemensPerMeterPluralName, cSiemensPerMeterPrefixes);
{$ENDIF}
end;

function SiemensPerMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSiemensPerMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSiemensPerMeterName, cSiemensPerMeterPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSiemensPerMeterPluralName, cSiemensPerMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSiemensPerMeterName, cSiemensPerMeterPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSiemensPerMeterPluralName, cSiemensPerMeterPrefixes);
{$ENDIF}
end;

function SiemensPerMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SiemensPerMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := SiemensPerMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSiemensPerMeterSymbol, cSiemensPerMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsSiemensPerMeterSymbol, APrefixes);
  end;
end;

function SiemensPerMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSiemensPerMeter then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function SiemensPerMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSiemensPerMeter then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cSiemensPerMeterPrefixes, cSiemensPerMeterExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cSiemensPerMeterPrefixes, cSiemensPerMeterExponents);
{$ENDIF}
end;

function TeslaToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cTesla then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsTeslaSymbol, cTeslaPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsTeslaSymbol, cTeslaPrefixes);
{$ENDIF}
end;

function TeslaToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cTesla then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cTeslaPrefixes, cTeslaExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cTeslaPrefixes, cTeslaExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsTeslaSymbol, cTeslaPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsTeslaSymbol, APrefixes);
end;

function TeslaToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := TeslaToFloat(AQuantity, APrefixes);
  FactoredTol   := TeslaToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsTeslaSymbol, cTeslaPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsTeslaSymbol, APrefixes);
  end;
end;

function TeslaToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cTesla then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsTeslaName, cTeslaPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsTeslaPluralName, cTeslaPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsTeslaName, cTeslaPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsTeslaPluralName, cTeslaPrefixes);
{$ENDIF}
end;

function TeslaToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cTesla then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsTeslaName, cTeslaPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsTeslaPluralName, cTeslaPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsTeslaName, cTeslaPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsTeslaPluralName, cTeslaPrefixes);
{$ENDIF}
end;

function TeslaToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := TeslaToFloat(AQuantity, APrefixes);
  FactoredTol   := TeslaToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsTeslaSymbol, cTeslaPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsTeslaSymbol, APrefixes);
  end;
end;

function TeslaToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cTesla then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function TeslaToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cTesla then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cTeslaPrefixes, cTeslaExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cTeslaPrefixes, cTeslaExponents);
{$ENDIF}
end;

function WeberPerSquareMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cTesla then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsWeberPerSquareMeterSymbol, cWeberPerSquareMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsWeberPerSquareMeterSymbol, cWeberPerSquareMeterPrefixes);
{$ENDIF}
end;

function WeberPerSquareMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cTesla then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cWeberPerSquareMeterPrefixes, cWeberPerSquareMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cWeberPerSquareMeterPrefixes, cWeberPerSquareMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWeberPerSquareMeterSymbol, cWeberPerSquareMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWeberPerSquareMeterSymbol, APrefixes);
end;

function WeberPerSquareMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := WeberPerSquareMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := WeberPerSquareMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWeberPerSquareMeterSymbol, cWeberPerSquareMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsWeberPerSquareMeterSymbol, APrefixes);
  end;
end;

function WeberPerSquareMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cTesla then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cWeberPerSquareMeterFactor) + ' ' + GetName(rsWeberPerSquareMeterName, cWeberPerSquareMeterPrefixes)
  else
    result := FloatToStr(AValue.FValue / cWeberPerSquareMeterFactor) + ' ' + GetName(rsWeberPerSquareMeterPluralName, cWeberPerSquareMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cWeberPerSquareMeterFactor) + ' ' + GetName(rsWeberPerSquareMeterName, cWeberPerSquareMeterPrefixes)
  else
    result := FloatToStr(AValue / cWeberPerSquareMeterFactor) + ' ' + GetName(rsWeberPerSquareMeterPluralName, cWeberPerSquareMeterPrefixes);
  result := '';
{$ENDIF}
end;

function WeberPerSquareMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cTesla then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cWeberPerSquareMeterFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWeberPerSquareMeterName, cWeberPerSquareMeterPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cWeberPerSquareMeterFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWeberPerSquareMeterPluralName, cWeberPerSquareMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cWeberPerSquareMeterFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWeberPerSquareMeterName, cWeberPerSquareMeterPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cWeberPerSquareMeterFactor, rsWeberPerSquareMeterPluralName);
{$ENDIF}
end;

function WeberPerSquareMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cTesla then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function WeberPerSquareMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cTesla then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cWeberPerSquareMeterPrefixes, cWeberPerSquareMeterExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cWeberPerSquareMeterPrefixes, cWeberPerSquareMeterExponents);
{$ENDIF}
end;

function KilogramPerAmperePerSquareSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cTesla then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsKilogramPerAmperePerSquareSecondSymbol, cKilogramPerAmperePerSquareSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsKilogramPerAmperePerSquareSecondSymbol, cKilogramPerAmperePerSquareSecondPrefixes);
{$ENDIF}
end;

function KilogramPerAmperePerSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cTesla then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cKilogramPerAmperePerSquareSecondPrefixes, cKilogramPerAmperePerSquareSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cKilogramPerAmperePerSquareSecondPrefixes, cKilogramPerAmperePerSquareSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramPerAmperePerSquareSecondSymbol, cKilogramPerAmperePerSquareSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramPerAmperePerSquareSecondSymbol, APrefixes);
end;

function KilogramPerAmperePerSquareSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := KilogramPerAmperePerSquareSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := KilogramPerAmperePerSquareSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramPerAmperePerSquareSecondSymbol, cKilogramPerAmperePerSquareSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsKilogramPerAmperePerSquareSecondSymbol, APrefixes);
  end;
end;

function KilogramPerAmperePerSquareSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cTesla then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cKilogramPerAmperePerSquareSecondFactor) + ' ' + GetName(rsKilogramPerAmperePerSquareSecondName, cKilogramPerAmperePerSquareSecondPrefixes)
  else
    result := FloatToStr(AValue.FValue / cKilogramPerAmperePerSquareSecondFactor) + ' ' + GetName(rsKilogramPerAmperePerSquareSecondPluralName, cKilogramPerAmperePerSquareSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cKilogramPerAmperePerSquareSecondFactor) + ' ' + GetName(rsKilogramPerAmperePerSquareSecondName, cKilogramPerAmperePerSquareSecondPrefixes)
  else
    result := FloatToStr(AValue / cKilogramPerAmperePerSquareSecondFactor) + ' ' + GetName(rsKilogramPerAmperePerSquareSecondPluralName, cKilogramPerAmperePerSquareSecondPrefixes);
  result := '';
{$ENDIF}
end;

function KilogramPerAmperePerSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cTesla then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cKilogramPerAmperePerSquareSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramPerAmperePerSquareSecondName, cKilogramPerAmperePerSquareSecondPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cKilogramPerAmperePerSquareSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramPerAmperePerSquareSecondPluralName, cKilogramPerAmperePerSquareSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cKilogramPerAmperePerSquareSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramPerAmperePerSquareSecondName, cKilogramPerAmperePerSquareSecondPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cKilogramPerAmperePerSquareSecondFactor, rsKilogramPerAmperePerSquareSecondPluralName);
{$ENDIF}
end;

function KilogramPerAmperePerSquareSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cTesla then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function KilogramPerAmperePerSquareSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cTesla then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cKilogramPerAmperePerSquareSecondPrefixes, cKilogramPerAmperePerSquareSecondExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cKilogramPerAmperePerSquareSecondPrefixes, cKilogramPerAmperePerSquareSecondExponents);
{$ENDIF}
end;

function WeberToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWeber then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsWeberSymbol, cWeberPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsWeberSymbol, cWeberPrefixes);
{$ENDIF}
end;

function WeberToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWeber then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cWeberPrefixes, cWeberExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cWeberPrefixes, cWeberExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWeberSymbol, cWeberPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWeberSymbol, APrefixes);
end;

function WeberToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := WeberToFloat(AQuantity, APrefixes);
  FactoredTol   := WeberToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWeberSymbol, cWeberPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsWeberSymbol, APrefixes);
  end;
end;

function WeberToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWeber then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsWeberName, cWeberPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsWeberPluralName, cWeberPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsWeberName, cWeberPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsWeberPluralName, cWeberPrefixes);
{$ENDIF}
end;

function WeberToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWeber then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWeberName, cWeberPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWeberPluralName, cWeberPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWeberName, cWeberPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWeberPluralName, cWeberPrefixes);
{$ENDIF}
end;

function WeberToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := WeberToFloat(AQuantity, APrefixes);
  FactoredTol   := WeberToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWeberSymbol, cWeberPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsWeberSymbol, APrefixes);
  end;
end;

function WeberToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWeber then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function WeberToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWeber then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cWeberPrefixes, cWeberExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cWeberPrefixes, cWeberExponents);
{$ENDIF}
end;

function KilogramSquareMeterPerAmperePerSquareSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWeber then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsKilogramSquareMeterPerAmperePerSquareSecondSymbol, cKilogramSquareMeterPerAmperePerSquareSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsKilogramSquareMeterPerAmperePerSquareSecondSymbol, cKilogramSquareMeterPerAmperePerSquareSecondPrefixes);
{$ENDIF}
end;

function KilogramSquareMeterPerAmperePerSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWeber then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cKilogramSquareMeterPerAmperePerSquareSecondPrefixes, cKilogramSquareMeterPerAmperePerSquareSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cKilogramSquareMeterPerAmperePerSquareSecondPrefixes, cKilogramSquareMeterPerAmperePerSquareSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramSquareMeterPerAmperePerSquareSecondSymbol, cKilogramSquareMeterPerAmperePerSquareSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramSquareMeterPerAmperePerSquareSecondSymbol, APrefixes);
end;

function KilogramSquareMeterPerAmperePerSquareSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := KilogramSquareMeterPerAmperePerSquareSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := KilogramSquareMeterPerAmperePerSquareSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramSquareMeterPerAmperePerSquareSecondSymbol, cKilogramSquareMeterPerAmperePerSquareSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsKilogramSquareMeterPerAmperePerSquareSecondSymbol, APrefixes);
  end;
end;

function KilogramSquareMeterPerAmperePerSquareSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWeber then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cKilogramSquareMeterPerAmperePerSquareSecondFactor) + ' ' + GetName(rsKilogramSquareMeterPerAmperePerSquareSecondName, cKilogramSquareMeterPerAmperePerSquareSecondPrefixes)
  else
    result := FloatToStr(AValue.FValue / cKilogramSquareMeterPerAmperePerSquareSecondFactor) + ' ' + GetName(rsKilogramSquareMeterPerAmperePerSquareSecondPluralName, cKilogramSquareMeterPerAmperePerSquareSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cKilogramSquareMeterPerAmperePerSquareSecondFactor) + ' ' + GetName(rsKilogramSquareMeterPerAmperePerSquareSecondName, cKilogramSquareMeterPerAmperePerSquareSecondPrefixes)
  else
    result := FloatToStr(AValue / cKilogramSquareMeterPerAmperePerSquareSecondFactor) + ' ' + GetName(rsKilogramSquareMeterPerAmperePerSquareSecondPluralName, cKilogramSquareMeterPerAmperePerSquareSecondPrefixes);
  result := '';
{$ENDIF}
end;

function KilogramSquareMeterPerAmperePerSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWeber then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cKilogramSquareMeterPerAmperePerSquareSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramSquareMeterPerAmperePerSquareSecondName, cKilogramSquareMeterPerAmperePerSquareSecondPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cKilogramSquareMeterPerAmperePerSquareSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramSquareMeterPerAmperePerSquareSecondPluralName, cKilogramSquareMeterPerAmperePerSquareSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cKilogramSquareMeterPerAmperePerSquareSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramSquareMeterPerAmperePerSquareSecondName, cKilogramSquareMeterPerAmperePerSquareSecondPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cKilogramSquareMeterPerAmperePerSquareSecondFactor, rsKilogramSquareMeterPerAmperePerSquareSecondPluralName);
{$ENDIF}
end;

function KilogramSquareMeterPerAmperePerSquareSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWeber then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function KilogramSquareMeterPerAmperePerSquareSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWeber then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cKilogramSquareMeterPerAmperePerSquareSecondPrefixes, cKilogramSquareMeterPerAmperePerSquareSecondExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cKilogramSquareMeterPerAmperePerSquareSecondPrefixes, cKilogramSquareMeterPerAmperePerSquareSecondExponents);
{$ENDIF}
end;

function HenryToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHenry then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsHenrySymbol, cHenryPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsHenrySymbol, cHenryPrefixes);
{$ENDIF}
end;

function HenryToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHenry then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cHenryPrefixes, cHenryExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cHenryPrefixes, cHenryExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsHenrySymbol, cHenryPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsHenrySymbol, APrefixes);
end;

function HenryToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := HenryToFloat(AQuantity, APrefixes);
  FactoredTol   := HenryToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsHenrySymbol, cHenryPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsHenrySymbol, APrefixes);
  end;
end;

function HenryToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHenry then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsHenryName, cHenryPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsHenryPluralName, cHenryPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsHenryName, cHenryPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsHenryPluralName, cHenryPrefixes);
{$ENDIF}
end;

function HenryToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHenry then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsHenryName, cHenryPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsHenryPluralName, cHenryPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsHenryName, cHenryPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsHenryPluralName, cHenryPrefixes);
{$ENDIF}
end;

function HenryToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := HenryToFloat(AQuantity, APrefixes);
  FactoredTol   := HenryToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsHenrySymbol, cHenryPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsHenrySymbol, APrefixes);
  end;
end;

function HenryToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHenry then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function HenryToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHenry then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cHenryPrefixes, cHenryExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cHenryPrefixes, cHenryExponents);
{$ENDIF}
end;

function KilogramSquareMeterPerSquareAmperePerSquareSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHenry then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsKilogramSquareMeterPerSquareAmperePerSquareSecondSymbol, cKilogramSquareMeterPerSquareAmperePerSquareSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsKilogramSquareMeterPerSquareAmperePerSquareSecondSymbol, cKilogramSquareMeterPerSquareAmperePerSquareSecondPrefixes);
{$ENDIF}
end;

function KilogramSquareMeterPerSquareAmperePerSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHenry then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cKilogramSquareMeterPerSquareAmperePerSquareSecondPrefixes, cKilogramSquareMeterPerSquareAmperePerSquareSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cKilogramSquareMeterPerSquareAmperePerSquareSecondPrefixes, cKilogramSquareMeterPerSquareAmperePerSquareSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramSquareMeterPerSquareAmperePerSquareSecondSymbol, cKilogramSquareMeterPerSquareAmperePerSquareSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramSquareMeterPerSquareAmperePerSquareSecondSymbol, APrefixes);
end;

function KilogramSquareMeterPerSquareAmperePerSquareSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := KilogramSquareMeterPerSquareAmperePerSquareSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := KilogramSquareMeterPerSquareAmperePerSquareSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramSquareMeterPerSquareAmperePerSquareSecondSymbol, cKilogramSquareMeterPerSquareAmperePerSquareSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsKilogramSquareMeterPerSquareAmperePerSquareSecondSymbol, APrefixes);
  end;
end;

function KilogramSquareMeterPerSquareAmperePerSquareSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHenry then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cKilogramSquareMeterPerSquareAmperePerSquareSecondFactor) + ' ' + GetName(rsKilogramSquareMeterPerSquareAmperePerSquareSecondName, cKilogramSquareMeterPerSquareAmperePerSquareSecondPrefixes)
  else
    result := FloatToStr(AValue.FValue / cKilogramSquareMeterPerSquareAmperePerSquareSecondFactor) + ' ' + GetName(rsKilogramSquareMeterPerSquareAmperePerSquareSecondPluralName, cKilogramSquareMeterPerSquareAmperePerSquareSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cKilogramSquareMeterPerSquareAmperePerSquareSecondFactor) + ' ' + GetName(rsKilogramSquareMeterPerSquareAmperePerSquareSecondName, cKilogramSquareMeterPerSquareAmperePerSquareSecondPrefixes)
  else
    result := FloatToStr(AValue / cKilogramSquareMeterPerSquareAmperePerSquareSecondFactor) + ' ' + GetName(rsKilogramSquareMeterPerSquareAmperePerSquareSecondPluralName, cKilogramSquareMeterPerSquareAmperePerSquareSecondPrefixes);
  result := '';
{$ENDIF}
end;

function KilogramSquareMeterPerSquareAmperePerSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHenry then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cKilogramSquareMeterPerSquareAmperePerSquareSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramSquareMeterPerSquareAmperePerSquareSecondName, cKilogramSquareMeterPerSquareAmperePerSquareSecondPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cKilogramSquareMeterPerSquareAmperePerSquareSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramSquareMeterPerSquareAmperePerSquareSecondPluralName, cKilogramSquareMeterPerSquareAmperePerSquareSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cKilogramSquareMeterPerSquareAmperePerSquareSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramSquareMeterPerSquareAmperePerSquareSecondName, cKilogramSquareMeterPerSquareAmperePerSquareSecondPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cKilogramSquareMeterPerSquareAmperePerSquareSecondFactor, rsKilogramSquareMeterPerSquareAmperePerSquareSecondPluralName);
{$ENDIF}
end;

function KilogramSquareMeterPerSquareAmperePerSquareSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHenry then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function KilogramSquareMeterPerSquareAmperePerSquareSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHenry then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cKilogramSquareMeterPerSquareAmperePerSquareSecondPrefixes, cKilogramSquareMeterPerSquareAmperePerSquareSecondExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cKilogramSquareMeterPerSquareAmperePerSquareSecondPrefixes, cKilogramSquareMeterPerSquareAmperePerSquareSecondExponents);
{$ENDIF}
end;

function ReciprocalHenryToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalHenry then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsReciprocalHenrySymbol, cReciprocalHenryPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsReciprocalHenrySymbol, cReciprocalHenryPrefixes);
{$ENDIF}
end;

function ReciprocalHenryToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalHenry then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cReciprocalHenryPrefixes, cReciprocalHenryExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cReciprocalHenryPrefixes, cReciprocalHenryExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsReciprocalHenrySymbol, cReciprocalHenryPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsReciprocalHenrySymbol, APrefixes);
end;

function ReciprocalHenryToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := ReciprocalHenryToFloat(AQuantity, APrefixes);
  FactoredTol   := ReciprocalHenryToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsReciprocalHenrySymbol, cReciprocalHenryPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsReciprocalHenrySymbol, APrefixes);
  end;
end;

function ReciprocalHenryToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalHenry then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsReciprocalHenryName, cReciprocalHenryPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsReciprocalHenryPluralName, cReciprocalHenryPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsReciprocalHenryName, cReciprocalHenryPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsReciprocalHenryPluralName, cReciprocalHenryPrefixes);
{$ENDIF}
end;

function ReciprocalHenryToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalHenry then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsReciprocalHenryName, cReciprocalHenryPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsReciprocalHenryPluralName, cReciprocalHenryPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsReciprocalHenryName, cReciprocalHenryPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsReciprocalHenryPluralName, cReciprocalHenryPrefixes);
{$ENDIF}
end;

function ReciprocalHenryToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := ReciprocalHenryToFloat(AQuantity, APrefixes);
  FactoredTol   := ReciprocalHenryToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsReciprocalHenrySymbol, cReciprocalHenryPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsReciprocalHenrySymbol, APrefixes);
  end;
end;

function ReciprocalHenryToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalHenry then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function ReciprocalHenryToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalHenry then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cReciprocalHenryPrefixes, cReciprocalHenryExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cReciprocalHenryPrefixes, cReciprocalHenryExponents);
{$ENDIF}
end;

function LumenToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLumen then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsLumenSymbol, cLumenPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsLumenSymbol, cLumenPrefixes);
{$ENDIF}
end;

function LumenToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLumen then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cLumenPrefixes, cLumenExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cLumenPrefixes, cLumenExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsLumenSymbol, cLumenPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsLumenSymbol, APrefixes);
end;

function LumenToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := LumenToFloat(AQuantity, APrefixes);
  FactoredTol   := LumenToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsLumenSymbol, cLumenPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsLumenSymbol, APrefixes);
  end;
end;

function LumenToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLumen then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsLumenName, cLumenPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsLumenPluralName, cLumenPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsLumenName, cLumenPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsLumenPluralName, cLumenPrefixes);
{$ENDIF}
end;

function LumenToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLumen then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsLumenName, cLumenPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsLumenPluralName, cLumenPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsLumenName, cLumenPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsLumenPluralName, cLumenPrefixes);
{$ENDIF}
end;

function LumenToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := LumenToFloat(AQuantity, APrefixes);
  FactoredTol   := LumenToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsLumenSymbol, cLumenPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsLumenSymbol, APrefixes);
  end;
end;

function LumenToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLumen then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function LumenToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLumen then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cLumenPrefixes, cLumenExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cLumenPrefixes, cLumenExponents);
{$ENDIF}
end;

function CandelaSteradianToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLumen then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsCandelaSteradianSymbol, cCandelaSteradianPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsCandelaSteradianSymbol, cCandelaSteradianPrefixes);
{$ENDIF}
end;

function CandelaSteradianToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLumen then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cCandelaSteradianPrefixes, cCandelaSteradianExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cCandelaSteradianPrefixes, cCandelaSteradianExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCandelaSteradianSymbol, cCandelaSteradianPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCandelaSteradianSymbol, APrefixes);
end;

function CandelaSteradianToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := CandelaSteradianToFloat(AQuantity, APrefixes);
  FactoredTol   := CandelaSteradianToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCandelaSteradianSymbol, cCandelaSteradianPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsCandelaSteradianSymbol, APrefixes);
  end;
end;

function CandelaSteradianToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLumen then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cCandelaSteradianFactor) + ' ' + GetName(rsCandelaSteradianName, cCandelaSteradianPrefixes)
  else
    result := FloatToStr(AValue.FValue / cCandelaSteradianFactor) + ' ' + GetName(rsCandelaSteradianPluralName, cCandelaSteradianPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cCandelaSteradianFactor) + ' ' + GetName(rsCandelaSteradianName, cCandelaSteradianPrefixes)
  else
    result := FloatToStr(AValue / cCandelaSteradianFactor) + ' ' + GetName(rsCandelaSteradianPluralName, cCandelaSteradianPrefixes);
  result := '';
{$ENDIF}
end;

function CandelaSteradianToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLumen then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cCandelaSteradianFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCandelaSteradianName, cCandelaSteradianPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cCandelaSteradianFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCandelaSteradianPluralName, cCandelaSteradianPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cCandelaSteradianFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCandelaSteradianName, cCandelaSteradianPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cCandelaSteradianFactor, rsCandelaSteradianPluralName);
{$ENDIF}
end;

function CandelaSteradianToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLumen then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function CandelaSteradianToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLumen then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cCandelaSteradianPrefixes, cCandelaSteradianExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cCandelaSteradianPrefixes, cCandelaSteradianExponents);
{$ENDIF}
end;

function LumenSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLumenSecond then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsLumenSecondSymbol, cLumenSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsLumenSecondSymbol, cLumenSecondPrefixes);
{$ENDIF}
end;

function LumenSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLumenSecond then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cLumenSecondPrefixes, cLumenSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cLumenSecondPrefixes, cLumenSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsLumenSecondSymbol, cLumenSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsLumenSecondSymbol, APrefixes);
end;

function LumenSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := LumenSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := LumenSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsLumenSecondSymbol, cLumenSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsLumenSecondSymbol, APrefixes);
  end;
end;

function LumenSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLumenSecond then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsLumenSecondName, cLumenSecondPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsLumenSecondPluralName, cLumenSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsLumenSecondName, cLumenSecondPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsLumenSecondPluralName, cLumenSecondPrefixes);
{$ENDIF}
end;

function LumenSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLumenSecond then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsLumenSecondName, cLumenSecondPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsLumenSecondPluralName, cLumenSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsLumenSecondName, cLumenSecondPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsLumenSecondPluralName, cLumenSecondPrefixes);
{$ENDIF}
end;

function LumenSecondToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := LumenSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := LumenSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsLumenSecondSymbol, cLumenSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsLumenSecondSymbol, APrefixes);
  end;
end;

function LumenSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLumenSecond then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function LumenSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLumenSecond then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cLumenSecondPrefixes, cLumenSecondExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cLumenSecondPrefixes, cLumenSecondExponents);
{$ENDIF}
end;

function LumenSecondPerCubicMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLumenSecondPerCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsLumenSecondPerCubicMeterSymbol, cLumenSecondPerCubicMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsLumenSecondPerCubicMeterSymbol, cLumenSecondPerCubicMeterPrefixes);
{$ENDIF}
end;

function LumenSecondPerCubicMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLumenSecondPerCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cLumenSecondPerCubicMeterPrefixes, cLumenSecondPerCubicMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cLumenSecondPerCubicMeterPrefixes, cLumenSecondPerCubicMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsLumenSecondPerCubicMeterSymbol, cLumenSecondPerCubicMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsLumenSecondPerCubicMeterSymbol, APrefixes);
end;

function LumenSecondPerCubicMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := LumenSecondPerCubicMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := LumenSecondPerCubicMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsLumenSecondPerCubicMeterSymbol, cLumenSecondPerCubicMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsLumenSecondPerCubicMeterSymbol, APrefixes);
  end;
end;

function LumenSecondPerCubicMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLumenSecondPerCubicMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsLumenSecondPerCubicMeterName, cLumenSecondPerCubicMeterPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsLumenSecondPerCubicMeterPluralName, cLumenSecondPerCubicMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsLumenSecondPerCubicMeterName, cLumenSecondPerCubicMeterPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsLumenSecondPerCubicMeterPluralName, cLumenSecondPerCubicMeterPrefixes);
{$ENDIF}
end;

function LumenSecondPerCubicMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLumenSecondPerCubicMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsLumenSecondPerCubicMeterName, cLumenSecondPerCubicMeterPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsLumenSecondPerCubicMeterPluralName, cLumenSecondPerCubicMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsLumenSecondPerCubicMeterName, cLumenSecondPerCubicMeterPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsLumenSecondPerCubicMeterPluralName, cLumenSecondPerCubicMeterPrefixes);
{$ENDIF}
end;

function LumenSecondPerCubicMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := LumenSecondPerCubicMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := LumenSecondPerCubicMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsLumenSecondPerCubicMeterSymbol, cLumenSecondPerCubicMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsLumenSecondPerCubicMeterSymbol, APrefixes);
  end;
end;

function LumenSecondPerCubicMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLumenSecondPerCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function LumenSecondPerCubicMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLumenSecondPerCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cLumenSecondPerCubicMeterPrefixes, cLumenSecondPerCubicMeterExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cLumenSecondPerCubicMeterPrefixes, cLumenSecondPerCubicMeterExponents);
{$ENDIF}
end;

function LuxToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLux then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsLuxSymbol, cLuxPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsLuxSymbol, cLuxPrefixes);
{$ENDIF}
end;

function LuxToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLux then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cLuxPrefixes, cLuxExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cLuxPrefixes, cLuxExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsLuxSymbol, cLuxPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsLuxSymbol, APrefixes);
end;

function LuxToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := LuxToFloat(AQuantity, APrefixes);
  FactoredTol   := LuxToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsLuxSymbol, cLuxPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsLuxSymbol, APrefixes);
  end;
end;

function LuxToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLux then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsLuxName, cLuxPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsLuxPluralName, cLuxPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsLuxName, cLuxPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsLuxPluralName, cLuxPrefixes);
{$ENDIF}
end;

function LuxToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLux then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsLuxName, cLuxPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsLuxPluralName, cLuxPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsLuxName, cLuxPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsLuxPluralName, cLuxPrefixes);
{$ENDIF}
end;

function LuxToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := LuxToFloat(AQuantity, APrefixes);
  FactoredTol   := LuxToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsLuxSymbol, cLuxPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsLuxSymbol, APrefixes);
  end;
end;

function LuxToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLux then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function LuxToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLux then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cLuxPrefixes, cLuxExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cLuxPrefixes, cLuxExponents);
{$ENDIF}
end;

function CandelaSteradianPerSquareMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLux then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsCandelaSteradianPerSquareMeterSymbol, cCandelaSteradianPerSquareMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsCandelaSteradianPerSquareMeterSymbol, cCandelaSteradianPerSquareMeterPrefixes);
{$ENDIF}
end;

function CandelaSteradianPerSquareMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLux then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cCandelaSteradianPerSquareMeterPrefixes, cCandelaSteradianPerSquareMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cCandelaSteradianPerSquareMeterPrefixes, cCandelaSteradianPerSquareMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCandelaSteradianPerSquareMeterSymbol, cCandelaSteradianPerSquareMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCandelaSteradianPerSquareMeterSymbol, APrefixes);
end;

function CandelaSteradianPerSquareMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := CandelaSteradianPerSquareMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := CandelaSteradianPerSquareMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCandelaSteradianPerSquareMeterSymbol, cCandelaSteradianPerSquareMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsCandelaSteradianPerSquareMeterSymbol, APrefixes);
  end;
end;

function CandelaSteradianPerSquareMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLux then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cCandelaSteradianPerSquareMeterFactor) + ' ' + GetName(rsCandelaSteradianPerSquareMeterName, cCandelaSteradianPerSquareMeterPrefixes)
  else
    result := FloatToStr(AValue.FValue / cCandelaSteradianPerSquareMeterFactor) + ' ' + GetName(rsCandelaSteradianPerSquareMeterPluralName, cCandelaSteradianPerSquareMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cCandelaSteradianPerSquareMeterFactor) + ' ' + GetName(rsCandelaSteradianPerSquareMeterName, cCandelaSteradianPerSquareMeterPrefixes)
  else
    result := FloatToStr(AValue / cCandelaSteradianPerSquareMeterFactor) + ' ' + GetName(rsCandelaSteradianPerSquareMeterPluralName, cCandelaSteradianPerSquareMeterPrefixes);
  result := '';
{$ENDIF}
end;

function CandelaSteradianPerSquareMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLux then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cCandelaSteradianPerSquareMeterFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCandelaSteradianPerSquareMeterName, cCandelaSteradianPerSquareMeterPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cCandelaSteradianPerSquareMeterFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCandelaSteradianPerSquareMeterPluralName, cCandelaSteradianPerSquareMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cCandelaSteradianPerSquareMeterFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCandelaSteradianPerSquareMeterName, cCandelaSteradianPerSquareMeterPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cCandelaSteradianPerSquareMeterFactor, rsCandelaSteradianPerSquareMeterPluralName);
{$ENDIF}
end;

function CandelaSteradianPerSquareMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLux then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function CandelaSteradianPerSquareMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLux then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cCandelaSteradianPerSquareMeterPrefixes, cCandelaSteradianPerSquareMeterExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cCandelaSteradianPerSquareMeterPrefixes, cCandelaSteradianPerSquareMeterExponents);
{$ENDIF}
end;

function LuxSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLuxSecond then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsLuxSecondSymbol, cLuxSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsLuxSecondSymbol, cLuxSecondPrefixes);
{$ENDIF}
end;

function LuxSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLuxSecond then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cLuxSecondPrefixes, cLuxSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cLuxSecondPrefixes, cLuxSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsLuxSecondSymbol, cLuxSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsLuxSecondSymbol, APrefixes);
end;

function LuxSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := LuxSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := LuxSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsLuxSecondSymbol, cLuxSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsLuxSecondSymbol, APrefixes);
  end;
end;

function LuxSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLuxSecond then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsLuxSecondName, cLuxSecondPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsLuxSecondPluralName, cLuxSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsLuxSecondName, cLuxSecondPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsLuxSecondPluralName, cLuxSecondPrefixes);
{$ENDIF}
end;

function LuxSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLuxSecond then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsLuxSecondName, cLuxSecondPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsLuxSecondPluralName, cLuxSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsLuxSecondName, cLuxSecondPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsLuxSecondPluralName, cLuxSecondPrefixes);
{$ENDIF}
end;

function LuxSecondToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := LuxSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := LuxSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsLuxSecondSymbol, cLuxSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsLuxSecondSymbol, APrefixes);
  end;
end;

function LuxSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLuxSecond then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function LuxSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLuxSecond then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cLuxSecondPrefixes, cLuxSecondExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cLuxSecondPrefixes, cLuxSecondExponents);
{$ENDIF}
end;

function BequerelToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHertz then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsBequerelSymbol, cBequerelPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsBequerelSymbol, cBequerelPrefixes);
{$ENDIF}
end;

function BequerelToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHertz then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cBequerelPrefixes, cBequerelExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cBequerelPrefixes, cBequerelExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsBequerelSymbol, cBequerelPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsBequerelSymbol, APrefixes);
end;

function BequerelToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := BequerelToFloat(AQuantity, APrefixes);
  FactoredTol   := BequerelToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsBequerelSymbol, cBequerelPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsBequerelSymbol, APrefixes);
  end;
end;

function BequerelToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHertz then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cBequerelFactor) + ' ' + GetName(rsBequerelName, cBequerelPrefixes)
  else
    result := FloatToStr(AValue.FValue / cBequerelFactor) + ' ' + GetName(rsBequerelPluralName, cBequerelPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cBequerelFactor) + ' ' + GetName(rsBequerelName, cBequerelPrefixes)
  else
    result := FloatToStr(AValue / cBequerelFactor) + ' ' + GetName(rsBequerelPluralName, cBequerelPrefixes);
  result := '';
{$ENDIF}
end;

function BequerelToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHertz then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cBequerelFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsBequerelName, cBequerelPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cBequerelFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsBequerelPluralName, cBequerelPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cBequerelFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsBequerelName, cBequerelPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cBequerelFactor, rsBequerelPluralName);
{$ENDIF}
end;

function BequerelToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHertz then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function BequerelToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHertz then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cBequerelPrefixes, cBequerelExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cBequerelPrefixes, cBequerelExponents);
{$ENDIF}
end;

function KatalToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKatal then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsKatalSymbol, cKatalPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsKatalSymbol, cKatalPrefixes);
{$ENDIF}
end;

function KatalToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKatal then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cKatalPrefixes, cKatalExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cKatalPrefixes, cKatalExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKatalSymbol, cKatalPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKatalSymbol, APrefixes);
end;

function KatalToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := KatalToFloat(AQuantity, APrefixes);
  FactoredTol   := KatalToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKatalSymbol, cKatalPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsKatalSymbol, APrefixes);
  end;
end;

function KatalToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKatal then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsKatalName, cKatalPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsKatalPluralName, cKatalPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsKatalName, cKatalPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsKatalPluralName, cKatalPrefixes);
{$ENDIF}
end;

function KatalToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKatal then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKatalName, cKatalPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKatalPluralName, cKatalPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKatalName, cKatalPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKatalPluralName, cKatalPrefixes);
{$ENDIF}
end;

function KatalToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := KatalToFloat(AQuantity, APrefixes);
  FactoredTol   := KatalToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKatalSymbol, cKatalPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsKatalSymbol, APrefixes);
  end;
end;

function KatalToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKatal then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function KatalToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKatal then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cKatalPrefixes, cKatalExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cKatalPrefixes, cKatalExponents);
{$ENDIF}
end;

function MolePerSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKatal then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsMolePerSecondSymbol, cMolePerSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsMolePerSecondSymbol, cMolePerSecondPrefixes);
{$ENDIF}
end;

function MolePerSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKatal then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cMolePerSecondPrefixes, cMolePerSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cMolePerSecondPrefixes, cMolePerSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMolePerSecondSymbol, cMolePerSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMolePerSecondSymbol, APrefixes);
end;

function MolePerSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := MolePerSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := MolePerSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMolePerSecondSymbol, cMolePerSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsMolePerSecondSymbol, APrefixes);
  end;
end;

function MolePerSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKatal then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cMolePerSecondFactor) + ' ' + GetName(rsMolePerSecondName, cMolePerSecondPrefixes)
  else
    result := FloatToStr(AValue.FValue / cMolePerSecondFactor) + ' ' + GetName(rsMolePerSecondPluralName, cMolePerSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cMolePerSecondFactor) + ' ' + GetName(rsMolePerSecondName, cMolePerSecondPrefixes)
  else
    result := FloatToStr(AValue / cMolePerSecondFactor) + ' ' + GetName(rsMolePerSecondPluralName, cMolePerSecondPrefixes);
  result := '';
{$ENDIF}
end;

function MolePerSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKatal then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cMolePerSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMolePerSecondName, cMolePerSecondPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cMolePerSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMolePerSecondPluralName, cMolePerSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cMolePerSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMolePerSecondName, cMolePerSecondPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cMolePerSecondFactor, rsMolePerSecondPluralName);
{$ENDIF}
end;

function MolePerSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKatal then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function MolePerSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKatal then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cMolePerSecondPrefixes, cMolePerSecondExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cMolePerSecondPrefixes, cMolePerSecondExponents);
{$ENDIF}
end;

function NewtonPerCubicMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsNewtonPerCubicMeterSymbol, cNewtonPerCubicMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsNewtonPerCubicMeterSymbol, cNewtonPerCubicMeterPrefixes);
{$ENDIF}
end;

function NewtonPerCubicMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cNewtonPerCubicMeterPrefixes, cNewtonPerCubicMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cNewtonPerCubicMeterPrefixes, cNewtonPerCubicMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonPerCubicMeterSymbol, cNewtonPerCubicMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonPerCubicMeterSymbol, APrefixes);
end;

function NewtonPerCubicMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := NewtonPerCubicMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := NewtonPerCubicMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonPerCubicMeterSymbol, cNewtonPerCubicMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsNewtonPerCubicMeterSymbol, APrefixes);
  end;
end;

function NewtonPerCubicMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerCubicMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsNewtonPerCubicMeterName, cNewtonPerCubicMeterPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsNewtonPerCubicMeterPluralName, cNewtonPerCubicMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsNewtonPerCubicMeterName, cNewtonPerCubicMeterPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsNewtonPerCubicMeterPluralName, cNewtonPerCubicMeterPrefixes);
{$ENDIF}
end;

function NewtonPerCubicMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerCubicMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNewtonPerCubicMeterName, cNewtonPerCubicMeterPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNewtonPerCubicMeterPluralName, cNewtonPerCubicMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNewtonPerCubicMeterName, cNewtonPerCubicMeterPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNewtonPerCubicMeterPluralName, cNewtonPerCubicMeterPrefixes);
{$ENDIF}
end;

function NewtonPerCubicMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := NewtonPerCubicMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := NewtonPerCubicMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNewtonPerCubicMeterSymbol, cNewtonPerCubicMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsNewtonPerCubicMeterSymbol, APrefixes);
  end;
end;

function NewtonPerCubicMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function NewtonPerCubicMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cNewtonPerCubicMeterPrefixes, cNewtonPerCubicMeterExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cNewtonPerCubicMeterPrefixes, cNewtonPerCubicMeterExponents);
{$ENDIF}
end;

function PascalPerMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsPascalPerMeterSymbol, cPascalPerMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsPascalPerMeterSymbol, cPascalPerMeterPrefixes);
{$ENDIF}
end;

function PascalPerMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cPascalPerMeterPrefixes, cPascalPerMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cPascalPerMeterPrefixes, cPascalPerMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsPascalPerMeterSymbol, cPascalPerMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsPascalPerMeterSymbol, APrefixes);
end;

function PascalPerMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := PascalPerMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := PascalPerMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsPascalPerMeterSymbol, cPascalPerMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsPascalPerMeterSymbol, APrefixes);
  end;
end;

function PascalPerMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cPascalPerMeterFactor) + ' ' + GetName(rsPascalPerMeterName, cPascalPerMeterPrefixes)
  else
    result := FloatToStr(AValue.FValue / cPascalPerMeterFactor) + ' ' + GetName(rsPascalPerMeterPluralName, cPascalPerMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cPascalPerMeterFactor) + ' ' + GetName(rsPascalPerMeterName, cPascalPerMeterPrefixes)
  else
    result := FloatToStr(AValue / cPascalPerMeterFactor) + ' ' + GetName(rsPascalPerMeterPluralName, cPascalPerMeterPrefixes);
  result := '';
{$ENDIF}
end;

function PascalPerMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cPascalPerMeterFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsPascalPerMeterName, cPascalPerMeterPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cPascalPerMeterFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsPascalPerMeterPluralName, cPascalPerMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cPascalPerMeterFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsPascalPerMeterName, cPascalPerMeterPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cPascalPerMeterFactor, rsPascalPerMeterPluralName);
{$ENDIF}
end;

function PascalPerMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function PascalPerMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cPascalPerMeterPrefixes, cPascalPerMeterExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cPascalPerMeterPrefixes, cPascalPerMeterExponents);
{$ENDIF}
end;

function KilogramPerSquareMeterPerSquareSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsKilogramPerSquareMeterPerSquareSecondSymbol, cKilogramPerSquareMeterPerSquareSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsKilogramPerSquareMeterPerSquareSecondSymbol, cKilogramPerSquareMeterPerSquareSecondPrefixes);
{$ENDIF}
end;

function KilogramPerSquareMeterPerSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cKilogramPerSquareMeterPerSquareSecondPrefixes, cKilogramPerSquareMeterPerSquareSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cKilogramPerSquareMeterPerSquareSecondPrefixes, cKilogramPerSquareMeterPerSquareSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramPerSquareMeterPerSquareSecondSymbol, cKilogramPerSquareMeterPerSquareSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramPerSquareMeterPerSquareSecondSymbol, APrefixes);
end;

function KilogramPerSquareMeterPerSquareSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := KilogramPerSquareMeterPerSquareSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := KilogramPerSquareMeterPerSquareSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramPerSquareMeterPerSquareSecondSymbol, cKilogramPerSquareMeterPerSquareSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsKilogramPerSquareMeterPerSquareSecondSymbol, APrefixes);
  end;
end;

function KilogramPerSquareMeterPerSquareSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cKilogramPerSquareMeterPerSquareSecondFactor) + ' ' + GetName(rsKilogramPerSquareMeterPerSquareSecondName, cKilogramPerSquareMeterPerSquareSecondPrefixes)
  else
    result := FloatToStr(AValue.FValue / cKilogramPerSquareMeterPerSquareSecondFactor) + ' ' + GetName(rsKilogramPerSquareMeterPerSquareSecondPluralName, cKilogramPerSquareMeterPerSquareSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cKilogramPerSquareMeterPerSquareSecondFactor) + ' ' + GetName(rsKilogramPerSquareMeterPerSquareSecondName, cKilogramPerSquareMeterPerSquareSecondPrefixes)
  else
    result := FloatToStr(AValue / cKilogramPerSquareMeterPerSquareSecondFactor) + ' ' + GetName(rsKilogramPerSquareMeterPerSquareSecondPluralName, cKilogramPerSquareMeterPerSquareSecondPrefixes);
  result := '';
{$ENDIF}
end;

function KilogramPerSquareMeterPerSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cKilogramPerSquareMeterPerSquareSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramPerSquareMeterPerSquareSecondName, cKilogramPerSquareMeterPerSquareSecondPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cKilogramPerSquareMeterPerSquareSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramPerSquareMeterPerSquareSecondPluralName, cKilogramPerSquareMeterPerSquareSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cKilogramPerSquareMeterPerSquareSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramPerSquareMeterPerSquareSecondName, cKilogramPerSquareMeterPerSquareSecondPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cKilogramPerSquareMeterPerSquareSecondFactor, rsKilogramPerSquareMeterPerSquareSecondPluralName);
{$ENDIF}
end;

function KilogramPerSquareMeterPerSquareSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function KilogramPerSquareMeterPerSquareSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cKilogramPerSquareMeterPerSquareSecondPrefixes, cKilogramPerSquareMeterPerSquareSecondExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cKilogramPerSquareMeterPerSquareSecondPrefixes, cKilogramPerSquareMeterPerSquareSecondExponents);
{$ENDIF}
end;

function NewtonPerMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerMeter then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsNewtonPerMeterSymbol, cNewtonPerMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsNewtonPerMeterSymbol, cNewtonPerMeterPrefixes);
{$ENDIF}
end;

function NewtonPerMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerMeter then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cNewtonPerMeterPrefixes, cNewtonPerMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cNewtonPerMeterPrefixes, cNewtonPerMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonPerMeterSymbol, cNewtonPerMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonPerMeterSymbol, APrefixes);
end;

function NewtonPerMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := NewtonPerMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := NewtonPerMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonPerMeterSymbol, cNewtonPerMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsNewtonPerMeterSymbol, APrefixes);
  end;
end;

function NewtonPerMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsNewtonPerMeterName, cNewtonPerMeterPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsNewtonPerMeterPluralName, cNewtonPerMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsNewtonPerMeterName, cNewtonPerMeterPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsNewtonPerMeterPluralName, cNewtonPerMeterPrefixes);
{$ENDIF}
end;

function NewtonPerMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNewtonPerMeterName, cNewtonPerMeterPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNewtonPerMeterPluralName, cNewtonPerMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNewtonPerMeterName, cNewtonPerMeterPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNewtonPerMeterPluralName, cNewtonPerMeterPrefixes);
{$ENDIF}
end;

function NewtonPerMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := NewtonPerMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := NewtonPerMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNewtonPerMeterSymbol, cNewtonPerMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsNewtonPerMeterSymbol, APrefixes);
  end;
end;

function NewtonPerMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerMeter then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function NewtonPerMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerMeter then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cNewtonPerMeterPrefixes, cNewtonPerMeterExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cNewtonPerMeterPrefixes, cNewtonPerMeterExponents);
{$ENDIF}
end;

function JoulePerSquareMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerMeter then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsJoulePerSquareMeterSymbol, cJoulePerSquareMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsJoulePerSquareMeterSymbol, cJoulePerSquareMeterPrefixes);
{$ENDIF}
end;

function JoulePerSquareMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerMeter then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cJoulePerSquareMeterPrefixes, cJoulePerSquareMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cJoulePerSquareMeterPrefixes, cJoulePerSquareMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsJoulePerSquareMeterSymbol, cJoulePerSquareMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsJoulePerSquareMeterSymbol, APrefixes);
end;

function JoulePerSquareMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := JoulePerSquareMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := JoulePerSquareMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsJoulePerSquareMeterSymbol, cJoulePerSquareMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsJoulePerSquareMeterSymbol, APrefixes);
  end;
end;

function JoulePerSquareMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerMeter then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cJoulePerSquareMeterFactor) + ' ' + GetName(rsJoulePerSquareMeterName, cJoulePerSquareMeterPrefixes)
  else
    result := FloatToStr(AValue.FValue / cJoulePerSquareMeterFactor) + ' ' + GetName(rsJoulePerSquareMeterPluralName, cJoulePerSquareMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cJoulePerSquareMeterFactor) + ' ' + GetName(rsJoulePerSquareMeterName, cJoulePerSquareMeterPrefixes)
  else
    result := FloatToStr(AValue / cJoulePerSquareMeterFactor) + ' ' + GetName(rsJoulePerSquareMeterPluralName, cJoulePerSquareMeterPrefixes);
  result := '';
{$ENDIF}
end;

function JoulePerSquareMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerMeter then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cJoulePerSquareMeterFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsJoulePerSquareMeterName, cJoulePerSquareMeterPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cJoulePerSquareMeterFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsJoulePerSquareMeterPluralName, cJoulePerSquareMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cJoulePerSquareMeterFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsJoulePerSquareMeterName, cJoulePerSquareMeterPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cJoulePerSquareMeterFactor, rsJoulePerSquareMeterPluralName);
{$ENDIF}
end;

function JoulePerSquareMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerMeter then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function JoulePerSquareMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerMeter then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cJoulePerSquareMeterPrefixes, cJoulePerSquareMeterExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cJoulePerSquareMeterPrefixes, cJoulePerSquareMeterExponents);
{$ENDIF}
end;

function WattPerSquareMeterPerHertzToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerMeter then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsWattPerSquareMeterPerHertzSymbol, cWattPerSquareMeterPerHertzPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsWattPerSquareMeterPerHertzSymbol, cWattPerSquareMeterPerHertzPrefixes);
{$ENDIF}
end;

function WattPerSquareMeterPerHertzToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerMeter then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cWattPerSquareMeterPerHertzPrefixes, cWattPerSquareMeterPerHertzExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cWattPerSquareMeterPerHertzPrefixes, cWattPerSquareMeterPerHertzExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattPerSquareMeterPerHertzSymbol, cWattPerSquareMeterPerHertzPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattPerSquareMeterPerHertzSymbol, APrefixes);
end;

function WattPerSquareMeterPerHertzToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := WattPerSquareMeterPerHertzToFloat(AQuantity, APrefixes);
  FactoredTol   := WattPerSquareMeterPerHertzToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattPerSquareMeterPerHertzSymbol, cWattPerSquareMeterPerHertzPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsWattPerSquareMeterPerHertzSymbol, APrefixes);
  end;
end;

function WattPerSquareMeterPerHertzToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerMeter then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cWattPerSquareMeterPerHertzFactor) + ' ' + GetName(rsWattPerSquareMeterPerHertzName, cWattPerSquareMeterPerHertzPrefixes)
  else
    result := FloatToStr(AValue.FValue / cWattPerSquareMeterPerHertzFactor) + ' ' + GetName(rsWattPerSquareMeterPerHertzPluralName, cWattPerSquareMeterPerHertzPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cWattPerSquareMeterPerHertzFactor) + ' ' + GetName(rsWattPerSquareMeterPerHertzName, cWattPerSquareMeterPerHertzPrefixes)
  else
    result := FloatToStr(AValue / cWattPerSquareMeterPerHertzFactor) + ' ' + GetName(rsWattPerSquareMeterPerHertzPluralName, cWattPerSquareMeterPerHertzPrefixes);
  result := '';
{$ENDIF}
end;

function WattPerSquareMeterPerHertzToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerMeter then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cWattPerSquareMeterPerHertzFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattPerSquareMeterPerHertzName, cWattPerSquareMeterPerHertzPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cWattPerSquareMeterPerHertzFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattPerSquareMeterPerHertzPluralName, cWattPerSquareMeterPerHertzPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cWattPerSquareMeterPerHertzFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattPerSquareMeterPerHertzName, cWattPerSquareMeterPerHertzPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cWattPerSquareMeterPerHertzFactor, rsWattPerSquareMeterPerHertzPluralName);
{$ENDIF}
end;

function WattPerSquareMeterPerHertzToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerMeter then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function WattPerSquareMeterPerHertzToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerMeter then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cWattPerSquareMeterPerHertzPrefixes, cWattPerSquareMeterPerHertzExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cWattPerSquareMeterPerHertzPrefixes, cWattPerSquareMeterPerHertzExponents);
{$ENDIF}
end;

function PoundForcePerInchToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerMeter then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue / cPoundForcePerInchFactor) + ' ' + GetSymbol(rsPoundForcePerInchSymbol, cPoundForcePerInchPrefixes);
{$ENDIF}
  result := FloatToStr(AValue / cPoundForcePerInchFactor) + ' ' + GetSymbol(rsPoundForcePerInchSymbol, cPoundForcePerInchPrefixes);
end;

function PoundForcePerInchToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerMeter then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue / cPoundForcePerInchFactor, APrefixes, cPoundForcePerInchPrefixes, cPoundForcePerInchExponents);
{$ELSE}
  FactoredValue := GetValue(AValue / cPoundForcePerInchFactor, APrefixes, cPoundForcePerInchPrefixes, cPoundForcePerInchExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsPoundForcePerInchSymbol, cPoundForcePerInchPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsPoundForcePerInchSymbol, APrefixes);
end;

function cPoundForcePerInchToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := PoundForcePerInchToFloat(AQuantity / cPoundForcePerInchFactor, APrefixes);
  FactoredTol   := PoundForcePerInchToFloat(ATolerance / cPoundForcePerInchFactor, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsPoundForcePerInchSymbol, cPoundForcePerInchPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsPoundForcePerInchSymbol, APrefixes);
  end;
end;

function PoundForcePerInchToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerMeter then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cPoundForcePerInchFactor) + ' ' + GetName(rsPoundForcePerInchName, cPoundForcePerInchPrefixes)
  else
    result := FloatToStr(AValue.FValue / cPoundForcePerInchFactor) + ' ' + GetName(rsPoundForcePerInchPluralName, cPoundForcePerInchPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cPoundForcePerInchFactor) + ' ' + GetName(rsPoundForcePerInchName, cPoundForcePerInchPrefixes)
  else
    result := FloatToStr(AValue / cPoundForcePerInchFactor) + ' ' + GetName(rsPoundForcePerInchPluralName, cPoundForcePerInchPrefixes);
  result := '';
{$ENDIF}
end;

function PoundForcePerInchToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerMeter then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cPoundForcePerInchFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsPoundForcePerInchName, cPoundForcePerInchPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cPoundForcePerInchFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsPoundForcePerInchPluralName, cPoundForcePerInchPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cPoundForcePerInchFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsPoundForcePerInchName, cPoundForcePerInchPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cPoundForcePerInchFactor, rsPoundForcePerInchPluralName);
{$ENDIF}
end;

function PoundForcePerInchToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerMeter then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue * cPoundForcePerInchFactor;
{$ELSE}
  result := AValue * cPoundForcePerInchFactor;
{$ENDIF}
end;

function PoundForcePerInchToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerMeter then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue * cPoundForcePerInchFactor, APrefixes, cPoundForcePerInchPrefixes, cPoundForcePerInchExponents);
{$ELSE}
  result := GetValue(AValue * cPoundForcePerInchFactor, APrefixes, cPoundForcePerInchPrefixes, cPoundForcePerInchExponents);
{$ENDIF}
end;

function KilogramPerSquareSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerMeter then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsKilogramPerSquareSecondSymbol, cKilogramPerSquareSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsKilogramPerSquareSecondSymbol, cKilogramPerSquareSecondPrefixes);
{$ENDIF}
end;

function KilogramPerSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerMeter then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cKilogramPerSquareSecondPrefixes, cKilogramPerSquareSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cKilogramPerSquareSecondPrefixes, cKilogramPerSquareSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramPerSquareSecondSymbol, cKilogramPerSquareSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramPerSquareSecondSymbol, APrefixes);
end;

function KilogramPerSquareSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := KilogramPerSquareSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := KilogramPerSquareSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramPerSquareSecondSymbol, cKilogramPerSquareSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsKilogramPerSquareSecondSymbol, APrefixes);
  end;
end;

function KilogramPerSquareSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerMeter then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cKilogramPerSquareSecondFactor) + ' ' + GetName(rsKilogramPerSquareSecondName, cKilogramPerSquareSecondPrefixes)
  else
    result := FloatToStr(AValue.FValue / cKilogramPerSquareSecondFactor) + ' ' + GetName(rsKilogramPerSquareSecondPluralName, cKilogramPerSquareSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cKilogramPerSquareSecondFactor) + ' ' + GetName(rsKilogramPerSquareSecondName, cKilogramPerSquareSecondPrefixes)
  else
    result := FloatToStr(AValue / cKilogramPerSquareSecondFactor) + ' ' + GetName(rsKilogramPerSquareSecondPluralName, cKilogramPerSquareSecondPrefixes);
  result := '';
{$ENDIF}
end;

function KilogramPerSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerMeter then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cKilogramPerSquareSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramPerSquareSecondName, cKilogramPerSquareSecondPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cKilogramPerSquareSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramPerSquareSecondPluralName, cKilogramPerSquareSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cKilogramPerSquareSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramPerSquareSecondName, cKilogramPerSquareSecondPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cKilogramPerSquareSecondFactor, rsKilogramPerSquareSecondPluralName);
{$ENDIF}
end;

function KilogramPerSquareSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerMeter then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function KilogramPerSquareSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerMeter then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cKilogramPerSquareSecondPrefixes, cKilogramPerSquareSecondExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cKilogramPerSquareSecondPrefixes, cKilogramPerSquareSecondExponents);
{$ENDIF}
end;

function CubicMeterPerSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsCubicMeterPerSecondSymbol, cCubicMeterPerSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsCubicMeterPerSecondSymbol, cCubicMeterPerSecondPrefixes);
{$ENDIF}
end;

function CubicMeterPerSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cCubicMeterPerSecondPrefixes, cCubicMeterPerSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cCubicMeterPerSecondPrefixes, cCubicMeterPerSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCubicMeterPerSecondSymbol, cCubicMeterPerSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCubicMeterPerSecondSymbol, APrefixes);
end;

function CubicMeterPerSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := CubicMeterPerSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := CubicMeterPerSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCubicMeterPerSecondSymbol, cCubicMeterPerSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsCubicMeterPerSecondSymbol, APrefixes);
  end;
end;

function CubicMeterPerSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsCubicMeterPerSecondName, cCubicMeterPerSecondPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsCubicMeterPerSecondPluralName, cCubicMeterPerSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsCubicMeterPerSecondName, cCubicMeterPerSecondPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsCubicMeterPerSecondPluralName, cCubicMeterPerSecondPrefixes);
{$ENDIF}
end;

function CubicMeterPerSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCubicMeterPerSecondName, cCubicMeterPerSecondPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCubicMeterPerSecondPluralName, cCubicMeterPerSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCubicMeterPerSecondName, cCubicMeterPerSecondPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCubicMeterPerSecondPluralName, cCubicMeterPerSecondPrefixes);
{$ENDIF}
end;

function CubicMeterPerSecondToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := CubicMeterPerSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := CubicMeterPerSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCubicMeterPerSecondSymbol, cCubicMeterPerSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsCubicMeterPerSecondSymbol, APrefixes);
  end;
end;

function CubicMeterPerSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function CubicMeterPerSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cCubicMeterPerSecondPrefixes, cCubicMeterPerSecondExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cCubicMeterPerSecondPrefixes, cCubicMeterPerSecondExponents);
{$ENDIF}
end;

function PoiseuilleToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPoiseuille then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsPoiseuilleSymbol, cPoiseuillePrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsPoiseuilleSymbol, cPoiseuillePrefixes);
{$ENDIF}
end;

function PoiseuilleToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPoiseuille then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cPoiseuillePrefixes, cPoiseuilleExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cPoiseuillePrefixes, cPoiseuilleExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsPoiseuilleSymbol, cPoiseuillePrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsPoiseuilleSymbol, APrefixes);
end;

function PoiseuilleToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := PoiseuilleToFloat(AQuantity, APrefixes);
  FactoredTol   := PoiseuilleToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsPoiseuilleSymbol, cPoiseuillePrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsPoiseuilleSymbol, APrefixes);
  end;
end;

function PoiseuilleToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPoiseuille then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsPoiseuilleName, cPoiseuillePrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsPoiseuillePluralName, cPoiseuillePrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsPoiseuilleName, cPoiseuillePrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsPoiseuillePluralName, cPoiseuillePrefixes);
{$ENDIF}
end;

function PoiseuilleToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPoiseuille then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsPoiseuilleName, cPoiseuillePrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsPoiseuillePluralName, cPoiseuillePrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsPoiseuilleName, cPoiseuillePrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsPoiseuillePluralName, cPoiseuillePrefixes);
{$ENDIF}
end;

function PoiseuilleToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := PoiseuilleToFloat(AQuantity, APrefixes);
  FactoredTol   := PoiseuilleToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsPoiseuilleSymbol, cPoiseuillePrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsPoiseuilleSymbol, APrefixes);
  end;
end;

function PoiseuilleToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPoiseuille then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function PoiseuilleToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPoiseuille then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cPoiseuillePrefixes, cPoiseuilleExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cPoiseuillePrefixes, cPoiseuilleExponents);
{$ENDIF}
end;

function PascalSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPoiseuille then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsPascalSecondSymbol, cPascalSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsPascalSecondSymbol, cPascalSecondPrefixes);
{$ENDIF}
end;

function PascalSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPoiseuille then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cPascalSecondPrefixes, cPascalSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cPascalSecondPrefixes, cPascalSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsPascalSecondSymbol, cPascalSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsPascalSecondSymbol, APrefixes);
end;

function PascalSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := PascalSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := PascalSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsPascalSecondSymbol, cPascalSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsPascalSecondSymbol, APrefixes);
  end;
end;

function PascalSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPoiseuille then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cPascalSecondFactor) + ' ' + GetName(rsPascalSecondName, cPascalSecondPrefixes)
  else
    result := FloatToStr(AValue.FValue / cPascalSecondFactor) + ' ' + GetName(rsPascalSecondPluralName, cPascalSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cPascalSecondFactor) + ' ' + GetName(rsPascalSecondName, cPascalSecondPrefixes)
  else
    result := FloatToStr(AValue / cPascalSecondFactor) + ' ' + GetName(rsPascalSecondPluralName, cPascalSecondPrefixes);
  result := '';
{$ENDIF}
end;

function PascalSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPoiseuille then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cPascalSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsPascalSecondName, cPascalSecondPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cPascalSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsPascalSecondPluralName, cPascalSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cPascalSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsPascalSecondName, cPascalSecondPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cPascalSecondFactor, rsPascalSecondPluralName);
{$ENDIF}
end;

function PascalSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPoiseuille then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function PascalSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPoiseuille then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cPascalSecondPrefixes, cPascalSecondExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cPascalSecondPrefixes, cPascalSecondExponents);
{$ENDIF}
end;

function KilogramPerMeterPerSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPoiseuille then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsKilogramPerMeterPerSecondSymbol, cKilogramPerMeterPerSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsKilogramPerMeterPerSecondSymbol, cKilogramPerMeterPerSecondPrefixes);
{$ENDIF}
end;

function KilogramPerMeterPerSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPoiseuille then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cKilogramPerMeterPerSecondPrefixes, cKilogramPerMeterPerSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cKilogramPerMeterPerSecondPrefixes, cKilogramPerMeterPerSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramPerMeterPerSecondSymbol, cKilogramPerMeterPerSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramPerMeterPerSecondSymbol, APrefixes);
end;

function KilogramPerMeterPerSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := KilogramPerMeterPerSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := KilogramPerMeterPerSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramPerMeterPerSecondSymbol, cKilogramPerMeterPerSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsKilogramPerMeterPerSecondSymbol, APrefixes);
  end;
end;

function KilogramPerMeterPerSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPoiseuille then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cKilogramPerMeterPerSecondFactor) + ' ' + GetName(rsKilogramPerMeterPerSecondName, cKilogramPerMeterPerSecondPrefixes)
  else
    result := FloatToStr(AValue.FValue / cKilogramPerMeterPerSecondFactor) + ' ' + GetName(rsKilogramPerMeterPerSecondPluralName, cKilogramPerMeterPerSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cKilogramPerMeterPerSecondFactor) + ' ' + GetName(rsKilogramPerMeterPerSecondName, cKilogramPerMeterPerSecondPrefixes)
  else
    result := FloatToStr(AValue / cKilogramPerMeterPerSecondFactor) + ' ' + GetName(rsKilogramPerMeterPerSecondPluralName, cKilogramPerMeterPerSecondPrefixes);
  result := '';
{$ENDIF}
end;

function KilogramPerMeterPerSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPoiseuille then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cKilogramPerMeterPerSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramPerMeterPerSecondName, cKilogramPerMeterPerSecondPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cKilogramPerMeterPerSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramPerMeterPerSecondPluralName, cKilogramPerMeterPerSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cKilogramPerMeterPerSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramPerMeterPerSecondName, cKilogramPerMeterPerSecondPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cKilogramPerMeterPerSecondFactor, rsKilogramPerMeterPerSecondPluralName);
{$ENDIF}
end;

function KilogramPerMeterPerSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPoiseuille then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function KilogramPerMeterPerSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPoiseuille then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cKilogramPerMeterPerSecondPrefixes, cKilogramPerMeterPerSecondExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cKilogramPerMeterPerSecondPrefixes, cKilogramPerMeterPerSecondExponents);
{$ENDIF}
end;

function SquareMeterPerSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsSquareMeterPerSecondSymbol, cSquareMeterPerSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsSquareMeterPerSecondSymbol, cSquareMeterPerSecondPrefixes);
{$ENDIF}
end;

function SquareMeterPerSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSquareMeterPerSecondPrefixes, cSquareMeterPerSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSquareMeterPerSecondPrefixes, cSquareMeterPerSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareMeterPerSecondSymbol, cSquareMeterPerSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareMeterPerSecondSymbol, APrefixes);
end;

function SquareMeterPerSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SquareMeterPerSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := SquareMeterPerSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareMeterPerSecondSymbol, cSquareMeterPerSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsSquareMeterPerSecondSymbol, APrefixes);
  end;
end;

function SquareMeterPerSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsSquareMeterPerSecondName, cSquareMeterPerSecondPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsSquareMeterPerSecondPluralName, cSquareMeterPerSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsSquareMeterPerSecondName, cSquareMeterPerSecondPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsSquareMeterPerSecondPluralName, cSquareMeterPerSecondPrefixes);
{$ENDIF}
end;

function SquareMeterPerSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareMeterPerSecondName, cSquareMeterPerSecondPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareMeterPerSecondPluralName, cSquareMeterPerSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareMeterPerSecondName, cSquareMeterPerSecondPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareMeterPerSecondPluralName, cSquareMeterPerSecondPrefixes);
{$ENDIF}
end;

function SquareMeterPerSecondToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SquareMeterPerSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := SquareMeterPerSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareMeterPerSecondSymbol, cSquareMeterPerSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsSquareMeterPerSecondSymbol, APrefixes);
  end;
end;

function SquareMeterPerSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function SquareMeterPerSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cSquareMeterPerSecondPrefixes, cSquareMeterPerSecondExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cSquareMeterPerSecondPrefixes, cSquareMeterPerSecondExponents);
{$ENDIF}
end;

function KilogramPerQuarticMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerQuarticMeter then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsKilogramPerQuarticMeterSymbol, cKilogramPerQuarticMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsKilogramPerQuarticMeterSymbol, cKilogramPerQuarticMeterPrefixes);
{$ENDIF}
end;

function KilogramPerQuarticMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerQuarticMeter then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cKilogramPerQuarticMeterPrefixes, cKilogramPerQuarticMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cKilogramPerQuarticMeterPrefixes, cKilogramPerQuarticMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramPerQuarticMeterSymbol, cKilogramPerQuarticMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramPerQuarticMeterSymbol, APrefixes);
end;

function KilogramPerQuarticMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := KilogramPerQuarticMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := KilogramPerQuarticMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramPerQuarticMeterSymbol, cKilogramPerQuarticMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsKilogramPerQuarticMeterSymbol, APrefixes);
  end;
end;

function KilogramPerQuarticMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerQuarticMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsKilogramPerQuarticMeterName, cKilogramPerQuarticMeterPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsKilogramPerQuarticMeterPluralName, cKilogramPerQuarticMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsKilogramPerQuarticMeterName, cKilogramPerQuarticMeterPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsKilogramPerQuarticMeterPluralName, cKilogramPerQuarticMeterPrefixes);
{$ENDIF}
end;

function KilogramPerQuarticMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerQuarticMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramPerQuarticMeterName, cKilogramPerQuarticMeterPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramPerQuarticMeterPluralName, cKilogramPerQuarticMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramPerQuarticMeterName, cKilogramPerQuarticMeterPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramPerQuarticMeterPluralName, cKilogramPerQuarticMeterPrefixes);
{$ENDIF}
end;

function KilogramPerQuarticMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := KilogramPerQuarticMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := KilogramPerQuarticMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramPerQuarticMeterSymbol, cKilogramPerQuarticMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsKilogramPerQuarticMeterSymbol, APrefixes);
  end;
end;

function KilogramPerQuarticMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerQuarticMeter then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function KilogramPerQuarticMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerQuarticMeter then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cKilogramPerQuarticMeterPrefixes, cKilogramPerQuarticMeterExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cKilogramPerQuarticMeterPrefixes, cKilogramPerQuarticMeterExponents);
{$ENDIF}
end;

function QuarticMeterSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cQuarticMeterSecond then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsQuarticMeterSecondSymbol, cQuarticMeterSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsQuarticMeterSecondSymbol, cQuarticMeterSecondPrefixes);
{$ENDIF}
end;

function QuarticMeterSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cQuarticMeterSecond then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cQuarticMeterSecondPrefixes, cQuarticMeterSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cQuarticMeterSecondPrefixes, cQuarticMeterSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsQuarticMeterSecondSymbol, cQuarticMeterSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsQuarticMeterSecondSymbol, APrefixes);
end;

function QuarticMeterSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := QuarticMeterSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := QuarticMeterSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsQuarticMeterSecondSymbol, cQuarticMeterSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsQuarticMeterSecondSymbol, APrefixes);
  end;
end;

function QuarticMeterSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cQuarticMeterSecond then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsQuarticMeterSecondName, cQuarticMeterSecondPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsQuarticMeterSecondPluralName, cQuarticMeterSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsQuarticMeterSecondName, cQuarticMeterSecondPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsQuarticMeterSecondPluralName, cQuarticMeterSecondPrefixes);
{$ENDIF}
end;

function QuarticMeterSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cQuarticMeterSecond then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsQuarticMeterSecondName, cQuarticMeterSecondPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsQuarticMeterSecondPluralName, cQuarticMeterSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsQuarticMeterSecondName, cQuarticMeterSecondPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsQuarticMeterSecondPluralName, cQuarticMeterSecondPrefixes);
{$ENDIF}
end;

function QuarticMeterSecondToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := QuarticMeterSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := QuarticMeterSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsQuarticMeterSecondSymbol, cQuarticMeterSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsQuarticMeterSecondSymbol, APrefixes);
  end;
end;

function QuarticMeterSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cQuarticMeterSecond then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function QuarticMeterSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cQuarticMeterSecond then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cQuarticMeterSecondPrefixes, cQuarticMeterSecondExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cQuarticMeterSecondPrefixes, cQuarticMeterSecondExponents);
{$ENDIF}
end;

function KilogramPerQuarticMeterPerSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerQuarticMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsKilogramPerQuarticMeterPerSecondSymbol, cKilogramPerQuarticMeterPerSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsKilogramPerQuarticMeterPerSecondSymbol, cKilogramPerQuarticMeterPerSecondPrefixes);
{$ENDIF}
end;

function KilogramPerQuarticMeterPerSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerQuarticMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cKilogramPerQuarticMeterPerSecondPrefixes, cKilogramPerQuarticMeterPerSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cKilogramPerQuarticMeterPerSecondPrefixes, cKilogramPerQuarticMeterPerSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramPerQuarticMeterPerSecondSymbol, cKilogramPerQuarticMeterPerSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramPerQuarticMeterPerSecondSymbol, APrefixes);
end;

function KilogramPerQuarticMeterPerSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := KilogramPerQuarticMeterPerSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := KilogramPerQuarticMeterPerSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramPerQuarticMeterPerSecondSymbol, cKilogramPerQuarticMeterPerSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsKilogramPerQuarticMeterPerSecondSymbol, APrefixes);
  end;
end;

function KilogramPerQuarticMeterPerSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerQuarticMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsKilogramPerQuarticMeterPerSecondName, cKilogramPerQuarticMeterPerSecondPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsKilogramPerQuarticMeterPerSecondPluralName, cKilogramPerQuarticMeterPerSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsKilogramPerQuarticMeterPerSecondName, cKilogramPerQuarticMeterPerSecondPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsKilogramPerQuarticMeterPerSecondPluralName, cKilogramPerQuarticMeterPerSecondPrefixes);
{$ENDIF}
end;

function KilogramPerQuarticMeterPerSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerQuarticMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramPerQuarticMeterPerSecondName, cKilogramPerQuarticMeterPerSecondPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramPerQuarticMeterPerSecondPluralName, cKilogramPerQuarticMeterPerSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramPerQuarticMeterPerSecondName, cKilogramPerQuarticMeterPerSecondPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramPerQuarticMeterPerSecondPluralName, cKilogramPerQuarticMeterPerSecondPrefixes);
{$ENDIF}
end;

function KilogramPerQuarticMeterPerSecondToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := KilogramPerQuarticMeterPerSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := KilogramPerQuarticMeterPerSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramPerQuarticMeterPerSecondSymbol, cKilogramPerQuarticMeterPerSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsKilogramPerQuarticMeterPerSecondSymbol, APrefixes);
  end;
end;

function KilogramPerQuarticMeterPerSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerQuarticMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function KilogramPerQuarticMeterPerSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerQuarticMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cKilogramPerQuarticMeterPerSecondPrefixes, cKilogramPerQuarticMeterPerSecondExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cKilogramPerQuarticMeterPerSecondPrefixes, cKilogramPerQuarticMeterPerSecondExponents);
{$ENDIF}
end;

function CubicMeterPerKilogramToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeterPerKilogram then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsCubicMeterPerKilogramSymbol, cCubicMeterPerKilogramPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsCubicMeterPerKilogramSymbol, cCubicMeterPerKilogramPrefixes);
{$ENDIF}
end;

function CubicMeterPerKilogramToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeterPerKilogram then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cCubicMeterPerKilogramPrefixes, cCubicMeterPerKilogramExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cCubicMeterPerKilogramPrefixes, cCubicMeterPerKilogramExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCubicMeterPerKilogramSymbol, cCubicMeterPerKilogramPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCubicMeterPerKilogramSymbol, APrefixes);
end;

function CubicMeterPerKilogramToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := CubicMeterPerKilogramToFloat(AQuantity, APrefixes);
  FactoredTol   := CubicMeterPerKilogramToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCubicMeterPerKilogramSymbol, cCubicMeterPerKilogramPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsCubicMeterPerKilogramSymbol, APrefixes);
  end;
end;

function CubicMeterPerKilogramToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeterPerKilogram then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsCubicMeterPerKilogramName, cCubicMeterPerKilogramPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsCubicMeterPerKilogramPluralName, cCubicMeterPerKilogramPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsCubicMeterPerKilogramName, cCubicMeterPerKilogramPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsCubicMeterPerKilogramPluralName, cCubicMeterPerKilogramPrefixes);
{$ENDIF}
end;

function CubicMeterPerKilogramToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeterPerKilogram then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCubicMeterPerKilogramName, cCubicMeterPerKilogramPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCubicMeterPerKilogramPluralName, cCubicMeterPerKilogramPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCubicMeterPerKilogramName, cCubicMeterPerKilogramPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCubicMeterPerKilogramPluralName, cCubicMeterPerKilogramPrefixes);
{$ENDIF}
end;

function CubicMeterPerKilogramToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := CubicMeterPerKilogramToFloat(AQuantity, APrefixes);
  FactoredTol   := CubicMeterPerKilogramToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCubicMeterPerKilogramSymbol, cCubicMeterPerKilogramPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsCubicMeterPerKilogramSymbol, APrefixes);
  end;
end;

function CubicMeterPerKilogramToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeterPerKilogram then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function CubicMeterPerKilogramToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeterPerKilogram then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cCubicMeterPerKilogramPrefixes, cCubicMeterPerKilogramExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cCubicMeterPerKilogramPrefixes, cCubicMeterPerKilogramExponents);
{$ENDIF}
end;

function KilogramSquareSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsKilogramSquareSecondSymbol, cKilogramSquareSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsKilogramSquareSecondSymbol, cKilogramSquareSecondPrefixes);
{$ENDIF}
end;

function KilogramSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cKilogramSquareSecondPrefixes, cKilogramSquareSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cKilogramSquareSecondPrefixes, cKilogramSquareSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramSquareSecondSymbol, cKilogramSquareSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramSquareSecondSymbol, APrefixes);
end;

function KilogramSquareSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := KilogramSquareSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := KilogramSquareSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramSquareSecondSymbol, cKilogramSquareSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsKilogramSquareSecondSymbol, APrefixes);
  end;
end;

function KilogramSquareSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareSecond then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsKilogramSquareSecondName, cKilogramSquareSecondPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsKilogramSquareSecondPluralName, cKilogramSquareSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsKilogramSquareSecondName, cKilogramSquareSecondPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsKilogramSquareSecondPluralName, cKilogramSquareSecondPrefixes);
{$ENDIF}
end;

function KilogramSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareSecond then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramSquareSecondName, cKilogramSquareSecondPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramSquareSecondPluralName, cKilogramSquareSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramSquareSecondName, cKilogramSquareSecondPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramSquareSecondPluralName, cKilogramSquareSecondPrefixes);
{$ENDIF}
end;

function KilogramSquareSecondToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := KilogramSquareSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := KilogramSquareSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramSquareSecondSymbol, cKilogramSquareSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsKilogramSquareSecondSymbol, APrefixes);
  end;
end;

function KilogramSquareSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function KilogramSquareSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cKilogramSquareSecondPrefixes, cKilogramSquareSecondExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cKilogramSquareSecondPrefixes, cKilogramSquareSecondExponents);
{$ENDIF}
end;

function CubicMeterPerSquareSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeterPerSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsCubicMeterPerSquareSecondSymbol, cCubicMeterPerSquareSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsCubicMeterPerSquareSecondSymbol, cCubicMeterPerSquareSecondPrefixes);
{$ENDIF}
end;

function CubicMeterPerSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeterPerSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cCubicMeterPerSquareSecondPrefixes, cCubicMeterPerSquareSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cCubicMeterPerSquareSecondPrefixes, cCubicMeterPerSquareSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCubicMeterPerSquareSecondSymbol, cCubicMeterPerSquareSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCubicMeterPerSquareSecondSymbol, APrefixes);
end;

function CubicMeterPerSquareSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := CubicMeterPerSquareSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := CubicMeterPerSquareSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCubicMeterPerSquareSecondSymbol, cCubicMeterPerSquareSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsCubicMeterPerSquareSecondSymbol, APrefixes);
  end;
end;

function CubicMeterPerSquareSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeterPerSquareSecond then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsCubicMeterPerSquareSecondName, cCubicMeterPerSquareSecondPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsCubicMeterPerSquareSecondPluralName, cCubicMeterPerSquareSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsCubicMeterPerSquareSecondName, cCubicMeterPerSquareSecondPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsCubicMeterPerSquareSecondPluralName, cCubicMeterPerSquareSecondPrefixes);
{$ENDIF}
end;

function CubicMeterPerSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeterPerSquareSecond then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCubicMeterPerSquareSecondName, cCubicMeterPerSquareSecondPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCubicMeterPerSquareSecondPluralName, cCubicMeterPerSquareSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCubicMeterPerSquareSecondName, cCubicMeterPerSquareSecondPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCubicMeterPerSquareSecondPluralName, cCubicMeterPerSquareSecondPrefixes);
{$ENDIF}
end;

function CubicMeterPerSquareSecondToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := CubicMeterPerSquareSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := CubicMeterPerSquareSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCubicMeterPerSquareSecondSymbol, cCubicMeterPerSquareSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsCubicMeterPerSquareSecondSymbol, APrefixes);
  end;
end;

function CubicMeterPerSquareSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeterPerSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function CubicMeterPerSquareSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeterPerSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cCubicMeterPerSquareSecondPrefixes, cCubicMeterPerSquareSecondExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cCubicMeterPerSquareSecondPrefixes, cCubicMeterPerSquareSecondExponents);
{$ENDIF}
end;

function NewtonSquareMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonSquareMeter then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsNewtonSquareMeterSymbol, cNewtonSquareMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsNewtonSquareMeterSymbol, cNewtonSquareMeterPrefixes);
{$ENDIF}
end;

function NewtonSquareMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonSquareMeter then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cNewtonSquareMeterPrefixes, cNewtonSquareMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cNewtonSquareMeterPrefixes, cNewtonSquareMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonSquareMeterSymbol, cNewtonSquareMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonSquareMeterSymbol, APrefixes);
end;

function NewtonSquareMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := NewtonSquareMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := NewtonSquareMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonSquareMeterSymbol, cNewtonSquareMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsNewtonSquareMeterSymbol, APrefixes);
  end;
end;

function NewtonSquareMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonSquareMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsNewtonSquareMeterName, cNewtonSquareMeterPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsNewtonSquareMeterPluralName, cNewtonSquareMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsNewtonSquareMeterName, cNewtonSquareMeterPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsNewtonSquareMeterPluralName, cNewtonSquareMeterPrefixes);
{$ENDIF}
end;

function NewtonSquareMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonSquareMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNewtonSquareMeterName, cNewtonSquareMeterPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNewtonSquareMeterPluralName, cNewtonSquareMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNewtonSquareMeterName, cNewtonSquareMeterPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNewtonSquareMeterPluralName, cNewtonSquareMeterPrefixes);
{$ENDIF}
end;

function NewtonSquareMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := NewtonSquareMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := NewtonSquareMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNewtonSquareMeterSymbol, cNewtonSquareMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsNewtonSquareMeterSymbol, APrefixes);
  end;
end;

function NewtonSquareMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonSquareMeter then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function NewtonSquareMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonSquareMeter then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cNewtonSquareMeterPrefixes, cNewtonSquareMeterExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cNewtonSquareMeterPrefixes, cNewtonSquareMeterExponents);
{$ENDIF}
end;

function KilogramCubicMeterPerSquareSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonSquareMeter then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsKilogramCubicMeterPerSquareSecondSymbol, cKilogramCubicMeterPerSquareSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsKilogramCubicMeterPerSquareSecondSymbol, cKilogramCubicMeterPerSquareSecondPrefixes);
{$ENDIF}
end;

function KilogramCubicMeterPerSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonSquareMeter then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cKilogramCubicMeterPerSquareSecondPrefixes, cKilogramCubicMeterPerSquareSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cKilogramCubicMeterPerSquareSecondPrefixes, cKilogramCubicMeterPerSquareSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramCubicMeterPerSquareSecondSymbol, cKilogramCubicMeterPerSquareSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramCubicMeterPerSquareSecondSymbol, APrefixes);
end;

function KilogramCubicMeterPerSquareSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := KilogramCubicMeterPerSquareSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := KilogramCubicMeterPerSquareSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramCubicMeterPerSquareSecondSymbol, cKilogramCubicMeterPerSquareSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsKilogramCubicMeterPerSquareSecondSymbol, APrefixes);
  end;
end;

function KilogramCubicMeterPerSquareSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonSquareMeter then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cKilogramCubicMeterPerSquareSecondFactor) + ' ' + GetName(rsKilogramCubicMeterPerSquareSecondName, cKilogramCubicMeterPerSquareSecondPrefixes)
  else
    result := FloatToStr(AValue.FValue / cKilogramCubicMeterPerSquareSecondFactor) + ' ' + GetName(rsKilogramCubicMeterPerSquareSecondPluralName, cKilogramCubicMeterPerSquareSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cKilogramCubicMeterPerSquareSecondFactor) + ' ' + GetName(rsKilogramCubicMeterPerSquareSecondName, cKilogramCubicMeterPerSquareSecondPrefixes)
  else
    result := FloatToStr(AValue / cKilogramCubicMeterPerSquareSecondFactor) + ' ' + GetName(rsKilogramCubicMeterPerSquareSecondPluralName, cKilogramCubicMeterPerSquareSecondPrefixes);
  result := '';
{$ENDIF}
end;

function KilogramCubicMeterPerSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonSquareMeter then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cKilogramCubicMeterPerSquareSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramCubicMeterPerSquareSecondName, cKilogramCubicMeterPerSquareSecondPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cKilogramCubicMeterPerSquareSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramCubicMeterPerSquareSecondPluralName, cKilogramCubicMeterPerSquareSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cKilogramCubicMeterPerSquareSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramCubicMeterPerSquareSecondName, cKilogramCubicMeterPerSquareSecondPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cKilogramCubicMeterPerSquareSecondFactor, rsKilogramCubicMeterPerSquareSecondPluralName);
{$ENDIF}
end;

function KilogramCubicMeterPerSquareSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonSquareMeter then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function KilogramCubicMeterPerSquareSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonSquareMeter then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cKilogramCubicMeterPerSquareSecondPrefixes, cKilogramCubicMeterPerSquareSecondExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cKilogramCubicMeterPerSquareSecondPrefixes, cKilogramCubicMeterPerSquareSecondExponents);
{$ENDIF}
end;

function NewtonCubicMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsNewtonCubicMeterSymbol, cNewtonCubicMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsNewtonCubicMeterSymbol, cNewtonCubicMeterPrefixes);
{$ENDIF}
end;

function NewtonCubicMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cNewtonCubicMeterPrefixes, cNewtonCubicMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cNewtonCubicMeterPrefixes, cNewtonCubicMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonCubicMeterSymbol, cNewtonCubicMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonCubicMeterSymbol, APrefixes);
end;

function NewtonCubicMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := NewtonCubicMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := NewtonCubicMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonCubicMeterSymbol, cNewtonCubicMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsNewtonCubicMeterSymbol, APrefixes);
  end;
end;

function NewtonCubicMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonCubicMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsNewtonCubicMeterName, cNewtonCubicMeterPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsNewtonCubicMeterPluralName, cNewtonCubicMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsNewtonCubicMeterName, cNewtonCubicMeterPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsNewtonCubicMeterPluralName, cNewtonCubicMeterPrefixes);
{$ENDIF}
end;

function NewtonCubicMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonCubicMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNewtonCubicMeterName, cNewtonCubicMeterPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNewtonCubicMeterPluralName, cNewtonCubicMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNewtonCubicMeterName, cNewtonCubicMeterPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNewtonCubicMeterPluralName, cNewtonCubicMeterPrefixes);
{$ENDIF}
end;

function NewtonCubicMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := NewtonCubicMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := NewtonCubicMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNewtonCubicMeterSymbol, cNewtonCubicMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsNewtonCubicMeterSymbol, APrefixes);
  end;
end;

function NewtonCubicMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function NewtonCubicMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cNewtonCubicMeterPrefixes, cNewtonCubicMeterExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cNewtonCubicMeterPrefixes, cNewtonCubicMeterExponents);
{$ENDIF}
end;

function KilogramQuarticMeterPerSquareSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsKilogramQuarticMeterPerSquareSecondSymbol, cKilogramQuarticMeterPerSquareSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsKilogramQuarticMeterPerSquareSecondSymbol, cKilogramQuarticMeterPerSquareSecondPrefixes);
{$ENDIF}
end;

function KilogramQuarticMeterPerSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cKilogramQuarticMeterPerSquareSecondPrefixes, cKilogramQuarticMeterPerSquareSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cKilogramQuarticMeterPerSquareSecondPrefixes, cKilogramQuarticMeterPerSquareSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramQuarticMeterPerSquareSecondSymbol, cKilogramQuarticMeterPerSquareSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramQuarticMeterPerSquareSecondSymbol, APrefixes);
end;

function KilogramQuarticMeterPerSquareSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := KilogramQuarticMeterPerSquareSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := KilogramQuarticMeterPerSquareSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramQuarticMeterPerSquareSecondSymbol, cKilogramQuarticMeterPerSquareSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsKilogramQuarticMeterPerSquareSecondSymbol, APrefixes);
  end;
end;

function KilogramQuarticMeterPerSquareSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cKilogramQuarticMeterPerSquareSecondFactor) + ' ' + GetName(rsKilogramQuarticMeterPerSquareSecondName, cKilogramQuarticMeterPerSquareSecondPrefixes)
  else
    result := FloatToStr(AValue.FValue / cKilogramQuarticMeterPerSquareSecondFactor) + ' ' + GetName(rsKilogramQuarticMeterPerSquareSecondPluralName, cKilogramQuarticMeterPerSquareSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cKilogramQuarticMeterPerSquareSecondFactor) + ' ' + GetName(rsKilogramQuarticMeterPerSquareSecondName, cKilogramQuarticMeterPerSquareSecondPrefixes)
  else
    result := FloatToStr(AValue / cKilogramQuarticMeterPerSquareSecondFactor) + ' ' + GetName(rsKilogramQuarticMeterPerSquareSecondPluralName, cKilogramQuarticMeterPerSquareSecondPrefixes);
  result := '';
{$ENDIF}
end;

function KilogramQuarticMeterPerSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cKilogramQuarticMeterPerSquareSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramQuarticMeterPerSquareSecondName, cKilogramQuarticMeterPerSquareSecondPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cKilogramQuarticMeterPerSquareSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramQuarticMeterPerSquareSecondPluralName, cKilogramQuarticMeterPerSquareSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cKilogramQuarticMeterPerSquareSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramQuarticMeterPerSquareSecondName, cKilogramQuarticMeterPerSquareSecondPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cKilogramQuarticMeterPerSquareSecondFactor, rsKilogramQuarticMeterPerSquareSecondPluralName);
{$ENDIF}
end;

function KilogramQuarticMeterPerSquareSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function KilogramQuarticMeterPerSquareSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cKilogramQuarticMeterPerSquareSecondPrefixes, cKilogramQuarticMeterPerSquareSecondExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cKilogramQuarticMeterPerSquareSecondPrefixes, cKilogramQuarticMeterPerSquareSecondExponents);
{$ENDIF}
end;

function NewtonPerSquareKilogramToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerSquareKilogram then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsNewtonPerSquareKilogramSymbol, cNewtonPerSquareKilogramPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsNewtonPerSquareKilogramSymbol, cNewtonPerSquareKilogramPrefixes);
{$ENDIF}
end;

function NewtonPerSquareKilogramToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerSquareKilogram then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cNewtonPerSquareKilogramPrefixes, cNewtonPerSquareKilogramExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cNewtonPerSquareKilogramPrefixes, cNewtonPerSquareKilogramExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonPerSquareKilogramSymbol, cNewtonPerSquareKilogramPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonPerSquareKilogramSymbol, APrefixes);
end;

function NewtonPerSquareKilogramToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := NewtonPerSquareKilogramToFloat(AQuantity, APrefixes);
  FactoredTol   := NewtonPerSquareKilogramToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonPerSquareKilogramSymbol, cNewtonPerSquareKilogramPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsNewtonPerSquareKilogramSymbol, APrefixes);
  end;
end;

function NewtonPerSquareKilogramToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerSquareKilogram then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsNewtonPerSquareKilogramName, cNewtonPerSquareKilogramPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsNewtonPerSquareKilogramPluralName, cNewtonPerSquareKilogramPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsNewtonPerSquareKilogramName, cNewtonPerSquareKilogramPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsNewtonPerSquareKilogramPluralName, cNewtonPerSquareKilogramPrefixes);
{$ENDIF}
end;

function NewtonPerSquareKilogramToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerSquareKilogram then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNewtonPerSquareKilogramName, cNewtonPerSquareKilogramPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNewtonPerSquareKilogramPluralName, cNewtonPerSquareKilogramPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNewtonPerSquareKilogramName, cNewtonPerSquareKilogramPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNewtonPerSquareKilogramPluralName, cNewtonPerSquareKilogramPrefixes);
{$ENDIF}
end;

function NewtonPerSquareKilogramToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := NewtonPerSquareKilogramToFloat(AQuantity, APrefixes);
  FactoredTol   := NewtonPerSquareKilogramToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNewtonPerSquareKilogramSymbol, cNewtonPerSquareKilogramPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsNewtonPerSquareKilogramSymbol, APrefixes);
  end;
end;

function NewtonPerSquareKilogramToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerSquareKilogram then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function NewtonPerSquareKilogramToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerSquareKilogram then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cNewtonPerSquareKilogramPrefixes, cNewtonPerSquareKilogramExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cNewtonPerSquareKilogramPrefixes, cNewtonPerSquareKilogramExponents);
{$ENDIF}
end;

function MeterPerKilogramPerSquareSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerSquareKilogram then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsMeterPerKilogramPerSquareSecondSymbol, cMeterPerKilogramPerSquareSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsMeterPerKilogramPerSquareSecondSymbol, cMeterPerKilogramPerSquareSecondPrefixes);
{$ENDIF}
end;

function MeterPerKilogramPerSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerSquareKilogram then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cMeterPerKilogramPerSquareSecondPrefixes, cMeterPerKilogramPerSquareSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cMeterPerKilogramPerSquareSecondPrefixes, cMeterPerKilogramPerSquareSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterPerKilogramPerSquareSecondSymbol, cMeterPerKilogramPerSquareSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterPerKilogramPerSquareSecondSymbol, APrefixes);
end;

function MeterPerKilogramPerSquareSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := MeterPerKilogramPerSquareSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := MeterPerKilogramPerSquareSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterPerKilogramPerSquareSecondSymbol, cMeterPerKilogramPerSquareSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsMeterPerKilogramPerSquareSecondSymbol, APrefixes);
  end;
end;

function MeterPerKilogramPerSquareSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerSquareKilogram then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cMeterPerKilogramPerSquareSecondFactor) + ' ' + GetName(rsMeterPerKilogramPerSquareSecondName, cMeterPerKilogramPerSquareSecondPrefixes)
  else
    result := FloatToStr(AValue.FValue / cMeterPerKilogramPerSquareSecondFactor) + ' ' + GetName(rsMeterPerKilogramPerSquareSecondPluralName, cMeterPerKilogramPerSquareSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cMeterPerKilogramPerSquareSecondFactor) + ' ' + GetName(rsMeterPerKilogramPerSquareSecondName, cMeterPerKilogramPerSquareSecondPrefixes)
  else
    result := FloatToStr(AValue / cMeterPerKilogramPerSquareSecondFactor) + ' ' + GetName(rsMeterPerKilogramPerSquareSecondPluralName, cMeterPerKilogramPerSquareSecondPrefixes);
  result := '';
{$ENDIF}
end;

function MeterPerKilogramPerSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerSquareKilogram then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cMeterPerKilogramPerSquareSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMeterPerKilogramPerSquareSecondName, cMeterPerKilogramPerSquareSecondPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cMeterPerKilogramPerSquareSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMeterPerKilogramPerSquareSecondPluralName, cMeterPerKilogramPerSquareSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cMeterPerKilogramPerSquareSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMeterPerKilogramPerSquareSecondName, cMeterPerKilogramPerSquareSecondPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cMeterPerKilogramPerSquareSecondFactor, rsMeterPerKilogramPerSquareSecondPluralName);
{$ENDIF}
end;

function MeterPerKilogramPerSquareSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerSquareKilogram then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function MeterPerKilogramPerSquareSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerSquareKilogram then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cMeterPerKilogramPerSquareSecondPrefixes, cMeterPerKilogramPerSquareSecondExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cMeterPerKilogramPerSquareSecondPrefixes, cMeterPerKilogramPerSquareSecondExponents);
{$ENDIF}
end;

function SquareKilogramPerMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareKilogramPerMeter then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsSquareKilogramPerMeterSymbol, cSquareKilogramPerMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsSquareKilogramPerMeterSymbol, cSquareKilogramPerMeterPrefixes);
{$ENDIF}
end;

function SquareKilogramPerMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareKilogramPerMeter then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSquareKilogramPerMeterPrefixes, cSquareKilogramPerMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSquareKilogramPerMeterPrefixes, cSquareKilogramPerMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareKilogramPerMeterSymbol, cSquareKilogramPerMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareKilogramPerMeterSymbol, APrefixes);
end;

function SquareKilogramPerMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SquareKilogramPerMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := SquareKilogramPerMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareKilogramPerMeterSymbol, cSquareKilogramPerMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsSquareKilogramPerMeterSymbol, APrefixes);
  end;
end;

function SquareKilogramPerMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareKilogramPerMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsSquareKilogramPerMeterName, cSquareKilogramPerMeterPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsSquareKilogramPerMeterPluralName, cSquareKilogramPerMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsSquareKilogramPerMeterName, cSquareKilogramPerMeterPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsSquareKilogramPerMeterPluralName, cSquareKilogramPerMeterPrefixes);
{$ENDIF}
end;

function SquareKilogramPerMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareKilogramPerMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareKilogramPerMeterName, cSquareKilogramPerMeterPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareKilogramPerMeterPluralName, cSquareKilogramPerMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareKilogramPerMeterName, cSquareKilogramPerMeterPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareKilogramPerMeterPluralName, cSquareKilogramPerMeterPrefixes);
{$ENDIF}
end;

function SquareKilogramPerMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SquareKilogramPerMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := SquareKilogramPerMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareKilogramPerMeterSymbol, cSquareKilogramPerMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsSquareKilogramPerMeterSymbol, APrefixes);
  end;
end;

function SquareKilogramPerMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareKilogramPerMeter then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function SquareKilogramPerMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareKilogramPerMeter then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cSquareKilogramPerMeterPrefixes, cSquareKilogramPerMeterExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cSquareKilogramPerMeterPrefixes, cSquareKilogramPerMeterExponents);
{$ENDIF}
end;

function SquareKilogramPerSquareMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareKilogramPerSquareMeter then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsSquareKilogramPerSquareMeterSymbol, cSquareKilogramPerSquareMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsSquareKilogramPerSquareMeterSymbol, cSquareKilogramPerSquareMeterPrefixes);
{$ENDIF}
end;

function SquareKilogramPerSquareMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareKilogramPerSquareMeter then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSquareKilogramPerSquareMeterPrefixes, cSquareKilogramPerSquareMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSquareKilogramPerSquareMeterPrefixes, cSquareKilogramPerSquareMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareKilogramPerSquareMeterSymbol, cSquareKilogramPerSquareMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareKilogramPerSquareMeterSymbol, APrefixes);
end;

function SquareKilogramPerSquareMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SquareKilogramPerSquareMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := SquareKilogramPerSquareMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareKilogramPerSquareMeterSymbol, cSquareKilogramPerSquareMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsSquareKilogramPerSquareMeterSymbol, APrefixes);
  end;
end;

function SquareKilogramPerSquareMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareKilogramPerSquareMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsSquareKilogramPerSquareMeterName, cSquareKilogramPerSquareMeterPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsSquareKilogramPerSquareMeterPluralName, cSquareKilogramPerSquareMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsSquareKilogramPerSquareMeterName, cSquareKilogramPerSquareMeterPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsSquareKilogramPerSquareMeterPluralName, cSquareKilogramPerSquareMeterPrefixes);
{$ENDIF}
end;

function SquareKilogramPerSquareMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareKilogramPerSquareMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareKilogramPerSquareMeterName, cSquareKilogramPerSquareMeterPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareKilogramPerSquareMeterPluralName, cSquareKilogramPerSquareMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareKilogramPerSquareMeterName, cSquareKilogramPerSquareMeterPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareKilogramPerSquareMeterPluralName, cSquareKilogramPerSquareMeterPrefixes);
{$ENDIF}
end;

function SquareKilogramPerSquareMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SquareKilogramPerSquareMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := SquareKilogramPerSquareMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareKilogramPerSquareMeterSymbol, cSquareKilogramPerSquareMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsSquareKilogramPerSquareMeterSymbol, APrefixes);
  end;
end;

function SquareKilogramPerSquareMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareKilogramPerSquareMeter then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function SquareKilogramPerSquareMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareKilogramPerSquareMeter then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cSquareKilogramPerSquareMeterPrefixes, cSquareKilogramPerSquareMeterExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cSquareKilogramPerSquareMeterPrefixes, cSquareKilogramPerSquareMeterExponents);
{$ENDIF}
end;

function SquareMeterPerSquareKilogramToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterPerSquareKilogram then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsSquareMeterPerSquareKilogramSymbol, cSquareMeterPerSquareKilogramPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsSquareMeterPerSquareKilogramSymbol, cSquareMeterPerSquareKilogramPrefixes);
{$ENDIF}
end;

function SquareMeterPerSquareKilogramToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterPerSquareKilogram then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSquareMeterPerSquareKilogramPrefixes, cSquareMeterPerSquareKilogramExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSquareMeterPerSquareKilogramPrefixes, cSquareMeterPerSquareKilogramExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareMeterPerSquareKilogramSymbol, cSquareMeterPerSquareKilogramPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareMeterPerSquareKilogramSymbol, APrefixes);
end;

function SquareMeterPerSquareKilogramToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SquareMeterPerSquareKilogramToFloat(AQuantity, APrefixes);
  FactoredTol   := SquareMeterPerSquareKilogramToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareMeterPerSquareKilogramSymbol, cSquareMeterPerSquareKilogramPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsSquareMeterPerSquareKilogramSymbol, APrefixes);
  end;
end;

function SquareMeterPerSquareKilogramToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterPerSquareKilogram then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsSquareMeterPerSquareKilogramName, cSquareMeterPerSquareKilogramPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsSquareMeterPerSquareKilogramPluralName, cSquareMeterPerSquareKilogramPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsSquareMeterPerSquareKilogramName, cSquareMeterPerSquareKilogramPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsSquareMeterPerSquareKilogramPluralName, cSquareMeterPerSquareKilogramPrefixes);
{$ENDIF}
end;

function SquareMeterPerSquareKilogramToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterPerSquareKilogram then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareMeterPerSquareKilogramName, cSquareMeterPerSquareKilogramPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareMeterPerSquareKilogramPluralName, cSquareMeterPerSquareKilogramPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareMeterPerSquareKilogramName, cSquareMeterPerSquareKilogramPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareMeterPerSquareKilogramPluralName, cSquareMeterPerSquareKilogramPrefixes);
{$ENDIF}
end;

function SquareMeterPerSquareKilogramToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SquareMeterPerSquareKilogramToFloat(AQuantity, APrefixes);
  FactoredTol   := SquareMeterPerSquareKilogramToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareMeterPerSquareKilogramSymbol, cSquareMeterPerSquareKilogramPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsSquareMeterPerSquareKilogramSymbol, APrefixes);
  end;
end;

function SquareMeterPerSquareKilogramToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterPerSquareKilogram then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function SquareMeterPerSquareKilogramToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterPerSquareKilogram then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cSquareMeterPerSquareKilogramPrefixes, cSquareMeterPerSquareKilogramExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cSquareMeterPerSquareKilogramPrefixes, cSquareMeterPerSquareKilogramExponents);
{$ENDIF}
end;

function NewtonSquareMeterPerSquareKilogramToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonSquareMeterPerSquareKilogram then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsNewtonSquareMeterPerSquareKilogramSymbol, cNewtonSquareMeterPerSquareKilogramPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsNewtonSquareMeterPerSquareKilogramSymbol, cNewtonSquareMeterPerSquareKilogramPrefixes);
{$ENDIF}
end;

function NewtonSquareMeterPerSquareKilogramToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonSquareMeterPerSquareKilogram then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cNewtonSquareMeterPerSquareKilogramPrefixes, cNewtonSquareMeterPerSquareKilogramExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cNewtonSquareMeterPerSquareKilogramPrefixes, cNewtonSquareMeterPerSquareKilogramExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonSquareMeterPerSquareKilogramSymbol, cNewtonSquareMeterPerSquareKilogramPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonSquareMeterPerSquareKilogramSymbol, APrefixes);
end;

function NewtonSquareMeterPerSquareKilogramToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := NewtonSquareMeterPerSquareKilogramToFloat(AQuantity, APrefixes);
  FactoredTol   := NewtonSquareMeterPerSquareKilogramToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonSquareMeterPerSquareKilogramSymbol, cNewtonSquareMeterPerSquareKilogramPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsNewtonSquareMeterPerSquareKilogramSymbol, APrefixes);
  end;
end;

function NewtonSquareMeterPerSquareKilogramToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonSquareMeterPerSquareKilogram then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsNewtonSquareMeterPerSquareKilogramName, cNewtonSquareMeterPerSquareKilogramPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsNewtonSquareMeterPerSquareKilogramPluralName, cNewtonSquareMeterPerSquareKilogramPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsNewtonSquareMeterPerSquareKilogramName, cNewtonSquareMeterPerSquareKilogramPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsNewtonSquareMeterPerSquareKilogramPluralName, cNewtonSquareMeterPerSquareKilogramPrefixes);
{$ENDIF}
end;

function NewtonSquareMeterPerSquareKilogramToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonSquareMeterPerSquareKilogram then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNewtonSquareMeterPerSquareKilogramName, cNewtonSquareMeterPerSquareKilogramPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNewtonSquareMeterPerSquareKilogramPluralName, cNewtonSquareMeterPerSquareKilogramPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNewtonSquareMeterPerSquareKilogramName, cNewtonSquareMeterPerSquareKilogramPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNewtonSquareMeterPerSquareKilogramPluralName, cNewtonSquareMeterPerSquareKilogramPrefixes);
{$ENDIF}
end;

function NewtonSquareMeterPerSquareKilogramToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := NewtonSquareMeterPerSquareKilogramToFloat(AQuantity, APrefixes);
  FactoredTol   := NewtonSquareMeterPerSquareKilogramToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNewtonSquareMeterPerSquareKilogramSymbol, cNewtonSquareMeterPerSquareKilogramPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsNewtonSquareMeterPerSquareKilogramSymbol, APrefixes);
  end;
end;

function NewtonSquareMeterPerSquareKilogramToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonSquareMeterPerSquareKilogram then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function NewtonSquareMeterPerSquareKilogramToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonSquareMeterPerSquareKilogram then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cNewtonSquareMeterPerSquareKilogramPrefixes, cNewtonSquareMeterPerSquareKilogramExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cNewtonSquareMeterPerSquareKilogramPrefixes, cNewtonSquareMeterPerSquareKilogramExponents);
{$ENDIF}
end;

function CubicMeterPerKilogramPerSquareSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonSquareMeterPerSquareKilogram then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsCubicMeterPerKilogramPerSquareSecondSymbol, cCubicMeterPerKilogramPerSquareSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsCubicMeterPerKilogramPerSquareSecondSymbol, cCubicMeterPerKilogramPerSquareSecondPrefixes);
{$ENDIF}
end;

function CubicMeterPerKilogramPerSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonSquareMeterPerSquareKilogram then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cCubicMeterPerKilogramPerSquareSecondPrefixes, cCubicMeterPerKilogramPerSquareSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cCubicMeterPerKilogramPerSquareSecondPrefixes, cCubicMeterPerKilogramPerSquareSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCubicMeterPerKilogramPerSquareSecondSymbol, cCubicMeterPerKilogramPerSquareSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCubicMeterPerKilogramPerSquareSecondSymbol, APrefixes);
end;

function CubicMeterPerKilogramPerSquareSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := CubicMeterPerKilogramPerSquareSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := CubicMeterPerKilogramPerSquareSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCubicMeterPerKilogramPerSquareSecondSymbol, cCubicMeterPerKilogramPerSquareSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsCubicMeterPerKilogramPerSquareSecondSymbol, APrefixes);
  end;
end;

function CubicMeterPerKilogramPerSquareSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonSquareMeterPerSquareKilogram then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cCubicMeterPerKilogramPerSquareSecondFactor) + ' ' + GetName(rsCubicMeterPerKilogramPerSquareSecondName, cCubicMeterPerKilogramPerSquareSecondPrefixes)
  else
    result := FloatToStr(AValue.FValue / cCubicMeterPerKilogramPerSquareSecondFactor) + ' ' + GetName(rsCubicMeterPerKilogramPerSquareSecondPluralName, cCubicMeterPerKilogramPerSquareSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cCubicMeterPerKilogramPerSquareSecondFactor) + ' ' + GetName(rsCubicMeterPerKilogramPerSquareSecondName, cCubicMeterPerKilogramPerSquareSecondPrefixes)
  else
    result := FloatToStr(AValue / cCubicMeterPerKilogramPerSquareSecondFactor) + ' ' + GetName(rsCubicMeterPerKilogramPerSquareSecondPluralName, cCubicMeterPerKilogramPerSquareSecondPrefixes);
  result := '';
{$ENDIF}
end;

function CubicMeterPerKilogramPerSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonSquareMeterPerSquareKilogram then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cCubicMeterPerKilogramPerSquareSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCubicMeterPerKilogramPerSquareSecondName, cCubicMeterPerKilogramPerSquareSecondPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cCubicMeterPerKilogramPerSquareSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCubicMeterPerKilogramPerSquareSecondPluralName, cCubicMeterPerKilogramPerSquareSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cCubicMeterPerKilogramPerSquareSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCubicMeterPerKilogramPerSquareSecondName, cCubicMeterPerKilogramPerSquareSecondPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cCubicMeterPerKilogramPerSquareSecondFactor, rsCubicMeterPerKilogramPerSquareSecondPluralName);
{$ENDIF}
end;

function CubicMeterPerKilogramPerSquareSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonSquareMeterPerSquareKilogram then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function CubicMeterPerKilogramPerSquareSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonSquareMeterPerSquareKilogram then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cCubicMeterPerKilogramPerSquareSecondPrefixes, cCubicMeterPerKilogramPerSquareSecondExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cCubicMeterPerKilogramPerSquareSecondPrefixes, cCubicMeterPerKilogramPerSquareSecondExponents);
{$ENDIF}
end;

function ReciprocalKelvinToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalKelvin then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsReciprocalKelvinSymbol, cReciprocalKelvinPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsReciprocalKelvinSymbol, cReciprocalKelvinPrefixes);
{$ENDIF}
end;

function ReciprocalKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalKelvin then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cReciprocalKelvinPrefixes, cReciprocalKelvinExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cReciprocalKelvinPrefixes, cReciprocalKelvinExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsReciprocalKelvinSymbol, cReciprocalKelvinPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsReciprocalKelvinSymbol, APrefixes);
end;

function ReciprocalKelvinToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := ReciprocalKelvinToFloat(AQuantity, APrefixes);
  FactoredTol   := ReciprocalKelvinToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsReciprocalKelvinSymbol, cReciprocalKelvinPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsReciprocalKelvinSymbol, APrefixes);
  end;
end;

function ReciprocalKelvinToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalKelvin then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsReciprocalKelvinName, cReciprocalKelvinPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsReciprocalKelvinPluralName, cReciprocalKelvinPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsReciprocalKelvinName, cReciprocalKelvinPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsReciprocalKelvinPluralName, cReciprocalKelvinPrefixes);
{$ENDIF}
end;

function ReciprocalKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalKelvin then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsReciprocalKelvinName, cReciprocalKelvinPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsReciprocalKelvinPluralName, cReciprocalKelvinPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsReciprocalKelvinName, cReciprocalKelvinPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsReciprocalKelvinPluralName, cReciprocalKelvinPrefixes);
{$ENDIF}
end;

function ReciprocalKelvinToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := ReciprocalKelvinToFloat(AQuantity, APrefixes);
  FactoredTol   := ReciprocalKelvinToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsReciprocalKelvinSymbol, cReciprocalKelvinPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsReciprocalKelvinSymbol, APrefixes);
  end;
end;

function ReciprocalKelvinToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalKelvin then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function ReciprocalKelvinToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalKelvin then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cReciprocalKelvinPrefixes, cReciprocalKelvinExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cReciprocalKelvinPrefixes, cReciprocalKelvinExponents);
{$ENDIF}
end;

function KilogramKelvinToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramKelvin then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsKilogramKelvinSymbol, cKilogramKelvinPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsKilogramKelvinSymbol, cKilogramKelvinPrefixes);
{$ENDIF}
end;

function KilogramKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramKelvin then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cKilogramKelvinPrefixes, cKilogramKelvinExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cKilogramKelvinPrefixes, cKilogramKelvinExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramKelvinSymbol, cKilogramKelvinPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramKelvinSymbol, APrefixes);
end;

function KilogramKelvinToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := KilogramKelvinToFloat(AQuantity, APrefixes);
  FactoredTol   := KilogramKelvinToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramKelvinSymbol, cKilogramKelvinPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsKilogramKelvinSymbol, APrefixes);
  end;
end;

function KilogramKelvinToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramKelvin then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsKilogramKelvinName, cKilogramKelvinPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsKilogramKelvinPluralName, cKilogramKelvinPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsKilogramKelvinName, cKilogramKelvinPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsKilogramKelvinPluralName, cKilogramKelvinPrefixes);
{$ENDIF}
end;

function KilogramKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramKelvin then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramKelvinName, cKilogramKelvinPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramKelvinPluralName, cKilogramKelvinPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramKelvinName, cKilogramKelvinPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramKelvinPluralName, cKilogramKelvinPrefixes);
{$ENDIF}
end;

function KilogramKelvinToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := KilogramKelvinToFloat(AQuantity, APrefixes);
  FactoredTol   := KilogramKelvinToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramKelvinSymbol, cKilogramKelvinPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsKilogramKelvinSymbol, APrefixes);
  end;
end;

function KilogramKelvinToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramKelvin then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function KilogramKelvinToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramKelvin then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cKilogramKelvinPrefixes, cKilogramKelvinExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cKilogramKelvinPrefixes, cKilogramKelvinExponents);
{$ENDIF}
end;

function JoulePerKelvinToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerKelvin then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsJoulePerKelvinSymbol, cJoulePerKelvinPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsJoulePerKelvinSymbol, cJoulePerKelvinPrefixes);
{$ENDIF}
end;

function JoulePerKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerKelvin then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cJoulePerKelvinPrefixes, cJoulePerKelvinExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cJoulePerKelvinPrefixes, cJoulePerKelvinExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsJoulePerKelvinSymbol, cJoulePerKelvinPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsJoulePerKelvinSymbol, APrefixes);
end;

function JoulePerKelvinToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := JoulePerKelvinToFloat(AQuantity, APrefixes);
  FactoredTol   := JoulePerKelvinToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsJoulePerKelvinSymbol, cJoulePerKelvinPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsJoulePerKelvinSymbol, APrefixes);
  end;
end;

function JoulePerKelvinToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerKelvin then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsJoulePerKelvinName, cJoulePerKelvinPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsJoulePerKelvinPluralName, cJoulePerKelvinPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsJoulePerKelvinName, cJoulePerKelvinPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsJoulePerKelvinPluralName, cJoulePerKelvinPrefixes);
{$ENDIF}
end;

function JoulePerKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerKelvin then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsJoulePerKelvinName, cJoulePerKelvinPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsJoulePerKelvinPluralName, cJoulePerKelvinPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsJoulePerKelvinName, cJoulePerKelvinPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsJoulePerKelvinPluralName, cJoulePerKelvinPrefixes);
{$ENDIF}
end;

function JoulePerKelvinToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := JoulePerKelvinToFloat(AQuantity, APrefixes);
  FactoredTol   := JoulePerKelvinToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsJoulePerKelvinSymbol, cJoulePerKelvinPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsJoulePerKelvinSymbol, APrefixes);
  end;
end;

function JoulePerKelvinToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerKelvin then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function JoulePerKelvinToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerKelvin then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cJoulePerKelvinPrefixes, cJoulePerKelvinExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cJoulePerKelvinPrefixes, cJoulePerKelvinExponents);
{$ENDIF}
end;

function KilogramSquareMeterPerSquareSecondPerKelvinToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerKelvin then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsKilogramSquareMeterPerSquareSecondPerKelvinSymbol, cKilogramSquareMeterPerSquareSecondPerKelvinPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsKilogramSquareMeterPerSquareSecondPerKelvinSymbol, cKilogramSquareMeterPerSquareSecondPerKelvinPrefixes);
{$ENDIF}
end;

function KilogramSquareMeterPerSquareSecondPerKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerKelvin then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cKilogramSquareMeterPerSquareSecondPerKelvinPrefixes, cKilogramSquareMeterPerSquareSecondPerKelvinExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cKilogramSquareMeterPerSquareSecondPerKelvinPrefixes, cKilogramSquareMeterPerSquareSecondPerKelvinExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramSquareMeterPerSquareSecondPerKelvinSymbol, cKilogramSquareMeterPerSquareSecondPerKelvinPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramSquareMeterPerSquareSecondPerKelvinSymbol, APrefixes);
end;

function KilogramSquareMeterPerSquareSecondPerKelvinToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := KilogramSquareMeterPerSquareSecondPerKelvinToFloat(AQuantity, APrefixes);
  FactoredTol   := KilogramSquareMeterPerSquareSecondPerKelvinToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramSquareMeterPerSquareSecondPerKelvinSymbol, cKilogramSquareMeterPerSquareSecondPerKelvinPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsKilogramSquareMeterPerSquareSecondPerKelvinSymbol, APrefixes);
  end;
end;

function KilogramSquareMeterPerSquareSecondPerKelvinToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerKelvin then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cKilogramSquareMeterPerSquareSecondPerKelvinFactor) + ' ' + GetName(rsKilogramSquareMeterPerSquareSecondPerKelvinName, cKilogramSquareMeterPerSquareSecondPerKelvinPrefixes)
  else
    result := FloatToStr(AValue.FValue / cKilogramSquareMeterPerSquareSecondPerKelvinFactor) + ' ' + GetName(rsKilogramSquareMeterPerSquareSecondPerKelvinPluralName, cKilogramSquareMeterPerSquareSecondPerKelvinPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cKilogramSquareMeterPerSquareSecondPerKelvinFactor) + ' ' + GetName(rsKilogramSquareMeterPerSquareSecondPerKelvinName, cKilogramSquareMeterPerSquareSecondPerKelvinPrefixes)
  else
    result := FloatToStr(AValue / cKilogramSquareMeterPerSquareSecondPerKelvinFactor) + ' ' + GetName(rsKilogramSquareMeterPerSquareSecondPerKelvinPluralName, cKilogramSquareMeterPerSquareSecondPerKelvinPrefixes);
  result := '';
{$ENDIF}
end;

function KilogramSquareMeterPerSquareSecondPerKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerKelvin then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cKilogramSquareMeterPerSquareSecondPerKelvinFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramSquareMeterPerSquareSecondPerKelvinName, cKilogramSquareMeterPerSquareSecondPerKelvinPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cKilogramSquareMeterPerSquareSecondPerKelvinFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramSquareMeterPerSquareSecondPerKelvinPluralName, cKilogramSquareMeterPerSquareSecondPerKelvinPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cKilogramSquareMeterPerSquareSecondPerKelvinFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramSquareMeterPerSquareSecondPerKelvinName, cKilogramSquareMeterPerSquareSecondPerKelvinPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cKilogramSquareMeterPerSquareSecondPerKelvinFactor, rsKilogramSquareMeterPerSquareSecondPerKelvinPluralName);
{$ENDIF}
end;

function KilogramSquareMeterPerSquareSecondPerKelvinToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerKelvin then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function KilogramSquareMeterPerSquareSecondPerKelvinToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerKelvin then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cKilogramSquareMeterPerSquareSecondPerKelvinPrefixes, cKilogramSquareMeterPerSquareSecondPerKelvinExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cKilogramSquareMeterPerSquareSecondPerKelvinPrefixes, cKilogramSquareMeterPerSquareSecondPerKelvinExponents);
{$ENDIF}
end;

function JoulePerKilogramPerKelvinToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerKilogramPerKelvin then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsJoulePerKilogramPerKelvinSymbol, cJoulePerKilogramPerKelvinPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsJoulePerKilogramPerKelvinSymbol, cJoulePerKilogramPerKelvinPrefixes);
{$ENDIF}
end;

function JoulePerKilogramPerKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerKilogramPerKelvin then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cJoulePerKilogramPerKelvinPrefixes, cJoulePerKilogramPerKelvinExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cJoulePerKilogramPerKelvinPrefixes, cJoulePerKilogramPerKelvinExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsJoulePerKilogramPerKelvinSymbol, cJoulePerKilogramPerKelvinPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsJoulePerKilogramPerKelvinSymbol, APrefixes);
end;

function JoulePerKilogramPerKelvinToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := JoulePerKilogramPerKelvinToFloat(AQuantity, APrefixes);
  FactoredTol   := JoulePerKilogramPerKelvinToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsJoulePerKilogramPerKelvinSymbol, cJoulePerKilogramPerKelvinPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsJoulePerKilogramPerKelvinSymbol, APrefixes);
  end;
end;

function JoulePerKilogramPerKelvinToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerKilogramPerKelvin then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsJoulePerKilogramPerKelvinName, cJoulePerKilogramPerKelvinPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsJoulePerKilogramPerKelvinPluralName, cJoulePerKilogramPerKelvinPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsJoulePerKilogramPerKelvinName, cJoulePerKilogramPerKelvinPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsJoulePerKilogramPerKelvinPluralName, cJoulePerKilogramPerKelvinPrefixes);
{$ENDIF}
end;

function JoulePerKilogramPerKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerKilogramPerKelvin then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsJoulePerKilogramPerKelvinName, cJoulePerKilogramPerKelvinPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsJoulePerKilogramPerKelvinPluralName, cJoulePerKilogramPerKelvinPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsJoulePerKilogramPerKelvinName, cJoulePerKilogramPerKelvinPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsJoulePerKilogramPerKelvinPluralName, cJoulePerKilogramPerKelvinPrefixes);
{$ENDIF}
end;

function JoulePerKilogramPerKelvinToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := JoulePerKilogramPerKelvinToFloat(AQuantity, APrefixes);
  FactoredTol   := JoulePerKilogramPerKelvinToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsJoulePerKilogramPerKelvinSymbol, cJoulePerKilogramPerKelvinPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsJoulePerKilogramPerKelvinSymbol, APrefixes);
  end;
end;

function JoulePerKilogramPerKelvinToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerKilogramPerKelvin then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function JoulePerKilogramPerKelvinToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerKilogramPerKelvin then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cJoulePerKilogramPerKelvinPrefixes, cJoulePerKilogramPerKelvinExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cJoulePerKilogramPerKelvinPrefixes, cJoulePerKilogramPerKelvinExponents);
{$ENDIF}
end;

function SquareMeterPerSquareSecondPerKelvinToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerKilogramPerKelvin then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsSquareMeterPerSquareSecondPerKelvinSymbol, cSquareMeterPerSquareSecondPerKelvinPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsSquareMeterPerSquareSecondPerKelvinSymbol, cSquareMeterPerSquareSecondPerKelvinPrefixes);
{$ENDIF}
end;

function SquareMeterPerSquareSecondPerKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerKilogramPerKelvin then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSquareMeterPerSquareSecondPerKelvinPrefixes, cSquareMeterPerSquareSecondPerKelvinExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSquareMeterPerSquareSecondPerKelvinPrefixes, cSquareMeterPerSquareSecondPerKelvinExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareMeterPerSquareSecondPerKelvinSymbol, cSquareMeterPerSquareSecondPerKelvinPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareMeterPerSquareSecondPerKelvinSymbol, APrefixes);
end;

function SquareMeterPerSquareSecondPerKelvinToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SquareMeterPerSquareSecondPerKelvinToFloat(AQuantity, APrefixes);
  FactoredTol   := SquareMeterPerSquareSecondPerKelvinToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareMeterPerSquareSecondPerKelvinSymbol, cSquareMeterPerSquareSecondPerKelvinPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsSquareMeterPerSquareSecondPerKelvinSymbol, APrefixes);
  end;
end;

function SquareMeterPerSquareSecondPerKelvinToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerKilogramPerKelvin then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cSquareMeterPerSquareSecondPerKelvinFactor) + ' ' + GetName(rsSquareMeterPerSquareSecondPerKelvinName, cSquareMeterPerSquareSecondPerKelvinPrefixes)
  else
    result := FloatToStr(AValue.FValue / cSquareMeterPerSquareSecondPerKelvinFactor) + ' ' + GetName(rsSquareMeterPerSquareSecondPerKelvinPluralName, cSquareMeterPerSquareSecondPerKelvinPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cSquareMeterPerSquareSecondPerKelvinFactor) + ' ' + GetName(rsSquareMeterPerSquareSecondPerKelvinName, cSquareMeterPerSquareSecondPerKelvinPrefixes)
  else
    result := FloatToStr(AValue / cSquareMeterPerSquareSecondPerKelvinFactor) + ' ' + GetName(rsSquareMeterPerSquareSecondPerKelvinPluralName, cSquareMeterPerSquareSecondPerKelvinPrefixes);
  result := '';
{$ENDIF}
end;

function SquareMeterPerSquareSecondPerKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerKilogramPerKelvin then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cSquareMeterPerSquareSecondPerKelvinFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareMeterPerSquareSecondPerKelvinName, cSquareMeterPerSquareSecondPerKelvinPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cSquareMeterPerSquareSecondPerKelvinFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareMeterPerSquareSecondPerKelvinPluralName, cSquareMeterPerSquareSecondPerKelvinPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cSquareMeterPerSquareSecondPerKelvinFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareMeterPerSquareSecondPerKelvinName, cSquareMeterPerSquareSecondPerKelvinPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cSquareMeterPerSquareSecondPerKelvinFactor, rsSquareMeterPerSquareSecondPerKelvinPluralName);
{$ENDIF}
end;

function SquareMeterPerSquareSecondPerKelvinToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerKilogramPerKelvin then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function SquareMeterPerSquareSecondPerKelvinToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerKilogramPerKelvin then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cSquareMeterPerSquareSecondPerKelvinPrefixes, cSquareMeterPerSquareSecondPerKelvinExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cSquareMeterPerSquareSecondPerKelvinPrefixes, cSquareMeterPerSquareSecondPerKelvinExponents);
{$ENDIF}
end;

function MeterKelvinToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterKelvin then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsMeterKelvinSymbol, cMeterKelvinPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsMeterKelvinSymbol, cMeterKelvinPrefixes);
{$ENDIF}
end;

function MeterKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterKelvin then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cMeterKelvinPrefixes, cMeterKelvinExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cMeterKelvinPrefixes, cMeterKelvinExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterKelvinSymbol, cMeterKelvinPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterKelvinSymbol, APrefixes);
end;

function MeterKelvinToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := MeterKelvinToFloat(AQuantity, APrefixes);
  FactoredTol   := MeterKelvinToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterKelvinSymbol, cMeterKelvinPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsMeterKelvinSymbol, APrefixes);
  end;
end;

function MeterKelvinToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterKelvin then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsMeterKelvinName, cMeterKelvinPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsMeterKelvinPluralName, cMeterKelvinPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsMeterKelvinName, cMeterKelvinPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsMeterKelvinPluralName, cMeterKelvinPrefixes);
{$ENDIF}
end;

function MeterKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterKelvin then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMeterKelvinName, cMeterKelvinPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMeterKelvinPluralName, cMeterKelvinPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMeterKelvinName, cMeterKelvinPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMeterKelvinPluralName, cMeterKelvinPrefixes);
{$ENDIF}
end;

function MeterKelvinToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := MeterKelvinToFloat(AQuantity, APrefixes);
  FactoredTol   := MeterKelvinToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMeterKelvinSymbol, cMeterKelvinPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsMeterKelvinSymbol, APrefixes);
  end;
end;

function MeterKelvinToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterKelvin then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function MeterKelvinToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterKelvin then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cMeterKelvinPrefixes, cMeterKelvinExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cMeterKelvinPrefixes, cMeterKelvinExponents);
{$ENDIF}
end;

function KelvinPerMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKelvinPerMeter then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsKelvinPerMeterSymbol, cKelvinPerMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsKelvinPerMeterSymbol, cKelvinPerMeterPrefixes);
{$ENDIF}
end;

function KelvinPerMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKelvinPerMeter then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cKelvinPerMeterPrefixes, cKelvinPerMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cKelvinPerMeterPrefixes, cKelvinPerMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKelvinPerMeterSymbol, cKelvinPerMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKelvinPerMeterSymbol, APrefixes);
end;

function KelvinPerMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := KelvinPerMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := KelvinPerMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKelvinPerMeterSymbol, cKelvinPerMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsKelvinPerMeterSymbol, APrefixes);
  end;
end;

function KelvinPerMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKelvinPerMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsKelvinPerMeterName, cKelvinPerMeterPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsKelvinPerMeterPluralName, cKelvinPerMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsKelvinPerMeterName, cKelvinPerMeterPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsKelvinPerMeterPluralName, cKelvinPerMeterPrefixes);
{$ENDIF}
end;

function KelvinPerMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKelvinPerMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKelvinPerMeterName, cKelvinPerMeterPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKelvinPerMeterPluralName, cKelvinPerMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKelvinPerMeterName, cKelvinPerMeterPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKelvinPerMeterPluralName, cKelvinPerMeterPrefixes);
{$ENDIF}
end;

function KelvinPerMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := KelvinPerMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := KelvinPerMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKelvinPerMeterSymbol, cKelvinPerMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsKelvinPerMeterSymbol, APrefixes);
  end;
end;

function KelvinPerMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKelvinPerMeter then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function KelvinPerMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKelvinPerMeter then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cKelvinPerMeterPrefixes, cKelvinPerMeterExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cKelvinPerMeterPrefixes, cKelvinPerMeterExponents);
{$ENDIF}
end;

function WattPerMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerMeter then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsWattPerMeterSymbol, cWattPerMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsWattPerMeterSymbol, cWattPerMeterPrefixes);
{$ENDIF}
end;

function WattPerMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerMeter then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cWattPerMeterPrefixes, cWattPerMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cWattPerMeterPrefixes, cWattPerMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattPerMeterSymbol, cWattPerMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattPerMeterSymbol, APrefixes);
end;

function WattPerMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := WattPerMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := WattPerMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattPerMeterSymbol, cWattPerMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsWattPerMeterSymbol, APrefixes);
  end;
end;

function WattPerMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsWattPerMeterName, cWattPerMeterPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsWattPerMeterPluralName, cWattPerMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsWattPerMeterName, cWattPerMeterPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsWattPerMeterPluralName, cWattPerMeterPrefixes);
{$ENDIF}
end;

function WattPerMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattPerMeterName, cWattPerMeterPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattPerMeterPluralName, cWattPerMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattPerMeterName, cWattPerMeterPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattPerMeterPluralName, cWattPerMeterPrefixes);
{$ENDIF}
end;

function WattPerMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := WattPerMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := WattPerMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattPerMeterSymbol, cWattPerMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsWattPerMeterSymbol, APrefixes);
  end;
end;

function WattPerMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerMeter then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function WattPerMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerMeter then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cWattPerMeterPrefixes, cWattPerMeterExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cWattPerMeterPrefixes, cWattPerMeterExponents);
{$ENDIF}
end;

function KilogramMeterPerCubicSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerMeter then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsKilogramMeterPerCubicSecondSymbol, cKilogramMeterPerCubicSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsKilogramMeterPerCubicSecondSymbol, cKilogramMeterPerCubicSecondPrefixes);
{$ENDIF}
end;

function KilogramMeterPerCubicSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerMeter then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cKilogramMeterPerCubicSecondPrefixes, cKilogramMeterPerCubicSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cKilogramMeterPerCubicSecondPrefixes, cKilogramMeterPerCubicSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramMeterPerCubicSecondSymbol, cKilogramMeterPerCubicSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramMeterPerCubicSecondSymbol, APrefixes);
end;

function KilogramMeterPerCubicSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := KilogramMeterPerCubicSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := KilogramMeterPerCubicSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramMeterPerCubicSecondSymbol, cKilogramMeterPerCubicSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsKilogramMeterPerCubicSecondSymbol, APrefixes);
  end;
end;

function KilogramMeterPerCubicSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerMeter then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cKilogramMeterPerCubicSecondFactor) + ' ' + GetName(rsKilogramMeterPerCubicSecondName, cKilogramMeterPerCubicSecondPrefixes)
  else
    result := FloatToStr(AValue.FValue / cKilogramMeterPerCubicSecondFactor) + ' ' + GetName(rsKilogramMeterPerCubicSecondPluralName, cKilogramMeterPerCubicSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cKilogramMeterPerCubicSecondFactor) + ' ' + GetName(rsKilogramMeterPerCubicSecondName, cKilogramMeterPerCubicSecondPrefixes)
  else
    result := FloatToStr(AValue / cKilogramMeterPerCubicSecondFactor) + ' ' + GetName(rsKilogramMeterPerCubicSecondPluralName, cKilogramMeterPerCubicSecondPrefixes);
  result := '';
{$ENDIF}
end;

function KilogramMeterPerCubicSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerMeter then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cKilogramMeterPerCubicSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramMeterPerCubicSecondName, cKilogramMeterPerCubicSecondPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cKilogramMeterPerCubicSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramMeterPerCubicSecondPluralName, cKilogramMeterPerCubicSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cKilogramMeterPerCubicSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramMeterPerCubicSecondName, cKilogramMeterPerCubicSecondPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cKilogramMeterPerCubicSecondFactor, rsKilogramMeterPerCubicSecondPluralName);
{$ENDIF}
end;

function KilogramMeterPerCubicSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerMeter then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function KilogramMeterPerCubicSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerMeter then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cKilogramMeterPerCubicSecondPrefixes, cKilogramMeterPerCubicSecondExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cKilogramMeterPerCubicSecondPrefixes, cKilogramMeterPerCubicSecondExponents);
{$ENDIF}
end;

function WattPerSquareMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSquareMeter then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsWattPerSquareMeterSymbol, cWattPerSquareMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsWattPerSquareMeterSymbol, cWattPerSquareMeterPrefixes);
{$ENDIF}
end;

function WattPerSquareMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSquareMeter then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cWattPerSquareMeterPrefixes, cWattPerSquareMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cWattPerSquareMeterPrefixes, cWattPerSquareMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattPerSquareMeterSymbol, cWattPerSquareMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattPerSquareMeterSymbol, APrefixes);
end;

function WattPerSquareMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := WattPerSquareMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := WattPerSquareMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattPerSquareMeterSymbol, cWattPerSquareMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsWattPerSquareMeterSymbol, APrefixes);
  end;
end;

function WattPerSquareMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSquareMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsWattPerSquareMeterName, cWattPerSquareMeterPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsWattPerSquareMeterPluralName, cWattPerSquareMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsWattPerSquareMeterName, cWattPerSquareMeterPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsWattPerSquareMeterPluralName, cWattPerSquareMeterPrefixes);
{$ENDIF}
end;

function WattPerSquareMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSquareMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattPerSquareMeterName, cWattPerSquareMeterPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattPerSquareMeterPluralName, cWattPerSquareMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattPerSquareMeterName, cWattPerSquareMeterPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattPerSquareMeterPluralName, cWattPerSquareMeterPrefixes);
{$ENDIF}
end;

function WattPerSquareMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := WattPerSquareMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := WattPerSquareMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattPerSquareMeterSymbol, cWattPerSquareMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsWattPerSquareMeterSymbol, APrefixes);
  end;
end;

function WattPerSquareMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSquareMeter then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function WattPerSquareMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSquareMeter then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cWattPerSquareMeterPrefixes, cWattPerSquareMeterExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cWattPerSquareMeterPrefixes, cWattPerSquareMeterExponents);
{$ENDIF}
end;

function KilogramPerCubicSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSquareMeter then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsKilogramPerCubicSecondSymbol, cKilogramPerCubicSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsKilogramPerCubicSecondSymbol, cKilogramPerCubicSecondPrefixes);
{$ENDIF}
end;

function KilogramPerCubicSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSquareMeter then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cKilogramPerCubicSecondPrefixes, cKilogramPerCubicSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cKilogramPerCubicSecondPrefixes, cKilogramPerCubicSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramPerCubicSecondSymbol, cKilogramPerCubicSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramPerCubicSecondSymbol, APrefixes);
end;

function KilogramPerCubicSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := KilogramPerCubicSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := KilogramPerCubicSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramPerCubicSecondSymbol, cKilogramPerCubicSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsKilogramPerCubicSecondSymbol, APrefixes);
  end;
end;

function KilogramPerCubicSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSquareMeter then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cKilogramPerCubicSecondFactor) + ' ' + GetName(rsKilogramPerCubicSecondName, cKilogramPerCubicSecondPrefixes)
  else
    result := FloatToStr(AValue.FValue / cKilogramPerCubicSecondFactor) + ' ' + GetName(rsKilogramPerCubicSecondPluralName, cKilogramPerCubicSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cKilogramPerCubicSecondFactor) + ' ' + GetName(rsKilogramPerCubicSecondName, cKilogramPerCubicSecondPrefixes)
  else
    result := FloatToStr(AValue / cKilogramPerCubicSecondFactor) + ' ' + GetName(rsKilogramPerCubicSecondPluralName, cKilogramPerCubicSecondPrefixes);
  result := '';
{$ENDIF}
end;

function KilogramPerCubicSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSquareMeter then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cKilogramPerCubicSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramPerCubicSecondName, cKilogramPerCubicSecondPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cKilogramPerCubicSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramPerCubicSecondPluralName, cKilogramPerCubicSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cKilogramPerCubicSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramPerCubicSecondName, cKilogramPerCubicSecondPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cKilogramPerCubicSecondFactor, rsKilogramPerCubicSecondPluralName);
{$ENDIF}
end;

function KilogramPerCubicSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSquareMeter then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function KilogramPerCubicSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSquareMeter then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cKilogramPerCubicSecondPrefixes, cKilogramPerCubicSecondExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cKilogramPerCubicSecondPrefixes, cKilogramPerCubicSecondExponents);
{$ENDIF}
end;

function WattPerCubicMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsWattPerCubicMeterSymbol, cWattPerCubicMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsWattPerCubicMeterSymbol, cWattPerCubicMeterPrefixes);
{$ENDIF}
end;

function WattPerCubicMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cWattPerCubicMeterPrefixes, cWattPerCubicMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cWattPerCubicMeterPrefixes, cWattPerCubicMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattPerCubicMeterSymbol, cWattPerCubicMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattPerCubicMeterSymbol, APrefixes);
end;

function WattPerCubicMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := WattPerCubicMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := WattPerCubicMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattPerCubicMeterSymbol, cWattPerCubicMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsWattPerCubicMeterSymbol, APrefixes);
  end;
end;

function WattPerCubicMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerCubicMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsWattPerCubicMeterName, cWattPerCubicMeterPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsWattPerCubicMeterPluralName, cWattPerCubicMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsWattPerCubicMeterName, cWattPerCubicMeterPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsWattPerCubicMeterPluralName, cWattPerCubicMeterPrefixes);
{$ENDIF}
end;

function WattPerCubicMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerCubicMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattPerCubicMeterName, cWattPerCubicMeterPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattPerCubicMeterPluralName, cWattPerCubicMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattPerCubicMeterName, cWattPerCubicMeterPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattPerCubicMeterPluralName, cWattPerCubicMeterPrefixes);
{$ENDIF}
end;

function WattPerCubicMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := WattPerCubicMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := WattPerCubicMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattPerCubicMeterSymbol, cWattPerCubicMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsWattPerCubicMeterSymbol, APrefixes);
  end;
end;

function WattPerCubicMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function WattPerCubicMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cWattPerCubicMeterPrefixes, cWattPerCubicMeterExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cWattPerCubicMeterPrefixes, cWattPerCubicMeterExponents);
{$ENDIF}
end;

function WattPerKelvinToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerKelvin then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsWattPerKelvinSymbol, cWattPerKelvinPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsWattPerKelvinSymbol, cWattPerKelvinPrefixes);
{$ENDIF}
end;

function WattPerKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerKelvin then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cWattPerKelvinPrefixes, cWattPerKelvinExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cWattPerKelvinPrefixes, cWattPerKelvinExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattPerKelvinSymbol, cWattPerKelvinPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattPerKelvinSymbol, APrefixes);
end;

function WattPerKelvinToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := WattPerKelvinToFloat(AQuantity, APrefixes);
  FactoredTol   := WattPerKelvinToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattPerKelvinSymbol, cWattPerKelvinPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsWattPerKelvinSymbol, APrefixes);
  end;
end;

function WattPerKelvinToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerKelvin then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsWattPerKelvinName, cWattPerKelvinPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsWattPerKelvinPluralName, cWattPerKelvinPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsWattPerKelvinName, cWattPerKelvinPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsWattPerKelvinPluralName, cWattPerKelvinPrefixes);
{$ENDIF}
end;

function WattPerKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerKelvin then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattPerKelvinName, cWattPerKelvinPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattPerKelvinPluralName, cWattPerKelvinPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattPerKelvinName, cWattPerKelvinPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattPerKelvinPluralName, cWattPerKelvinPrefixes);
{$ENDIF}
end;

function WattPerKelvinToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := WattPerKelvinToFloat(AQuantity, APrefixes);
  FactoredTol   := WattPerKelvinToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattPerKelvinSymbol, cWattPerKelvinPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsWattPerKelvinSymbol, APrefixes);
  end;
end;

function WattPerKelvinToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerKelvin then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function WattPerKelvinToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerKelvin then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cWattPerKelvinPrefixes, cWattPerKelvinExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cWattPerKelvinPrefixes, cWattPerKelvinExponents);
{$ENDIF}
end;

function KilogramSquareMeterPerCubicSecondPerKelvinToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerKelvin then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsKilogramSquareMeterPerCubicSecondPerKelvinSymbol, cKilogramSquareMeterPerCubicSecondPerKelvinPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsKilogramSquareMeterPerCubicSecondPerKelvinSymbol, cKilogramSquareMeterPerCubicSecondPerKelvinPrefixes);
{$ENDIF}
end;

function KilogramSquareMeterPerCubicSecondPerKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerKelvin then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cKilogramSquareMeterPerCubicSecondPerKelvinPrefixes, cKilogramSquareMeterPerCubicSecondPerKelvinExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cKilogramSquareMeterPerCubicSecondPerKelvinPrefixes, cKilogramSquareMeterPerCubicSecondPerKelvinExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramSquareMeterPerCubicSecondPerKelvinSymbol, cKilogramSquareMeterPerCubicSecondPerKelvinPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramSquareMeterPerCubicSecondPerKelvinSymbol, APrefixes);
end;

function KilogramSquareMeterPerCubicSecondPerKelvinToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := KilogramSquareMeterPerCubicSecondPerKelvinToFloat(AQuantity, APrefixes);
  FactoredTol   := KilogramSquareMeterPerCubicSecondPerKelvinToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramSquareMeterPerCubicSecondPerKelvinSymbol, cKilogramSquareMeterPerCubicSecondPerKelvinPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsKilogramSquareMeterPerCubicSecondPerKelvinSymbol, APrefixes);
  end;
end;

function KilogramSquareMeterPerCubicSecondPerKelvinToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerKelvin then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cKilogramSquareMeterPerCubicSecondPerKelvinFactor) + ' ' + GetName(rsKilogramSquareMeterPerCubicSecondPerKelvinName, cKilogramSquareMeterPerCubicSecondPerKelvinPrefixes)
  else
    result := FloatToStr(AValue.FValue / cKilogramSquareMeterPerCubicSecondPerKelvinFactor) + ' ' + GetName(rsKilogramSquareMeterPerCubicSecondPerKelvinPluralName, cKilogramSquareMeterPerCubicSecondPerKelvinPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cKilogramSquareMeterPerCubicSecondPerKelvinFactor) + ' ' + GetName(rsKilogramSquareMeterPerCubicSecondPerKelvinName, cKilogramSquareMeterPerCubicSecondPerKelvinPrefixes)
  else
    result := FloatToStr(AValue / cKilogramSquareMeterPerCubicSecondPerKelvinFactor) + ' ' + GetName(rsKilogramSquareMeterPerCubicSecondPerKelvinPluralName, cKilogramSquareMeterPerCubicSecondPerKelvinPrefixes);
  result := '';
{$ENDIF}
end;

function KilogramSquareMeterPerCubicSecondPerKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerKelvin then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cKilogramSquareMeterPerCubicSecondPerKelvinFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramSquareMeterPerCubicSecondPerKelvinName, cKilogramSquareMeterPerCubicSecondPerKelvinPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cKilogramSquareMeterPerCubicSecondPerKelvinFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramSquareMeterPerCubicSecondPerKelvinPluralName, cKilogramSquareMeterPerCubicSecondPerKelvinPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cKilogramSquareMeterPerCubicSecondPerKelvinFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramSquareMeterPerCubicSecondPerKelvinName, cKilogramSquareMeterPerCubicSecondPerKelvinPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cKilogramSquareMeterPerCubicSecondPerKelvinFactor, rsKilogramSquareMeterPerCubicSecondPerKelvinPluralName);
{$ENDIF}
end;

function KilogramSquareMeterPerCubicSecondPerKelvinToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerKelvin then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function KilogramSquareMeterPerCubicSecondPerKelvinToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerKelvin then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cKilogramSquareMeterPerCubicSecondPerKelvinPrefixes, cKilogramSquareMeterPerCubicSecondPerKelvinExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cKilogramSquareMeterPerCubicSecondPerKelvinPrefixes, cKilogramSquareMeterPerCubicSecondPerKelvinExponents);
{$ENDIF}
end;

function WattPerMeterPerKelvinToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerMeterPerKelvin then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsWattPerMeterPerKelvinSymbol, cWattPerMeterPerKelvinPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsWattPerMeterPerKelvinSymbol, cWattPerMeterPerKelvinPrefixes);
{$ENDIF}
end;

function WattPerMeterPerKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerMeterPerKelvin then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cWattPerMeterPerKelvinPrefixes, cWattPerMeterPerKelvinExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cWattPerMeterPerKelvinPrefixes, cWattPerMeterPerKelvinExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattPerMeterPerKelvinSymbol, cWattPerMeterPerKelvinPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattPerMeterPerKelvinSymbol, APrefixes);
end;

function WattPerMeterPerKelvinToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := WattPerMeterPerKelvinToFloat(AQuantity, APrefixes);
  FactoredTol   := WattPerMeterPerKelvinToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattPerMeterPerKelvinSymbol, cWattPerMeterPerKelvinPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsWattPerMeterPerKelvinSymbol, APrefixes);
  end;
end;

function WattPerMeterPerKelvinToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerMeterPerKelvin then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsWattPerMeterPerKelvinName, cWattPerMeterPerKelvinPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsWattPerMeterPerKelvinPluralName, cWattPerMeterPerKelvinPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsWattPerMeterPerKelvinName, cWattPerMeterPerKelvinPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsWattPerMeterPerKelvinPluralName, cWattPerMeterPerKelvinPrefixes);
{$ENDIF}
end;

function WattPerMeterPerKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerMeterPerKelvin then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattPerMeterPerKelvinName, cWattPerMeterPerKelvinPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattPerMeterPerKelvinPluralName, cWattPerMeterPerKelvinPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattPerMeterPerKelvinName, cWattPerMeterPerKelvinPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattPerMeterPerKelvinPluralName, cWattPerMeterPerKelvinPrefixes);
{$ENDIF}
end;

function WattPerMeterPerKelvinToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := WattPerMeterPerKelvinToFloat(AQuantity, APrefixes);
  FactoredTol   := WattPerMeterPerKelvinToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattPerMeterPerKelvinSymbol, cWattPerMeterPerKelvinPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsWattPerMeterPerKelvinSymbol, APrefixes);
  end;
end;

function WattPerMeterPerKelvinToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerMeterPerKelvin then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function WattPerMeterPerKelvinToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerMeterPerKelvin then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cWattPerMeterPerKelvinPrefixes, cWattPerMeterPerKelvinExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cWattPerMeterPerKelvinPrefixes, cWattPerMeterPerKelvinExponents);
{$ENDIF}
end;

function KilogramMeterPerCubicSecondPerKelvinToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerMeterPerKelvin then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsKilogramMeterPerCubicSecondPerKelvinSymbol, cKilogramMeterPerCubicSecondPerKelvinPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsKilogramMeterPerCubicSecondPerKelvinSymbol, cKilogramMeterPerCubicSecondPerKelvinPrefixes);
{$ENDIF}
end;

function KilogramMeterPerCubicSecondPerKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerMeterPerKelvin then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cKilogramMeterPerCubicSecondPerKelvinPrefixes, cKilogramMeterPerCubicSecondPerKelvinExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cKilogramMeterPerCubicSecondPerKelvinPrefixes, cKilogramMeterPerCubicSecondPerKelvinExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramMeterPerCubicSecondPerKelvinSymbol, cKilogramMeterPerCubicSecondPerKelvinPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramMeterPerCubicSecondPerKelvinSymbol, APrefixes);
end;

function KilogramMeterPerCubicSecondPerKelvinToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := KilogramMeterPerCubicSecondPerKelvinToFloat(AQuantity, APrefixes);
  FactoredTol   := KilogramMeterPerCubicSecondPerKelvinToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramMeterPerCubicSecondPerKelvinSymbol, cKilogramMeterPerCubicSecondPerKelvinPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsKilogramMeterPerCubicSecondPerKelvinSymbol, APrefixes);
  end;
end;

function KilogramMeterPerCubicSecondPerKelvinToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerMeterPerKelvin then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cKilogramMeterPerCubicSecondPerKelvinFactor) + ' ' + GetName(rsKilogramMeterPerCubicSecondPerKelvinName, cKilogramMeterPerCubicSecondPerKelvinPrefixes)
  else
    result := FloatToStr(AValue.FValue / cKilogramMeterPerCubicSecondPerKelvinFactor) + ' ' + GetName(rsKilogramMeterPerCubicSecondPerKelvinPluralName, cKilogramMeterPerCubicSecondPerKelvinPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cKilogramMeterPerCubicSecondPerKelvinFactor) + ' ' + GetName(rsKilogramMeterPerCubicSecondPerKelvinName, cKilogramMeterPerCubicSecondPerKelvinPrefixes)
  else
    result := FloatToStr(AValue / cKilogramMeterPerCubicSecondPerKelvinFactor) + ' ' + GetName(rsKilogramMeterPerCubicSecondPerKelvinPluralName, cKilogramMeterPerCubicSecondPerKelvinPrefixes);
  result := '';
{$ENDIF}
end;

function KilogramMeterPerCubicSecondPerKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerMeterPerKelvin then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cKilogramMeterPerCubicSecondPerKelvinFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramMeterPerCubicSecondPerKelvinName, cKilogramMeterPerCubicSecondPerKelvinPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cKilogramMeterPerCubicSecondPerKelvinFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramMeterPerCubicSecondPerKelvinPluralName, cKilogramMeterPerCubicSecondPerKelvinPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cKilogramMeterPerCubicSecondPerKelvinFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramMeterPerCubicSecondPerKelvinName, cKilogramMeterPerCubicSecondPerKelvinPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cKilogramMeterPerCubicSecondPerKelvinFactor, rsKilogramMeterPerCubicSecondPerKelvinPluralName);
{$ENDIF}
end;

function KilogramMeterPerCubicSecondPerKelvinToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerMeterPerKelvin then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function KilogramMeterPerCubicSecondPerKelvinToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerMeterPerKelvin then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cKilogramMeterPerCubicSecondPerKelvinPrefixes, cKilogramMeterPerCubicSecondPerKelvinExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cKilogramMeterPerCubicSecondPerKelvinPrefixes, cKilogramMeterPerCubicSecondPerKelvinExponents);
{$ENDIF}
end;

function KelvinPerWattToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKelvinPerWatt then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsKelvinPerWattSymbol, cKelvinPerWattPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsKelvinPerWattSymbol, cKelvinPerWattPrefixes);
{$ENDIF}
end;

function KelvinPerWattToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKelvinPerWatt then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cKelvinPerWattPrefixes, cKelvinPerWattExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cKelvinPerWattPrefixes, cKelvinPerWattExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKelvinPerWattSymbol, cKelvinPerWattPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKelvinPerWattSymbol, APrefixes);
end;

function KelvinPerWattToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := KelvinPerWattToFloat(AQuantity, APrefixes);
  FactoredTol   := KelvinPerWattToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKelvinPerWattSymbol, cKelvinPerWattPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsKelvinPerWattSymbol, APrefixes);
  end;
end;

function KelvinPerWattToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKelvinPerWatt then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsKelvinPerWattName, cKelvinPerWattPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsKelvinPerWattPluralName, cKelvinPerWattPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsKelvinPerWattName, cKelvinPerWattPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsKelvinPerWattPluralName, cKelvinPerWattPrefixes);
{$ENDIF}
end;

function KelvinPerWattToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKelvinPerWatt then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKelvinPerWattName, cKelvinPerWattPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKelvinPerWattPluralName, cKelvinPerWattPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKelvinPerWattName, cKelvinPerWattPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKelvinPerWattPluralName, cKelvinPerWattPrefixes);
{$ENDIF}
end;

function KelvinPerWattToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := KelvinPerWattToFloat(AQuantity, APrefixes);
  FactoredTol   := KelvinPerWattToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKelvinPerWattSymbol, cKelvinPerWattPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsKelvinPerWattSymbol, APrefixes);
  end;
end;

function KelvinPerWattToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKelvinPerWatt then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function KelvinPerWattToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKelvinPerWatt then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cKelvinPerWattPrefixes, cKelvinPerWattExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cKelvinPerWattPrefixes, cKelvinPerWattExponents);
{$ENDIF}
end;

function MeterPerWattToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerWatt then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsMeterPerWattSymbol, cMeterPerWattPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsMeterPerWattSymbol, cMeterPerWattPrefixes);
{$ENDIF}
end;

function MeterPerWattToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerWatt then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cMeterPerWattPrefixes, cMeterPerWattExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cMeterPerWattPrefixes, cMeterPerWattExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterPerWattSymbol, cMeterPerWattPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterPerWattSymbol, APrefixes);
end;

function MeterPerWattToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := MeterPerWattToFloat(AQuantity, APrefixes);
  FactoredTol   := MeterPerWattToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterPerWattSymbol, cMeterPerWattPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsMeterPerWattSymbol, APrefixes);
  end;
end;

function MeterPerWattToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerWatt then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsMeterPerWattName, cMeterPerWattPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsMeterPerWattPluralName, cMeterPerWattPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsMeterPerWattName, cMeterPerWattPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsMeterPerWattPluralName, cMeterPerWattPrefixes);
{$ENDIF}
end;

function MeterPerWattToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerWatt then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMeterPerWattName, cMeterPerWattPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMeterPerWattPluralName, cMeterPerWattPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMeterPerWattName, cMeterPerWattPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMeterPerWattPluralName, cMeterPerWattPrefixes);
{$ENDIF}
end;

function MeterPerWattToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := MeterPerWattToFloat(AQuantity, APrefixes);
  FactoredTol   := MeterPerWattToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMeterPerWattSymbol, cMeterPerWattPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsMeterPerWattSymbol, APrefixes);
  end;
end;

function MeterPerWattToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerWatt then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function MeterPerWattToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerWatt then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cMeterPerWattPrefixes, cMeterPerWattExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cMeterPerWattPrefixes, cMeterPerWattExponents);
{$ENDIF}
end;

function MeterKelvinPerWattToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterKelvinPerWatt then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsMeterKelvinPerWattSymbol, cMeterKelvinPerWattPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsMeterKelvinPerWattSymbol, cMeterKelvinPerWattPrefixes);
{$ENDIF}
end;

function MeterKelvinPerWattToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterKelvinPerWatt then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cMeterKelvinPerWattPrefixes, cMeterKelvinPerWattExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cMeterKelvinPerWattPrefixes, cMeterKelvinPerWattExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterKelvinPerWattSymbol, cMeterKelvinPerWattPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterKelvinPerWattSymbol, APrefixes);
end;

function MeterKelvinPerWattToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := MeterKelvinPerWattToFloat(AQuantity, APrefixes);
  FactoredTol   := MeterKelvinPerWattToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterKelvinPerWattSymbol, cMeterKelvinPerWattPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsMeterKelvinPerWattSymbol, APrefixes);
  end;
end;

function MeterKelvinPerWattToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterKelvinPerWatt then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsMeterKelvinPerWattName, cMeterKelvinPerWattPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsMeterKelvinPerWattPluralName, cMeterKelvinPerWattPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsMeterKelvinPerWattName, cMeterKelvinPerWattPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsMeterKelvinPerWattPluralName, cMeterKelvinPerWattPrefixes);
{$ENDIF}
end;

function MeterKelvinPerWattToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterKelvinPerWatt then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMeterKelvinPerWattName, cMeterKelvinPerWattPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMeterKelvinPerWattPluralName, cMeterKelvinPerWattPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMeterKelvinPerWattName, cMeterKelvinPerWattPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMeterKelvinPerWattPluralName, cMeterKelvinPerWattPrefixes);
{$ENDIF}
end;

function MeterKelvinPerWattToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := MeterKelvinPerWattToFloat(AQuantity, APrefixes);
  FactoredTol   := MeterKelvinPerWattToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMeterKelvinPerWattSymbol, cMeterKelvinPerWattPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsMeterKelvinPerWattSymbol, APrefixes);
  end;
end;

function MeterKelvinPerWattToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterKelvinPerWatt then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function MeterKelvinPerWattToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterKelvinPerWatt then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cMeterKelvinPerWattPrefixes, cMeterKelvinPerWattExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cMeterKelvinPerWattPrefixes, cMeterKelvinPerWattExponents);
{$ENDIF}
end;

function SquareMeterKelvinToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterKelvin then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsSquareMeterKelvinSymbol, cSquareMeterKelvinPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsSquareMeterKelvinSymbol, cSquareMeterKelvinPrefixes);
{$ENDIF}
end;

function SquareMeterKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterKelvin then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSquareMeterKelvinPrefixes, cSquareMeterKelvinExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSquareMeterKelvinPrefixes, cSquareMeterKelvinExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareMeterKelvinSymbol, cSquareMeterKelvinPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareMeterKelvinSymbol, APrefixes);
end;

function SquareMeterKelvinToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SquareMeterKelvinToFloat(AQuantity, APrefixes);
  FactoredTol   := SquareMeterKelvinToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareMeterKelvinSymbol, cSquareMeterKelvinPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsSquareMeterKelvinSymbol, APrefixes);
  end;
end;

function SquareMeterKelvinToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterKelvin then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsSquareMeterKelvinName, cSquareMeterKelvinPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsSquareMeterKelvinPluralName, cSquareMeterKelvinPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsSquareMeterKelvinName, cSquareMeterKelvinPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsSquareMeterKelvinPluralName, cSquareMeterKelvinPrefixes);
{$ENDIF}
end;

function SquareMeterKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterKelvin then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareMeterKelvinName, cSquareMeterKelvinPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareMeterKelvinPluralName, cSquareMeterKelvinPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareMeterKelvinName, cSquareMeterKelvinPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareMeterKelvinPluralName, cSquareMeterKelvinPrefixes);
{$ENDIF}
end;

function SquareMeterKelvinToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SquareMeterKelvinToFloat(AQuantity, APrefixes);
  FactoredTol   := SquareMeterKelvinToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareMeterKelvinSymbol, cSquareMeterKelvinPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsSquareMeterKelvinSymbol, APrefixes);
  end;
end;

function SquareMeterKelvinToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterKelvin then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function SquareMeterKelvinToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterKelvin then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cSquareMeterKelvinPrefixes, cSquareMeterKelvinExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cSquareMeterKelvinPrefixes, cSquareMeterKelvinExponents);
{$ENDIF}
end;

function WattPerSquareMeterPerKelvinToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSquareMeterPerKelvin then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsWattPerSquareMeterPerKelvinSymbol, cWattPerSquareMeterPerKelvinPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsWattPerSquareMeterPerKelvinSymbol, cWattPerSquareMeterPerKelvinPrefixes);
{$ENDIF}
end;

function WattPerSquareMeterPerKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSquareMeterPerKelvin then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cWattPerSquareMeterPerKelvinPrefixes, cWattPerSquareMeterPerKelvinExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cWattPerSquareMeterPerKelvinPrefixes, cWattPerSquareMeterPerKelvinExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattPerSquareMeterPerKelvinSymbol, cWattPerSquareMeterPerKelvinPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattPerSquareMeterPerKelvinSymbol, APrefixes);
end;

function WattPerSquareMeterPerKelvinToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := WattPerSquareMeterPerKelvinToFloat(AQuantity, APrefixes);
  FactoredTol   := WattPerSquareMeterPerKelvinToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattPerSquareMeterPerKelvinSymbol, cWattPerSquareMeterPerKelvinPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsWattPerSquareMeterPerKelvinSymbol, APrefixes);
  end;
end;

function WattPerSquareMeterPerKelvinToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSquareMeterPerKelvin then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsWattPerSquareMeterPerKelvinName, cWattPerSquareMeterPerKelvinPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsWattPerSquareMeterPerKelvinPluralName, cWattPerSquareMeterPerKelvinPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsWattPerSquareMeterPerKelvinName, cWattPerSquareMeterPerKelvinPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsWattPerSquareMeterPerKelvinPluralName, cWattPerSquareMeterPerKelvinPrefixes);
{$ENDIF}
end;

function WattPerSquareMeterPerKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSquareMeterPerKelvin then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattPerSquareMeterPerKelvinName, cWattPerSquareMeterPerKelvinPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattPerSquareMeterPerKelvinPluralName, cWattPerSquareMeterPerKelvinPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattPerSquareMeterPerKelvinName, cWattPerSquareMeterPerKelvinPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattPerSquareMeterPerKelvinPluralName, cWattPerSquareMeterPerKelvinPrefixes);
{$ENDIF}
end;

function WattPerSquareMeterPerKelvinToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := WattPerSquareMeterPerKelvinToFloat(AQuantity, APrefixes);
  FactoredTol   := WattPerSquareMeterPerKelvinToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattPerSquareMeterPerKelvinSymbol, cWattPerSquareMeterPerKelvinPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsWattPerSquareMeterPerKelvinSymbol, APrefixes);
  end;
end;

function WattPerSquareMeterPerKelvinToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSquareMeterPerKelvin then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function WattPerSquareMeterPerKelvinToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSquareMeterPerKelvin then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cWattPerSquareMeterPerKelvinPrefixes, cWattPerSquareMeterPerKelvinExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cWattPerSquareMeterPerKelvinPrefixes, cWattPerSquareMeterPerKelvinExponents);
{$ENDIF}
end;

function KilogramPerCubicSecondPerKelvinToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSquareMeterPerKelvin then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsKilogramPerCubicSecondPerKelvinSymbol, cKilogramPerCubicSecondPerKelvinPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsKilogramPerCubicSecondPerKelvinSymbol, cKilogramPerCubicSecondPerKelvinPrefixes);
{$ENDIF}
end;

function KilogramPerCubicSecondPerKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSquareMeterPerKelvin then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cKilogramPerCubicSecondPerKelvinPrefixes, cKilogramPerCubicSecondPerKelvinExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cKilogramPerCubicSecondPerKelvinPrefixes, cKilogramPerCubicSecondPerKelvinExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramPerCubicSecondPerKelvinSymbol, cKilogramPerCubicSecondPerKelvinPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramPerCubicSecondPerKelvinSymbol, APrefixes);
end;

function KilogramPerCubicSecondPerKelvinToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := KilogramPerCubicSecondPerKelvinToFloat(AQuantity, APrefixes);
  FactoredTol   := KilogramPerCubicSecondPerKelvinToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramPerCubicSecondPerKelvinSymbol, cKilogramPerCubicSecondPerKelvinPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsKilogramPerCubicSecondPerKelvinSymbol, APrefixes);
  end;
end;

function KilogramPerCubicSecondPerKelvinToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSquareMeterPerKelvin then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cKilogramPerCubicSecondPerKelvinFactor) + ' ' + GetName(rsKilogramPerCubicSecondPerKelvinName, cKilogramPerCubicSecondPerKelvinPrefixes)
  else
    result := FloatToStr(AValue.FValue / cKilogramPerCubicSecondPerKelvinFactor) + ' ' + GetName(rsKilogramPerCubicSecondPerKelvinPluralName, cKilogramPerCubicSecondPerKelvinPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cKilogramPerCubicSecondPerKelvinFactor) + ' ' + GetName(rsKilogramPerCubicSecondPerKelvinName, cKilogramPerCubicSecondPerKelvinPrefixes)
  else
    result := FloatToStr(AValue / cKilogramPerCubicSecondPerKelvinFactor) + ' ' + GetName(rsKilogramPerCubicSecondPerKelvinPluralName, cKilogramPerCubicSecondPerKelvinPrefixes);
  result := '';
{$ENDIF}
end;

function KilogramPerCubicSecondPerKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSquareMeterPerKelvin then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cKilogramPerCubicSecondPerKelvinFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramPerCubicSecondPerKelvinName, cKilogramPerCubicSecondPerKelvinPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cKilogramPerCubicSecondPerKelvinFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramPerCubicSecondPerKelvinPluralName, cKilogramPerCubicSecondPerKelvinPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cKilogramPerCubicSecondPerKelvinFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKilogramPerCubicSecondPerKelvinName, cKilogramPerCubicSecondPerKelvinPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cKilogramPerCubicSecondPerKelvinFactor, rsKilogramPerCubicSecondPerKelvinPluralName);
{$ENDIF}
end;

function KilogramPerCubicSecondPerKelvinToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSquareMeterPerKelvin then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function KilogramPerCubicSecondPerKelvinToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSquareMeterPerKelvin then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cKilogramPerCubicSecondPerKelvinPrefixes, cKilogramPerCubicSecondPerKelvinExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cKilogramPerCubicSecondPerKelvinPrefixes, cKilogramPerCubicSecondPerKelvinExponents);
{$ENDIF}
end;

function SquareMeterQuarticKelvinToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterQuarticKelvin then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsSquareMeterQuarticKelvinSymbol, cSquareMeterQuarticKelvinPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsSquareMeterQuarticKelvinSymbol, cSquareMeterQuarticKelvinPrefixes);
{$ENDIF}
end;

function SquareMeterQuarticKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterQuarticKelvin then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSquareMeterQuarticKelvinPrefixes, cSquareMeterQuarticKelvinExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSquareMeterQuarticKelvinPrefixes, cSquareMeterQuarticKelvinExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareMeterQuarticKelvinSymbol, cSquareMeterQuarticKelvinPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareMeterQuarticKelvinSymbol, APrefixes);
end;

function SquareMeterQuarticKelvinToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SquareMeterQuarticKelvinToFloat(AQuantity, APrefixes);
  FactoredTol   := SquareMeterQuarticKelvinToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareMeterQuarticKelvinSymbol, cSquareMeterQuarticKelvinPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsSquareMeterQuarticKelvinSymbol, APrefixes);
  end;
end;

function SquareMeterQuarticKelvinToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterQuarticKelvin then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsSquareMeterQuarticKelvinName, cSquareMeterQuarticKelvinPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsSquareMeterQuarticKelvinPluralName, cSquareMeterQuarticKelvinPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsSquareMeterQuarticKelvinName, cSquareMeterQuarticKelvinPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsSquareMeterQuarticKelvinPluralName, cSquareMeterQuarticKelvinPrefixes);
{$ENDIF}
end;

function SquareMeterQuarticKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterQuarticKelvin then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareMeterQuarticKelvinName, cSquareMeterQuarticKelvinPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareMeterQuarticKelvinPluralName, cSquareMeterQuarticKelvinPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareMeterQuarticKelvinName, cSquareMeterQuarticKelvinPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareMeterQuarticKelvinPluralName, cSquareMeterQuarticKelvinPrefixes);
{$ENDIF}
end;

function SquareMeterQuarticKelvinToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SquareMeterQuarticKelvinToFloat(AQuantity, APrefixes);
  FactoredTol   := SquareMeterQuarticKelvinToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareMeterQuarticKelvinSymbol, cSquareMeterQuarticKelvinPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsSquareMeterQuarticKelvinSymbol, APrefixes);
  end;
end;

function SquareMeterQuarticKelvinToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterQuarticKelvin then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function SquareMeterQuarticKelvinToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterQuarticKelvin then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cSquareMeterQuarticKelvinPrefixes, cSquareMeterQuarticKelvinExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cSquareMeterQuarticKelvinPrefixes, cSquareMeterQuarticKelvinExponents);
{$ENDIF}
end;

function WattPerQuarticKelvinToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerQuarticKelvin then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsWattPerQuarticKelvinSymbol, cWattPerQuarticKelvinPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsWattPerQuarticKelvinSymbol, cWattPerQuarticKelvinPrefixes);
{$ENDIF}
end;

function WattPerQuarticKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerQuarticKelvin then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cWattPerQuarticKelvinPrefixes, cWattPerQuarticKelvinExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cWattPerQuarticKelvinPrefixes, cWattPerQuarticKelvinExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattPerQuarticKelvinSymbol, cWattPerQuarticKelvinPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattPerQuarticKelvinSymbol, APrefixes);
end;

function WattPerQuarticKelvinToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := WattPerQuarticKelvinToFloat(AQuantity, APrefixes);
  FactoredTol   := WattPerQuarticKelvinToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattPerQuarticKelvinSymbol, cWattPerQuarticKelvinPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsWattPerQuarticKelvinSymbol, APrefixes);
  end;
end;

function WattPerQuarticKelvinToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerQuarticKelvin then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsWattPerQuarticKelvinName, cWattPerQuarticKelvinPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsWattPerQuarticKelvinPluralName, cWattPerQuarticKelvinPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsWattPerQuarticKelvinName, cWattPerQuarticKelvinPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsWattPerQuarticKelvinPluralName, cWattPerQuarticKelvinPrefixes);
{$ENDIF}
end;

function WattPerQuarticKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerQuarticKelvin then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattPerQuarticKelvinName, cWattPerQuarticKelvinPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattPerQuarticKelvinPluralName, cWattPerQuarticKelvinPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattPerQuarticKelvinName, cWattPerQuarticKelvinPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattPerQuarticKelvinPluralName, cWattPerQuarticKelvinPrefixes);
{$ENDIF}
end;

function WattPerQuarticKelvinToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := WattPerQuarticKelvinToFloat(AQuantity, APrefixes);
  FactoredTol   := WattPerQuarticKelvinToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattPerQuarticKelvinSymbol, cWattPerQuarticKelvinPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsWattPerQuarticKelvinSymbol, APrefixes);
  end;
end;

function WattPerQuarticKelvinToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerQuarticKelvin then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function WattPerQuarticKelvinToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerQuarticKelvin then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cWattPerQuarticKelvinPrefixes, cWattPerQuarticKelvinExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cWattPerQuarticKelvinPrefixes, cWattPerQuarticKelvinExponents);
{$ENDIF}
end;

function WattPerSquareMeterPerQuarticKelvinToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSquareMeterPerQuarticKelvin then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsWattPerSquareMeterPerQuarticKelvinSymbol, cWattPerSquareMeterPerQuarticKelvinPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsWattPerSquareMeterPerQuarticKelvinSymbol, cWattPerSquareMeterPerQuarticKelvinPrefixes);
{$ENDIF}
end;

function WattPerSquareMeterPerQuarticKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSquareMeterPerQuarticKelvin then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cWattPerSquareMeterPerQuarticKelvinPrefixes, cWattPerSquareMeterPerQuarticKelvinExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cWattPerSquareMeterPerQuarticKelvinPrefixes, cWattPerSquareMeterPerQuarticKelvinExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattPerSquareMeterPerQuarticKelvinSymbol, cWattPerSquareMeterPerQuarticKelvinPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattPerSquareMeterPerQuarticKelvinSymbol, APrefixes);
end;

function WattPerSquareMeterPerQuarticKelvinToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := WattPerSquareMeterPerQuarticKelvinToFloat(AQuantity, APrefixes);
  FactoredTol   := WattPerSquareMeterPerQuarticKelvinToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattPerSquareMeterPerQuarticKelvinSymbol, cWattPerSquareMeterPerQuarticKelvinPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsWattPerSquareMeterPerQuarticKelvinSymbol, APrefixes);
  end;
end;

function WattPerSquareMeterPerQuarticKelvinToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSquareMeterPerQuarticKelvin then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsWattPerSquareMeterPerQuarticKelvinName, cWattPerSquareMeterPerQuarticKelvinPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsWattPerSquareMeterPerQuarticKelvinPluralName, cWattPerSquareMeterPerQuarticKelvinPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsWattPerSquareMeterPerQuarticKelvinName, cWattPerSquareMeterPerQuarticKelvinPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsWattPerSquareMeterPerQuarticKelvinPluralName, cWattPerSquareMeterPerQuarticKelvinPrefixes);
{$ENDIF}
end;

function WattPerSquareMeterPerQuarticKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSquareMeterPerQuarticKelvin then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattPerSquareMeterPerQuarticKelvinName, cWattPerSquareMeterPerQuarticKelvinPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattPerSquareMeterPerQuarticKelvinPluralName, cWattPerSquareMeterPerQuarticKelvinPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattPerSquareMeterPerQuarticKelvinName, cWattPerSquareMeterPerQuarticKelvinPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattPerSquareMeterPerQuarticKelvinPluralName, cWattPerSquareMeterPerQuarticKelvinPrefixes);
{$ENDIF}
end;

function WattPerSquareMeterPerQuarticKelvinToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := WattPerSquareMeterPerQuarticKelvinToFloat(AQuantity, APrefixes);
  FactoredTol   := WattPerSquareMeterPerQuarticKelvinToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattPerSquareMeterPerQuarticKelvinSymbol, cWattPerSquareMeterPerQuarticKelvinPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsWattPerSquareMeterPerQuarticKelvinSymbol, APrefixes);
  end;
end;

function WattPerSquareMeterPerQuarticKelvinToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSquareMeterPerQuarticKelvin then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function WattPerSquareMeterPerQuarticKelvinToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSquareMeterPerQuarticKelvin then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cWattPerSquareMeterPerQuarticKelvinPrefixes, cWattPerSquareMeterPerQuarticKelvinExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cWattPerSquareMeterPerQuarticKelvinPrefixes, cWattPerSquareMeterPerQuarticKelvinExponents);
{$ENDIF}
end;

function JoulePerMoleToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerMole then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsJoulePerMoleSymbol, cJoulePerMolePrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsJoulePerMoleSymbol, cJoulePerMolePrefixes);
{$ENDIF}
end;

function JoulePerMoleToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerMole then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cJoulePerMolePrefixes, cJoulePerMoleExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cJoulePerMolePrefixes, cJoulePerMoleExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsJoulePerMoleSymbol, cJoulePerMolePrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsJoulePerMoleSymbol, APrefixes);
end;

function JoulePerMoleToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := JoulePerMoleToFloat(AQuantity, APrefixes);
  FactoredTol   := JoulePerMoleToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsJoulePerMoleSymbol, cJoulePerMolePrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsJoulePerMoleSymbol, APrefixes);
  end;
end;

function JoulePerMoleToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerMole then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsJoulePerMoleName, cJoulePerMolePrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsJoulePerMolePluralName, cJoulePerMolePrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsJoulePerMoleName, cJoulePerMolePrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsJoulePerMolePluralName, cJoulePerMolePrefixes);
{$ENDIF}
end;

function JoulePerMoleToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerMole then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsJoulePerMoleName, cJoulePerMolePrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsJoulePerMolePluralName, cJoulePerMolePrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsJoulePerMoleName, cJoulePerMolePrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsJoulePerMolePluralName, cJoulePerMolePrefixes);
{$ENDIF}
end;

function JoulePerMoleToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := JoulePerMoleToFloat(AQuantity, APrefixes);
  FactoredTol   := JoulePerMoleToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsJoulePerMoleSymbol, cJoulePerMolePrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsJoulePerMoleSymbol, APrefixes);
  end;
end;

function JoulePerMoleToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerMole then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function JoulePerMoleToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerMole then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cJoulePerMolePrefixes, cJoulePerMoleExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cJoulePerMolePrefixes, cJoulePerMoleExponents);
{$ENDIF}
end;

function MoleKelvinToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMoleKelvin then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsMoleKelvinSymbol, cMoleKelvinPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsMoleKelvinSymbol, cMoleKelvinPrefixes);
{$ENDIF}
end;

function MoleKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMoleKelvin then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cMoleKelvinPrefixes, cMoleKelvinExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cMoleKelvinPrefixes, cMoleKelvinExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMoleKelvinSymbol, cMoleKelvinPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMoleKelvinSymbol, APrefixes);
end;

function MoleKelvinToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := MoleKelvinToFloat(AQuantity, APrefixes);
  FactoredTol   := MoleKelvinToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMoleKelvinSymbol, cMoleKelvinPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsMoleKelvinSymbol, APrefixes);
  end;
end;

function MoleKelvinToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMoleKelvin then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsMoleKelvinName, cMoleKelvinPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsMoleKelvinPluralName, cMoleKelvinPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsMoleKelvinName, cMoleKelvinPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsMoleKelvinPluralName, cMoleKelvinPrefixes);
{$ENDIF}
end;

function MoleKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMoleKelvin then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMoleKelvinName, cMoleKelvinPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMoleKelvinPluralName, cMoleKelvinPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMoleKelvinName, cMoleKelvinPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMoleKelvinPluralName, cMoleKelvinPrefixes);
{$ENDIF}
end;

function MoleKelvinToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := MoleKelvinToFloat(AQuantity, APrefixes);
  FactoredTol   := MoleKelvinToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMoleKelvinSymbol, cMoleKelvinPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsMoleKelvinSymbol, APrefixes);
  end;
end;

function MoleKelvinToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMoleKelvin then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function MoleKelvinToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMoleKelvin then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cMoleKelvinPrefixes, cMoleKelvinExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cMoleKelvinPrefixes, cMoleKelvinExponents);
{$ENDIF}
end;

function JoulePerMolePerKelvinToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerMolePerKelvin then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsJoulePerMolePerKelvinSymbol, cJoulePerMolePerKelvinPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsJoulePerMolePerKelvinSymbol, cJoulePerMolePerKelvinPrefixes);
{$ENDIF}
end;

function JoulePerMolePerKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerMolePerKelvin then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cJoulePerMolePerKelvinPrefixes, cJoulePerMolePerKelvinExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cJoulePerMolePerKelvinPrefixes, cJoulePerMolePerKelvinExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsJoulePerMolePerKelvinSymbol, cJoulePerMolePerKelvinPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsJoulePerMolePerKelvinSymbol, APrefixes);
end;

function JoulePerMolePerKelvinToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := JoulePerMolePerKelvinToFloat(AQuantity, APrefixes);
  FactoredTol   := JoulePerMolePerKelvinToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsJoulePerMolePerKelvinSymbol, cJoulePerMolePerKelvinPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsJoulePerMolePerKelvinSymbol, APrefixes);
  end;
end;

function JoulePerMolePerKelvinToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerMolePerKelvin then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsJoulePerMolePerKelvinName, cJoulePerMolePerKelvinPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsJoulePerMolePerKelvinPluralName, cJoulePerMolePerKelvinPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsJoulePerMolePerKelvinName, cJoulePerMolePerKelvinPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsJoulePerMolePerKelvinPluralName, cJoulePerMolePerKelvinPrefixes);
{$ENDIF}
end;

function JoulePerMolePerKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerMolePerKelvin then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsJoulePerMolePerKelvinName, cJoulePerMolePerKelvinPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsJoulePerMolePerKelvinPluralName, cJoulePerMolePerKelvinPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsJoulePerMolePerKelvinName, cJoulePerMolePerKelvinPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsJoulePerMolePerKelvinPluralName, cJoulePerMolePerKelvinPrefixes);
{$ENDIF}
end;

function JoulePerMolePerKelvinToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := JoulePerMolePerKelvinToFloat(AQuantity, APrefixes);
  FactoredTol   := JoulePerMolePerKelvinToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsJoulePerMolePerKelvinSymbol, cJoulePerMolePerKelvinPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsJoulePerMolePerKelvinSymbol, APrefixes);
  end;
end;

function JoulePerMolePerKelvinToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerMolePerKelvin then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function JoulePerMolePerKelvinToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerMolePerKelvin then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cJoulePerMolePerKelvinPrefixes, cJoulePerMolePerKelvinExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cJoulePerMolePerKelvinPrefixes, cJoulePerMolePerKelvinExponents);
{$ENDIF}
end;

function OhmMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cOhmMeter then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsOhmMeterSymbol, cOhmMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsOhmMeterSymbol, cOhmMeterPrefixes);
{$ENDIF}
end;

function OhmMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cOhmMeter then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cOhmMeterPrefixes, cOhmMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cOhmMeterPrefixes, cOhmMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsOhmMeterSymbol, cOhmMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsOhmMeterSymbol, APrefixes);
end;

function OhmMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := OhmMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := OhmMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsOhmMeterSymbol, cOhmMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsOhmMeterSymbol, APrefixes);
  end;
end;

function OhmMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cOhmMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsOhmMeterName, cOhmMeterPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsOhmMeterPluralName, cOhmMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsOhmMeterName, cOhmMeterPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsOhmMeterPluralName, cOhmMeterPrefixes);
{$ENDIF}
end;

function OhmMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cOhmMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsOhmMeterName, cOhmMeterPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsOhmMeterPluralName, cOhmMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsOhmMeterName, cOhmMeterPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsOhmMeterPluralName, cOhmMeterPrefixes);
{$ENDIF}
end;

function OhmMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := OhmMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := OhmMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsOhmMeterSymbol, cOhmMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsOhmMeterSymbol, APrefixes);
  end;
end;

function OhmMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cOhmMeter then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function OhmMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cOhmMeter then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cOhmMeterPrefixes, cOhmMeterExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cOhmMeterPrefixes, cOhmMeterExponents);
{$ENDIF}
end;

function VoltPerMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVoltPerMeter then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsVoltPerMeterSymbol, cVoltPerMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsVoltPerMeterSymbol, cVoltPerMeterPrefixes);
{$ENDIF}
end;

function VoltPerMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVoltPerMeter then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cVoltPerMeterPrefixes, cVoltPerMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cVoltPerMeterPrefixes, cVoltPerMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsVoltPerMeterSymbol, cVoltPerMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsVoltPerMeterSymbol, APrefixes);
end;

function VoltPerMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := VoltPerMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := VoltPerMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsVoltPerMeterSymbol, cVoltPerMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsVoltPerMeterSymbol, APrefixes);
  end;
end;

function VoltPerMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVoltPerMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsVoltPerMeterName, cVoltPerMeterPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsVoltPerMeterPluralName, cVoltPerMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsVoltPerMeterName, cVoltPerMeterPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsVoltPerMeterPluralName, cVoltPerMeterPrefixes);
{$ENDIF}
end;

function VoltPerMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVoltPerMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsVoltPerMeterName, cVoltPerMeterPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsVoltPerMeterPluralName, cVoltPerMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsVoltPerMeterName, cVoltPerMeterPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsVoltPerMeterPluralName, cVoltPerMeterPrefixes);
{$ENDIF}
end;

function VoltPerMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := VoltPerMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := VoltPerMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsVoltPerMeterSymbol, cVoltPerMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsVoltPerMeterSymbol, APrefixes);
  end;
end;

function VoltPerMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVoltPerMeter then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function VoltPerMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVoltPerMeter then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cVoltPerMeterPrefixes, cVoltPerMeterExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cVoltPerMeterPrefixes, cVoltPerMeterExponents);
{$ENDIF}
end;

function NewtonPerCoulombToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVoltPerMeter then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsNewtonPerCoulombSymbol, cNewtonPerCoulombPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsNewtonPerCoulombSymbol, cNewtonPerCoulombPrefixes);
{$ENDIF}
end;

function NewtonPerCoulombToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVoltPerMeter then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cNewtonPerCoulombPrefixes, cNewtonPerCoulombExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cNewtonPerCoulombPrefixes, cNewtonPerCoulombExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonPerCoulombSymbol, cNewtonPerCoulombPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonPerCoulombSymbol, APrefixes);
end;

function NewtonPerCoulombToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := NewtonPerCoulombToFloat(AQuantity, APrefixes);
  FactoredTol   := NewtonPerCoulombToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonPerCoulombSymbol, cNewtonPerCoulombPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsNewtonPerCoulombSymbol, APrefixes);
  end;
end;

function NewtonPerCoulombToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVoltPerMeter then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cNewtonPerCoulombFactor) + ' ' + GetName(rsNewtonPerCoulombName, cNewtonPerCoulombPrefixes)
  else
    result := FloatToStr(AValue.FValue / cNewtonPerCoulombFactor) + ' ' + GetName(rsNewtonPerCoulombPluralName, cNewtonPerCoulombPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cNewtonPerCoulombFactor) + ' ' + GetName(rsNewtonPerCoulombName, cNewtonPerCoulombPrefixes)
  else
    result := FloatToStr(AValue / cNewtonPerCoulombFactor) + ' ' + GetName(rsNewtonPerCoulombPluralName, cNewtonPerCoulombPrefixes);
  result := '';
{$ENDIF}
end;

function NewtonPerCoulombToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVoltPerMeter then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cNewtonPerCoulombFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNewtonPerCoulombName, cNewtonPerCoulombPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cNewtonPerCoulombFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNewtonPerCoulombPluralName, cNewtonPerCoulombPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cNewtonPerCoulombFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNewtonPerCoulombName, cNewtonPerCoulombPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cNewtonPerCoulombFactor, rsNewtonPerCoulombPluralName);
{$ENDIF}
end;

function NewtonPerCoulombToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVoltPerMeter then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function NewtonPerCoulombToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVoltPerMeter then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cNewtonPerCoulombPrefixes, cNewtonPerCoulombExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cNewtonPerCoulombPrefixes, cNewtonPerCoulombExponents);
{$ENDIF}
end;

function CoulombPerMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulombPerMeter then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsCoulombPerMeterSymbol, cCoulombPerMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsCoulombPerMeterSymbol, cCoulombPerMeterPrefixes);
{$ENDIF}
end;

function CoulombPerMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulombPerMeter then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cCoulombPerMeterPrefixes, cCoulombPerMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cCoulombPerMeterPrefixes, cCoulombPerMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCoulombPerMeterSymbol, cCoulombPerMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCoulombPerMeterSymbol, APrefixes);
end;

function CoulombPerMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := CoulombPerMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := CoulombPerMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCoulombPerMeterSymbol, cCoulombPerMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsCoulombPerMeterSymbol, APrefixes);
  end;
end;

function CoulombPerMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulombPerMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsCoulombPerMeterName, cCoulombPerMeterPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsCoulombPerMeterPluralName, cCoulombPerMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsCoulombPerMeterName, cCoulombPerMeterPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsCoulombPerMeterPluralName, cCoulombPerMeterPrefixes);
{$ENDIF}
end;

function CoulombPerMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulombPerMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCoulombPerMeterName, cCoulombPerMeterPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCoulombPerMeterPluralName, cCoulombPerMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCoulombPerMeterName, cCoulombPerMeterPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCoulombPerMeterPluralName, cCoulombPerMeterPrefixes);
{$ENDIF}
end;

function CoulombPerMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := CoulombPerMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := CoulombPerMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCoulombPerMeterSymbol, cCoulombPerMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsCoulombPerMeterSymbol, APrefixes);
  end;
end;

function CoulombPerMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulombPerMeter then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function CoulombPerMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulombPerMeter then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cCoulombPerMeterPrefixes, cCoulombPerMeterExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cCoulombPerMeterPrefixes, cCoulombPerMeterExponents);
{$ENDIF}
end;

function SquareCoulombPerMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareCoulombPerMeter then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsSquareCoulombPerMeterSymbol, cSquareCoulombPerMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsSquareCoulombPerMeterSymbol, cSquareCoulombPerMeterPrefixes);
{$ENDIF}
end;

function SquareCoulombPerMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareCoulombPerMeter then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSquareCoulombPerMeterPrefixes, cSquareCoulombPerMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSquareCoulombPerMeterPrefixes, cSquareCoulombPerMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareCoulombPerMeterSymbol, cSquareCoulombPerMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareCoulombPerMeterSymbol, APrefixes);
end;

function SquareCoulombPerMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SquareCoulombPerMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := SquareCoulombPerMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareCoulombPerMeterSymbol, cSquareCoulombPerMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsSquareCoulombPerMeterSymbol, APrefixes);
  end;
end;

function SquareCoulombPerMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareCoulombPerMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsSquareCoulombPerMeterName, cSquareCoulombPerMeterPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsSquareCoulombPerMeterPluralName, cSquareCoulombPerMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsSquareCoulombPerMeterName, cSquareCoulombPerMeterPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsSquareCoulombPerMeterPluralName, cSquareCoulombPerMeterPrefixes);
{$ENDIF}
end;

function SquareCoulombPerMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareCoulombPerMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareCoulombPerMeterName, cSquareCoulombPerMeterPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareCoulombPerMeterPluralName, cSquareCoulombPerMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareCoulombPerMeterName, cSquareCoulombPerMeterPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareCoulombPerMeterPluralName, cSquareCoulombPerMeterPrefixes);
{$ENDIF}
end;

function SquareCoulombPerMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SquareCoulombPerMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := SquareCoulombPerMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareCoulombPerMeterSymbol, cSquareCoulombPerMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsSquareCoulombPerMeterSymbol, APrefixes);
  end;
end;

function SquareCoulombPerMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareCoulombPerMeter then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function SquareCoulombPerMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareCoulombPerMeter then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cSquareCoulombPerMeterPrefixes, cSquareCoulombPerMeterExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cSquareCoulombPerMeterPrefixes, cSquareCoulombPerMeterExponents);
{$ENDIF}
end;

function CoulombPerSquareMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulombPerSquareMeter then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsCoulombPerSquareMeterSymbol, cCoulombPerSquareMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsCoulombPerSquareMeterSymbol, cCoulombPerSquareMeterPrefixes);
{$ENDIF}
end;

function CoulombPerSquareMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulombPerSquareMeter then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cCoulombPerSquareMeterPrefixes, cCoulombPerSquareMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cCoulombPerSquareMeterPrefixes, cCoulombPerSquareMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCoulombPerSquareMeterSymbol, cCoulombPerSquareMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCoulombPerSquareMeterSymbol, APrefixes);
end;

function CoulombPerSquareMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := CoulombPerSquareMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := CoulombPerSquareMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCoulombPerSquareMeterSymbol, cCoulombPerSquareMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsCoulombPerSquareMeterSymbol, APrefixes);
  end;
end;

function CoulombPerSquareMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulombPerSquareMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsCoulombPerSquareMeterName, cCoulombPerSquareMeterPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsCoulombPerSquareMeterPluralName, cCoulombPerSquareMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsCoulombPerSquareMeterName, cCoulombPerSquareMeterPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsCoulombPerSquareMeterPluralName, cCoulombPerSquareMeterPrefixes);
{$ENDIF}
end;

function CoulombPerSquareMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulombPerSquareMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCoulombPerSquareMeterName, cCoulombPerSquareMeterPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCoulombPerSquareMeterPluralName, cCoulombPerSquareMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCoulombPerSquareMeterName, cCoulombPerSquareMeterPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCoulombPerSquareMeterPluralName, cCoulombPerSquareMeterPrefixes);
{$ENDIF}
end;

function CoulombPerSquareMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := CoulombPerSquareMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := CoulombPerSquareMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCoulombPerSquareMeterSymbol, cCoulombPerSquareMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsCoulombPerSquareMeterSymbol, APrefixes);
  end;
end;

function CoulombPerSquareMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulombPerSquareMeter then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function CoulombPerSquareMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulombPerSquareMeter then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cCoulombPerSquareMeterPrefixes, cCoulombPerSquareMeterExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cCoulombPerSquareMeterPrefixes, cCoulombPerSquareMeterExponents);
{$ENDIF}
end;

function SquareMeterPerSquareCoulombToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterPerSquareCoulomb then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsSquareMeterPerSquareCoulombSymbol, cSquareMeterPerSquareCoulombPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsSquareMeterPerSquareCoulombSymbol, cSquareMeterPerSquareCoulombPrefixes);
{$ENDIF}
end;

function SquareMeterPerSquareCoulombToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterPerSquareCoulomb then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSquareMeterPerSquareCoulombPrefixes, cSquareMeterPerSquareCoulombExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSquareMeterPerSquareCoulombPrefixes, cSquareMeterPerSquareCoulombExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareMeterPerSquareCoulombSymbol, cSquareMeterPerSquareCoulombPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareMeterPerSquareCoulombSymbol, APrefixes);
end;

function SquareMeterPerSquareCoulombToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SquareMeterPerSquareCoulombToFloat(AQuantity, APrefixes);
  FactoredTol   := SquareMeterPerSquareCoulombToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareMeterPerSquareCoulombSymbol, cSquareMeterPerSquareCoulombPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsSquareMeterPerSquareCoulombSymbol, APrefixes);
  end;
end;

function SquareMeterPerSquareCoulombToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterPerSquareCoulomb then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsSquareMeterPerSquareCoulombName, cSquareMeterPerSquareCoulombPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsSquareMeterPerSquareCoulombPluralName, cSquareMeterPerSquareCoulombPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsSquareMeterPerSquareCoulombName, cSquareMeterPerSquareCoulombPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsSquareMeterPerSquareCoulombPluralName, cSquareMeterPerSquareCoulombPrefixes);
{$ENDIF}
end;

function SquareMeterPerSquareCoulombToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterPerSquareCoulomb then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareMeterPerSquareCoulombName, cSquareMeterPerSquareCoulombPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareMeterPerSquareCoulombPluralName, cSquareMeterPerSquareCoulombPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareMeterPerSquareCoulombName, cSquareMeterPerSquareCoulombPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareMeterPerSquareCoulombPluralName, cSquareMeterPerSquareCoulombPrefixes);
{$ENDIF}
end;

function SquareMeterPerSquareCoulombToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SquareMeterPerSquareCoulombToFloat(AQuantity, APrefixes);
  FactoredTol   := SquareMeterPerSquareCoulombToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareMeterPerSquareCoulombSymbol, cSquareMeterPerSquareCoulombPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsSquareMeterPerSquareCoulombSymbol, APrefixes);
  end;
end;

function SquareMeterPerSquareCoulombToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterPerSquareCoulomb then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function SquareMeterPerSquareCoulombToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterPerSquareCoulomb then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cSquareMeterPerSquareCoulombPrefixes, cSquareMeterPerSquareCoulombExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cSquareMeterPerSquareCoulombPrefixes, cSquareMeterPerSquareCoulombExponents);
{$ENDIF}
end;

function NewtonPerSquareCoulombToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerSquareCoulomb then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsNewtonPerSquareCoulombSymbol, cNewtonPerSquareCoulombPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsNewtonPerSquareCoulombSymbol, cNewtonPerSquareCoulombPrefixes);
{$ENDIF}
end;

function NewtonPerSquareCoulombToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerSquareCoulomb then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cNewtonPerSquareCoulombPrefixes, cNewtonPerSquareCoulombExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cNewtonPerSquareCoulombPrefixes, cNewtonPerSquareCoulombExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonPerSquareCoulombSymbol, cNewtonPerSquareCoulombPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonPerSquareCoulombSymbol, APrefixes);
end;

function NewtonPerSquareCoulombToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := NewtonPerSquareCoulombToFloat(AQuantity, APrefixes);
  FactoredTol   := NewtonPerSquareCoulombToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonPerSquareCoulombSymbol, cNewtonPerSquareCoulombPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsNewtonPerSquareCoulombSymbol, APrefixes);
  end;
end;

function NewtonPerSquareCoulombToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerSquareCoulomb then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsNewtonPerSquareCoulombName, cNewtonPerSquareCoulombPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsNewtonPerSquareCoulombPluralName, cNewtonPerSquareCoulombPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsNewtonPerSquareCoulombName, cNewtonPerSquareCoulombPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsNewtonPerSquareCoulombPluralName, cNewtonPerSquareCoulombPrefixes);
{$ENDIF}
end;

function NewtonPerSquareCoulombToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerSquareCoulomb then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNewtonPerSquareCoulombName, cNewtonPerSquareCoulombPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNewtonPerSquareCoulombPluralName, cNewtonPerSquareCoulombPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNewtonPerSquareCoulombName, cNewtonPerSquareCoulombPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNewtonPerSquareCoulombPluralName, cNewtonPerSquareCoulombPrefixes);
{$ENDIF}
end;

function NewtonPerSquareCoulombToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := NewtonPerSquareCoulombToFloat(AQuantity, APrefixes);
  FactoredTol   := NewtonPerSquareCoulombToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNewtonPerSquareCoulombSymbol, cNewtonPerSquareCoulombPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsNewtonPerSquareCoulombSymbol, APrefixes);
  end;
end;

function NewtonPerSquareCoulombToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerSquareCoulomb then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function NewtonPerSquareCoulombToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerSquareCoulomb then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cNewtonPerSquareCoulombPrefixes, cNewtonPerSquareCoulombExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cNewtonPerSquareCoulombPrefixes, cNewtonPerSquareCoulombExponents);
{$ENDIF}
end;

function NewtonSquareMeterPerSquareCoulombToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonSquareMeterPerSquareCoulomb then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsNewtonSquareMeterPerSquareCoulombSymbol, cNewtonSquareMeterPerSquareCoulombPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsNewtonSquareMeterPerSquareCoulombSymbol, cNewtonSquareMeterPerSquareCoulombPrefixes);
{$ENDIF}
end;

function NewtonSquareMeterPerSquareCoulombToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonSquareMeterPerSquareCoulomb then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cNewtonSquareMeterPerSquareCoulombPrefixes, cNewtonSquareMeterPerSquareCoulombExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cNewtonSquareMeterPerSquareCoulombPrefixes, cNewtonSquareMeterPerSquareCoulombExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonSquareMeterPerSquareCoulombSymbol, cNewtonSquareMeterPerSquareCoulombPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonSquareMeterPerSquareCoulombSymbol, APrefixes);
end;

function NewtonSquareMeterPerSquareCoulombToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := NewtonSquareMeterPerSquareCoulombToFloat(AQuantity, APrefixes);
  FactoredTol   := NewtonSquareMeterPerSquareCoulombToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonSquareMeterPerSquareCoulombSymbol, cNewtonSquareMeterPerSquareCoulombPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsNewtonSquareMeterPerSquareCoulombSymbol, APrefixes);
  end;
end;

function NewtonSquareMeterPerSquareCoulombToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonSquareMeterPerSquareCoulomb then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsNewtonSquareMeterPerSquareCoulombName, cNewtonSquareMeterPerSquareCoulombPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsNewtonSquareMeterPerSquareCoulombPluralName, cNewtonSquareMeterPerSquareCoulombPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsNewtonSquareMeterPerSquareCoulombName, cNewtonSquareMeterPerSquareCoulombPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsNewtonSquareMeterPerSquareCoulombPluralName, cNewtonSquareMeterPerSquareCoulombPrefixes);
{$ENDIF}
end;

function NewtonSquareMeterPerSquareCoulombToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonSquareMeterPerSquareCoulomb then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNewtonSquareMeterPerSquareCoulombName, cNewtonSquareMeterPerSquareCoulombPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNewtonSquareMeterPerSquareCoulombPluralName, cNewtonSquareMeterPerSquareCoulombPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNewtonSquareMeterPerSquareCoulombName, cNewtonSquareMeterPerSquareCoulombPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNewtonSquareMeterPerSquareCoulombPluralName, cNewtonSquareMeterPerSquareCoulombPrefixes);
{$ENDIF}
end;

function NewtonSquareMeterPerSquareCoulombToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := NewtonSquareMeterPerSquareCoulombToFloat(AQuantity, APrefixes);
  FactoredTol   := NewtonSquareMeterPerSquareCoulombToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNewtonSquareMeterPerSquareCoulombSymbol, cNewtonSquareMeterPerSquareCoulombPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsNewtonSquareMeterPerSquareCoulombSymbol, APrefixes);
  end;
end;

function NewtonSquareMeterPerSquareCoulombToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonSquareMeterPerSquareCoulomb then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function NewtonSquareMeterPerSquareCoulombToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonSquareMeterPerSquareCoulomb then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cNewtonSquareMeterPerSquareCoulombPrefixes, cNewtonSquareMeterPerSquareCoulombExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cNewtonSquareMeterPerSquareCoulombPrefixes, cNewtonSquareMeterPerSquareCoulombExponents);
{$ENDIF}
end;

function VoltMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVoltMeter then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsVoltMeterSymbol, cVoltMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsVoltMeterSymbol, cVoltMeterPrefixes);
{$ENDIF}
end;

function VoltMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVoltMeter then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cVoltMeterPrefixes, cVoltMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cVoltMeterPrefixes, cVoltMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsVoltMeterSymbol, cVoltMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsVoltMeterSymbol, APrefixes);
end;

function VoltMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := VoltMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := VoltMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsVoltMeterSymbol, cVoltMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsVoltMeterSymbol, APrefixes);
  end;
end;

function VoltMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVoltMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsVoltMeterName, cVoltMeterPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsVoltMeterPluralName, cVoltMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsVoltMeterName, cVoltMeterPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsVoltMeterPluralName, cVoltMeterPrefixes);
{$ENDIF}
end;

function VoltMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVoltMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsVoltMeterName, cVoltMeterPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsVoltMeterPluralName, cVoltMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsVoltMeterName, cVoltMeterPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsVoltMeterPluralName, cVoltMeterPrefixes);
{$ENDIF}
end;

function VoltMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := VoltMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := VoltMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsVoltMeterSymbol, cVoltMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsVoltMeterSymbol, APrefixes);
  end;
end;

function VoltMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVoltMeter then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function VoltMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVoltMeter then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cVoltMeterPrefixes, cVoltMeterExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cVoltMeterPrefixes, cVoltMeterExponents);
{$ENDIF}
end;

function NewtonSquareMeterPerCoulombToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVoltMeter then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsNewtonSquareMeterPerCoulombSymbol, cNewtonSquareMeterPerCoulombPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsNewtonSquareMeterPerCoulombSymbol, cNewtonSquareMeterPerCoulombPrefixes);
{$ENDIF}
end;

function NewtonSquareMeterPerCoulombToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVoltMeter then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cNewtonSquareMeterPerCoulombPrefixes, cNewtonSquareMeterPerCoulombExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cNewtonSquareMeterPerCoulombPrefixes, cNewtonSquareMeterPerCoulombExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonSquareMeterPerCoulombSymbol, cNewtonSquareMeterPerCoulombPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonSquareMeterPerCoulombSymbol, APrefixes);
end;

function NewtonSquareMeterPerCoulombToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := NewtonSquareMeterPerCoulombToFloat(AQuantity, APrefixes);
  FactoredTol   := NewtonSquareMeterPerCoulombToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonSquareMeterPerCoulombSymbol, cNewtonSquareMeterPerCoulombPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsNewtonSquareMeterPerCoulombSymbol, APrefixes);
  end;
end;

function NewtonSquareMeterPerCoulombToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVoltMeter then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cNewtonSquareMeterPerCoulombFactor) + ' ' + GetName(rsNewtonSquareMeterPerCoulombName, cNewtonSquareMeterPerCoulombPrefixes)
  else
    result := FloatToStr(AValue.FValue / cNewtonSquareMeterPerCoulombFactor) + ' ' + GetName(rsNewtonSquareMeterPerCoulombPluralName, cNewtonSquareMeterPerCoulombPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cNewtonSquareMeterPerCoulombFactor) + ' ' + GetName(rsNewtonSquareMeterPerCoulombName, cNewtonSquareMeterPerCoulombPrefixes)
  else
    result := FloatToStr(AValue / cNewtonSquareMeterPerCoulombFactor) + ' ' + GetName(rsNewtonSquareMeterPerCoulombPluralName, cNewtonSquareMeterPerCoulombPrefixes);
  result := '';
{$ENDIF}
end;

function NewtonSquareMeterPerCoulombToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVoltMeter then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cNewtonSquareMeterPerCoulombFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNewtonSquareMeterPerCoulombName, cNewtonSquareMeterPerCoulombPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cNewtonSquareMeterPerCoulombFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNewtonSquareMeterPerCoulombPluralName, cNewtonSquareMeterPerCoulombPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cNewtonSquareMeterPerCoulombFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNewtonSquareMeterPerCoulombName, cNewtonSquareMeterPerCoulombPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cNewtonSquareMeterPerCoulombFactor, rsNewtonSquareMeterPerCoulombPluralName);
{$ENDIF}
end;

function NewtonSquareMeterPerCoulombToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVoltMeter then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function NewtonSquareMeterPerCoulombToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVoltMeter then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cNewtonSquareMeterPerCoulombPrefixes, cNewtonSquareMeterPerCoulombExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cNewtonSquareMeterPerCoulombPrefixes, cNewtonSquareMeterPerCoulombExponents);
{$ENDIF}
end;

function VoltMeterPerSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVoltMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsVoltMeterPerSecondSymbol, cVoltMeterPerSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsVoltMeterPerSecondSymbol, cVoltMeterPerSecondPrefixes);
{$ENDIF}
end;

function VoltMeterPerSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVoltMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cVoltMeterPerSecondPrefixes, cVoltMeterPerSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cVoltMeterPerSecondPrefixes, cVoltMeterPerSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsVoltMeterPerSecondSymbol, cVoltMeterPerSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsVoltMeterPerSecondSymbol, APrefixes);
end;

function VoltMeterPerSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := VoltMeterPerSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := VoltMeterPerSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsVoltMeterPerSecondSymbol, cVoltMeterPerSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsVoltMeterPerSecondSymbol, APrefixes);
  end;
end;

function VoltMeterPerSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVoltMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsVoltMeterPerSecondName, cVoltMeterPerSecondPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsVoltMeterPerSecondPluralName, cVoltMeterPerSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsVoltMeterPerSecondName, cVoltMeterPerSecondPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsVoltMeterPerSecondPluralName, cVoltMeterPerSecondPrefixes);
{$ENDIF}
end;

function VoltMeterPerSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVoltMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsVoltMeterPerSecondName, cVoltMeterPerSecondPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsVoltMeterPerSecondPluralName, cVoltMeterPerSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsVoltMeterPerSecondName, cVoltMeterPerSecondPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsVoltMeterPerSecondPluralName, cVoltMeterPerSecondPrefixes);
{$ENDIF}
end;

function VoltMeterPerSecondToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := VoltMeterPerSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := VoltMeterPerSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsVoltMeterPerSecondSymbol, cVoltMeterPerSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsVoltMeterPerSecondSymbol, APrefixes);
  end;
end;

function VoltMeterPerSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVoltMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function VoltMeterPerSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVoltMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cVoltMeterPerSecondPrefixes, cVoltMeterPerSecondExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cVoltMeterPerSecondPrefixes, cVoltMeterPerSecondExponents);
{$ENDIF}
end;

function FaradPerMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cFaradPerMeter then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsFaradPerMeterSymbol, cFaradPerMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsFaradPerMeterSymbol, cFaradPerMeterPrefixes);
{$ENDIF}
end;

function FaradPerMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cFaradPerMeter then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cFaradPerMeterPrefixes, cFaradPerMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cFaradPerMeterPrefixes, cFaradPerMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsFaradPerMeterSymbol, cFaradPerMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsFaradPerMeterSymbol, APrefixes);
end;

function FaradPerMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := FaradPerMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := FaradPerMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsFaradPerMeterSymbol, cFaradPerMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsFaradPerMeterSymbol, APrefixes);
  end;
end;

function FaradPerMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cFaradPerMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsFaradPerMeterName, cFaradPerMeterPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsFaradPerMeterPluralName, cFaradPerMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsFaradPerMeterName, cFaradPerMeterPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsFaradPerMeterPluralName, cFaradPerMeterPrefixes);
{$ENDIF}
end;

function FaradPerMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cFaradPerMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsFaradPerMeterName, cFaradPerMeterPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsFaradPerMeterPluralName, cFaradPerMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsFaradPerMeterName, cFaradPerMeterPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsFaradPerMeterPluralName, cFaradPerMeterPrefixes);
{$ENDIF}
end;

function FaradPerMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := FaradPerMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := FaradPerMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsFaradPerMeterSymbol, cFaradPerMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsFaradPerMeterSymbol, APrefixes);
  end;
end;

function FaradPerMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cFaradPerMeter then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function FaradPerMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cFaradPerMeter then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cFaradPerMeterPrefixes, cFaradPerMeterExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cFaradPerMeterPrefixes, cFaradPerMeterExponents);
{$ENDIF}
end;

function AmperePerMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cAmperePerMeter then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsAmperePerMeterSymbol, cAmperePerMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsAmperePerMeterSymbol, cAmperePerMeterPrefixes);
{$ENDIF}
end;

function AmperePerMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cAmperePerMeter then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cAmperePerMeterPrefixes, cAmperePerMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cAmperePerMeterPrefixes, cAmperePerMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsAmperePerMeterSymbol, cAmperePerMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsAmperePerMeterSymbol, APrefixes);
end;

function AmperePerMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := AmperePerMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := AmperePerMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsAmperePerMeterSymbol, cAmperePerMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsAmperePerMeterSymbol, APrefixes);
  end;
end;

function AmperePerMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cAmperePerMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsAmperePerMeterName, cAmperePerMeterPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsAmperePerMeterPluralName, cAmperePerMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsAmperePerMeterName, cAmperePerMeterPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsAmperePerMeterPluralName, cAmperePerMeterPrefixes);
{$ENDIF}
end;

function AmperePerMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cAmperePerMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsAmperePerMeterName, cAmperePerMeterPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsAmperePerMeterPluralName, cAmperePerMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsAmperePerMeterName, cAmperePerMeterPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsAmperePerMeterPluralName, cAmperePerMeterPrefixes);
{$ENDIF}
end;

function AmperePerMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := AmperePerMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := AmperePerMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsAmperePerMeterSymbol, cAmperePerMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsAmperePerMeterSymbol, APrefixes);
  end;
end;

function AmperePerMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cAmperePerMeter then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function AmperePerMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cAmperePerMeter then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cAmperePerMeterPrefixes, cAmperePerMeterExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cAmperePerMeterPrefixes, cAmperePerMeterExponents);
{$ENDIF}
end;

function MeterPerAmpereToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerAmpere then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsMeterPerAmpereSymbol, cMeterPerAmperePrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsMeterPerAmpereSymbol, cMeterPerAmperePrefixes);
{$ENDIF}
end;

function MeterPerAmpereToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerAmpere then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cMeterPerAmperePrefixes, cMeterPerAmpereExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cMeterPerAmperePrefixes, cMeterPerAmpereExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterPerAmpereSymbol, cMeterPerAmperePrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterPerAmpereSymbol, APrefixes);
end;

function MeterPerAmpereToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := MeterPerAmpereToFloat(AQuantity, APrefixes);
  FactoredTol   := MeterPerAmpereToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterPerAmpereSymbol, cMeterPerAmperePrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsMeterPerAmpereSymbol, APrefixes);
  end;
end;

function MeterPerAmpereToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerAmpere then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsMeterPerAmpereName, cMeterPerAmperePrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsMeterPerAmperePluralName, cMeterPerAmperePrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsMeterPerAmpereName, cMeterPerAmperePrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsMeterPerAmperePluralName, cMeterPerAmperePrefixes);
{$ENDIF}
end;

function MeterPerAmpereToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerAmpere then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMeterPerAmpereName, cMeterPerAmperePrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMeterPerAmperePluralName, cMeterPerAmperePrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMeterPerAmpereName, cMeterPerAmperePrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMeterPerAmperePluralName, cMeterPerAmperePrefixes);
{$ENDIF}
end;

function MeterPerAmpereToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := MeterPerAmpereToFloat(AQuantity, APrefixes);
  FactoredTol   := MeterPerAmpereToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMeterPerAmpereSymbol, cMeterPerAmperePrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsMeterPerAmpereSymbol, APrefixes);
  end;
end;

function MeterPerAmpereToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerAmpere then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function MeterPerAmpereToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerAmpere then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cMeterPerAmperePrefixes, cMeterPerAmpereExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cMeterPerAmperePrefixes, cMeterPerAmpereExponents);
{$ENDIF}
end;

function TeslaMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cTeslaMeter then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsTeslaMeterSymbol, cTeslaMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsTeslaMeterSymbol, cTeslaMeterPrefixes);
{$ENDIF}
end;

function TeslaMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cTeslaMeter then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cTeslaMeterPrefixes, cTeslaMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cTeslaMeterPrefixes, cTeslaMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsTeslaMeterSymbol, cTeslaMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsTeslaMeterSymbol, APrefixes);
end;

function TeslaMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := TeslaMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := TeslaMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsTeslaMeterSymbol, cTeslaMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsTeslaMeterSymbol, APrefixes);
  end;
end;

function TeslaMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cTeslaMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsTeslaMeterName, cTeslaMeterPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsTeslaMeterPluralName, cTeslaMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsTeslaMeterName, cTeslaMeterPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsTeslaMeterPluralName, cTeslaMeterPrefixes);
{$ENDIF}
end;

function TeslaMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cTeslaMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsTeslaMeterName, cTeslaMeterPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsTeslaMeterPluralName, cTeslaMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsTeslaMeterName, cTeslaMeterPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsTeslaMeterPluralName, cTeslaMeterPrefixes);
{$ENDIF}
end;

function TeslaMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := TeslaMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := TeslaMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsTeslaMeterSymbol, cTeslaMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsTeslaMeterSymbol, APrefixes);
  end;
end;

function TeslaMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cTeslaMeter then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function TeslaMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cTeslaMeter then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cTeslaMeterPrefixes, cTeslaMeterExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cTeslaMeterPrefixes, cTeslaMeterExponents);
{$ENDIF}
end;

function NewtonPerAmpereToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cTeslaMeter then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsNewtonPerAmpereSymbol, cNewtonPerAmperePrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsNewtonPerAmpereSymbol, cNewtonPerAmperePrefixes);
{$ENDIF}
end;

function NewtonPerAmpereToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cTeslaMeter then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cNewtonPerAmperePrefixes, cNewtonPerAmpereExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cNewtonPerAmperePrefixes, cNewtonPerAmpereExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonPerAmpereSymbol, cNewtonPerAmperePrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonPerAmpereSymbol, APrefixes);
end;

function NewtonPerAmpereToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := NewtonPerAmpereToFloat(AQuantity, APrefixes);
  FactoredTol   := NewtonPerAmpereToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonPerAmpereSymbol, cNewtonPerAmperePrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsNewtonPerAmpereSymbol, APrefixes);
  end;
end;

function NewtonPerAmpereToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cTeslaMeter then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cNewtonPerAmpereFactor) + ' ' + GetName(rsNewtonPerAmpereName, cNewtonPerAmperePrefixes)
  else
    result := FloatToStr(AValue.FValue / cNewtonPerAmpereFactor) + ' ' + GetName(rsNewtonPerAmperePluralName, cNewtonPerAmperePrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cNewtonPerAmpereFactor) + ' ' + GetName(rsNewtonPerAmpereName, cNewtonPerAmperePrefixes)
  else
    result := FloatToStr(AValue / cNewtonPerAmpereFactor) + ' ' + GetName(rsNewtonPerAmperePluralName, cNewtonPerAmperePrefixes);
  result := '';
{$ENDIF}
end;

function NewtonPerAmpereToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cTeslaMeter then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cNewtonPerAmpereFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNewtonPerAmpereName, cNewtonPerAmperePrefixes)
  else
    result := FloatToStrF(AValue.FValue / cNewtonPerAmpereFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNewtonPerAmperePluralName, cNewtonPerAmperePrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cNewtonPerAmpereFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNewtonPerAmpereName, cNewtonPerAmperePrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cNewtonPerAmpereFactor, rsNewtonPerAmperePluralName);
{$ENDIF}
end;

function NewtonPerAmpereToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cTeslaMeter then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function NewtonPerAmpereToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cTeslaMeter then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cNewtonPerAmperePrefixes, cNewtonPerAmpereExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cNewtonPerAmperePrefixes, cNewtonPerAmpereExponents);
{$ENDIF}
end;

function TeslaPerAmpereToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cTeslaPerAmpere then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsTeslaPerAmpereSymbol, cTeslaPerAmperePrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsTeslaPerAmpereSymbol, cTeslaPerAmperePrefixes);
{$ENDIF}
end;

function TeslaPerAmpereToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cTeslaPerAmpere then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cTeslaPerAmperePrefixes, cTeslaPerAmpereExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cTeslaPerAmperePrefixes, cTeslaPerAmpereExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsTeslaPerAmpereSymbol, cTeslaPerAmperePrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsTeslaPerAmpereSymbol, APrefixes);
end;

function TeslaPerAmpereToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := TeslaPerAmpereToFloat(AQuantity, APrefixes);
  FactoredTol   := TeslaPerAmpereToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsTeslaPerAmpereSymbol, cTeslaPerAmperePrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsTeslaPerAmpereSymbol, APrefixes);
  end;
end;

function TeslaPerAmpereToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cTeslaPerAmpere then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsTeslaPerAmpereName, cTeslaPerAmperePrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsTeslaPerAmperePluralName, cTeslaPerAmperePrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsTeslaPerAmpereName, cTeslaPerAmperePrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsTeslaPerAmperePluralName, cTeslaPerAmperePrefixes);
{$ENDIF}
end;

function TeslaPerAmpereToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cTeslaPerAmpere then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsTeslaPerAmpereName, cTeslaPerAmperePrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsTeslaPerAmperePluralName, cTeslaPerAmperePrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsTeslaPerAmpereName, cTeslaPerAmperePrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsTeslaPerAmperePluralName, cTeslaPerAmperePrefixes);
{$ENDIF}
end;

function TeslaPerAmpereToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := TeslaPerAmpereToFloat(AQuantity, APrefixes);
  FactoredTol   := TeslaPerAmpereToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsTeslaPerAmpereSymbol, cTeslaPerAmperePrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsTeslaPerAmpereSymbol, APrefixes);
  end;
end;

function TeslaPerAmpereToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cTeslaPerAmpere then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function TeslaPerAmpereToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cTeslaPerAmpere then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cTeslaPerAmperePrefixes, cTeslaPerAmpereExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cTeslaPerAmperePrefixes, cTeslaPerAmpereExponents);
{$ENDIF}
end;

function HenryPerMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHenryPerMeter then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsHenryPerMeterSymbol, cHenryPerMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsHenryPerMeterSymbol, cHenryPerMeterPrefixes);
{$ENDIF}
end;

function HenryPerMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHenryPerMeter then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cHenryPerMeterPrefixes, cHenryPerMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cHenryPerMeterPrefixes, cHenryPerMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsHenryPerMeterSymbol, cHenryPerMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsHenryPerMeterSymbol, APrefixes);
end;

function HenryPerMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := HenryPerMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := HenryPerMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsHenryPerMeterSymbol, cHenryPerMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsHenryPerMeterSymbol, APrefixes);
  end;
end;

function HenryPerMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHenryPerMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsHenryPerMeterName, cHenryPerMeterPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsHenryPerMeterPluralName, cHenryPerMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsHenryPerMeterName, cHenryPerMeterPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsHenryPerMeterPluralName, cHenryPerMeterPrefixes);
{$ENDIF}
end;

function HenryPerMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHenryPerMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsHenryPerMeterName, cHenryPerMeterPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsHenryPerMeterPluralName, cHenryPerMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsHenryPerMeterName, cHenryPerMeterPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsHenryPerMeterPluralName, cHenryPerMeterPrefixes);
{$ENDIF}
end;

function HenryPerMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := HenryPerMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := HenryPerMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsHenryPerMeterSymbol, cHenryPerMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsHenryPerMeterSymbol, APrefixes);
  end;
end;

function HenryPerMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHenryPerMeter then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function HenryPerMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHenryPerMeter then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cHenryPerMeterPrefixes, cHenryPerMeterExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cHenryPerMeterPrefixes, cHenryPerMeterExponents);
{$ENDIF}
end;

function TeslaMeterPerAmpereToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHenryPerMeter then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsTeslaMeterPerAmpereSymbol, cTeslaMeterPerAmperePrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsTeslaMeterPerAmpereSymbol, cTeslaMeterPerAmperePrefixes);
{$ENDIF}
end;

function TeslaMeterPerAmpereToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHenryPerMeter then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cTeslaMeterPerAmperePrefixes, cTeslaMeterPerAmpereExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cTeslaMeterPerAmperePrefixes, cTeslaMeterPerAmpereExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsTeslaMeterPerAmpereSymbol, cTeslaMeterPerAmperePrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsTeslaMeterPerAmpereSymbol, APrefixes);
end;

function TeslaMeterPerAmpereToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := TeslaMeterPerAmpereToFloat(AQuantity, APrefixes);
  FactoredTol   := TeslaMeterPerAmpereToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsTeslaMeterPerAmpereSymbol, cTeslaMeterPerAmperePrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsTeslaMeterPerAmpereSymbol, APrefixes);
  end;
end;

function TeslaMeterPerAmpereToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHenryPerMeter then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cTeslaMeterPerAmpereFactor) + ' ' + GetName(rsTeslaMeterPerAmpereName, cTeslaMeterPerAmperePrefixes)
  else
    result := FloatToStr(AValue.FValue / cTeslaMeterPerAmpereFactor) + ' ' + GetName(rsTeslaMeterPerAmperePluralName, cTeslaMeterPerAmperePrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cTeslaMeterPerAmpereFactor) + ' ' + GetName(rsTeslaMeterPerAmpereName, cTeslaMeterPerAmperePrefixes)
  else
    result := FloatToStr(AValue / cTeslaMeterPerAmpereFactor) + ' ' + GetName(rsTeslaMeterPerAmperePluralName, cTeslaMeterPerAmperePrefixes);
  result := '';
{$ENDIF}
end;

function TeslaMeterPerAmpereToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHenryPerMeter then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cTeslaMeterPerAmpereFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsTeslaMeterPerAmpereName, cTeslaMeterPerAmperePrefixes)
  else
    result := FloatToStrF(AValue.FValue / cTeslaMeterPerAmpereFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsTeslaMeterPerAmperePluralName, cTeslaMeterPerAmperePrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cTeslaMeterPerAmpereFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsTeslaMeterPerAmpereName, cTeslaMeterPerAmperePrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cTeslaMeterPerAmpereFactor, rsTeslaMeterPerAmperePluralName);
{$ENDIF}
end;

function TeslaMeterPerAmpereToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHenryPerMeter then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function TeslaMeterPerAmpereToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHenryPerMeter then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cTeslaMeterPerAmperePrefixes, cTeslaMeterPerAmpereExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cTeslaMeterPerAmperePrefixes, cTeslaMeterPerAmpereExponents);
{$ENDIF}
end;

function NewtonPerSquareAmpereToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHenryPerMeter then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsNewtonPerSquareAmpereSymbol, cNewtonPerSquareAmperePrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsNewtonPerSquareAmpereSymbol, cNewtonPerSquareAmperePrefixes);
{$ENDIF}
end;

function NewtonPerSquareAmpereToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHenryPerMeter then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cNewtonPerSquareAmperePrefixes, cNewtonPerSquareAmpereExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cNewtonPerSquareAmperePrefixes, cNewtonPerSquareAmpereExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonPerSquareAmpereSymbol, cNewtonPerSquareAmperePrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonPerSquareAmpereSymbol, APrefixes);
end;

function NewtonPerSquareAmpereToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := NewtonPerSquareAmpereToFloat(AQuantity, APrefixes);
  FactoredTol   := NewtonPerSquareAmpereToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonPerSquareAmpereSymbol, cNewtonPerSquareAmperePrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsNewtonPerSquareAmpereSymbol, APrefixes);
  end;
end;

function NewtonPerSquareAmpereToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHenryPerMeter then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cNewtonPerSquareAmpereFactor) + ' ' + GetName(rsNewtonPerSquareAmpereName, cNewtonPerSquareAmperePrefixes)
  else
    result := FloatToStr(AValue.FValue / cNewtonPerSquareAmpereFactor) + ' ' + GetName(rsNewtonPerSquareAmperePluralName, cNewtonPerSquareAmperePrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cNewtonPerSquareAmpereFactor) + ' ' + GetName(rsNewtonPerSquareAmpereName, cNewtonPerSquareAmperePrefixes)
  else
    result := FloatToStr(AValue / cNewtonPerSquareAmpereFactor) + ' ' + GetName(rsNewtonPerSquareAmperePluralName, cNewtonPerSquareAmperePrefixes);
  result := '';
{$ENDIF}
end;

function NewtonPerSquareAmpereToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHenryPerMeter then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cNewtonPerSquareAmpereFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNewtonPerSquareAmpereName, cNewtonPerSquareAmperePrefixes)
  else
    result := FloatToStrF(AValue.FValue / cNewtonPerSquareAmpereFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNewtonPerSquareAmperePluralName, cNewtonPerSquareAmperePrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cNewtonPerSquareAmpereFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsNewtonPerSquareAmpereName, cNewtonPerSquareAmperePrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cNewtonPerSquareAmpereFactor, rsNewtonPerSquareAmperePluralName);
{$ENDIF}
end;

function NewtonPerSquareAmpereToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHenryPerMeter then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function NewtonPerSquareAmpereToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHenryPerMeter then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cNewtonPerSquareAmperePrefixes, cNewtonPerSquareAmpereExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cNewtonPerSquareAmperePrefixes, cNewtonPerSquareAmpereExponents);
{$ENDIF}
end;

function RadianPerMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cRadianPerMeter then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsRadianPerMeterSymbol, cRadianPerMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsRadianPerMeterSymbol, cRadianPerMeterPrefixes);
{$ENDIF}
end;

function RadianPerMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cRadianPerMeter then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cRadianPerMeterPrefixes, cRadianPerMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cRadianPerMeterPrefixes, cRadianPerMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsRadianPerMeterSymbol, cRadianPerMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsRadianPerMeterSymbol, APrefixes);
end;

function RadianPerMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := RadianPerMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := RadianPerMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsRadianPerMeterSymbol, cRadianPerMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsRadianPerMeterSymbol, APrefixes);
  end;
end;

function RadianPerMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cRadianPerMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsRadianPerMeterName, cRadianPerMeterPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsRadianPerMeterPluralName, cRadianPerMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsRadianPerMeterName, cRadianPerMeterPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsRadianPerMeterPluralName, cRadianPerMeterPrefixes);
{$ENDIF}
end;

function RadianPerMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cRadianPerMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsRadianPerMeterName, cRadianPerMeterPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsRadianPerMeterPluralName, cRadianPerMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsRadianPerMeterName, cRadianPerMeterPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsRadianPerMeterPluralName, cRadianPerMeterPrefixes);
{$ENDIF}
end;

function RadianPerMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := RadianPerMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := RadianPerMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsRadianPerMeterSymbol, cRadianPerMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsRadianPerMeterSymbol, APrefixes);
  end;
end;

function RadianPerMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cRadianPerMeter then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function RadianPerMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cRadianPerMeter then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cRadianPerMeterPrefixes, cRadianPerMeterExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cRadianPerMeterPrefixes, cRadianPerMeterExponents);
{$ENDIF}
end;

function SquareKilogramPerSquareSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareKilogramPerSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsSquareKilogramPerSquareSecondSymbol, cSquareKilogramPerSquareSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsSquareKilogramPerSquareSecondSymbol, cSquareKilogramPerSquareSecondPrefixes);
{$ENDIF}
end;

function SquareKilogramPerSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareKilogramPerSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSquareKilogramPerSquareSecondPrefixes, cSquareKilogramPerSquareSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSquareKilogramPerSquareSecondPrefixes, cSquareKilogramPerSquareSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareKilogramPerSquareSecondSymbol, cSquareKilogramPerSquareSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareKilogramPerSquareSecondSymbol, APrefixes);
end;

function SquareKilogramPerSquareSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SquareKilogramPerSquareSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := SquareKilogramPerSquareSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareKilogramPerSquareSecondSymbol, cSquareKilogramPerSquareSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsSquareKilogramPerSquareSecondSymbol, APrefixes);
  end;
end;

function SquareKilogramPerSquareSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareKilogramPerSquareSecond then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsSquareKilogramPerSquareSecondName, cSquareKilogramPerSquareSecondPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsSquareKilogramPerSquareSecondPluralName, cSquareKilogramPerSquareSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsSquareKilogramPerSquareSecondName, cSquareKilogramPerSquareSecondPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsSquareKilogramPerSquareSecondPluralName, cSquareKilogramPerSquareSecondPrefixes);
{$ENDIF}
end;

function SquareKilogramPerSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareKilogramPerSquareSecond then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareKilogramPerSquareSecondName, cSquareKilogramPerSquareSecondPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareKilogramPerSquareSecondPluralName, cSquareKilogramPerSquareSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareKilogramPerSquareSecondName, cSquareKilogramPerSquareSecondPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareKilogramPerSquareSecondPluralName, cSquareKilogramPerSquareSecondPrefixes);
{$ENDIF}
end;

function SquareKilogramPerSquareSecondToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SquareKilogramPerSquareSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := SquareKilogramPerSquareSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareKilogramPerSquareSecondSymbol, cSquareKilogramPerSquareSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsSquareKilogramPerSquareSecondSymbol, APrefixes);
  end;
end;

function SquareKilogramPerSquareSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareKilogramPerSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function SquareKilogramPerSquareSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareKilogramPerSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cSquareKilogramPerSquareSecondPrefixes, cSquareKilogramPerSquareSecondExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cSquareKilogramPerSquareSecondPrefixes, cSquareKilogramPerSquareSecondExponents);
{$ENDIF}
end;

function SquareSecondPerSquareMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareSecondPerSquareMeter then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsSquareSecondPerSquareMeterSymbol, cSquareSecondPerSquareMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsSquareSecondPerSquareMeterSymbol, cSquareSecondPerSquareMeterPrefixes);
{$ENDIF}
end;

function SquareSecondPerSquareMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareSecondPerSquareMeter then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSquareSecondPerSquareMeterPrefixes, cSquareSecondPerSquareMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSquareSecondPerSquareMeterPrefixes, cSquareSecondPerSquareMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareSecondPerSquareMeterSymbol, cSquareSecondPerSquareMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareSecondPerSquareMeterSymbol, APrefixes);
end;

function SquareSecondPerSquareMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SquareSecondPerSquareMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := SquareSecondPerSquareMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareSecondPerSquareMeterSymbol, cSquareSecondPerSquareMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsSquareSecondPerSquareMeterSymbol, APrefixes);
  end;
end;

function SquareSecondPerSquareMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareSecondPerSquareMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsSquareSecondPerSquareMeterName, cSquareSecondPerSquareMeterPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsSquareSecondPerSquareMeterPluralName, cSquareSecondPerSquareMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsSquareSecondPerSquareMeterName, cSquareSecondPerSquareMeterPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsSquareSecondPerSquareMeterPluralName, cSquareSecondPerSquareMeterPrefixes);
{$ENDIF}
end;

function SquareSecondPerSquareMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareSecondPerSquareMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareSecondPerSquareMeterName, cSquareSecondPerSquareMeterPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareSecondPerSquareMeterPluralName, cSquareSecondPerSquareMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareSecondPerSquareMeterName, cSquareSecondPerSquareMeterPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareSecondPerSquareMeterPluralName, cSquareSecondPerSquareMeterPrefixes);
{$ENDIF}
end;

function SquareSecondPerSquareMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SquareSecondPerSquareMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := SquareSecondPerSquareMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareSecondPerSquareMeterSymbol, cSquareSecondPerSquareMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsSquareSecondPerSquareMeterSymbol, APrefixes);
  end;
end;

function SquareSecondPerSquareMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareSecondPerSquareMeter then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function SquareSecondPerSquareMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareSecondPerSquareMeter then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cSquareSecondPerSquareMeterPrefixes, cSquareSecondPerSquareMeterExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cSquareSecondPerSquareMeterPrefixes, cSquareSecondPerSquareMeterExponents);
{$ENDIF}
end;

function SquareJouleToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareJoule then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsSquareJouleSymbol, cSquareJoulePrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsSquareJouleSymbol, cSquareJoulePrefixes);
{$ENDIF}
end;

function SquareJouleToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareJoule then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSquareJoulePrefixes, cSquareJouleExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSquareJoulePrefixes, cSquareJouleExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareJouleSymbol, cSquareJoulePrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareJouleSymbol, APrefixes);
end;

function SquareJouleToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SquareJouleToFloat(AQuantity, APrefixes);
  FactoredTol   := SquareJouleToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareJouleSymbol, cSquareJoulePrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsSquareJouleSymbol, APrefixes);
  end;
end;

function SquareJouleToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareJoule then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsSquareJouleName, cSquareJoulePrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsSquareJoulePluralName, cSquareJoulePrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsSquareJouleName, cSquareJoulePrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsSquareJoulePluralName, cSquareJoulePrefixes);
{$ENDIF}
end;

function SquareJouleToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareJoule then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareJouleName, cSquareJoulePrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareJoulePluralName, cSquareJoulePrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareJouleName, cSquareJoulePrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareJoulePluralName, cSquareJoulePrefixes);
{$ENDIF}
end;

function SquareJouleToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SquareJouleToFloat(AQuantity, APrefixes);
  FactoredTol   := SquareJouleToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareJouleSymbol, cSquareJoulePrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsSquareJouleSymbol, APrefixes);
  end;
end;

function SquareJouleToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareJoule then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function SquareJouleToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareJoule then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cSquareJoulePrefixes, cSquareJouleExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cSquareJoulePrefixes, cSquareJouleExponents);
{$ENDIF}
end;

function JouleSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsJouleSecondSymbol, cJouleSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsJouleSecondSymbol, cJouleSecondPrefixes);
{$ENDIF}
end;

function JouleSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cJouleSecondPrefixes, cJouleSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cJouleSecondPrefixes, cJouleSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsJouleSecondSymbol, cJouleSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsJouleSecondSymbol, APrefixes);
end;

function JouleSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := JouleSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := JouleSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsJouleSecondSymbol, cJouleSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsJouleSecondSymbol, APrefixes);
  end;
end;

function JouleSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cJouleSecondFactor) + ' ' + GetName(rsJouleSecondName, cJouleSecondPrefixes)
  else
    result := FloatToStr(AValue.FValue / cJouleSecondFactor) + ' ' + GetName(rsJouleSecondPluralName, cJouleSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cJouleSecondFactor) + ' ' + GetName(rsJouleSecondName, cJouleSecondPrefixes)
  else
    result := FloatToStr(AValue / cJouleSecondFactor) + ' ' + GetName(rsJouleSecondPluralName, cJouleSecondPrefixes);
  result := '';
{$ENDIF}
end;

function JouleSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cJouleSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsJouleSecondName, cJouleSecondPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cJouleSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsJouleSecondPluralName, cJouleSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cJouleSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsJouleSecondName, cJouleSecondPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cJouleSecondFactor, rsJouleSecondPluralName);
{$ENDIF}
end;

function JouleSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function JouleSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cJouleSecondPrefixes, cJouleSecondExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cJouleSecondPrefixes, cJouleSecondExponents);
{$ENDIF}
end;

function JoulePerHertzToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsJoulePerHertzSymbol, cJoulePerHertzPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsJoulePerHertzSymbol, cJoulePerHertzPrefixes);
{$ENDIF}
end;

function JoulePerHertzToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cJoulePerHertzPrefixes, cJoulePerHertzExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cJoulePerHertzPrefixes, cJoulePerHertzExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsJoulePerHertzSymbol, cJoulePerHertzPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsJoulePerHertzSymbol, APrefixes);
end;

function JoulePerHertzToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := JoulePerHertzToFloat(AQuantity, APrefixes);
  FactoredTol   := JoulePerHertzToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsJoulePerHertzSymbol, cJoulePerHertzPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsJoulePerHertzSymbol, APrefixes);
  end;
end;

function JoulePerHertzToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cJoulePerHertzFactor) + ' ' + GetName(rsJoulePerHertzName, cJoulePerHertzPrefixes)
  else
    result := FloatToStr(AValue.FValue / cJoulePerHertzFactor) + ' ' + GetName(rsJoulePerHertzPluralName, cJoulePerHertzPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cJoulePerHertzFactor) + ' ' + GetName(rsJoulePerHertzName, cJoulePerHertzPrefixes)
  else
    result := FloatToStr(AValue / cJoulePerHertzFactor) + ' ' + GetName(rsJoulePerHertzPluralName, cJoulePerHertzPrefixes);
  result := '';
{$ENDIF}
end;

function JoulePerHertzToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cJoulePerHertzFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsJoulePerHertzName, cJoulePerHertzPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cJoulePerHertzFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsJoulePerHertzPluralName, cJoulePerHertzPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cJoulePerHertzFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsJoulePerHertzName, cJoulePerHertzPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cJoulePerHertzFactor, rsJoulePerHertzPluralName);
{$ENDIF}
end;

function JoulePerHertzToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function JoulePerHertzToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cJoulePerHertzPrefixes, cJoulePerHertzExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cJoulePerHertzPrefixes, cJoulePerHertzExponents);
{$ENDIF}
end;

function ElectronvoltSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue / cElectronvoltSecondFactor) + ' ' + GetSymbol(rsElectronvoltSecondSymbol, cElectronvoltSecondPrefixes);
{$ENDIF}
  result := FloatToStr(AValue / cElectronvoltSecondFactor) + ' ' + GetSymbol(rsElectronvoltSecondSymbol, cElectronvoltSecondPrefixes);
end;

function ElectronvoltSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue / cElectronvoltSecondFactor, APrefixes, cElectronvoltSecondPrefixes, cElectronvoltSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue / cElectronvoltSecondFactor, APrefixes, cElectronvoltSecondPrefixes, cElectronvoltSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsElectronvoltSecondSymbol, cElectronvoltSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsElectronvoltSecondSymbol, APrefixes);
end;

function cElectronvoltSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := ElectronvoltSecondToFloat(AQuantity / cElectronvoltSecondFactor, APrefixes);
  FactoredTol   := ElectronvoltSecondToFloat(ATolerance / cElectronvoltSecondFactor, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsElectronvoltSecondSymbol, cElectronvoltSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsElectronvoltSecondSymbol, APrefixes);
  end;
end;

function ElectronvoltSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cElectronvoltSecondFactor) + ' ' + GetName(rsElectronvoltSecondName, cElectronvoltSecondPrefixes)
  else
    result := FloatToStr(AValue.FValue / cElectronvoltSecondFactor) + ' ' + GetName(rsElectronvoltSecondPluralName, cElectronvoltSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cElectronvoltSecondFactor) + ' ' + GetName(rsElectronvoltSecondName, cElectronvoltSecondPrefixes)
  else
    result := FloatToStr(AValue / cElectronvoltSecondFactor) + ' ' + GetName(rsElectronvoltSecondPluralName, cElectronvoltSecondPrefixes);
  result := '';
{$ENDIF}
end;

function ElectronvoltSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cElectronvoltSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsElectronvoltSecondName, cElectronvoltSecondPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cElectronvoltSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsElectronvoltSecondPluralName, cElectronvoltSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cElectronvoltSecondFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsElectronvoltSecondName, cElectronvoltSecondPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cElectronvoltSecondFactor, rsElectronvoltSecondPluralName);
{$ENDIF}
end;

function ElectronvoltSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue * cElectronvoltSecondFactor;
{$ELSE}
  result := AValue * cElectronvoltSecondFactor;
{$ENDIF}
end;

function ElectronvoltSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue * cElectronvoltSecondFactor, APrefixes, cElectronvoltSecondPrefixes, cElectronvoltSecondExponents);
{$ELSE}
  result := GetValue(AValue * cElectronvoltSecondFactor, APrefixes, cElectronvoltSecondPrefixes, cElectronvoltSecondExponents);
{$ENDIF}
end;

function ElectronvoltMeterPerSpeedOfLightToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue / cElectronvoltMeterPerSpeedOfLightFactor) + ' ' + GetSymbol(rsElectronvoltMeterPerSpeedOfLightSymbol, cElectronvoltMeterPerSpeedOfLightPrefixes);
{$ENDIF}
  result := FloatToStr(AValue / cElectronvoltMeterPerSpeedOfLightFactor) + ' ' + GetSymbol(rsElectronvoltMeterPerSpeedOfLightSymbol, cElectronvoltMeterPerSpeedOfLightPrefixes);
end;

function ElectronvoltMeterPerSpeedOfLightToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue / cElectronvoltMeterPerSpeedOfLightFactor, APrefixes, cElectronvoltMeterPerSpeedOfLightPrefixes, cElectronvoltMeterPerSpeedOfLightExponents);
{$ELSE}
  FactoredValue := GetValue(AValue / cElectronvoltMeterPerSpeedOfLightFactor, APrefixes, cElectronvoltMeterPerSpeedOfLightPrefixes, cElectronvoltMeterPerSpeedOfLightExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsElectronvoltMeterPerSpeedOfLightSymbol, cElectronvoltMeterPerSpeedOfLightPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsElectronvoltMeterPerSpeedOfLightSymbol, APrefixes);
end;

function cElectronvoltMeterPerSpeedOfLightToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := ElectronvoltMeterPerSpeedOfLightToFloat(AQuantity / cElectronvoltMeterPerSpeedOfLightFactor, APrefixes);
  FactoredTol   := ElectronvoltMeterPerSpeedOfLightToFloat(ATolerance / cElectronvoltMeterPerSpeedOfLightFactor, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsElectronvoltMeterPerSpeedOfLightSymbol, cElectronvoltMeterPerSpeedOfLightPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsElectronvoltMeterPerSpeedOfLightSymbol, APrefixes);
  end;
end;

function ElectronvoltMeterPerSpeedOfLightToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cElectronvoltMeterPerSpeedOfLightFactor) + ' ' + GetName(rsElectronvoltMeterPerSpeedOfLightName, cElectronvoltMeterPerSpeedOfLightPrefixes)
  else
    result := FloatToStr(AValue.FValue / cElectronvoltMeterPerSpeedOfLightFactor) + ' ' + GetName(rsElectronvoltMeterPerSpeedOfLightPluralName, cElectronvoltMeterPerSpeedOfLightPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cElectronvoltMeterPerSpeedOfLightFactor) + ' ' + GetName(rsElectronvoltMeterPerSpeedOfLightName, cElectronvoltMeterPerSpeedOfLightPrefixes)
  else
    result := FloatToStr(AValue / cElectronvoltMeterPerSpeedOfLightFactor) + ' ' + GetName(rsElectronvoltMeterPerSpeedOfLightPluralName, cElectronvoltMeterPerSpeedOfLightPrefixes);
  result := '';
{$ENDIF}
end;

function ElectronvoltMeterPerSpeedOfLightToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cElectronvoltMeterPerSpeedOfLightFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsElectronvoltMeterPerSpeedOfLightName, cElectronvoltMeterPerSpeedOfLightPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cElectronvoltMeterPerSpeedOfLightFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsElectronvoltMeterPerSpeedOfLightPluralName, cElectronvoltMeterPerSpeedOfLightPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cElectronvoltMeterPerSpeedOfLightFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsElectronvoltMeterPerSpeedOfLightName, cElectronvoltMeterPerSpeedOfLightPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cElectronvoltMeterPerSpeedOfLightFactor, rsElectronvoltMeterPerSpeedOfLightPluralName);
{$ENDIF}
end;

function ElectronvoltMeterPerSpeedOfLightToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue * cElectronvoltMeterPerSpeedOfLightFactor;
{$ELSE}
  result := AValue * cElectronvoltMeterPerSpeedOfLightFactor;
{$ENDIF}
end;

function ElectronvoltMeterPerSpeedOfLightToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareMeterPerSecond then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue * cElectronvoltMeterPerSpeedOfLightFactor, APrefixes, cElectronvoltMeterPerSpeedOfLightPrefixes, cElectronvoltMeterPerSpeedOfLightExponents);
{$ELSE}
  result := GetValue(AValue * cElectronvoltMeterPerSpeedOfLightFactor, APrefixes, cElectronvoltMeterPerSpeedOfLightPrefixes, cElectronvoltMeterPerSpeedOfLightExponents);
{$ENDIF}
end;

function SquareJouleSquareSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareJouleSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsSquareJouleSquareSecondSymbol, cSquareJouleSquareSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsSquareJouleSquareSecondSymbol, cSquareJouleSquareSecondPrefixes);
{$ENDIF}
end;

function SquareJouleSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareJouleSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSquareJouleSquareSecondPrefixes, cSquareJouleSquareSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSquareJouleSquareSecondPrefixes, cSquareJouleSquareSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareJouleSquareSecondSymbol, cSquareJouleSquareSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareJouleSquareSecondSymbol, APrefixes);
end;

function SquareJouleSquareSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SquareJouleSquareSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := SquareJouleSquareSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareJouleSquareSecondSymbol, cSquareJouleSquareSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsSquareJouleSquareSecondSymbol, APrefixes);
  end;
end;

function SquareJouleSquareSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareJouleSquareSecond then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsSquareJouleSquareSecondName, cSquareJouleSquareSecondPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsSquareJouleSquareSecondPluralName, cSquareJouleSquareSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsSquareJouleSquareSecondName, cSquareJouleSquareSecondPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsSquareJouleSquareSecondPluralName, cSquareJouleSquareSecondPrefixes);
{$ENDIF}
end;

function SquareJouleSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareJouleSquareSecond then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareJouleSquareSecondName, cSquareJouleSquareSecondPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareJouleSquareSecondPluralName, cSquareJouleSquareSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareJouleSquareSecondName, cSquareJouleSquareSecondPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareJouleSquareSecondPluralName, cSquareJouleSquareSecondPrefixes);
{$ENDIF}
end;

function SquareJouleSquareSecondToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SquareJouleSquareSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := SquareJouleSquareSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareJouleSquareSecondSymbol, cSquareJouleSquareSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsSquareJouleSquareSecondSymbol, APrefixes);
  end;
end;

function SquareJouleSquareSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareJouleSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function SquareJouleSquareSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareJouleSquareSecond then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cSquareJouleSquareSecondPrefixes, cSquareJouleSquareSecondExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cSquareJouleSquareSecondPrefixes, cSquareJouleSquareSecondExponents);
{$ENDIF}
end;

function CoulombPerKilogramToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulombPerKilogram then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsCoulombPerKilogramSymbol, cCoulombPerKilogramPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsCoulombPerKilogramSymbol, cCoulombPerKilogramPrefixes);
{$ENDIF}
end;

function CoulombPerKilogramToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulombPerKilogram then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cCoulombPerKilogramPrefixes, cCoulombPerKilogramExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cCoulombPerKilogramPrefixes, cCoulombPerKilogramExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCoulombPerKilogramSymbol, cCoulombPerKilogramPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCoulombPerKilogramSymbol, APrefixes);
end;

function CoulombPerKilogramToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := CoulombPerKilogramToFloat(AQuantity, APrefixes);
  FactoredTol   := CoulombPerKilogramToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCoulombPerKilogramSymbol, cCoulombPerKilogramPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsCoulombPerKilogramSymbol, APrefixes);
  end;
end;

function CoulombPerKilogramToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulombPerKilogram then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsCoulombPerKilogramName, cCoulombPerKilogramPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsCoulombPerKilogramPluralName, cCoulombPerKilogramPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsCoulombPerKilogramName, cCoulombPerKilogramPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsCoulombPerKilogramPluralName, cCoulombPerKilogramPrefixes);
{$ENDIF}
end;

function CoulombPerKilogramToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulombPerKilogram then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCoulombPerKilogramName, cCoulombPerKilogramPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCoulombPerKilogramPluralName, cCoulombPerKilogramPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCoulombPerKilogramName, cCoulombPerKilogramPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCoulombPerKilogramPluralName, cCoulombPerKilogramPrefixes);
{$ENDIF}
end;

function CoulombPerKilogramToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := CoulombPerKilogramToFloat(AQuantity, APrefixes);
  FactoredTol   := CoulombPerKilogramToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCoulombPerKilogramSymbol, cCoulombPerKilogramPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsCoulombPerKilogramSymbol, APrefixes);
  end;
end;

function CoulombPerKilogramToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulombPerKilogram then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function CoulombPerKilogramToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulombPerKilogram then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cCoulombPerKilogramPrefixes, cCoulombPerKilogramExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cCoulombPerKilogramPrefixes, cCoulombPerKilogramExponents);
{$ENDIF}
end;

function SquareMeterAmpereToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterAmpere then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsSquareMeterAmpereSymbol, cSquareMeterAmperePrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsSquareMeterAmpereSymbol, cSquareMeterAmperePrefixes);
{$ENDIF}
end;

function SquareMeterAmpereToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterAmpere then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSquareMeterAmperePrefixes, cSquareMeterAmpereExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSquareMeterAmperePrefixes, cSquareMeterAmpereExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareMeterAmpereSymbol, cSquareMeterAmperePrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareMeterAmpereSymbol, APrefixes);
end;

function SquareMeterAmpereToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SquareMeterAmpereToFloat(AQuantity, APrefixes);
  FactoredTol   := SquareMeterAmpereToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareMeterAmpereSymbol, cSquareMeterAmperePrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsSquareMeterAmpereSymbol, APrefixes);
  end;
end;

function SquareMeterAmpereToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterAmpere then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsSquareMeterAmpereName, cSquareMeterAmperePrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsSquareMeterAmperePluralName, cSquareMeterAmperePrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsSquareMeterAmpereName, cSquareMeterAmperePrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsSquareMeterAmperePluralName, cSquareMeterAmperePrefixes);
{$ENDIF}
end;

function SquareMeterAmpereToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterAmpere then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareMeterAmpereName, cSquareMeterAmperePrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareMeterAmperePluralName, cSquareMeterAmperePrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareMeterAmpereName, cSquareMeterAmperePrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareMeterAmperePluralName, cSquareMeterAmperePrefixes);
{$ENDIF}
end;

function SquareMeterAmpereToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SquareMeterAmpereToFloat(AQuantity, APrefixes);
  FactoredTol   := SquareMeterAmpereToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareMeterAmpereSymbol, cSquareMeterAmperePrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsSquareMeterAmpereSymbol, APrefixes);
  end;
end;

function SquareMeterAmpereToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterAmpere then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function SquareMeterAmpereToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterAmpere then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cSquareMeterAmperePrefixes, cSquareMeterAmpereExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cSquareMeterAmperePrefixes, cSquareMeterAmpereExponents);
{$ENDIF}
end;

function JoulePerTeslaToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterAmpere then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsJoulePerTeslaSymbol, cJoulePerTeslaPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsJoulePerTeslaSymbol, cJoulePerTeslaPrefixes);
{$ENDIF}
end;

function JoulePerTeslaToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterAmpere then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cJoulePerTeslaPrefixes, cJoulePerTeslaExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cJoulePerTeslaPrefixes, cJoulePerTeslaExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsJoulePerTeslaSymbol, cJoulePerTeslaPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsJoulePerTeslaSymbol, APrefixes);
end;

function JoulePerTeslaToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := JoulePerTeslaToFloat(AQuantity, APrefixes);
  FactoredTol   := JoulePerTeslaToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsJoulePerTeslaSymbol, cJoulePerTeslaPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsJoulePerTeslaSymbol, APrefixes);
  end;
end;

function JoulePerTeslaToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterAmpere then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue / cJoulePerTeslaFactor) + ' ' + GetName(rsJoulePerTeslaName, cJoulePerTeslaPrefixes)
  else
    result := FloatToStr(AValue.FValue / cJoulePerTeslaFactor) + ' ' + GetName(rsJoulePerTeslaPluralName, cJoulePerTeslaPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue / cJoulePerTeslaFactor) + ' ' + GetName(rsJoulePerTeslaName, cJoulePerTeslaPrefixes)
  else
    result := FloatToStr(AValue / cJoulePerTeslaFactor) + ' ' + GetName(rsJoulePerTeslaPluralName, cJoulePerTeslaPrefixes);
  result := '';
{$ENDIF}
end;

function JoulePerTeslaToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterAmpere then
    raise Exception.Create('Wrong units of measurements');
  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue / cJoulePerTeslaFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsJoulePerTeslaName, cJoulePerTeslaPrefixes)
  else
    result := FloatToStrF(AValue.FValue / cJoulePerTeslaFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsJoulePerTeslaPluralName, cJoulePerTeslaPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue / cJoulePerTeslaFactor, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsJoulePerTeslaName, cJoulePerTeslaPrefixes)
  else
    result := FloatToStrF(AValue /  ffGeneral, APrecision, ADigits) + ' ' + GetName(cJoulePerTeslaFactor, rsJoulePerTeslaPluralName);
{$ENDIF}
end;

function JoulePerTeslaToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterAmpere then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function JoulePerTeslaToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterAmpere then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cJoulePerTeslaPrefixes, cJoulePerTeslaExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cJoulePerTeslaPrefixes, cJoulePerTeslaExponents);
{$ENDIF}
end;

function LumenPerWattToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLumenPerWatt then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsLumenPerWattSymbol, cLumenPerWattPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsLumenPerWattSymbol, cLumenPerWattPrefixes);
{$ENDIF}
end;

function LumenPerWattToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLumenPerWatt then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cLumenPerWattPrefixes, cLumenPerWattExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cLumenPerWattPrefixes, cLumenPerWattExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsLumenPerWattSymbol, cLumenPerWattPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsLumenPerWattSymbol, APrefixes);
end;

function LumenPerWattToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := LumenPerWattToFloat(AQuantity, APrefixes);
  FactoredTol   := LumenPerWattToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsLumenPerWattSymbol, cLumenPerWattPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsLumenPerWattSymbol, APrefixes);
  end;
end;

function LumenPerWattToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLumenPerWatt then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsLumenPerWattName, cLumenPerWattPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsLumenPerWattPluralName, cLumenPerWattPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsLumenPerWattName, cLumenPerWattPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsLumenPerWattPluralName, cLumenPerWattPrefixes);
{$ENDIF}
end;

function LumenPerWattToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLumenPerWatt then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsLumenPerWattName, cLumenPerWattPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsLumenPerWattPluralName, cLumenPerWattPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsLumenPerWattName, cLumenPerWattPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsLumenPerWattPluralName, cLumenPerWattPrefixes);
{$ENDIF}
end;

function LumenPerWattToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := LumenPerWattToFloat(AQuantity, APrefixes);
  FactoredTol   := LumenPerWattToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsLumenPerWattSymbol, cLumenPerWattPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsLumenPerWattSymbol, APrefixes);
  end;
end;

function LumenPerWattToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLumenPerWatt then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function LumenPerWattToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLumenPerWatt then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cLumenPerWattPrefixes, cLumenPerWattExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cLumenPerWattPrefixes, cLumenPerWattExponents);
{$ENDIF}
end;

function ReciprocalMoleToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalMole then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsReciprocalMoleSymbol, cReciprocalMolePrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsReciprocalMoleSymbol, cReciprocalMolePrefixes);
{$ENDIF}
end;

function ReciprocalMoleToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalMole then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cReciprocalMolePrefixes, cReciprocalMoleExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cReciprocalMolePrefixes, cReciprocalMoleExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsReciprocalMoleSymbol, cReciprocalMolePrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsReciprocalMoleSymbol, APrefixes);
end;

function ReciprocalMoleToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := ReciprocalMoleToFloat(AQuantity, APrefixes);
  FactoredTol   := ReciprocalMoleToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsReciprocalMoleSymbol, cReciprocalMolePrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsReciprocalMoleSymbol, APrefixes);
  end;
end;

function ReciprocalMoleToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalMole then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsReciprocalMoleName, cReciprocalMolePrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsReciprocalMolePluralName, cReciprocalMolePrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsReciprocalMoleName, cReciprocalMolePrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsReciprocalMolePluralName, cReciprocalMolePrefixes);
{$ENDIF}
end;

function ReciprocalMoleToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalMole then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsReciprocalMoleName, cReciprocalMolePrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsReciprocalMolePluralName, cReciprocalMolePrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsReciprocalMoleName, cReciprocalMolePrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsReciprocalMolePluralName, cReciprocalMolePrefixes);
{$ENDIF}
end;

function ReciprocalMoleToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := ReciprocalMoleToFloat(AQuantity, APrefixes);
  FactoredTol   := ReciprocalMoleToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsReciprocalMoleSymbol, cReciprocalMolePrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsReciprocalMoleSymbol, APrefixes);
  end;
end;

function ReciprocalMoleToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalMole then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function ReciprocalMoleToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalMole then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cReciprocalMolePrefixes, cReciprocalMoleExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cReciprocalMolePrefixes, cReciprocalMoleExponents);
{$ENDIF}
end;

function AmperePerSquareMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cAmperePerSquareMeter then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsAmperePerSquareMeterSymbol, cAmperePerSquareMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsAmperePerSquareMeterSymbol, cAmperePerSquareMeterPrefixes);
{$ENDIF}
end;

function AmperePerSquareMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cAmperePerSquareMeter then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cAmperePerSquareMeterPrefixes, cAmperePerSquareMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cAmperePerSquareMeterPrefixes, cAmperePerSquareMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsAmperePerSquareMeterSymbol, cAmperePerSquareMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsAmperePerSquareMeterSymbol, APrefixes);
end;

function AmperePerSquareMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := AmperePerSquareMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := AmperePerSquareMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsAmperePerSquareMeterSymbol, cAmperePerSquareMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsAmperePerSquareMeterSymbol, APrefixes);
  end;
end;

function AmperePerSquareMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cAmperePerSquareMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsAmperePerSquareMeterName, cAmperePerSquareMeterPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsAmperePerSquareMeterPluralName, cAmperePerSquareMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsAmperePerSquareMeterName, cAmperePerSquareMeterPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsAmperePerSquareMeterPluralName, cAmperePerSquareMeterPrefixes);
{$ENDIF}
end;

function AmperePerSquareMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cAmperePerSquareMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsAmperePerSquareMeterName, cAmperePerSquareMeterPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsAmperePerSquareMeterPluralName, cAmperePerSquareMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsAmperePerSquareMeterName, cAmperePerSquareMeterPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsAmperePerSquareMeterPluralName, cAmperePerSquareMeterPrefixes);
{$ENDIF}
end;

function AmperePerSquareMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := AmperePerSquareMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := AmperePerSquareMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsAmperePerSquareMeterSymbol, cAmperePerSquareMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsAmperePerSquareMeterSymbol, APrefixes);
  end;
end;

function AmperePerSquareMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cAmperePerSquareMeter then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function AmperePerSquareMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cAmperePerSquareMeter then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cAmperePerSquareMeterPrefixes, cAmperePerSquareMeterExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cAmperePerSquareMeterPrefixes, cAmperePerSquareMeterExponents);
{$ENDIF}
end;

function MolePerCubicMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMolePerCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsMolePerCubicMeterSymbol, cMolePerCubicMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsMolePerCubicMeterSymbol, cMolePerCubicMeterPrefixes);
{$ENDIF}
end;

function MolePerCubicMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMolePerCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cMolePerCubicMeterPrefixes, cMolePerCubicMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cMolePerCubicMeterPrefixes, cMolePerCubicMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMolePerCubicMeterSymbol, cMolePerCubicMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMolePerCubicMeterSymbol, APrefixes);
end;

function MolePerCubicMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := MolePerCubicMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := MolePerCubicMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMolePerCubicMeterSymbol, cMolePerCubicMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsMolePerCubicMeterSymbol, APrefixes);
  end;
end;

function MolePerCubicMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMolePerCubicMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsMolePerCubicMeterName, cMolePerCubicMeterPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsMolePerCubicMeterPluralName, cMolePerCubicMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsMolePerCubicMeterName, cMolePerCubicMeterPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsMolePerCubicMeterPluralName, cMolePerCubicMeterPrefixes);
{$ENDIF}
end;

function MolePerCubicMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMolePerCubicMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMolePerCubicMeterName, cMolePerCubicMeterPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMolePerCubicMeterPluralName, cMolePerCubicMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMolePerCubicMeterName, cMolePerCubicMeterPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMolePerCubicMeterPluralName, cMolePerCubicMeterPrefixes);
{$ENDIF}
end;

function MolePerCubicMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := MolePerCubicMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := MolePerCubicMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMolePerCubicMeterSymbol, cMolePerCubicMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsMolePerCubicMeterSymbol, APrefixes);
  end;
end;

function MolePerCubicMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMolePerCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function MolePerCubicMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMolePerCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cMolePerCubicMeterPrefixes, cMolePerCubicMeterExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cMolePerCubicMeterPrefixes, cMolePerCubicMeterExponents);
{$ENDIF}
end;

function CandelaPerSquareMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCandelaPerSquareMeter then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsCandelaPerSquareMeterSymbol, cCandelaPerSquareMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsCandelaPerSquareMeterSymbol, cCandelaPerSquareMeterPrefixes);
{$ENDIF}
end;

function CandelaPerSquareMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCandelaPerSquareMeter then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cCandelaPerSquareMeterPrefixes, cCandelaPerSquareMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cCandelaPerSquareMeterPrefixes, cCandelaPerSquareMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCandelaPerSquareMeterSymbol, cCandelaPerSquareMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCandelaPerSquareMeterSymbol, APrefixes);
end;

function CandelaPerSquareMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := CandelaPerSquareMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := CandelaPerSquareMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCandelaPerSquareMeterSymbol, cCandelaPerSquareMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsCandelaPerSquareMeterSymbol, APrefixes);
  end;
end;

function CandelaPerSquareMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCandelaPerSquareMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsCandelaPerSquareMeterName, cCandelaPerSquareMeterPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsCandelaPerSquareMeterPluralName, cCandelaPerSquareMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsCandelaPerSquareMeterName, cCandelaPerSquareMeterPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsCandelaPerSquareMeterPluralName, cCandelaPerSquareMeterPrefixes);
{$ENDIF}
end;

function CandelaPerSquareMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCandelaPerSquareMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCandelaPerSquareMeterName, cCandelaPerSquareMeterPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCandelaPerSquareMeterPluralName, cCandelaPerSquareMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCandelaPerSquareMeterName, cCandelaPerSquareMeterPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCandelaPerSquareMeterPluralName, cCandelaPerSquareMeterPrefixes);
{$ENDIF}
end;

function CandelaPerSquareMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := CandelaPerSquareMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := CandelaPerSquareMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCandelaPerSquareMeterSymbol, cCandelaPerSquareMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsCandelaPerSquareMeterSymbol, APrefixes);
  end;
end;

function CandelaPerSquareMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCandelaPerSquareMeter then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function CandelaPerSquareMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCandelaPerSquareMeter then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cCandelaPerSquareMeterPrefixes, cCandelaPerSquareMeterExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cCandelaPerSquareMeterPrefixes, cCandelaPerSquareMeterExponents);
{$ENDIF}
end;

function CoulombPerCubicMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulombPerCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsCoulombPerCubicMeterSymbol, cCoulombPerCubicMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsCoulombPerCubicMeterSymbol, cCoulombPerCubicMeterPrefixes);
{$ENDIF}
end;

function CoulombPerCubicMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulombPerCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cCoulombPerCubicMeterPrefixes, cCoulombPerCubicMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cCoulombPerCubicMeterPrefixes, cCoulombPerCubicMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCoulombPerCubicMeterSymbol, cCoulombPerCubicMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCoulombPerCubicMeterSymbol, APrefixes);
end;

function CoulombPerCubicMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := CoulombPerCubicMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := CoulombPerCubicMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCoulombPerCubicMeterSymbol, cCoulombPerCubicMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsCoulombPerCubicMeterSymbol, APrefixes);
  end;
end;

function CoulombPerCubicMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulombPerCubicMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsCoulombPerCubicMeterName, cCoulombPerCubicMeterPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsCoulombPerCubicMeterPluralName, cCoulombPerCubicMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsCoulombPerCubicMeterName, cCoulombPerCubicMeterPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsCoulombPerCubicMeterPluralName, cCoulombPerCubicMeterPrefixes);
{$ENDIF}
end;

function CoulombPerCubicMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulombPerCubicMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCoulombPerCubicMeterName, cCoulombPerCubicMeterPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCoulombPerCubicMeterPluralName, cCoulombPerCubicMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCoulombPerCubicMeterName, cCoulombPerCubicMeterPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCoulombPerCubicMeterPluralName, cCoulombPerCubicMeterPrefixes);
{$ENDIF}
end;

function CoulombPerCubicMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := CoulombPerCubicMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := CoulombPerCubicMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCoulombPerCubicMeterSymbol, cCoulombPerCubicMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsCoulombPerCubicMeterSymbol, APrefixes);
  end;
end;

function CoulombPerCubicMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulombPerCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function CoulombPerCubicMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulombPerCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cCoulombPerCubicMeterPrefixes, cCoulombPerCubicMeterExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cCoulombPerCubicMeterPrefixes, cCoulombPerCubicMeterExponents);
{$ENDIF}
end;

function GrayPerSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cGrayPerSecond then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsGrayPerSecondSymbol, cGrayPerSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsGrayPerSecondSymbol, cGrayPerSecondPrefixes);
{$ENDIF}
end;

function GrayPerSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cGrayPerSecond then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cGrayPerSecondPrefixes, cGrayPerSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cGrayPerSecondPrefixes, cGrayPerSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsGrayPerSecondSymbol, cGrayPerSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsGrayPerSecondSymbol, APrefixes);
end;

function GrayPerSecondToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := GrayPerSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := GrayPerSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsGrayPerSecondSymbol, cGrayPerSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsGrayPerSecondSymbol, APrefixes);
  end;
end;

function GrayPerSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cGrayPerSecond then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsGrayPerSecondName, cGrayPerSecondPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsGrayPerSecondPluralName, cGrayPerSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsGrayPerSecondName, cGrayPerSecondPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsGrayPerSecondPluralName, cGrayPerSecondPrefixes);
{$ENDIF}
end;

function GrayPerSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cGrayPerSecond then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsGrayPerSecondName, cGrayPerSecondPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsGrayPerSecondPluralName, cGrayPerSecondPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsGrayPerSecondName, cGrayPerSecondPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsGrayPerSecondPluralName, cGrayPerSecondPrefixes);
{$ENDIF}
end;

function GrayPerSecondToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := GrayPerSecondToFloat(AQuantity, APrefixes);
  FactoredTol   := GrayPerSecondToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsGrayPerSecondSymbol, cGrayPerSecondPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsGrayPerSecondSymbol, APrefixes);
  end;
end;

function GrayPerSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cGrayPerSecond then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function GrayPerSecondToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cGrayPerSecond then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cGrayPerSecondPrefixes, cGrayPerSecondExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cGrayPerSecondPrefixes, cGrayPerSecondExponents);
{$ENDIF}
end;

function SteradianHertzToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSteradianHertz then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsSteradianHertzSymbol, cSteradianHertzPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsSteradianHertzSymbol, cSteradianHertzPrefixes);
{$ENDIF}
end;

function SteradianHertzToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSteradianHertz then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSteradianHertzPrefixes, cSteradianHertzExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSteradianHertzPrefixes, cSteradianHertzExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSteradianHertzSymbol, cSteradianHertzPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSteradianHertzSymbol, APrefixes);
end;

function SteradianHertzToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SteradianHertzToFloat(AQuantity, APrefixes);
  FactoredTol   := SteradianHertzToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSteradianHertzSymbol, cSteradianHertzPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsSteradianHertzSymbol, APrefixes);
  end;
end;

function SteradianHertzToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSteradianHertz then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsSteradianHertzName, cSteradianHertzPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsSteradianHertzPluralName, cSteradianHertzPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsSteradianHertzName, cSteradianHertzPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsSteradianHertzPluralName, cSteradianHertzPrefixes);
{$ENDIF}
end;

function SteradianHertzToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSteradianHertz then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSteradianHertzName, cSteradianHertzPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSteradianHertzPluralName, cSteradianHertzPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSteradianHertzName, cSteradianHertzPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSteradianHertzPluralName, cSteradianHertzPrefixes);
{$ENDIF}
end;

function SteradianHertzToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SteradianHertzToFloat(AQuantity, APrefixes);
  FactoredTol   := SteradianHertzToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSteradianHertzSymbol, cSteradianHertzPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsSteradianHertzSymbol, APrefixes);
  end;
end;

function SteradianHertzToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSteradianHertz then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function SteradianHertzToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSteradianHertz then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cSteradianHertzPrefixes, cSteradianHertzExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cSteradianHertzPrefixes, cSteradianHertzExponents);
{$ENDIF}
end;

function MeterSteradianToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterSteradian then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsMeterSteradianSymbol, cMeterSteradianPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsMeterSteradianSymbol, cMeterSteradianPrefixes);
{$ENDIF}
end;

function MeterSteradianToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterSteradian then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cMeterSteradianPrefixes, cMeterSteradianExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cMeterSteradianPrefixes, cMeterSteradianExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterSteradianSymbol, cMeterSteradianPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterSteradianSymbol, APrefixes);
end;

function MeterSteradianToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := MeterSteradianToFloat(AQuantity, APrefixes);
  FactoredTol   := MeterSteradianToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterSteradianSymbol, cMeterSteradianPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsMeterSteradianSymbol, APrefixes);
  end;
end;

function MeterSteradianToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterSteradian then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsMeterSteradianName, cMeterSteradianPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsMeterSteradianPluralName, cMeterSteradianPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsMeterSteradianName, cMeterSteradianPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsMeterSteradianPluralName, cMeterSteradianPrefixes);
{$ENDIF}
end;

function MeterSteradianToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterSteradian then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMeterSteradianName, cMeterSteradianPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMeterSteradianPluralName, cMeterSteradianPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMeterSteradianName, cMeterSteradianPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMeterSteradianPluralName, cMeterSteradianPrefixes);
{$ENDIF}
end;

function MeterSteradianToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := MeterSteradianToFloat(AQuantity, APrefixes);
  FactoredTol   := MeterSteradianToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsMeterSteradianSymbol, cMeterSteradianPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsMeterSteradianSymbol, APrefixes);
  end;
end;

function MeterSteradianToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterSteradian then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function MeterSteradianToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterSteradian then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cMeterSteradianPrefixes, cMeterSteradianExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cMeterSteradianPrefixes, cMeterSteradianExponents);
{$ENDIF}
end;

function SquareMeterSteradianToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterSteradian then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsSquareMeterSteradianSymbol, cSquareMeterSteradianPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsSquareMeterSteradianSymbol, cSquareMeterSteradianPrefixes);
{$ENDIF}
end;

function SquareMeterSteradianToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterSteradian then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSquareMeterSteradianPrefixes, cSquareMeterSteradianExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSquareMeterSteradianPrefixes, cSquareMeterSteradianExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareMeterSteradianSymbol, cSquareMeterSteradianPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareMeterSteradianSymbol, APrefixes);
end;

function SquareMeterSteradianToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SquareMeterSteradianToFloat(AQuantity, APrefixes);
  FactoredTol   := SquareMeterSteradianToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareMeterSteradianSymbol, cSquareMeterSteradianPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsSquareMeterSteradianSymbol, APrefixes);
  end;
end;

function SquareMeterSteradianToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterSteradian then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsSquareMeterSteradianName, cSquareMeterSteradianPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsSquareMeterSteradianPluralName, cSquareMeterSteradianPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsSquareMeterSteradianName, cSquareMeterSteradianPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsSquareMeterSteradianPluralName, cSquareMeterSteradianPrefixes);
{$ENDIF}
end;

function SquareMeterSteradianToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterSteradian then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareMeterSteradianName, cSquareMeterSteradianPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareMeterSteradianPluralName, cSquareMeterSteradianPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareMeterSteradianName, cSquareMeterSteradianPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareMeterSteradianPluralName, cSquareMeterSteradianPrefixes);
{$ENDIF}
end;

function SquareMeterSteradianToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SquareMeterSteradianToFloat(AQuantity, APrefixes);
  FactoredTol   := SquareMeterSteradianToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareMeterSteradianSymbol, cSquareMeterSteradianPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsSquareMeterSteradianSymbol, APrefixes);
  end;
end;

function SquareMeterSteradianToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterSteradian then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function SquareMeterSteradianToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterSteradian then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cSquareMeterSteradianPrefixes, cSquareMeterSteradianExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cSquareMeterSteradianPrefixes, cSquareMeterSteradianExponents);
{$ENDIF}
end;

function CubicMeterSteradianToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeterSteradian then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsCubicMeterSteradianSymbol, cCubicMeterSteradianPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsCubicMeterSteradianSymbol, cCubicMeterSteradianPrefixes);
{$ENDIF}
end;

function CubicMeterSteradianToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeterSteradian then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cCubicMeterSteradianPrefixes, cCubicMeterSteradianExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cCubicMeterSteradianPrefixes, cCubicMeterSteradianExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCubicMeterSteradianSymbol, cCubicMeterSteradianPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCubicMeterSteradianSymbol, APrefixes);
end;

function CubicMeterSteradianToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := CubicMeterSteradianToFloat(AQuantity, APrefixes);
  FactoredTol   := CubicMeterSteradianToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCubicMeterSteradianSymbol, cCubicMeterSteradianPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsCubicMeterSteradianSymbol, APrefixes);
  end;
end;

function CubicMeterSteradianToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeterSteradian then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsCubicMeterSteradianName, cCubicMeterSteradianPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsCubicMeterSteradianPluralName, cCubicMeterSteradianPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsCubicMeterSteradianName, cCubicMeterSteradianPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsCubicMeterSteradianPluralName, cCubicMeterSteradianPrefixes);
{$ENDIF}
end;

function CubicMeterSteradianToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeterSteradian then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCubicMeterSteradianName, cCubicMeterSteradianPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCubicMeterSteradianPluralName, cCubicMeterSteradianPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCubicMeterSteradianName, cCubicMeterSteradianPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCubicMeterSteradianPluralName, cCubicMeterSteradianPrefixes);
{$ENDIF}
end;

function CubicMeterSteradianToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := CubicMeterSteradianToFloat(AQuantity, APrefixes);
  FactoredTol   := CubicMeterSteradianToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCubicMeterSteradianSymbol, cCubicMeterSteradianPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsCubicMeterSteradianSymbol, APrefixes);
  end;
end;

function CubicMeterSteradianToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeterSteradian then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function CubicMeterSteradianToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeterSteradian then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cCubicMeterSteradianPrefixes, cCubicMeterSteradianExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cCubicMeterSteradianPrefixes, cCubicMeterSteradianExponents);
{$ENDIF}
end;

function SquareMeterSteradianHertzToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterSteradianHertz then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsSquareMeterSteradianHertzSymbol, cSquareMeterSteradianHertzPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsSquareMeterSteradianHertzSymbol, cSquareMeterSteradianHertzPrefixes);
{$ENDIF}
end;

function SquareMeterSteradianHertzToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterSteradianHertz then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSquareMeterSteradianHertzPrefixes, cSquareMeterSteradianHertzExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSquareMeterSteradianHertzPrefixes, cSquareMeterSteradianHertzExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareMeterSteradianHertzSymbol, cSquareMeterSteradianHertzPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareMeterSteradianHertzSymbol, APrefixes);
end;

function SquareMeterSteradianHertzToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SquareMeterSteradianHertzToFloat(AQuantity, APrefixes);
  FactoredTol   := SquareMeterSteradianHertzToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareMeterSteradianHertzSymbol, cSquareMeterSteradianHertzPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsSquareMeterSteradianHertzSymbol, APrefixes);
  end;
end;

function SquareMeterSteradianHertzToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterSteradianHertz then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsSquareMeterSteradianHertzName, cSquareMeterSteradianHertzPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsSquareMeterSteradianHertzPluralName, cSquareMeterSteradianHertzPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsSquareMeterSteradianHertzName, cSquareMeterSteradianHertzPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsSquareMeterSteradianHertzPluralName, cSquareMeterSteradianHertzPrefixes);
{$ENDIF}
end;

function SquareMeterSteradianHertzToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterSteradianHertz then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareMeterSteradianHertzName, cSquareMeterSteradianHertzPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareMeterSteradianHertzPluralName, cSquareMeterSteradianHertzPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareMeterSteradianHertzName, cSquareMeterSteradianHertzPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareMeterSteradianHertzPluralName, cSquareMeterSteradianHertzPrefixes);
{$ENDIF}
end;

function SquareMeterSteradianHertzToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := SquareMeterSteradianHertzToFloat(AQuantity, APrefixes);
  FactoredTol   := SquareMeterSteradianHertzToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsSquareMeterSteradianHertzSymbol, cSquareMeterSteradianHertzPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsSquareMeterSteradianHertzSymbol, APrefixes);
  end;
end;

function SquareMeterSteradianHertzToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterSteradianHertz then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function SquareMeterSteradianHertzToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterSteradianHertz then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cSquareMeterSteradianHertzPrefixes, cSquareMeterSteradianHertzExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cSquareMeterSteradianHertzPrefixes, cSquareMeterSteradianHertzExponents);
{$ENDIF}
end;

function WattPerSteradianToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSteradian then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsWattPerSteradianSymbol, cWattPerSteradianPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsWattPerSteradianSymbol, cWattPerSteradianPrefixes);
{$ENDIF}
end;

function WattPerSteradianToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSteradian then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cWattPerSteradianPrefixes, cWattPerSteradianExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cWattPerSteradianPrefixes, cWattPerSteradianExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattPerSteradianSymbol, cWattPerSteradianPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattPerSteradianSymbol, APrefixes);
end;

function WattPerSteradianToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := WattPerSteradianToFloat(AQuantity, APrefixes);
  FactoredTol   := WattPerSteradianToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattPerSteradianSymbol, cWattPerSteradianPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsWattPerSteradianSymbol, APrefixes);
  end;
end;

function WattPerSteradianToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSteradian then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsWattPerSteradianName, cWattPerSteradianPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsWattPerSteradianPluralName, cWattPerSteradianPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsWattPerSteradianName, cWattPerSteradianPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsWattPerSteradianPluralName, cWattPerSteradianPrefixes);
{$ENDIF}
end;

function WattPerSteradianToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSteradian then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattPerSteradianName, cWattPerSteradianPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattPerSteradianPluralName, cWattPerSteradianPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattPerSteradianName, cWattPerSteradianPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattPerSteradianPluralName, cWattPerSteradianPrefixes);
{$ENDIF}
end;

function WattPerSteradianToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := WattPerSteradianToFloat(AQuantity, APrefixes);
  FactoredTol   := WattPerSteradianToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattPerSteradianSymbol, cWattPerSteradianPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsWattPerSteradianSymbol, APrefixes);
  end;
end;

function WattPerSteradianToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSteradian then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function WattPerSteradianToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSteradian then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cWattPerSteradianPrefixes, cWattPerSteradianExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cWattPerSteradianPrefixes, cWattPerSteradianExponents);
{$ENDIF}
end;

function WattPerSteradianPerHertzToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSteradianPerHertz then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsWattPerSteradianPerHertzSymbol, cWattPerSteradianPerHertzPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsWattPerSteradianPerHertzSymbol, cWattPerSteradianPerHertzPrefixes);
{$ENDIF}
end;

function WattPerSteradianPerHertzToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSteradianPerHertz then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cWattPerSteradianPerHertzPrefixes, cWattPerSteradianPerHertzExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cWattPerSteradianPerHertzPrefixes, cWattPerSteradianPerHertzExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattPerSteradianPerHertzSymbol, cWattPerSteradianPerHertzPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattPerSteradianPerHertzSymbol, APrefixes);
end;

function WattPerSteradianPerHertzToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := WattPerSteradianPerHertzToFloat(AQuantity, APrefixes);
  FactoredTol   := WattPerSteradianPerHertzToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattPerSteradianPerHertzSymbol, cWattPerSteradianPerHertzPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsWattPerSteradianPerHertzSymbol, APrefixes);
  end;
end;

function WattPerSteradianPerHertzToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSteradianPerHertz then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsWattPerSteradianPerHertzName, cWattPerSteradianPerHertzPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsWattPerSteradianPerHertzPluralName, cWattPerSteradianPerHertzPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsWattPerSteradianPerHertzName, cWattPerSteradianPerHertzPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsWattPerSteradianPerHertzPluralName, cWattPerSteradianPerHertzPrefixes);
{$ENDIF}
end;

function WattPerSteradianPerHertzToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSteradianPerHertz then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattPerSteradianPerHertzName, cWattPerSteradianPerHertzPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattPerSteradianPerHertzPluralName, cWattPerSteradianPerHertzPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattPerSteradianPerHertzName, cWattPerSteradianPerHertzPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattPerSteradianPerHertzPluralName, cWattPerSteradianPerHertzPrefixes);
{$ENDIF}
end;

function WattPerSteradianPerHertzToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := WattPerSteradianPerHertzToFloat(AQuantity, APrefixes);
  FactoredTol   := WattPerSteradianPerHertzToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattPerSteradianPerHertzSymbol, cWattPerSteradianPerHertzPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsWattPerSteradianPerHertzSymbol, APrefixes);
  end;
end;

function WattPerSteradianPerHertzToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSteradianPerHertz then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function WattPerSteradianPerHertzToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSteradianPerHertz then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cWattPerSteradianPerHertzPrefixes, cWattPerSteradianPerHertzExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cWattPerSteradianPerHertzPrefixes, cWattPerSteradianPerHertzExponents);
{$ENDIF}
end;

function WattPerMeterPerSteradianToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerMeterPerSteradian then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsWattPerMeterPerSteradianSymbol, cWattPerMeterPerSteradianPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsWattPerMeterPerSteradianSymbol, cWattPerMeterPerSteradianPrefixes);
{$ENDIF}
end;

function WattPerMeterPerSteradianToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerMeterPerSteradian then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cWattPerMeterPerSteradianPrefixes, cWattPerMeterPerSteradianExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cWattPerMeterPerSteradianPrefixes, cWattPerMeterPerSteradianExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattPerMeterPerSteradianSymbol, cWattPerMeterPerSteradianPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattPerMeterPerSteradianSymbol, APrefixes);
end;

function WattPerMeterPerSteradianToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := WattPerMeterPerSteradianToFloat(AQuantity, APrefixes);
  FactoredTol   := WattPerMeterPerSteradianToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattPerMeterPerSteradianSymbol, cWattPerMeterPerSteradianPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsWattPerMeterPerSteradianSymbol, APrefixes);
  end;
end;

function WattPerMeterPerSteradianToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerMeterPerSteradian then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsWattPerMeterPerSteradianName, cWattPerMeterPerSteradianPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsWattPerMeterPerSteradianPluralName, cWattPerMeterPerSteradianPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsWattPerMeterPerSteradianName, cWattPerMeterPerSteradianPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsWattPerMeterPerSteradianPluralName, cWattPerMeterPerSteradianPrefixes);
{$ENDIF}
end;

function WattPerMeterPerSteradianToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerMeterPerSteradian then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattPerMeterPerSteradianName, cWattPerMeterPerSteradianPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattPerMeterPerSteradianPluralName, cWattPerMeterPerSteradianPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattPerMeterPerSteradianName, cWattPerMeterPerSteradianPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattPerMeterPerSteradianPluralName, cWattPerMeterPerSteradianPrefixes);
{$ENDIF}
end;

function WattPerMeterPerSteradianToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := WattPerMeterPerSteradianToFloat(AQuantity, APrefixes);
  FactoredTol   := WattPerMeterPerSteradianToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattPerMeterPerSteradianSymbol, cWattPerMeterPerSteradianPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsWattPerMeterPerSteradianSymbol, APrefixes);
  end;
end;

function WattPerMeterPerSteradianToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerMeterPerSteradian then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function WattPerMeterPerSteradianToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerMeterPerSteradian then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cWattPerMeterPerSteradianPrefixes, cWattPerMeterPerSteradianExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cWattPerMeterPerSteradianPrefixes, cWattPerMeterPerSteradianExponents);
{$ENDIF}
end;

function WattPerSquareMeterPerSteradianToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSquareMeterPerSteradian then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsWattPerSquareMeterPerSteradianSymbol, cWattPerSquareMeterPerSteradianPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsWattPerSquareMeterPerSteradianSymbol, cWattPerSquareMeterPerSteradianPrefixes);
{$ENDIF}
end;

function WattPerSquareMeterPerSteradianToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSquareMeterPerSteradian then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cWattPerSquareMeterPerSteradianPrefixes, cWattPerSquareMeterPerSteradianExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cWattPerSquareMeterPerSteradianPrefixes, cWattPerSquareMeterPerSteradianExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattPerSquareMeterPerSteradianSymbol, cWattPerSquareMeterPerSteradianPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattPerSquareMeterPerSteradianSymbol, APrefixes);
end;

function WattPerSquareMeterPerSteradianToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := WattPerSquareMeterPerSteradianToFloat(AQuantity, APrefixes);
  FactoredTol   := WattPerSquareMeterPerSteradianToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattPerSquareMeterPerSteradianSymbol, cWattPerSquareMeterPerSteradianPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsWattPerSquareMeterPerSteradianSymbol, APrefixes);
  end;
end;

function WattPerSquareMeterPerSteradianToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSquareMeterPerSteradian then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsWattPerSquareMeterPerSteradianName, cWattPerSquareMeterPerSteradianPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsWattPerSquareMeterPerSteradianPluralName, cWattPerSquareMeterPerSteradianPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsWattPerSquareMeterPerSteradianName, cWattPerSquareMeterPerSteradianPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsWattPerSquareMeterPerSteradianPluralName, cWattPerSquareMeterPerSteradianPrefixes);
{$ENDIF}
end;

function WattPerSquareMeterPerSteradianToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSquareMeterPerSteradian then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattPerSquareMeterPerSteradianName, cWattPerSquareMeterPerSteradianPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattPerSquareMeterPerSteradianPluralName, cWattPerSquareMeterPerSteradianPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattPerSquareMeterPerSteradianName, cWattPerSquareMeterPerSteradianPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattPerSquareMeterPerSteradianPluralName, cWattPerSquareMeterPerSteradianPrefixes);
{$ENDIF}
end;

function WattPerSquareMeterPerSteradianToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := WattPerSquareMeterPerSteradianToFloat(AQuantity, APrefixes);
  FactoredTol   := WattPerSquareMeterPerSteradianToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattPerSquareMeterPerSteradianSymbol, cWattPerSquareMeterPerSteradianPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsWattPerSquareMeterPerSteradianSymbol, APrefixes);
  end;
end;

function WattPerSquareMeterPerSteradianToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSquareMeterPerSteradian then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function WattPerSquareMeterPerSteradianToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSquareMeterPerSteradian then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cWattPerSquareMeterPerSteradianPrefixes, cWattPerSquareMeterPerSteradianExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cWattPerSquareMeterPerSteradianPrefixes, cWattPerSquareMeterPerSteradianExponents);
{$ENDIF}
end;

function WattPerCubicMeterPerSteradianToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerCubicMeterPerSteradian then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsWattPerCubicMeterPerSteradianSymbol, cWattPerCubicMeterPerSteradianPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsWattPerCubicMeterPerSteradianSymbol, cWattPerCubicMeterPerSteradianPrefixes);
{$ENDIF}
end;

function WattPerCubicMeterPerSteradianToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerCubicMeterPerSteradian then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cWattPerCubicMeterPerSteradianPrefixes, cWattPerCubicMeterPerSteradianExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cWattPerCubicMeterPerSteradianPrefixes, cWattPerCubicMeterPerSteradianExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattPerCubicMeterPerSteradianSymbol, cWattPerCubicMeterPerSteradianPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattPerCubicMeterPerSteradianSymbol, APrefixes);
end;

function WattPerCubicMeterPerSteradianToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := WattPerCubicMeterPerSteradianToFloat(AQuantity, APrefixes);
  FactoredTol   := WattPerCubicMeterPerSteradianToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattPerCubicMeterPerSteradianSymbol, cWattPerCubicMeterPerSteradianPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsWattPerCubicMeterPerSteradianSymbol, APrefixes);
  end;
end;

function WattPerCubicMeterPerSteradianToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerCubicMeterPerSteradian then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsWattPerCubicMeterPerSteradianName, cWattPerCubicMeterPerSteradianPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsWattPerCubicMeterPerSteradianPluralName, cWattPerCubicMeterPerSteradianPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsWattPerCubicMeterPerSteradianName, cWattPerCubicMeterPerSteradianPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsWattPerCubicMeterPerSteradianPluralName, cWattPerCubicMeterPerSteradianPrefixes);
{$ENDIF}
end;

function WattPerCubicMeterPerSteradianToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerCubicMeterPerSteradian then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattPerCubicMeterPerSteradianName, cWattPerCubicMeterPerSteradianPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattPerCubicMeterPerSteradianPluralName, cWattPerCubicMeterPerSteradianPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattPerCubicMeterPerSteradianName, cWattPerCubicMeterPerSteradianPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattPerCubicMeterPerSteradianPluralName, cWattPerCubicMeterPerSteradianPrefixes);
{$ENDIF}
end;

function WattPerCubicMeterPerSteradianToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := WattPerCubicMeterPerSteradianToFloat(AQuantity, APrefixes);
  FactoredTol   := WattPerCubicMeterPerSteradianToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattPerCubicMeterPerSteradianSymbol, cWattPerCubicMeterPerSteradianPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsWattPerCubicMeterPerSteradianSymbol, APrefixes);
  end;
end;

function WattPerCubicMeterPerSteradianToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerCubicMeterPerSteradian then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function WattPerCubicMeterPerSteradianToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerCubicMeterPerSteradian then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cWattPerCubicMeterPerSteradianPrefixes, cWattPerCubicMeterPerSteradianExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cWattPerCubicMeterPerSteradianPrefixes, cWattPerCubicMeterPerSteradianExponents);
{$ENDIF}
end;

function WattPerSquareMeterPerSteradianPerHertzToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSquareMeterPerSteradianPerHertz then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsWattPerSquareMeterPerSteradianPerHertzSymbol, cWattPerSquareMeterPerSteradianPerHertzPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsWattPerSquareMeterPerSteradianPerHertzSymbol, cWattPerSquareMeterPerSteradianPerHertzPrefixes);
{$ENDIF}
end;

function WattPerSquareMeterPerSteradianPerHertzToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSquareMeterPerSteradianPerHertz then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cWattPerSquareMeterPerSteradianPerHertzPrefixes, cWattPerSquareMeterPerSteradianPerHertzExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cWattPerSquareMeterPerSteradianPerHertzPrefixes, cWattPerSquareMeterPerSteradianPerHertzExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattPerSquareMeterPerSteradianPerHertzSymbol, cWattPerSquareMeterPerSteradianPerHertzPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattPerSquareMeterPerSteradianPerHertzSymbol, APrefixes);
end;

function WattPerSquareMeterPerSteradianPerHertzToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := WattPerSquareMeterPerSteradianPerHertzToFloat(AQuantity, APrefixes);
  FactoredTol   := WattPerSquareMeterPerSteradianPerHertzToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattPerSquareMeterPerSteradianPerHertzSymbol, cWattPerSquareMeterPerSteradianPerHertzPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsWattPerSquareMeterPerSteradianPerHertzSymbol, APrefixes);
  end;
end;

function WattPerSquareMeterPerSteradianPerHertzToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSquareMeterPerSteradianPerHertz then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsWattPerSquareMeterPerSteradianPerHertzName, cWattPerSquareMeterPerSteradianPerHertzPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsWattPerSquareMeterPerSteradianPerHertzPluralName, cWattPerSquareMeterPerSteradianPerHertzPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsWattPerSquareMeterPerSteradianPerHertzName, cWattPerSquareMeterPerSteradianPerHertzPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsWattPerSquareMeterPerSteradianPerHertzPluralName, cWattPerSquareMeterPerSteradianPerHertzPrefixes);
{$ENDIF}
end;

function WattPerSquareMeterPerSteradianPerHertzToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSquareMeterPerSteradianPerHertz then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattPerSquareMeterPerSteradianPerHertzName, cWattPerSquareMeterPerSteradianPerHertzPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattPerSquareMeterPerSteradianPerHertzPluralName, cWattPerSquareMeterPerSteradianPerHertzPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattPerSquareMeterPerSteradianPerHertzName, cWattPerSquareMeterPerSteradianPerHertzPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattPerSquareMeterPerSteradianPerHertzPluralName, cWattPerSquareMeterPerSteradianPerHertzPrefixes);
{$ENDIF}
end;

function WattPerSquareMeterPerSteradianPerHertzToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := WattPerSquareMeterPerSteradianPerHertzToFloat(AQuantity, APrefixes);
  FactoredTol   := WattPerSquareMeterPerSteradianPerHertzToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsWattPerSquareMeterPerSteradianPerHertzSymbol, cWattPerSquareMeterPerSteradianPerHertzPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsWattPerSquareMeterPerSteradianPerHertzSymbol, APrefixes);
  end;
end;

function WattPerSquareMeterPerSteradianPerHertzToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSquareMeterPerSteradianPerHertz then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function WattPerSquareMeterPerSteradianPerHertzToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSquareMeterPerSteradianPerHertz then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cWattPerSquareMeterPerSteradianPerHertzPrefixes, cWattPerSquareMeterPerSteradianPerHertzExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cWattPerSquareMeterPerSteradianPerHertzPrefixes, cWattPerSquareMeterPerSteradianPerHertzExponents);
{$ENDIF}
end;

function KatalPerCubicMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKatalPerCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsKatalPerCubicMeterSymbol, cKatalPerCubicMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsKatalPerCubicMeterSymbol, cKatalPerCubicMeterPrefixes);
{$ENDIF}
end;

function KatalPerCubicMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKatalPerCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cKatalPerCubicMeterPrefixes, cKatalPerCubicMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cKatalPerCubicMeterPrefixes, cKatalPerCubicMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKatalPerCubicMeterSymbol, cKatalPerCubicMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKatalPerCubicMeterSymbol, APrefixes);
end;

function KatalPerCubicMeterToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := KatalPerCubicMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := KatalPerCubicMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKatalPerCubicMeterSymbol, cKatalPerCubicMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsKatalPerCubicMeterSymbol, APrefixes);
  end;
end;

function KatalPerCubicMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKatalPerCubicMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsKatalPerCubicMeterName, cKatalPerCubicMeterPrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsKatalPerCubicMeterPluralName, cKatalPerCubicMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsKatalPerCubicMeterName, cKatalPerCubicMeterPrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsKatalPerCubicMeterPluralName, cKatalPerCubicMeterPrefixes);
{$ENDIF}
end;

function KatalPerCubicMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKatalPerCubicMeter then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKatalPerCubicMeterName, cKatalPerCubicMeterPrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKatalPerCubicMeterPluralName, cKatalPerCubicMeterPrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKatalPerCubicMeterName, cKatalPerCubicMeterPrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKatalPerCubicMeterPluralName, cKatalPerCubicMeterPrefixes);
{$ENDIF}
end;

function KatalPerCubicMeterToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := KatalPerCubicMeterToFloat(AQuantity, APrefixes);
  FactoredTol   := KatalPerCubicMeterToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsKatalPerCubicMeterSymbol, cKatalPerCubicMeterPrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsKatalPerCubicMeterSymbol, APrefixes);
  end;
end;

function KatalPerCubicMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKatalPerCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function KatalPerCubicMeterToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKatalPerCubicMeter then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cKatalPerCubicMeterPrefixes, cKatalPerCubicMeterExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cKatalPerCubicMeterPrefixes, cKatalPerCubicMeterExponents);
{$ENDIF}
end;

function CoulombPerMoleToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulombPerMole then
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsCoulombPerMoleSymbol, cCoulombPerMolePrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsCoulombPerMoleSymbol, cCoulombPerMolePrefixes);
{$ENDIF}
end;

function CoulombPerMoleToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulombPerMole then
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cCoulombPerMolePrefixes, cCoulombPerMoleExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cCoulombPerMolePrefixes, cCoulombPerMoleExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCoulombPerMoleSymbol, cCoulombPerMolePrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCoulombPerMoleSymbol, APrefixes);
end;

function CoulombPerMoleToString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := CoulombPerMoleToFloat(AQuantity, APrefixes);
  FactoredTol   := CoulombPerMoleToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCoulombPerMoleSymbol, cCoulombPerMolePrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetSymbol(rsCoulombPerMoleSymbol, APrefixes);
  end;
end;

function CoulombPerMoleToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulombPerMole then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsCoulombPerMoleName, cCoulombPerMolePrefixes)
  else
    result := FloatToStr(AValue.FValue) + ' ' + GetName(rsCoulombPerMolePluralName, cCoulombPerMolePrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStr(AValue) + ' ' + GetName(rsCoulombPerMoleName, cCoulombPerMolePrefixes)
  else
    result := FloatToStr(AValue) + ' ' + GetName(rsCoulombPerMolePluralName, cCoulombPerMolePrefixes);
{$ENDIF}
end;

function CoulombPerMoleToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulombPerMole then
    raise Exception.Create('Wrong units of measurements');

  if (AValue.FValue > -1) and (AValue.FValue < 1) then
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCoulombPerMoleName, cCoulombPerMolePrefixes)
  else
    result := FloatToStrF(AValue.FValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCoulombPerMolePluralName, cCoulombPerMolePrefixes);
{$ELSE}
  if (AValue > -1) and (AValue < 1) then
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCoulombPerMoleName, cCoulombPerMolePrefixes)
  else
    result := FloatToStrF(AValue, ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCoulombPerMolePluralName, cCoulombPerMolePrefixes);
{$ENDIF}
end;

function CoulombPerMoleToVerboseString(const AQuantity, ATolerance: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredTol: double;
  FactoredValue: double;
begin
  FactoredValue := CoulombPerMoleToFloat(AQuantity, APrefixes);
  FactoredTol   := CoulombPerMoleToFloat(ATolerance, APrefixes);

  if Length(APrefixes) = 0 then
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' ' + GetName(rsCoulombPerMoleSymbol, cCoulombPerMolePrefixes)
  end else
  begin
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ± ' +
              FloatToStrF(FactoredTol,   ffGeneral, APrecision, ADigits) + ' '   + GetName(rsCoulombPerMoleSymbol, APrefixes);
  end;
end;

function CoulombPerMoleToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulombPerMole then
    raise Exception.Create('Wrong units of measurements');
  result := AValue.FValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

function CoulombPerMoleToFloat(const AValue: TQuantity; const APrefixes: TPrefixes): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulombPerMole then
    raise Exception.Create('Wrong units of measurements');
  result := GetValue(AValue.FValue, APrefixes, cCoulombPerMolePrefixes, cCoulombPerMoleExponents);
{$ELSE}
  result := GetValue(AValue, APrefixes, cCoulombPerMolePrefixes, cCoulombPerMoleExponents);
{$ENDIF}
end;

{ Helpers }

{ Power functions }

function SquarePower(const AValue: TQuantity): TQuantity;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := PowerTable[result.FUnitOfMeasurement].Square;
  if result.FUnitOfMeasurement = -1 then
    raise Exception.Create('Wrong units of measurements');
  result.FValue := IntPower(AValue.FValue, 2);
{$ELSE}
  result := IntPower(AValue, 2);
{$ENDIF}
end;

function CubicPower(const AValue: TQuantity): TQuantity;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := PowerTable[result.FUnitOfMeasurement].Cubic;
  if result.FUnitOfMeasurement = -1 then
    raise Exception.Create('Wrong units of measurements');
  result.FValue := IntPower(AValue.FValue, 3);
{$ELSE}
  result := IntPower(AValue, 3);
{$ENDIF}
end;

function QuarticPower(const AValue: TQuantity): TQuantity;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := PowerTable[result.FUnitOfMeasurement].Quartic;
  if result.FUnitOfMeasurement = -1 then
    raise Exception.Create('Wrong units of measurements');
  result.FValue := IntPower(AValue.FValue, 4);
{$ELSE}
  result := IntPower(AValue, 4);
{$ENDIF}
end;

function QuinticPower(const AValue: TQuantity): TQuantity;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := PowerTable[result.FUnitOfMeasurement].Quintic;
  if result.FUnitOfMeasurement = -1 then
    raise Exception.Create('Wrong units of measurements');
  result.FValue := IntPower(AValue.FValue, 5);
{$ELSE}
  result := IntPower(AValue, 5);
{$ENDIF}
end;

function SexticPower(const AValue: TQuantity): TQuantity;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := PowerTable[result.FUnitOfMeasurement].Sextic;
  if result.FUnitOfMeasurement = -1 then
    raise Exception.Create('Wrong units of measurements');
  result.FValue := IntPower(AValue.FValue, 6);
{$ELSE}
  result := IntPower(AValue, 6);
{$ENDIF}
end;

function SquareRoot(const AValue: TQuantity): TQuantity;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := RootTable[result.FUnitOfMeasurement].Square;
  if result.FUnitOfMeasurement = -1 then
    raise Exception.Create('Wrong units of measurements');
  result.FValue := Power(AValue.FValue, 1/2);
{$ELSE}
  result := Power(AValue, 1/2);
{$ENDIF}
end;

function CubicRoot(const AValue: TQuantity): TQuantity;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := RootTable[result.FUnitOfMeasurement].Cubic;
  if result.FUnitOfMeasurement = -1 then
    raise Exception.Create('Wrong units of measurements');
  result.FValue := Power(AValue.FValue, 1/3);
{$ELSE}
  result := Power(AValue, 1/3);
{$ENDIF}
end;

function QuarticRoot(const AValue: TQuantity): TQuantity;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := RootTable[result.FUnitOfMeasurement].Quartic;
  if result.FUnitOfMeasurement = -1 then
    raise Exception.Create('Wrong units of measurements');
  result.FValue := Power(AValue.FValue, 1/4);
{$ELSE}
  result := Power(AValue, 1/4);
{$ENDIF}
end;

function QuinticRoot(const AValue: TQuantity): TQuantity;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := RootTable[result.FUnitOfMeasurement].Quintic;
  if result.FUnitOfMeasurement = -1 then
    raise Exception.Create('Wrong units of measurements');
  result.FValue := Power(AValue.FValue, 1/5);
{$ELSE}
  result := Power(AValue, 1/5);
{$ENDIF}
end;

function SexticRoot(const AValue: TQuantity): TQuantity;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := RootTable[result.FUnitOfMeasurement].Sextic;
  if result.FUnitOfMeasurement = -1 then
    raise Exception.Create('Wrong units of measurements');
  result.FValue := Power(AValue.FValue, 1/6);
{$ELSE}
  result := Power(AValue, 1/6);
{$ENDIF}
end;

{$IFOPT D+}
{$ENDIF}
{ Trigonometric functions }

function Cos(const AQuantity: TQuantity): double;
begin
  if AQuantity.FUnitOfMeasurement <> cScalar then
    raise Exception.Create('Wrong units of measurements');
  result := System.Cos(AQuantity.FValue);
end;

function Sin(const AQuantity: TQuantity): double;
begin
  if AQuantity.FUnitOfMeasurement <> cScalar then
    raise Exception.Create('Wrong units of measurements');
  result := System.Sin(AQuantity.FValue);
end;

function Tan(const AQuantity: TQuantity): double;
begin
  if AQuantity.FUnitOfMeasurement <> cScalar then
    raise Exception.Create('Wrong units of measurements');
  result := Math.Tan(AQuantity.FValue);
end;

function Cotan(const AQuantity: TQuantity): double;
begin
  if AQuantity.FUnitOfMeasurement <> cScalar then
    raise Exception.Create('Wrong units of measurements');
  result := Math.Cotan(AQuantity.FValue);
end;

function Secant(const AQuantity: TQuantity): double;
begin
  if AQuantity.FUnitOfMeasurement <> cScalar then
    raise Exception.Create('Wrong units of measurements');
  result := Math.Secant(AQuantity.FValue);
end;

function Cosecant(const AQuantity: TQuantity): double;
begin
  if AQuantity.FUnitOfMeasurement <> cScalar then
    raise Exception.Create('Wrong units of measurements');
  result := Math.Cosecant(AQuantity.FValue);
end;

function ArcCos(const AQuantity: double): TQuantity;
begin
  result.FUnitOfMeasurement := cScalar;
  result.FValue := Math.ArcCos(AQuantity);
end;

function ArcSin(const AQuantity: double): TQuantity;
begin
  result.FUnitOfMeasurement := cScalar;
  result.FValue := Math.ArcSin(AQuantity);
end;

function ArcTan(const AQuantity: double): TQuantity;
begin
  result.FUnitOfMeasurement := cScalar;
  result.FValue := System.ArcTan(AQuantity);
end;

function ArcTan2(const x, y: double): TQuantity;
begin
  result.FUnitOfMeasurement := cScalar;
  result.FValue := Math.ArcTan2(x, y);
end;

{ Override trigonometric functions }

{$IFOPT D+}
function Cos(const AQuantity: double): double;
begin
  result := System.Cos(AQuantity);
end;

function Sin(const AQuantity: double): double;
begin
  result := System.Sin(AQuantity);
end;

function Tan(const AQuantity: double): double;

begin
  result := Math.Tan(AQuantity);
end;

function Cotan(const AQuantity: double): double;
begin
  result := Math.Cotan(AQuantity);
end;

function Secant(const AQuantity: double): double;
begin
  result := Math.Secant(AQuantity);
end;

function Cosecant(const AQuantity: double): double;
begin
  result := Math.Cosecant(AQuantity);
end;
{$ENDIF}

{ Helper functions }

function SameValue(const ALeft, ARight: TQuantity): boolean;
begin
  if ALeft.FUnitOfMeasurement <> ARight.FUnitOfMeasurement then
    raise Exception.Create('Wrong units of measurements');
  result := Math.SameValue(ALeft.FValue, ARight.FValue);
end;

function Min(const ALeft, ARight: TQuantity): TQuantity;
begin
  if ALeft.FUnitOfMeasurement <> ARight.FUnitOfMeasurement then
    raise Exception.Create('Wrong units of measurements');
  result.FUnitOfMeasurement := ARight.FUnitOfMeasurement;
  result.FValue := Math.Min(ALeft.FValue, ARight.FValue);
end;

function Max(const ALeft, ARight: TQuantity): TQuantity;
begin
  if ALeft.FUnitOfMeasurement <> ARight.FUnitOfMeasurement then
    raise Exception.Create('Wrong units of measurements');
  result.FUnitOfMeasurement := ARight.FUnitOfMeasurement;
  result.FValue := Math.Max(ALeft.FValue, ARight.FValue);
end;

function Exp(const AQuantity: TQuantity): TQuantity;
begin
  if AQuantity.FUnitOfMeasurement <> cScalar then
    raise Exception.Create('Wrong units of measurements');
  result.FUnitOfMeasurement := cScalar;
  result.FValue := System.Exp(AQuantity.FValue);
end;

end.
