{
  ADimRT library built on 5-10-24.

  Number of base units: 160
  Number of factored units: 120
  Number of operators: 0 (0 external, 0 internal)
}

unit ADimRT;

{$H+}{$J-}
{$modeswitch typehelpers}
{$modeswitch advancedrecords}
{$WARN 5024 OFF} // Suppress warning for unused routine parameter.
{$WARN 5033 OFF} // Suppress warning for unassigned function's return value.
{$MACRO ON}

interface

uses
  DateUtils, Sysutils;

type
  { Prefix }

  TPrefix = (pQuetta, pRonna, pYotta, pZetta, pExa, pPeta, pTera, pGiga, pMega, pKilo, pHecto, pDeca,
    pNone, pDeci, pCenti, pMilli, pMicro, pNano, pPico, pFemto, pAtto, pZepto, pYocto, pRonto, pQuecto);

  { Prefixes }

  TPrefixes = array of TPrefix;

  { Exponents }

  TExponents = array of longint;

{ TQuantity }

type
  {$IFOPT D+}
  TQuantity = record
  private
    FUnitOfMeasurement: longint;
    FValue: double;
  public
    class operator +(const ALeft, ARight: TQuantity): TQuantity; inline;
    class operator -(const ALeft, ARight: TQuantity): TQuantity; inline;
    class operator *(const ALeft, ARight: TQuantity): TQuantity; inline;
    class operator /(const ALeft, ARight: TQuantity): TQuantity; inline;
    class operator *(const ALeft: double; const ARight: TQuantity): TQuantity; inline;
    class operator *(const ALeft: TQuantity; const ARight: double): TQuantity; inline;
    class operator /(const ALeft: TQuantity; const ARight: double): TQuantity; inline;
  end;
  {$ELSE}
  TQuantity = double;
  {$ENDIF}

type
  TScalarUnit = record
    class operator *(const AValue: double; const ASelf: TScalarUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TScalarUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TScalarUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TScalarUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsScalarSymbol     = '';
  rsScalarName       = '';
  rsScalarPluralName = '';

const
  cScalar                       = (0);
  cScalarPrefixes  : TPrefixes  = ();
  cScalarExponents : TExponents = ();

type
  TRadianUnit = record
    class operator *(const AValue: double; const ASelf: TRadianUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TRadianUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TRadianUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TRadianUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsRadianSymbol     = 'rad';
  rsRadianName       = 'radian';
  rsRadianPluralName = 'radians';

const
  cRadian                       = (0);
  cRadianPrefixes  : TPrefixes  = ();
  cRadianExponents : TExponents = ();

var
  rad        : TRadianUnit;

type
  TDegreeUnit = record
    class operator *(const AValue: double; const ASelf: TDegreeUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TDegreeUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TDegreeUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TDegreeUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsDegreeSymbol     = 'deg';
  rsDegreeName       = 'degree';
  rsDegreePluralName = 'degrees';

const
  cDegree                       = (0);
  cDegreePrefixes  : TPrefixes  = ();
  cDegreeExponents : TExponents = ();

const
  deg        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cScalar; FValue: Pi/180); {$ELSE} (Pi/180); {$ENDIF}

type
  TSteradianUnit = record
    class operator *(const AValue: double; const ASelf: TSteradianUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TSteradianUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TSteradianUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TSteradianUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsSteradianSymbol     = 'sr';
  rsSteradianName       = 'steradian';
  rsSteradianPluralName = 'steradians';

const
  cSteradian                       = (0);
  cSteradianPrefixes  : TPrefixes  = ();
  cSteradianExponents : TExponents = ();

var
  sr         : TSteradianUnit;

type
  TSquareDegreeUnit = record
    class operator *(const AValue: double; const ASelf: TSquareDegreeUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TSquareDegreeUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TSquareDegreeUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TSquareDegreeUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsSquareDegreeSymbol     = 'deg2';
  rsSquareDegreeName       = 'square degree';
  rsSquareDegreePluralName = 'square degrees';

const
  cSquareDegree                       = (0);
  cSquareDegreePrefixes  : TPrefixes  = ();
  cSquareDegreeExponents : TExponents = ();

const
  deg2       : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cScalar; FValue: Pi*Pi/32400); {$ELSE} (Pi*Pi/32400); {$ENDIF}

type
  TSecondUnit = record
    class operator *(const AValue: double; const ASelf: TSecondUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TSecondUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TSecondUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TSecondUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsSecondSymbol     = '%ss';
  rsSecondName       = '%ssecond';
  rsSecondPluralName = '%sseconds';

const
  cSecond                       = (0);
  cSecondPrefixes  : TPrefixes  = (pNone);
  cSecondExponents : TExponents = (1);

var
  s          : TSecondUnit;

const
  ds         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSecond; FValue: 1E-01); {$ELSE} (1E-01); {$ENDIF}
  cs         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSecond; FValue: 1E-02); {$ELSE} (1E-02); {$ENDIF}
  ms         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSecond; FValue: 1E-03); {$ELSE} (1E-03); {$ENDIF}
  mis        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSecond; FValue: 1E-06); {$ELSE} (1E-06); {$ENDIF}
  ns         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSecond; FValue: 1E-09); {$ELSE} (1E-09); {$ENDIF}
  ps         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSecond; FValue: 1E-12); {$ELSE} (1E-12); {$ENDIF}

type
  TDayUnit = record
    class operator *(const AValue: double; const ASelf: TDayUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TDayUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TDayUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TDayUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsDaySymbol     = 'd';
  rsDayName       = 'day';
  rsDayPluralName = 'days';

const
  cDay                       = (0);
  cDayPrefixes  : TPrefixes  = ();
  cDayExponents : TExponents = ();

const
  day        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSecond; FValue: 86400); {$ELSE} (86400); {$ENDIF}

type
  THourUnit = record
    class operator *(const AValue: double; const ASelf: THourUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: THourUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: THourUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: THourUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsHourSymbol     = 'h';
  rsHourName       = 'hour';
  rsHourPluralName = 'hours';

const
  cHour                       = (0);
  cHourPrefixes  : TPrefixes  = ();
  cHourExponents : TExponents = ();

const
  hr         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSecond; FValue: 3600); {$ELSE} (3600); {$ENDIF}

type
  TMinuteUnit = record
    class operator *(const AValue: double; const ASelf: TMinuteUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TMinuteUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TMinuteUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TMinuteUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsMinuteSymbol     = 'min';
  rsMinuteName       = 'minute';
  rsMinutePluralName = 'minutes';

const
  cMinute                       = (0);
  cMinutePrefixes  : TPrefixes  = ();
  cMinuteExponents : TExponents = ();

const
  minute     : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSecond; FValue: 60); {$ELSE} (60); {$ENDIF}

type
  TSquareSecondUnit = record
    class operator *(const AValue: double; const ASelf: TSquareSecondUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TSquareSecondUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TSquareSecondUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TSquareSecondUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsSquareSecondSymbol     = '%ss2';
  rsSquareSecondName       = 'square %ssecond';
  rsSquareSecondPluralName = 'square %sseconds';

const
  cSquareSecond                       = (0);
  cSquareSecondPrefixes  : TPrefixes  = (pNone);
  cSquareSecondExponents : TExponents = (2);

var
  s2         : TSquareSecondUnit;

const
  ds2        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSquareSecond; FValue: 1E-02); {$ELSE} (1E-02); {$ENDIF}
  cs2        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSquareSecond; FValue: 1E-04); {$ELSE} (1E-04); {$ENDIF}
  ms2        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSquareSecond; FValue: 1E-06); {$ELSE} (1E-06); {$ENDIF}
  mis2       : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSquareSecond; FValue: 1E-12); {$ELSE} (1E-12); {$ENDIF}
  ns2        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSquareSecond; FValue: 1E-18); {$ELSE} (1E-18); {$ENDIF}
  ps2        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSquareSecond; FValue: 1E-24); {$ELSE} (1E-24); {$ENDIF}

type
  TSquareDayUnit = record
    class operator *(const AValue: double; const ASelf: TSquareDayUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TSquareDayUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TSquareDayUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TSquareDayUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsSquareDaySymbol     = 'd2';
  rsSquareDayName       = 'square day';
  rsSquareDayPluralName = 'square days';

const
  cSquareDay                       = (0);
  cSquareDayPrefixes  : TPrefixes  = ();
  cSquareDayExponents : TExponents = ();

const
  day2       : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSquareSecond; FValue: 7464960000); {$ELSE} (7464960000); {$ENDIF}

type
  TSquareHourUnit = record
    class operator *(const AValue: double; const ASelf: TSquareHourUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TSquareHourUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TSquareHourUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TSquareHourUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsSquareHourSymbol     = 'h2';
  rsSquareHourName       = 'square hour';
  rsSquareHourPluralName = 'square hours';

const
  cSquareHour                       = (0);
  cSquareHourPrefixes  : TPrefixes  = ();
  cSquareHourExponents : TExponents = ();

const
  hr2        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSquareSecond; FValue: 12960000); {$ELSE} (12960000); {$ENDIF}

type
  TSquareMinuteUnit = record
    class operator *(const AValue: double; const ASelf: TSquareMinuteUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TSquareMinuteUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TSquareMinuteUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TSquareMinuteUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsSquareMinuteSymbol     = 'min2';
  rsSquareMinuteName       = 'square minute';
  rsSquareMinutePluralName = 'square minutes';

const
  cSquareMinute                       = (0);
  cSquareMinutePrefixes  : TPrefixes  = ();
  cSquareMinuteExponents : TExponents = ();

const
  minute2    : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSquareSecond; FValue: 3600); {$ELSE} (3600); {$ENDIF}

type
  TCubicSecondUnit = record
    class operator *(const AValue: double; const ASelf: TCubicSecondUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TCubicSecondUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TCubicSecondUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TCubicSecondUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsCubicSecondSymbol     = '%ss3';
  rsCubicSecondName       = 'cubic %ssecond';
  rsCubicSecondPluralName = 'cubic %sseconds';

const
  cCubicSecond                       = (0);
  cCubicSecondPrefixes  : TPrefixes  = (pNone);
  cCubicSecondExponents : TExponents = (3);

var
  s3         : TCubicSecondUnit;

const
  ds3        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cCubicSecond; FValue: 1E-03); {$ELSE} (1E-03); {$ENDIF}
  cs3        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cCubicSecond; FValue: 1E-06); {$ELSE} (1E-06); {$ENDIF}
  ms3        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cCubicSecond; FValue: 1E-09); {$ELSE} (1E-09); {$ENDIF}
  mis3       : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cCubicSecond; FValue: 1E-18); {$ELSE} (1E-18); {$ENDIF}
  ns3        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cCubicSecond; FValue: 1E-27); {$ELSE} (1E-27); {$ENDIF}
  ps3        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cCubicSecond; FValue: 1E-36); {$ELSE} (1E-36); {$ENDIF}

type
  TQuarticSecondUnit = record
    class operator *(const AValue: double; const ASelf: TQuarticSecondUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TQuarticSecondUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TQuarticSecondUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TQuarticSecondUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsQuarticSecondSymbol     = '%ss4';
  rsQuarticSecondName       = 'quartic %ssecond';
  rsQuarticSecondPluralName = 'quartic %sseconds';

const
  cQuarticSecond                       = (0);
  cQuarticSecondPrefixes  : TPrefixes  = (pNone);
  cQuarticSecondExponents : TExponents = (4);

var
  s4         : TQuarticSecondUnit;

const
  ds4        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cQuarticSecond; FValue: 1E-04); {$ELSE} (1E-04); {$ENDIF}
  cs4        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cQuarticSecond; FValue: 1E-08); {$ELSE} (1E-08); {$ENDIF}
  ms4        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cQuarticSecond; FValue: 1E-12); {$ELSE} (1E-12); {$ENDIF}
  mis4       : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cQuarticSecond; FValue: 1E-24); {$ELSE} (1E-24); {$ENDIF}
  ns4        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cQuarticSecond; FValue: 1E-36); {$ELSE} (1E-36); {$ENDIF}
  ps4        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cQuarticSecond; FValue: 1E-48); {$ELSE} (1E-48); {$ENDIF}

type
  TQuinticSecondUnit = record
    class operator *(const AValue: double; const ASelf: TQuinticSecondUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TQuinticSecondUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TQuinticSecondUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TQuinticSecondUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsQuinticSecondSymbol     = '%ss5';
  rsQuinticSecondName       = 'quintic %ssecond';
  rsQuinticSecondPluralName = 'quintic %sseconds';

const
  cQuinticSecond                       = (0);
  cQuinticSecondPrefixes  : TPrefixes  = (pNone);
  cQuinticSecondExponents : TExponents = (5);

var
  s5         : TQuinticSecondUnit;

const
  ds5        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cQuinticSecond; FValue: 1E-05); {$ELSE} (1E-05); {$ENDIF}
  cs5        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cQuinticSecond; FValue: 1E-10); {$ELSE} (1E-10); {$ENDIF}
  ms5        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cQuinticSecond; FValue: 1E-15); {$ELSE} (1E-15); {$ENDIF}
  mis5       : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cQuinticSecond; FValue: 1E-30); {$ELSE} (1E-30); {$ENDIF}
  ns5        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cQuinticSecond; FValue: 1E-45); {$ELSE} (1E-45); {$ENDIF}
  ps5        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cQuinticSecond; FValue: 1E-60); {$ELSE} (1E-60); {$ENDIF}

type
  TSexticSecondUnit = record
    class operator *(const AValue: double; const ASelf: TSexticSecondUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TSexticSecondUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TSexticSecondUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TSexticSecondUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsSexticSecondSymbol     = '%ss6';
  rsSexticSecondName       = 'sextic %ssecond';
  rsSexticSecondPluralName = 'sextic %sseconds';

const
  cSexticSecond                       = (0);
  cSexticSecondPrefixes  : TPrefixes  = (pNone);
  cSexticSecondExponents : TExponents = (6);

var
  s6         : TSexticSecondUnit;

const
  ds6        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSexticSecond; FValue: 1E-06); {$ELSE} (1E-06); {$ENDIF}
  cs6        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSexticSecond; FValue: 1E-12); {$ELSE} (1E-12); {$ENDIF}
  ms6        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSexticSecond; FValue: 1E-18); {$ELSE} (1E-18); {$ENDIF}
  mis6       : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSexticSecond; FValue: 1E-36); {$ELSE} (1E-36); {$ENDIF}
  ns6        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSexticSecond; FValue: 1E-54); {$ELSE} (1E-54); {$ENDIF}
  ps6        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSexticSecond; FValue: 1E-72); {$ELSE} (1E-72); {$ENDIF}

type
  TMeterUnit = record
    class operator *(const AValue: double; const ASelf: TMeterUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TMeterUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TMeterUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TMeterUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsMeterSymbol     = '%sm';
  rsMeterName       = '%smeter';
  rsMeterPluralName = '%smeters';

const
  cMeter                       = (0);
  cMeterPrefixes  : TPrefixes  = (pNone);
  cMeterExponents : TExponents = (1);

var
  m          : TMeterUnit;

const
  km         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cMeter; FValue: 1E+03); {$ELSE} (1E+03); {$ENDIF}
  dm         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cMeter; FValue: 1E-01); {$ELSE} (1E-01); {$ENDIF}
  cm         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cMeter; FValue: 1E-02); {$ELSE} (1E-02); {$ENDIF}
  mm         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cMeter; FValue: 1E-03); {$ELSE} (1E-03); {$ENDIF}
  mim        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cMeter; FValue: 1E-06); {$ELSE} (1E-06); {$ENDIF}
  nm         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cMeter; FValue: 1E-09); {$ELSE} (1E-09); {$ENDIF}
  pm         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cMeter; FValue: 1E-12); {$ELSE} (1E-12); {$ENDIF}

type
  TAstronomicalUnit = record
    class operator *(const AValue: double; const ASelf: TAstronomicalUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TAstronomicalUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TAstronomicalUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TAstronomicalUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsAstronomicalSymbol     = 'au';
  rsAstronomicalName       = 'astronomical unit';
  rsAstronomicalPluralName = 'astronomical units';

const
  cAstronomical                       = (0);
  cAstronomicalPrefixes  : TPrefixes  = ();
  cAstronomicalExponents : TExponents = ();

const
  au         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cMeter; FValue: 149597870691); {$ELSE} (149597870691); {$ENDIF}

type
  TInchUnit = record
    class operator *(const AValue: double; const ASelf: TInchUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TInchUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TInchUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TInchUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsInchSymbol     = 'in';
  rsInchName       = 'inch';
  rsInchPluralName = 'inches';

const
  cInch                       = (0);
  cInchPrefixes  : TPrefixes  = ();
  cInchExponents : TExponents = ();

const
  inch       : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cMeter; FValue: 0.0254); {$ELSE} (0.0254); {$ENDIF}

type
  TFootUnit = record
    class operator *(const AValue: double; const ASelf: TFootUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TFootUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TFootUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TFootUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsFootSymbol     = 'ft';
  rsFootName       = 'foot';
  rsFootPluralName = 'feet';

const
  cFoot                       = (0);
  cFootPrefixes  : TPrefixes  = ();
  cFootExponents : TExponents = ();

const
  ft         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cMeter; FValue: 0.3048); {$ELSE} (0.3048); {$ENDIF}

type
  TYardUnit = record
    class operator *(const AValue: double; const ASelf: TYardUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TYardUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TYardUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TYardUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsYardSymbol     = 'yd';
  rsYardName       = 'yard';
  rsYardPluralName = 'yards';

const
  cYard                       = (0);
  cYardPrefixes  : TPrefixes  = ();
  cYardExponents : TExponents = ();

const
  yd         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cMeter; FValue: 0.9144); {$ELSE} (0.9144); {$ENDIF}

type
  TMileUnit = record
    class operator *(const AValue: double; const ASelf: TMileUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TMileUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TMileUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TMileUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsMileSymbol     = 'mi';
  rsMileName       = 'mile';
  rsMilePluralName = 'miles';

const
  cMile                       = (0);
  cMilePrefixes  : TPrefixes  = ();
  cMileExponents : TExponents = ();

const
  mi         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cMeter; FValue: 1609.344); {$ELSE} (1609.344); {$ENDIF}

type
  TNauticalMileUnit = record
    class operator *(const AValue: double; const ASelf: TNauticalMileUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TNauticalMileUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TNauticalMileUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TNauticalMileUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsNauticalMileSymbol     = 'nmi';
  rsNauticalMileName       = 'nautical mile';
  rsNauticalMilePluralName = 'nautical miles';

const
  cNauticalMile                       = (0);
  cNauticalMilePrefixes  : TPrefixes  = ();
  cNauticalMileExponents : TExponents = ();

const
  nmi        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cMeter; FValue: 1852); {$ELSE} (1852); {$ENDIF}

type
  TAngstromUnit = record
    class operator *(const AValue: double; const ASelf: TAngstromUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TAngstromUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TAngstromUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TAngstromUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsAngstromSymbol     = '%sÅ';
  rsAngstromName       = '%sangstrom';
  rsAngstromPluralName = '%sangstroms';

const
  cAngstrom                       = (0);
  cAngstromPrefixes  : TPrefixes  = (pNone);
  cAngstromExponents : TExponents = (1);

const
  angstrom   : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cMeter; FValue: 1E-10); {$ELSE} (1E-10); {$ENDIF}

type
  TSquareRootMeterUnit = record
    class operator *(const AValue: double; const ASelf: TSquareRootMeterUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TSquareRootMeterUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TSquareRootMeterUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TSquareRootMeterUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsSquareRootMeterSymbol     = '√%sm';
  rsSquareRootMeterName       = 'square root %smeter';
  rsSquareRootMeterPluralName = 'square root %smeters';

const
  cSquareRootMeter                       = (0);
  cSquareRootMeterPrefixes  : TPrefixes  = (pNone);
  cSquareRootMeterExponents : TExponents = (1);

type
  TSquareMeterUnit = record
    class operator *(const AValue: double; const ASelf: TSquareMeterUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TSquareMeterUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TSquareMeterUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TSquareMeterUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsSquareMeterSymbol     = '%sm2';
  rsSquareMeterName       = 'square %smeter';
  rsSquareMeterPluralName = 'square %smeters';

const
  cSquareMeter                       = (0);
  cSquareMeterPrefixes  : TPrefixes  = (pNone);
  cSquareMeterExponents : TExponents = (2);

var
  m2         : TSquareMeterUnit;

const
  km2        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSquareMeter; FValue: 1E+06); {$ELSE} (1E+06); {$ENDIF}
  dm2        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSquareMeter; FValue: 1E-02); {$ELSE} (1E-02); {$ENDIF}
  cm2        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSquareMeter; FValue: 1E-04); {$ELSE} (1E-04); {$ENDIF}
  mm2        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSquareMeter; FValue: 1E-06); {$ELSE} (1E-06); {$ENDIF}
  mim2       : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSquareMeter; FValue: 1E-12); {$ELSE} (1E-12); {$ENDIF}
  nm2        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSquareMeter; FValue: 1E-18); {$ELSE} (1E-18); {$ENDIF}
  pm2        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSquareMeter; FValue: 1E-24); {$ELSE} (1E-24); {$ENDIF}

type
  TSquareInchUnit = record
    class operator *(const AValue: double; const ASelf: TSquareInchUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TSquareInchUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TSquareInchUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TSquareInchUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsSquareInchSymbol     = 'in2';
  rsSquareInchName       = 'square inch';
  rsSquareInchPluralName = 'square inches';

const
  cSquareInch                       = (0);
  cSquareInchPrefixes  : TPrefixes  = ();
  cSquareInchExponents : TExponents = ();

const
  inch2      : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSquareMeter; FValue: 0.00064516); {$ELSE} (0.00064516); {$ENDIF}

type
  TSquareFootUnit = record
    class operator *(const AValue: double; const ASelf: TSquareFootUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TSquareFootUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TSquareFootUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TSquareFootUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsSquareFootSymbol     = 'ft2';
  rsSquareFootName       = 'square foot';
  rsSquareFootPluralName = 'square feet';

const
  cSquareFoot                       = (0);
  cSquareFootPrefixes  : TPrefixes  = ();
  cSquareFootExponents : TExponents = ();

const
  ft2        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSquareMeter; FValue: 0.09290304); {$ELSE} (0.09290304); {$ENDIF}

type
  TSquareYardUnit = record
    class operator *(const AValue: double; const ASelf: TSquareYardUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TSquareYardUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TSquareYardUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TSquareYardUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsSquareYardSymbol     = 'yd2';
  rsSquareYardName       = 'square yard';
  rsSquareYardPluralName = 'square yards';

const
  cSquareYard                       = (0);
  cSquareYardPrefixes  : TPrefixes  = ();
  cSquareYardExponents : TExponents = ();

const
  yd2        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSquareMeter; FValue: 0.83612736); {$ELSE} (0.83612736); {$ENDIF}

type
  TSquareMileUnit = record
    class operator *(const AValue: double; const ASelf: TSquareMileUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TSquareMileUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TSquareMileUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TSquareMileUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsSquareMileSymbol     = 'mi2';
  rsSquareMileName       = 'square mile';
  rsSquareMilePluralName = 'square miles';

const
  cSquareMile                       = (0);
  cSquareMilePrefixes  : TPrefixes  = ();
  cSquareMileExponents : TExponents = ();

const
  mi2        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSquareMeter; FValue: 2589988.110336); {$ELSE} (2589988.110336); {$ENDIF}

type
  TCubicMeterUnit = record
    class operator *(const AValue: double; const ASelf: TCubicMeterUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TCubicMeterUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TCubicMeterUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TCubicMeterUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsCubicMeterSymbol     = '%sm3';
  rsCubicMeterName       = 'cubic %smeter';
  rsCubicMeterPluralName = 'cubic %smeters';

const
  cCubicMeter                       = (0);
  cCubicMeterPrefixes  : TPrefixes  = (pNone);
  cCubicMeterExponents : TExponents = (3);

var
  m3         : TCubicMeterUnit;

const
  km3        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cCubicMeter; FValue: 1E+09); {$ELSE} (1E+09); {$ENDIF}
  dm3        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cCubicMeter; FValue: 1E-03); {$ELSE} (1E-03); {$ENDIF}
  cm3        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cCubicMeter; FValue: 1E-06); {$ELSE} (1E-06); {$ENDIF}
  mm3        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cCubicMeter; FValue: 1E-09); {$ELSE} (1E-09); {$ENDIF}
  mim3       : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cCubicMeter; FValue: 1E-18); {$ELSE} (1E-18); {$ENDIF}
  nm3        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cCubicMeter; FValue: 1E-27); {$ELSE} (1E-27); {$ENDIF}
  pm3        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cCubicMeter; FValue: 1E-36); {$ELSE} (1E-36); {$ENDIF}

type
  TCubicInchUnit = record
    class operator *(const AValue: double; const ASelf: TCubicInchUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TCubicInchUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TCubicInchUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TCubicInchUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsCubicInchSymbol     = 'in3';
  rsCubicInchName       = 'cubic inch';
  rsCubicInchPluralName = 'cubic inches';

const
  cCubicInch                       = (0);
  cCubicInchPrefixes  : TPrefixes  = ();
  cCubicInchExponents : TExponents = ();

const
  inch3      : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cCubicMeter; FValue: 0.000016387064); {$ELSE} (0.000016387064); {$ENDIF}

type
  TCubicFootUnit = record
    class operator *(const AValue: double; const ASelf: TCubicFootUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TCubicFootUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TCubicFootUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TCubicFootUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsCubicFootSymbol     = 'ft3';
  rsCubicFootName       = 'cubic foot';
  rsCubicFootPluralName = 'cubic feet';

const
  cCubicFoot                       = (0);
  cCubicFootPrefixes  : TPrefixes  = ();
  cCubicFootExponents : TExponents = ();

const
  ft3        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cCubicMeter; FValue: 0.028316846592); {$ELSE} (0.028316846592); {$ENDIF}

type
  TCubicYardUnit = record
    class operator *(const AValue: double; const ASelf: TCubicYardUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TCubicYardUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TCubicYardUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TCubicYardUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsCubicYardSymbol     = 'yd3';
  rsCubicYardName       = 'cubic yard';
  rsCubicYardPluralName = 'cubic yards';

const
  cCubicYard                       = (0);
  cCubicYardPrefixes  : TPrefixes  = ();
  cCubicYardExponents : TExponents = ();

const
  yd3        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cCubicMeter; FValue: 0.764554857984); {$ELSE} (0.764554857984); {$ENDIF}

type
  TLitreUnit = record
    class operator *(const AValue: double; const ASelf: TLitreUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TLitreUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TLitreUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TLitreUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsLitreSymbol     = '%sL';
  rsLitreName       = '%slitre';
  rsLitrePluralName = '%slitres';

const
  cLitre                       = (0);
  cLitrePrefixes  : TPrefixes  = (pNone);
  cLitreExponents : TExponents = (1);

const
  L          : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cCubicMeter; FValue: 1E-03); {$ELSE} (1E-03); {$ENDIF}

const
  dL         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cCubicMeter; FValue: 1E-03 * 1E-01); {$ELSE} (1E-03 * 1E-01); {$ENDIF}
  cL         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cCubicMeter; FValue: 1E-03 * 1E-02); {$ELSE} (1E-03 * 1E-02); {$ENDIF}
  mL         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cCubicMeter; FValue: 1E-03 * 1E-03); {$ELSE} (1E-03 * 1E-03); {$ENDIF}

type
  TGallonUnit = record
    class operator *(const AValue: double; const ASelf: TGallonUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TGallonUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TGallonUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TGallonUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsGallonSymbol     = 'gal';
  rsGallonName       = 'gallon';
  rsGallonPluralName = 'gallons';

const
  cGallon                       = (0);
  cGallonPrefixes  : TPrefixes  = ();
  cGallonExponents : TExponents = ();

const
  gal        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cCubicMeter; FValue: 0.0037854119678); {$ELSE} (0.0037854119678); {$ENDIF}

type
  TQuarticMeterUnit = record
    class operator *(const AValue: double; const ASelf: TQuarticMeterUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TQuarticMeterUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TQuarticMeterUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TQuarticMeterUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsQuarticMeterSymbol     = '%sm4';
  rsQuarticMeterName       = 'quartic %smeter';
  rsQuarticMeterPluralName = 'quartic %smeters';

const
  cQuarticMeter                       = (0);
  cQuarticMeterPrefixes  : TPrefixes  = (pNone);
  cQuarticMeterExponents : TExponents = (4);

var
  m4         : TQuarticMeterUnit;

const
  km4        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cQuarticMeter; FValue: 1E+12); {$ELSE} (1E+12); {$ENDIF}
  dm4        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cQuarticMeter; FValue: 1E-04); {$ELSE} (1E-04); {$ENDIF}
  cm4        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cQuarticMeter; FValue: 1E-08); {$ELSE} (1E-08); {$ENDIF}
  mm4        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cQuarticMeter; FValue: 1E-12); {$ELSE} (1E-12); {$ENDIF}
  mim4       : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cQuarticMeter; FValue: 1E-24); {$ELSE} (1E-24); {$ENDIF}
  nm4        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cQuarticMeter; FValue: 1E-36); {$ELSE} (1E-36); {$ENDIF}
  pm4        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cQuarticMeter; FValue: 1E-48); {$ELSE} (1E-48); {$ENDIF}

type
  TQuinticMeterUnit = record
    class operator *(const AValue: double; const ASelf: TQuinticMeterUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TQuinticMeterUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TQuinticMeterUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TQuinticMeterUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsQuinticMeterSymbol     = '%sm5';
  rsQuinticMeterName       = 'quintic %smeter';
  rsQuinticMeterPluralName = 'quintic %smeters';

const
  cQuinticMeter                       = (0);
  cQuinticMeterPrefixes  : TPrefixes  = (pNone);
  cQuinticMeterExponents : TExponents = (5);

var
  m5         : TQuinticMeterUnit;

const
  km5        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cQuinticMeter; FValue: 1E+15); {$ELSE} (1E+15); {$ENDIF}
  dm5        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cQuinticMeter; FValue: 1E-05); {$ELSE} (1E-05); {$ENDIF}
  cm5        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cQuinticMeter; FValue: 1E-10); {$ELSE} (1E-10); {$ENDIF}
  mm5        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cQuinticMeter; FValue: 1E-15); {$ELSE} (1E-15); {$ENDIF}
  mim5       : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cQuinticMeter; FValue: 1E-30); {$ELSE} (1E-30); {$ENDIF}
  nm5        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cQuinticMeter; FValue: 1E-45); {$ELSE} (1E-45); {$ENDIF}
  pm5        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cQuinticMeter; FValue: 1E-60); {$ELSE} (1E-60); {$ENDIF}

type
  TSexticMeterUnit = record
    class operator *(const AValue: double; const ASelf: TSexticMeterUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TSexticMeterUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TSexticMeterUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TSexticMeterUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsSexticMeterSymbol     = '%sm6';
  rsSexticMeterName       = 'sextic %smeter';
  rsSexticMeterPluralName = 'sextic %smeters';

const
  cSexticMeter                       = (0);
  cSexticMeterPrefixes  : TPrefixes  = (pNone);
  cSexticMeterExponents : TExponents = (6);

var
  m6         : TSexticMeterUnit;

const
  km6        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSexticMeter; FValue: 1E+18); {$ELSE} (1E+18); {$ENDIF}
  dm6        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSexticMeter; FValue: 1E-06); {$ELSE} (1E-06); {$ENDIF}
  cm6        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSexticMeter; FValue: 1E-12); {$ELSE} (1E-12); {$ENDIF}
  mm6        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSexticMeter; FValue: 1E-18); {$ELSE} (1E-18); {$ENDIF}
  mim6       : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSexticMeter; FValue: 1E-36); {$ELSE} (1E-36); {$ENDIF}
  nm6        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSexticMeter; FValue: 1E-54); {$ELSE} (1E-54); {$ENDIF}
  pm6        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSexticMeter; FValue: 1E-72); {$ELSE} (1E-72); {$ENDIF}

type
  TKilogramUnit = record
    class operator *(const AValue: double; const ASelf: TKilogramUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TKilogramUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TKilogramUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TKilogramUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsKilogramSymbol     = '%sg';
  rsKilogramName       = '%sgram';
  rsKilogramPluralName = '%sgrams';

const
  cKilogram                       = (0);
  cKilogramPrefixes  : TPrefixes  = (pKilo);
  cKilogramExponents : TExponents = (1);

var
  kg         : TKilogramUnit;

type
  TTonneUnit = record
    class operator *(const AValue: double; const ASelf: TTonneUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TTonneUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TTonneUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TTonneUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsTonneSymbol     = '%st';
  rsTonneName       = '%stonne';
  rsTonnePluralName = '%stonnes';

const
  cTonne                       = (0);
  cTonnePrefixes  : TPrefixes  = (pNone);
  cTonneExponents : TExponents = (1);

const
  tonne      : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cKilogram; FValue: 1E+03); {$ELSE} (1E+03); {$ENDIF}

const
  gigatonne  : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cKilogram; FValue: 1E+03 * 1E+09); {$ELSE} (1E+03 * 1E+09); {$ENDIF}
  megatonne  : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cKilogram; FValue: 1E+03 * 1E+06); {$ELSE} (1E+03 * 1E+06); {$ENDIF}
  kilotonne  : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cKilogram; FValue: 1E+03 * 1E+03); {$ELSE} (1E+03 * 1E+03); {$ENDIF}

type
  TPoundUnit = record
    class operator *(const AValue: double; const ASelf: TPoundUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TPoundUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TPoundUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TPoundUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsPoundSymbol     = 'lb';
  rsPoundName       = 'pound';
  rsPoundPluralName = 'pounds';

const
  cPound                       = (0);
  cPoundPrefixes  : TPrefixes  = ();
  cPoundExponents : TExponents = ();

const
  lb         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cKilogram; FValue: 0.45359237); {$ELSE} (0.45359237); {$ENDIF}

type
  TOunceUnit = record
    class operator *(const AValue: double; const ASelf: TOunceUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TOunceUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TOunceUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TOunceUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsOunceSymbol     = 'oz';
  rsOunceName       = 'ounce';
  rsOuncePluralName = 'ounces';

const
  cOunce                       = (0);
  cOuncePrefixes  : TPrefixes  = ();
  cOunceExponents : TExponents = ();

const
  oz         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cKilogram; FValue: 0.028349523125); {$ELSE} (0.028349523125); {$ENDIF}

type
  TStoneUnit = record
    class operator *(const AValue: double; const ASelf: TStoneUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TStoneUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TStoneUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TStoneUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsStoneSymbol     = 'st';
  rsStoneName       = 'stone';
  rsStonePluralName = 'stones';

const
  cStone                       = (0);
  cStonePrefixes  : TPrefixes  = ();
  cStoneExponents : TExponents = ();

const
  st         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cKilogram; FValue: 6.35029318); {$ELSE} (6.35029318); {$ENDIF}

type
  TTonUnit = record
    class operator *(const AValue: double; const ASelf: TTonUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TTonUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TTonUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TTonUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsTonSymbol     = 'ton';
  rsTonName       = 'ton';
  rsTonPluralName = 'tons';

const
  cTon                       = (0);
  cTonPrefixes  : TPrefixes  = ();
  cTonExponents : TExponents = ();

const
  ton        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cKilogram; FValue: 907.18474); {$ELSE} (907.18474); {$ENDIF}

type
  TElectronvoltPerSquareSpeedOfLightUnit = record
    class operator *(const AValue: double; const ASelf: TElectronvoltPerSquareSpeedOfLightUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TElectronvoltPerSquareSpeedOfLightUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TElectronvoltPerSquareSpeedOfLightUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TElectronvoltPerSquareSpeedOfLightUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsElectronvoltPerSquareSpeedOfLightSymbol     = '%seV/c2';
  rsElectronvoltPerSquareSpeedOfLightName       = '%selectronvolt per squared speed of light';
  rsElectronvoltPerSquareSpeedOfLightPluralName = '%selectronvolts per squared speed of light';

const
  cElectronvoltPerSquareSpeedOfLight                       = (0);
  cElectronvoltPerSquareSpeedOfLightPrefixes  : TPrefixes  = (pNone);
  cElectronvoltPerSquareSpeedOfLightExponents : TExponents = (1);

type
  TSquareKilogramUnit = record
    class operator *(const AValue: double; const ASelf: TSquareKilogramUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TSquareKilogramUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TSquareKilogramUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TSquareKilogramUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsSquareKilogramSymbol     = '%sg2';
  rsSquareKilogramName       = 'square %sgram';
  rsSquareKilogramPluralName = 'square %sgrams';

const
  cSquareKilogram                       = (0);
  cSquareKilogramPrefixes  : TPrefixes  = (pKilo);
  cSquareKilogramExponents : TExponents = (2);

var
  kg2        : TSquareKilogramUnit;

type
  TAmpereUnit = record
    class operator *(const AValue: double; const ASelf: TAmpereUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TAmpereUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TAmpereUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TAmpereUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsAmpereSymbol     = '%sA';
  rsAmpereName       = '%sampere';
  rsAmperePluralName = '%samperes';

const
  cAmpere                       = (0);
  cAmperePrefixes  : TPrefixes  = (pNone);
  cAmpereExponents : TExponents = (1);

var
  A          : TAmpereUnit;

const
  kA         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cAmpere; FValue: 1E+03); {$ELSE} (1E+03); {$ENDIF}
  hA         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cAmpere; FValue: 1E+02); {$ELSE} (1E+02); {$ENDIF}
  daA        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cAmpere; FValue: 1E+01); {$ELSE} (1E+01); {$ENDIF}
  dA         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cAmpere; FValue: 1E-01); {$ELSE} (1E-01); {$ENDIF}
  cA         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cAmpere; FValue: 1E-02); {$ELSE} (1E-02); {$ENDIF}
  mA         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cAmpere; FValue: 1E-03); {$ELSE} (1E-03); {$ENDIF}
  miA        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cAmpere; FValue: 1E-06); {$ELSE} (1E-06); {$ENDIF}
  nA         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cAmpere; FValue: 1E-09); {$ELSE} (1E-09); {$ENDIF}
  picoA      : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cAmpere; FValue: 1E-12); {$ELSE} (1E-12); {$ENDIF}

type
  TSquareAmpereUnit = record
    class operator *(const AValue: double; const ASelf: TSquareAmpereUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TSquareAmpereUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TSquareAmpereUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TSquareAmpereUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsSquareAmpereSymbol     = '%sA2';
  rsSquareAmpereName       = 'square %sampere';
  rsSquareAmperePluralName = 'square %samperes';

const
  cSquareAmpere                       = (0);
  cSquareAmperePrefixes  : TPrefixes  = (pNone);
  cSquareAmpereExponents : TExponents = (2);

var
  A2         : TSquareAmpereUnit;

const
  kA2        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSquareAmpere; FValue: 1E+06); {$ELSE} (1E+06); {$ENDIF}
  hA2        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSquareAmpere; FValue: 1E+04); {$ELSE} (1E+04); {$ENDIF}
  daA2       : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSquareAmpere; FValue: 1E+02); {$ELSE} (1E+02); {$ENDIF}
  dA2        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSquareAmpere; FValue: 1E-02); {$ELSE} (1E-02); {$ENDIF}
  cA2        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSquareAmpere; FValue: 1E-04); {$ELSE} (1E-04); {$ENDIF}
  mA2        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSquareAmpere; FValue: 1E-06); {$ELSE} (1E-06); {$ENDIF}
  miA2       : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSquareAmpere; FValue: 1E-12); {$ELSE} (1E-12); {$ENDIF}
  nA2        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSquareAmpere; FValue: 1E-18); {$ELSE} (1E-18); {$ENDIF}
  picoA2     : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSquareAmpere; FValue: 1E-24); {$ELSE} (1E-24); {$ENDIF}

type
  TKelvinUnit = record
    class operator *(const AValue: double; const ASelf: TKelvinUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TKelvinUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TKelvinUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TKelvinUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsKelvinSymbol     = '%sK';
  rsKelvinName       = '%skelvin';
  rsKelvinPluralName = '%skelvins';

const
  cKelvin                       = (0);
  cKelvinPrefixes  : TPrefixes  = (pNone);
  cKelvinExponents : TExponents = (1);

var
  K          : TKelvinUnit;

type
  TDegreeCelsiusUnit = record
    class operator *(const AValue: double; const ASelf: TDegreeCelsiusUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TDegreeCelsiusUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TDegreeCelsiusUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TDegreeCelsiusUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsDegreeCelsiusSymbol     = 'ºC';
  rsDegreeCelsiusName       = 'degree Celsius';
  rsDegreeCelsiusPluralName = 'degrees Celsius';

const
  cDegreeCelsius                       = (0);
  cDegreeCelsiusPrefixes  : TPrefixes  = ();
  cDegreeCelsiusExponents : TExponents = ();

var
  degC       : TDegreeCelsiusUnit;

type
  TDegreeFahrenheitUnit = record
    class operator *(const AValue: double; const ASelf: TDegreeFahrenheitUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TDegreeFahrenheitUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TDegreeFahrenheitUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TDegreeFahrenheitUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsDegreeFahrenheitSymbol     = 'ºF';
  rsDegreeFahrenheitName       = 'degree Fahrenheit';
  rsDegreeFahrenheitPluralName = 'degrees Fahrenheit';

const
  cDegreeFahrenheit                       = (0);
  cDegreeFahrenheitPrefixes  : TPrefixes  = ();
  cDegreeFahrenheitExponents : TExponents = ();

var
  degF       : TDegreeFahrenheitUnit;

type
  TSquareKelvinUnit = record
    class operator *(const AValue: double; const ASelf: TSquareKelvinUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TSquareKelvinUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TSquareKelvinUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TSquareKelvinUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsSquareKelvinSymbol     = '%sK2';
  rsSquareKelvinName       = 'square %skelvin';
  rsSquareKelvinPluralName = 'square %skelvins';

const
  cSquareKelvin                       = (0);
  cSquareKelvinPrefixes  : TPrefixes  = (pNone);
  cSquareKelvinExponents : TExponents = (2);

var
  K2         : TSquareKelvinUnit;

type
  TCubicKelvinUnit = record
    class operator *(const AValue: double; const ASelf: TCubicKelvinUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TCubicKelvinUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TCubicKelvinUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TCubicKelvinUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsCubicKelvinSymbol     = '%sK3';
  rsCubicKelvinName       = 'cubic %skelvin';
  rsCubicKelvinPluralName = 'cubic %skelvins';

const
  cCubicKelvin                       = (0);
  cCubicKelvinPrefixes  : TPrefixes  = (pNone);
  cCubicKelvinExponents : TExponents = (3);

var
  K3         : TCubicKelvinUnit;

type
  TQuarticKelvinUnit = record
    class operator *(const AValue: double; const ASelf: TQuarticKelvinUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TQuarticKelvinUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TQuarticKelvinUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TQuarticKelvinUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsQuarticKelvinSymbol     = '%sK4';
  rsQuarticKelvinName       = 'quartic %skelvin';
  rsQuarticKelvinPluralName = 'quartic %skelvins';

const
  cQuarticKelvin                       = (0);
  cQuarticKelvinPrefixes  : TPrefixes  = (pNone);
  cQuarticKelvinExponents : TExponents = (4);

var
  K4         : TQuarticKelvinUnit;

type
  TMoleUnit = record
    class operator *(const AValue: double; const ASelf: TMoleUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TMoleUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TMoleUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TMoleUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsMoleSymbol     = '%smol';
  rsMoleName       = '%smole';
  rsMolePluralName = '%smoles';

const
  cMole                       = (0);
  cMolePrefixes  : TPrefixes  = (pNone);
  cMoleExponents : TExponents = (1);

var
  mol        : TMoleUnit;

const
  kmol       : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cMole; FValue: 1E+03); {$ELSE} (1E+03); {$ENDIF}
  hmol       : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cMole; FValue: 1E+02); {$ELSE} (1E+02); {$ENDIF}
  damol      : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cMole; FValue: 1E+01); {$ELSE} (1E+01); {$ENDIF}

type
  TCandelaUnit = record
    class operator *(const AValue: double; const ASelf: TCandelaUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TCandelaUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TCandelaUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TCandelaUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsCandelaSymbol     = '%scd';
  rsCandelaName       = '%scandela';
  rsCandelaPluralName = '%scandelas';

const
  cCandela                       = (0);
  cCandelaPrefixes  : TPrefixes  = (pNone);
  cCandelaExponents : TExponents = (1);

var
  cd         : TCandelaUnit;

type
  THertzUnit = record
    class operator *(const AValue: double; const ASelf: THertzUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: THertzUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: THertzUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: THertzUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsHertzSymbol     = '%sHz';
  rsHertzName       = '%shertz';
  rsHertzPluralName = '%shertz';

const
  cHertz                       = (0);
  cHertzPrefixes  : TPrefixes  = (pNone);
  cHertzExponents : TExponents = (1);

var
  Hz         : THertzUnit;

const
  THz        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cHertz; FValue: 1E+12); {$ELSE} (1E+12); {$ENDIF}
  GHz        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cHertz; FValue: 1E+09); {$ELSE} (1E+09); {$ENDIF}
  MHz        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cHertz; FValue: 1E+06); {$ELSE} (1E+06); {$ENDIF}
  kHz        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cHertz; FValue: 1E+03); {$ELSE} (1E+03); {$ENDIF}

type
  TReciprocalSecondUnit = record
    class operator *(const AValue: double; const ASelf: TReciprocalSecondUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TReciprocalSecondUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TReciprocalSecondUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TReciprocalSecondUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsReciprocalSecondSymbol     = '1/%ss';
  rsReciprocalSecondName       = 'reciprocal %ssecond';
  rsReciprocalSecondPluralName = 'reciprocal %sseconds';

const
  cReciprocalSecond                       = (0);
  cReciprocalSecondPrefixes  : TPrefixes  = (pNone);
  cReciprocalSecondExponents : TExponents = (-1);

type
  TRadianPerSecondUnit = record
    class operator *(const AValue: double; const ASelf: TRadianPerSecondUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TRadianPerSecondUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TRadianPerSecondUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TRadianPerSecondUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsRadianPerSecondSymbol     = 'rad/%ss';
  rsRadianPerSecondName       = 'radian per %ssecond';
  rsRadianPerSecondPluralName = 'radians per %ssecond';

const
  cRadianPerSecond                       = (0);
  cRadianPerSecondPrefixes  : TPrefixes  = (pNone);
  cRadianPerSecondExponents : TExponents = (-1);

type
  TSquareHertzUnit = record
    class operator *(const AValue: double; const ASelf: TSquareHertzUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TSquareHertzUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TSquareHertzUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TSquareHertzUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsSquareHertzSymbol     = '%sHz2';
  rsSquareHertzName       = 'square %shertz';
  rsSquareHertzPluralName = 'square %shertz';

const
  cSquareHertz                       = (0);
  cSquareHertzPrefixes  : TPrefixes  = (pNone);
  cSquareHertzExponents : TExponents = (2);

var
  Hz2        : TSquareHertzUnit;

const
  THz2       : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSquareHertz; FValue: 1E+24); {$ELSE} (1E+24); {$ENDIF}
  GHz2       : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSquareHertz; FValue: 1E+18); {$ELSE} (1E+18); {$ENDIF}
  MHz2       : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSquareHertz; FValue: 1E+12); {$ELSE} (1E+12); {$ENDIF}
  kHz2       : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSquareHertz; FValue: 1E+06); {$ELSE} (1E+06); {$ENDIF}

type
  TReciprocalSquareSecondUnit = record
    class operator *(const AValue: double; const ASelf: TReciprocalSquareSecondUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TReciprocalSquareSecondUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TReciprocalSquareSecondUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TReciprocalSquareSecondUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsReciprocalSquareSecondSymbol     = '1/%ss2';
  rsReciprocalSquareSecondName       = 'reciprocal square %ssecond';
  rsReciprocalSquareSecondPluralName = 'reciprocal square %sseconds';

const
  cReciprocalSquareSecond                       = (0);
  cReciprocalSquareSecondPrefixes  : TPrefixes  = (pNone);
  cReciprocalSquareSecondExponents : TExponents = (-2);

type
  TRadianPerSquareSecondUnit = record
    class operator *(const AValue: double; const ASelf: TRadianPerSquareSecondUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TRadianPerSquareSecondUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TRadianPerSquareSecondUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TRadianPerSquareSecondUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsRadianPerSquareSecondSymbol     = 'rad/%ss2';
  rsRadianPerSquareSecondName       = 'radian per square %ssecond';
  rsRadianPerSquareSecondPluralName = 'radians per square %ssecond';

const
  cRadianPerSquareSecond                       = (0);
  cRadianPerSquareSecondPrefixes  : TPrefixes  = (pNone);
  cRadianPerSquareSecondExponents : TExponents = (-2);

type
  TSteradianPerSquareSecondUnit = record
    class operator *(const AValue: double; const ASelf: TSteradianPerSquareSecondUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TSteradianPerSquareSecondUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TSteradianPerSquareSecondUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TSteradianPerSquareSecondUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsSteradianPerSquareSecondSymbol     = 'sr/%ss2';
  rsSteradianPerSquareSecondName       = 'steradian per square %ssecond';
  rsSteradianPerSquareSecondPluralName = 'steradians per square %ssecond';

const
  cSteradianPerSquareSecond                       = (0);
  cSteradianPerSquareSecondPrefixes  : TPrefixes  = (pNone);
  cSteradianPerSquareSecondExponents : TExponents = (-2);

type
  TMeterPerSecondUnit = record
    class operator *(const AValue: double; const ASelf: TMeterPerSecondUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TMeterPerSecondUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TMeterPerSecondUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TMeterPerSecondUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsMeterPerSecondSymbol     = '%sm/%ss';
  rsMeterPerSecondName       = '%smeter per %ssecond';
  rsMeterPerSecondPluralName = '%smeters per %ssecond';

const
  cMeterPerSecond                       = (0);
  cMeterPerSecondPrefixes  : TPrefixes  = (pNone, pNone);
  cMeterPerSecondExponents : TExponents = (1, -1);

type
  TMeterPerHourUnit = record
    class operator *(const AValue: double; const ASelf: TMeterPerHourUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TMeterPerHourUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TMeterPerHourUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TMeterPerHourUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsMeterPerHourSymbol     = '%sm/h';
  rsMeterPerHourName       = '%smeter per hour';
  rsMeterPerHourPluralName = '%smeters per hour';

const
  cMeterPerHour                       = (0);
  cMeterPerHourPrefixes  : TPrefixes  = (pNone);
  cMeterPerHourExponents : TExponents = (1);

type
  TMilePerHourUnit = record
    class operator *(const AValue: double; const ASelf: TMilePerHourUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TMilePerHourUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TMilePerHourUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TMilePerHourUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsMilePerHourSymbol     = 'mi/h';
  rsMilePerHourName       = 'mile per hour';
  rsMilePerHourPluralName = 'miles per hour';

const
  cMilePerHour                       = (0);
  cMilePerHourPrefixes  : TPrefixes  = ();
  cMilePerHourExponents : TExponents = ();

type
  TNauticalMilePerHourUnit = record
    class operator *(const AValue: double; const ASelf: TNauticalMilePerHourUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TNauticalMilePerHourUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TNauticalMilePerHourUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TNauticalMilePerHourUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsNauticalMilePerHourSymbol     = 'nmi/h';
  rsNauticalMilePerHourName       = 'nautical mile per hour';
  rsNauticalMilePerHourPluralName = 'nautical miles per hour';

const
  cNauticalMilePerHour                       = (0);
  cNauticalMilePerHourPrefixes  : TPrefixes  = ();
  cNauticalMilePerHourExponents : TExponents = ();

type
  TMeterPerSquareSecondUnit = record
    class operator *(const AValue: double; const ASelf: TMeterPerSquareSecondUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TMeterPerSquareSecondUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TMeterPerSquareSecondUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TMeterPerSquareSecondUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsMeterPerSquareSecondSymbol     = '%sm/%ss2';
  rsMeterPerSquareSecondName       = '%smeter per %ssecond squared';
  rsMeterPerSquareSecondPluralName = '%smeters per %ssecond squared';

const
  cMeterPerSquareSecond                       = (0);
  cMeterPerSquareSecondPrefixes  : TPrefixes  = (pNone, pNone);
  cMeterPerSquareSecondExponents : TExponents = (1, -2);

type
  TMeterPerSecondPerSecondUnit = record
    class operator *(const AValue: double; const ASelf: TMeterPerSecondPerSecondUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TMeterPerSecondPerSecondUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TMeterPerSecondPerSecondUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TMeterPerSecondPerSecondUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsMeterPerSecondPerSecondSymbol     = '%sm/%ss/%ss';
  rsMeterPerSecondPerSecondName       = '%smeter per %ssecond per %ssecond';
  rsMeterPerSecondPerSecondPluralName = '%smeters per %ssecond per %ssecond';

const
  cMeterPerSecondPerSecond                       = (0);
  cMeterPerSecondPerSecondPrefixes  : TPrefixes  = (pNone, pNone, pNone);
  cMeterPerSecondPerSecondExponents : TExponents = (1, -1, -1);

type
  TMeterPerHourPerSecondUnit = record
    class operator *(const AValue: double; const ASelf: TMeterPerHourPerSecondUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TMeterPerHourPerSecondUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TMeterPerHourPerSecondUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TMeterPerHourPerSecondUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsMeterPerHourPerSecondSymbol     = '%sm/h/%ss';
  rsMeterPerHourPerSecondName       = '%smeter per hour per %ssecond';
  rsMeterPerHourPerSecondPluralName = '%smeters per hour per %ssecond';

const
  cMeterPerHourPerSecond                       = (0);
  cMeterPerHourPerSecondPrefixes  : TPrefixes  = (pNone, pNone);
  cMeterPerHourPerSecondExponents : TExponents = (1, -1);

type
  TMeterPerCubicSecondUnit = record
    class operator *(const AValue: double; const ASelf: TMeterPerCubicSecondUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TMeterPerCubicSecondUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TMeterPerCubicSecondUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TMeterPerCubicSecondUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsMeterPerCubicSecondSymbol     = '%sm/%ss3';
  rsMeterPerCubicSecondName       = '%smeter per cubic %ssecond';
  rsMeterPerCubicSecondPluralName = '%smeters per cubic %ssecond';

const
  cMeterPerCubicSecond                       = (0);
  cMeterPerCubicSecondPrefixes  : TPrefixes  = (pNone, pNone);
  cMeterPerCubicSecondExponents : TExponents = (1, -3);

type
  TMeterPerQuarticSecondUnit = record
    class operator *(const AValue: double; const ASelf: TMeterPerQuarticSecondUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TMeterPerQuarticSecondUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TMeterPerQuarticSecondUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TMeterPerQuarticSecondUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsMeterPerQuarticSecondSymbol     = '%sm/%ss4';
  rsMeterPerQuarticSecondName       = '%smeter per quartic %ssecond';
  rsMeterPerQuarticSecondPluralName = '%smeters per quartic %ssecond';

const
  cMeterPerQuarticSecond                       = (0);
  cMeterPerQuarticSecondPrefixes  : TPrefixes  = (pNone, pNone);
  cMeterPerQuarticSecondExponents : TExponents = (1, -4);

type
  TMeterPerQuinticSecondUnit = record
    class operator *(const AValue: double; const ASelf: TMeterPerQuinticSecondUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TMeterPerQuinticSecondUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TMeterPerQuinticSecondUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TMeterPerQuinticSecondUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsMeterPerQuinticSecondSymbol     = '%sm/%ss5';
  rsMeterPerQuinticSecondName       = '%smeter per quintic %ssecond';
  rsMeterPerQuinticSecondPluralName = '%smeters per quintic %ssecond';

const
  cMeterPerQuinticSecond                       = (0);
  cMeterPerQuinticSecondPrefixes  : TPrefixes  = (pNone, pNone);
  cMeterPerQuinticSecondExponents : TExponents = (1, -5);

type
  TMeterPerSexticSecondUnit = record
    class operator *(const AValue: double; const ASelf: TMeterPerSexticSecondUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TMeterPerSexticSecondUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TMeterPerSexticSecondUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TMeterPerSexticSecondUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsMeterPerSexticSecondSymbol     = '%sm/%ss6';
  rsMeterPerSexticSecondName       = '%smeter per sextic %ssecond';
  rsMeterPerSexticSecondPluralName = '%smeters per sextic %ssecond';

const
  cMeterPerSexticSecond                       = (0);
  cMeterPerSexticSecondPrefixes  : TPrefixes  = (pNone, pNone);
  cMeterPerSexticSecondExponents : TExponents = (1, -6);

type
  TSquareMeterPerSquareSecondUnit = record
    class operator *(const AValue: double; const ASelf: TSquareMeterPerSquareSecondUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TSquareMeterPerSquareSecondUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TSquareMeterPerSquareSecondUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TSquareMeterPerSquareSecondUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsSquareMeterPerSquareSecondSymbol     = '%sm2/%ss2';
  rsSquareMeterPerSquareSecondName       = 'square %smeter per square %ssecond';
  rsSquareMeterPerSquareSecondPluralName = 'square %smeters per square %ssecond';

const
  cSquareMeterPerSquareSecond                       = (0);
  cSquareMeterPerSquareSecondPrefixes  : TPrefixes  = (pNone, pNone);
  cSquareMeterPerSquareSecondExponents : TExponents = (2, -2);

type
  TJoulePerKilogramUnit = record
    class operator *(const AValue: double; const ASelf: TJoulePerKilogramUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TJoulePerKilogramUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TJoulePerKilogramUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TJoulePerKilogramUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsJoulePerKilogramSymbol     = '%sJ/%sg';
  rsJoulePerKilogramName       = '%sjoule per %sgram';
  rsJoulePerKilogramPluralName = '%sjoules per %sgram';

const
  cJoulePerKilogram                       = (0);
  cJoulePerKilogramPrefixes  : TPrefixes  = (pNone, pKilo);
  cJoulePerKilogramExponents : TExponents = (1, -1);

type
  TGrayUnit = record
    class operator *(const AValue: double; const ASelf: TGrayUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TGrayUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TGrayUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TGrayUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsGraySymbol     = '%sGy';
  rsGrayName       = '%sgray';
  rsGrayPluralName = '%sgrays';

const
  cGray                       = (0);
  cGrayPrefixes  : TPrefixes  = (pNone);
  cGrayExponents : TExponents = (1);

var
  Gy         : TGrayUnit;

const
  kGy        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSquareMeterPerSquareSecond; FValue: 1E+03); {$ELSE} (1E+03); {$ENDIF}
  mGy        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSquareMeterPerSquareSecond; FValue: 1E-03); {$ELSE} (1E-03); {$ENDIF}
  miGy       : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSquareMeterPerSquareSecond; FValue: 1E-06); {$ELSE} (1E-06); {$ENDIF}
  nGy        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSquareMeterPerSquareSecond; FValue: 1E-09); {$ELSE} (1E-09); {$ENDIF}

type
  TSievertUnit = record
    class operator *(const AValue: double; const ASelf: TSievertUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TSievertUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TSievertUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TSievertUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsSievertSymbol     = '%sSv';
  rsSievertName       = '%ssievert';
  rsSievertPluralName = '%ssieverts';

const
  cSievert                       = (0);
  cSievertPrefixes  : TPrefixes  = (pNone);
  cSievertExponents : TExponents = (1);

var
  Sv         : TSievertUnit;

const
  kSv        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSquareMeterPerSquareSecond; FValue: 1E+03); {$ELSE} (1E+03); {$ENDIF}
  mSv        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSquareMeterPerSquareSecond; FValue: 1E-03); {$ELSE} (1E-03); {$ENDIF}
  miSv       : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSquareMeterPerSquareSecond; FValue: 1E-06); {$ELSE} (1E-06); {$ENDIF}
  nSv        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSquareMeterPerSquareSecond; FValue: 1E-09); {$ELSE} (1E-09); {$ENDIF}

type
  TMeterSecondUnit = record
    class operator *(const AValue: double; const ASelf: TMeterSecondUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TMeterSecondUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TMeterSecondUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TMeterSecondUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsMeterSecondSymbol     = '%sm.%ss';
  rsMeterSecondName       = '%smeter %ssecond';
  rsMeterSecondPluralName = '%smeter %sseconds';

const
  cMeterSecond                       = (0);
  cMeterSecondPrefixes  : TPrefixes  = (pNone, pNone);
  cMeterSecondExponents : TExponents = (1, 1);

type
  TKilogramMeterUnit = record
    class operator *(const AValue: double; const ASelf: TKilogramMeterUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TKilogramMeterUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TKilogramMeterUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TKilogramMeterUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsKilogramMeterSymbol     = '%sg.%sm';
  rsKilogramMeterName       = '%sgram %smeter';
  rsKilogramMeterPluralName = '%sgram %smeters';

const
  cKilogramMeter                       = (0);
  cKilogramMeterPrefixes  : TPrefixes  = (pKilo, pNone);
  cKilogramMeterExponents : TExponents = (1, 1);

type
  TKilogramPerSecondUnit = record
    class operator *(const AValue: double; const ASelf: TKilogramPerSecondUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TKilogramPerSecondUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TKilogramPerSecondUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TKilogramPerSecondUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsKilogramPerSecondSymbol     = '%sg/%ss';
  rsKilogramPerSecondName       = '%sgram per %ssecond';
  rsKilogramPerSecondPluralName = '%sgrams per %ssecond';

const
  cKilogramPerSecond                       = (0);
  cKilogramPerSecondPrefixes  : TPrefixes  = (pKilo, pNone);
  cKilogramPerSecondExponents : TExponents = (1, -1);

type
  TJoulePerSquareMeterPerHertzUnit = record
    class operator *(const AValue: double; const ASelf: TJoulePerSquareMeterPerHertzUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TJoulePerSquareMeterPerHertzUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TJoulePerSquareMeterPerHertzUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TJoulePerSquareMeterPerHertzUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsJoulePerSquareMeterPerHertzSymbol     = '%sJ/%sm2/%sHz';
  rsJoulePerSquareMeterPerHertzName       = '%sjoule per square %smeter per %shertz';
  rsJoulePerSquareMeterPerHertzPluralName = '%sjoules per square %smeter per %shertz';

const
  cJoulePerSquareMeterPerHertz                       = (0);
  cJoulePerSquareMeterPerHertzPrefixes  : TPrefixes  = (pNone, pNone, pNone);
  cJoulePerSquareMeterPerHertzExponents : TExponents = (1, -2, -1);

type
  TKilogramMeterPerSecondUnit = record
    class operator *(const AValue: double; const ASelf: TKilogramMeterPerSecondUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TKilogramMeterPerSecondUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TKilogramMeterPerSecondUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TKilogramMeterPerSecondUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsKilogramMeterPerSecondSymbol     = '%sg.%sm/%ss';
  rsKilogramMeterPerSecondName       = '%sgram %smeter per %ssecond';
  rsKilogramMeterPerSecondPluralName = '%sgram %smeters per %ssecond';

const
  cKilogramMeterPerSecond                       = (0);
  cKilogramMeterPerSecondPrefixes  : TPrefixes  = (pKilo, pNone, pNone);
  cKilogramMeterPerSecondExponents : TExponents = (1, 1, -1);

type
  TNewtonSecondUnit = record
    class operator *(const AValue: double; const ASelf: TNewtonSecondUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TNewtonSecondUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TNewtonSecondUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TNewtonSecondUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsNewtonSecondSymbol     = '%sN.%ss';
  rsNewtonSecondName       = '%snewton %ssecond';
  rsNewtonSecondPluralName = '%snewton %sseconds';

const
  cNewtonSecond                       = (0);
  cNewtonSecondPrefixes  : TPrefixes  = (pNone, pNone);
  cNewtonSecondExponents : TExponents = (1, 1);

type
  TSquareKilogramSquareMeterPerSquareSecondUnit = record
    class operator *(const AValue: double; const ASelf: TSquareKilogramSquareMeterPerSquareSecondUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TSquareKilogramSquareMeterPerSquareSecondUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TSquareKilogramSquareMeterPerSquareSecondUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TSquareKilogramSquareMeterPerSquareSecondUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsSquareKilogramSquareMeterPerSquareSecondSymbol     = '%sg2.%sm2/%ss2';
  rsSquareKilogramSquareMeterPerSquareSecondName       = 'square%sgram square%smeter per square%ssecond';
  rsSquareKilogramSquareMeterPerSquareSecondPluralName = 'square%sgram square%smeters per square%ssecond';

const
  cSquareKilogramSquareMeterPerSquareSecond                       = (0);
  cSquareKilogramSquareMeterPerSquareSecondPrefixes  : TPrefixes  = (pKilo, pNone, pNone);
  cSquareKilogramSquareMeterPerSquareSecondExponents : TExponents = (2, 2, -2);

type
  TReciprocalSquareRootMeterUnit = record
    class operator *(const AValue: double; const ASelf: TReciprocalSquareRootMeterUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TReciprocalSquareRootMeterUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TReciprocalSquareRootMeterUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TReciprocalSquareRootMeterUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsReciprocalSquareRootMeterSymbol     = '1/√%sm';
  rsReciprocalSquareRootMeterName       = 'reciprocal square root %smeter';
  rsReciprocalSquareRootMeterPluralName = 'reciprocal square root %smeters';

const
  cReciprocalSquareRootMeter                       = (0);
  cReciprocalSquareRootMeterPrefixes  : TPrefixes  = (pNone);
  cReciprocalSquareRootMeterExponents : TExponents = (-1);

type
  TReciprocalMeterUnit = record
    class operator *(const AValue: double; const ASelf: TReciprocalMeterUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TReciprocalMeterUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TReciprocalMeterUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TReciprocalMeterUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsReciprocalMeterSymbol     = '1/%sm';
  rsReciprocalMeterName       = 'reciprocal %smeter';
  rsReciprocalMeterPluralName = 'reciprocal %smeters';

const
  cReciprocalMeter                       = (0);
  cReciprocalMeterPrefixes  : TPrefixes  = (pNone);
  cReciprocalMeterExponents : TExponents = (-1);

type
  TDioptreUnit = record
    class operator *(const AValue: double; const ASelf: TDioptreUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TDioptreUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TDioptreUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TDioptreUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsDioptreSymbol     = 'dpt';
  rsDioptreName       = '%sdioptre';
  rsDioptrePluralName = '%sdioptres';

const
  cDioptre                       = (0);
  cDioptrePrefixes  : TPrefixes  = ();
  cDioptreExponents : TExponents = ();

type
  TReciprocalSquareRootCubicMeterUnit = record
    class operator *(const AValue: double; const ASelf: TReciprocalSquareRootCubicMeterUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TReciprocalSquareRootCubicMeterUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TReciprocalSquareRootCubicMeterUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TReciprocalSquareRootCubicMeterUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsReciprocalSquareRootCubicMeterSymbol     = '1/√%sm3';
  rsReciprocalSquareRootCubicMeterName       = 'reciprocal square root cubic %smeter';
  rsReciprocalSquareRootCubicMeterPluralName = 'reciprocal square root cubic %smeters';

const
  cReciprocalSquareRootCubicMeter                       = (0);
  cReciprocalSquareRootCubicMeterPrefixes  : TPrefixes  = (pNone);
  cReciprocalSquareRootCubicMeterExponents : TExponents = (-3);

type
  TReciprocalSquareMeterUnit = record
    class operator *(const AValue: double; const ASelf: TReciprocalSquareMeterUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TReciprocalSquareMeterUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TReciprocalSquareMeterUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TReciprocalSquareMeterUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsReciprocalSquareMeterSymbol     = '1/%sm2';
  rsReciprocalSquareMeterName       = 'reciprocal square %smeter';
  rsReciprocalSquareMeterPluralName = 'reciprocal square %smeters';

const
  cReciprocalSquareMeter                       = (0);
  cReciprocalSquareMeterPrefixes  : TPrefixes  = (pNone);
  cReciprocalSquareMeterExponents : TExponents = (-2);

type
  TReciprocalCubicMeterUnit = record
    class operator *(const AValue: double; const ASelf: TReciprocalCubicMeterUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TReciprocalCubicMeterUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TReciprocalCubicMeterUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TReciprocalCubicMeterUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsReciprocalCubicMeterSymbol     = '1/%sm3';
  rsReciprocalCubicMeterName       = 'reciprocal cubic %smeter';
  rsReciprocalCubicMeterPluralName = 'reciprocal cubic %smeters';

const
  cReciprocalCubicMeter                       = (0);
  cReciprocalCubicMeterPrefixes  : TPrefixes  = (pNone);
  cReciprocalCubicMeterExponents : TExponents = (-3);

type
  TReciprocalQuarticMeterUnit = record
    class operator *(const AValue: double; const ASelf: TReciprocalQuarticMeterUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TReciprocalQuarticMeterUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TReciprocalQuarticMeterUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TReciprocalQuarticMeterUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsReciprocalQuarticMeterSymbol     = '1/%sm4';
  rsReciprocalQuarticMeterName       = 'reciprocal quartic %smeter';
  rsReciprocalQuarticMeterPluralName = 'reciprocal quartic %smeters';

const
  cReciprocalQuarticMeter                       = (0);
  cReciprocalQuarticMeterPrefixes  : TPrefixes  = (pNone);
  cReciprocalQuarticMeterExponents : TExponents = (-4);

type
  TKilogramSquareMeterUnit = record
    class operator *(const AValue: double; const ASelf: TKilogramSquareMeterUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TKilogramSquareMeterUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TKilogramSquareMeterUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TKilogramSquareMeterUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsKilogramSquareMeterSymbol     = '%sg.%sm2';
  rsKilogramSquareMeterName       = '%sgram square %smeter';
  rsKilogramSquareMeterPluralName = '%sgram square %smeters';

const
  cKilogramSquareMeter                       = (0);
  cKilogramSquareMeterPrefixes  : TPrefixes  = (pKilo, pNone);
  cKilogramSquareMeterExponents : TExponents = (1, 2);

type
  TKilogramSquareMeterPerSecondUnit = record
    class operator *(const AValue: double; const ASelf: TKilogramSquareMeterPerSecondUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TKilogramSquareMeterPerSecondUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TKilogramSquareMeterPerSecondUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TKilogramSquareMeterPerSecondUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsKilogramSquareMeterPerSecondSymbol     = '%sg.%sm2/%ss';
  rsKilogramSquareMeterPerSecondName       = '%sgram square %smeter per %ssecond';
  rsKilogramSquareMeterPerSecondPluralName = '%sgram square %smeters per %ssecond';

const
  cKilogramSquareMeterPerSecond                       = (0);
  cKilogramSquareMeterPerSecondPrefixes  : TPrefixes  = (pKilo, pNone, pNone);
  cKilogramSquareMeterPerSecondExponents : TExponents = (1, 2, -1);

type
  TNewtonMeterSecondUnit = record
    class operator *(const AValue: double; const ASelf: TNewtonMeterSecondUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TNewtonMeterSecondUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TNewtonMeterSecondUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TNewtonMeterSecondUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsNewtonMeterSecondSymbol     = '%sN.%sm.%ss';
  rsNewtonMeterSecondName       = '%snewton %smeter %ssecond';
  rsNewtonMeterSecondPluralName = '%snewton %smeter %sseconds';

const
  cNewtonMeterSecond                       = (0);
  cNewtonMeterSecondPrefixes  : TPrefixes  = (pNone, pNone, pNone);
  cNewtonMeterSecondExponents : TExponents = (1, 1, 1);

type
  TSecondPerMeterUnit = record
    class operator *(const AValue: double; const ASelf: TSecondPerMeterUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TSecondPerMeterUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TSecondPerMeterUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TSecondPerMeterUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsSecondPerMeterSymbol     = '%ss/%sm';
  rsSecondPerMeterName       = '%ssecond per %smeter';
  rsSecondPerMeterPluralName = '%sseconds per %smeter';

const
  cSecondPerMeter                       = (0);
  cSecondPerMeterPrefixes  : TPrefixes  = (pNone, pNone);
  cSecondPerMeterExponents : TExponents = (1, -1);

type
  TKilogramPerMeterUnit = record
    class operator *(const AValue: double; const ASelf: TKilogramPerMeterUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TKilogramPerMeterUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TKilogramPerMeterUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TKilogramPerMeterUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsKilogramPerMeterSymbol     = '%sg/%sm';
  rsKilogramPerMeterName       = '%sgram per %smeter';
  rsKilogramPerMeterPluralName = '%sgrams per %smeter';

const
  cKilogramPerMeter                       = (0);
  cKilogramPerMeterPrefixes  : TPrefixes  = (pKilo, pNone);
  cKilogramPerMeterExponents : TExponents = (1, -1);

type
  TKilogramPerSquareMeterUnit = record
    class operator *(const AValue: double; const ASelf: TKilogramPerSquareMeterUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TKilogramPerSquareMeterUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TKilogramPerSquareMeterUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TKilogramPerSquareMeterUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsKilogramPerSquareMeterSymbol     = '%sg/%sm2';
  rsKilogramPerSquareMeterName       = '%sgram per square %smeter';
  rsKilogramPerSquareMeterPluralName = '%sgrams per square %smeter';

const
  cKilogramPerSquareMeter                       = (0);
  cKilogramPerSquareMeterPrefixes  : TPrefixes  = (pKilo, pNone);
  cKilogramPerSquareMeterExponents : TExponents = (1, -2);

type
  TKilogramPerCubicMeterUnit = record
    class operator *(const AValue: double; const ASelf: TKilogramPerCubicMeterUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TKilogramPerCubicMeterUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TKilogramPerCubicMeterUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TKilogramPerCubicMeterUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsKilogramPerCubicMeterSymbol     = '%sg/%sm3';
  rsKilogramPerCubicMeterName       = '%sgram per cubic %smeter';
  rsKilogramPerCubicMeterPluralName = '%sgrams per cubic %smeter';

const
  cKilogramPerCubicMeter                       = (0);
  cKilogramPerCubicMeterPrefixes  : TPrefixes  = (pKilo, pNone);
  cKilogramPerCubicMeterExponents : TExponents = (1, -3);

type
  TPoundPerCubicInchUnit = record
    class operator *(const AValue: double; const ASelf: TPoundPerCubicInchUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TPoundPerCubicInchUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TPoundPerCubicInchUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TPoundPerCubicInchUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsPoundPerCubicInchSymbol     = 'lb/in3';
  rsPoundPerCubicInchName       = 'pound per cubic inch';
  rsPoundPerCubicInchPluralName = 'pounds per cubic inch';

const
  cPoundPerCubicInch                       = (0);
  cPoundPerCubicInchPrefixes  : TPrefixes  = ();
  cPoundPerCubicInchExponents : TExponents = ();

type
  TNewtonUnit = record
    class operator *(const AValue: double; const ASelf: TNewtonUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TNewtonUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TNewtonUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TNewtonUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsNewtonSymbol     = '%sN';
  rsNewtonName       = '%snewton';
  rsNewtonPluralName = '%snewtons';

const
  cNewton                       = (0);
  cNewtonPrefixes  : TPrefixes  = (pNone);
  cNewtonExponents : TExponents = (1);

var
  N          : TNewtonUnit;

const
  GN         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cNewton; FValue: 1E+09); {$ELSE} (1E+09); {$ENDIF}
  MN         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cNewton; FValue: 1E+06); {$ELSE} (1E+06); {$ENDIF}
  kN         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cNewton; FValue: 1E+03); {$ELSE} (1E+03); {$ENDIF}
  hN         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cNewton; FValue: 1E+02); {$ELSE} (1E+02); {$ENDIF}
  daN        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cNewton; FValue: 1E+01); {$ELSE} (1E+01); {$ENDIF}

type
  TPoundForceUnit = record
    class operator *(const AValue: double; const ASelf: TPoundForceUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TPoundForceUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TPoundForceUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TPoundForceUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsPoundForceSymbol     = 'lbf';
  rsPoundForceName       = 'pound-force';
  rsPoundForcePluralName = 'pounds-force';

const
  cPoundForce                       = (0);
  cPoundForcePrefixes  : TPrefixes  = ();
  cPoundForceExponents : TExponents = ();

const
  lbf        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cNewton; FValue: 4.4482216152605); {$ELSE} (4.4482216152605); {$ENDIF}

type
  TKilogramMeterPerSquareSecondUnit = record
    class operator *(const AValue: double; const ASelf: TKilogramMeterPerSquareSecondUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TKilogramMeterPerSquareSecondUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TKilogramMeterPerSquareSecondUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TKilogramMeterPerSquareSecondUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsKilogramMeterPerSquareSecondSymbol     = '%sg.%sm/%ss2';
  rsKilogramMeterPerSquareSecondName       = '%sgram %smeter per square %ssecond';
  rsKilogramMeterPerSquareSecondPluralName = '%sgram %smeters per square %ssecond';

const
  cKilogramMeterPerSquareSecond                       = (0);
  cKilogramMeterPerSquareSecondPrefixes  : TPrefixes  = (pKilo, pNone, pNone);
  cKilogramMeterPerSquareSecondExponents : TExponents = (1, 1, -2);

type
  TNewtonRadianUnit = record
    class operator *(const AValue: double; const ASelf: TNewtonRadianUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TNewtonRadianUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TNewtonRadianUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TNewtonRadianUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsNewtonRadianSymbol     = '%sN.%srad';
  rsNewtonRadianName       = '%snewton %sradian';
  rsNewtonRadianPluralName = '%snewton %sradians';

const
  cNewtonRadian                       = (0);
  cNewtonRadianPrefixes  : TPrefixes  = (pNone, pNone);
  cNewtonRadianExponents : TExponents = (1, 1);

type
  TSquareNewtonUnit = record
    class operator *(const AValue: double; const ASelf: TSquareNewtonUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TSquareNewtonUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TSquareNewtonUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TSquareNewtonUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsSquareNewtonSymbol     = '%sN2';
  rsSquareNewtonName       = 'square %snewton';
  rsSquareNewtonPluralName = 'square %snewtons';

const
  cSquareNewton                       = (0);
  cSquareNewtonPrefixes  : TPrefixes  = (pNone);
  cSquareNewtonExponents : TExponents = (2);

var
  N2         : TSquareNewtonUnit;

const
  GN2        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSquareNewton; FValue: 1E+18); {$ELSE} (1E+18); {$ENDIF}
  MN2        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSquareNewton; FValue: 1E+12); {$ELSE} (1E+12); {$ENDIF}
  kN2        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSquareNewton; FValue: 1E+06); {$ELSE} (1E+06); {$ENDIF}
  hN2        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSquareNewton; FValue: 1E+04); {$ELSE} (1E+04); {$ENDIF}
  daN2       : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSquareNewton; FValue: 1E+02); {$ELSE} (1E+02); {$ENDIF}

type
  TSquareKilogramSquareMeterPerQuarticSecondUnit = record
    class operator *(const AValue: double; const ASelf: TSquareKilogramSquareMeterPerQuarticSecondUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TSquareKilogramSquareMeterPerQuarticSecondUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TSquareKilogramSquareMeterPerQuarticSecondUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TSquareKilogramSquareMeterPerQuarticSecondUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsSquareKilogramSquareMeterPerQuarticSecondSymbol     = '%sg2.%sm2/%ss4';
  rsSquareKilogramSquareMeterPerQuarticSecondName       = 'square %sgram square %smeter per quartic %ssecond';
  rsSquareKilogramSquareMeterPerQuarticSecondPluralName = 'square %sgram square %smeters per quartic %ssecond';

const
  cSquareKilogramSquareMeterPerQuarticSecond                       = (0);
  cSquareKilogramSquareMeterPerQuarticSecondPrefixes  : TPrefixes  = (pKilo, pNone, pNone);
  cSquareKilogramSquareMeterPerQuarticSecondExponents : TExponents = (2, 2, -4);

type
  TPascalUnit = record
    class operator *(const AValue: double; const ASelf: TPascalUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TPascalUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TPascalUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TPascalUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsPascalSymbol     = '%sPa';
  rsPascalName       = '%spascal';
  rsPascalPluralName = '%spascals';

const
  cPascal                       = (0);
  cPascalPrefixes  : TPrefixes  = (pNone);
  cPascalExponents : TExponents = (1);

var
  Pa         : TPascalUnit;

const
  TPa        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cPascal; FValue: 1E+12); {$ELSE} (1E+12); {$ENDIF}
  GPa        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cPascal; FValue: 1E+09); {$ELSE} (1E+09); {$ENDIF}
  MPa        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cPascal; FValue: 1E+06); {$ELSE} (1E+06); {$ENDIF}
  kPa        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cPascal; FValue: 1E+03); {$ELSE} (1E+03); {$ENDIF}

type
  TNewtonPerSquareMeterUnit = record
    class operator *(const AValue: double; const ASelf: TNewtonPerSquareMeterUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TNewtonPerSquareMeterUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TNewtonPerSquareMeterUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TNewtonPerSquareMeterUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsNewtonPerSquareMeterSymbol     = '%sN/%sm2';
  rsNewtonPerSquareMeterName       = '%snewton per square %smeter';
  rsNewtonPerSquareMeterPluralName = '%snewtons per square %smeter';

const
  cNewtonPerSquareMeter                       = (0);
  cNewtonPerSquareMeterPrefixes  : TPrefixes  = (pNone, pNone);
  cNewtonPerSquareMeterExponents : TExponents = (1, -2);

type
  TBarUnit = record
    class operator *(const AValue: double; const ASelf: TBarUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TBarUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TBarUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TBarUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsBarSymbol     = '%sbar';
  rsBarName       = '%sbar';
  rsBarPluralName = '%sbars';

const
  cBar                       = (0);
  cBarPrefixes  : TPrefixes  = (pNone);
  cBarExponents : TExponents = (1);

const
  bar        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cPascal; FValue: 1E+05); {$ELSE} (1E+05); {$ENDIF}

const
  kbar       : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cPascal; FValue: 1E+05 * 1E+03); {$ELSE} (1E+05 * 1E+03); {$ENDIF}
  mbar       : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cPascal; FValue: 1E+05 * 1E-03); {$ELSE} (1E+05 * 1E-03); {$ENDIF}

type
  TPoundPerSquareInchUnit = record
    class operator *(const AValue: double; const ASelf: TPoundPerSquareInchUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TPoundPerSquareInchUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TPoundPerSquareInchUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TPoundPerSquareInchUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsPoundPerSquareInchSymbol     = '%spsi';
  rsPoundPerSquareInchName       = '%spound per square inch';
  rsPoundPerSquareInchPluralName = '%spounds per square inch';

const
  cPoundPerSquareInch                       = (0);
  cPoundPerSquareInchPrefixes  : TPrefixes  = (pNone);
  cPoundPerSquareInchExponents : TExponents = (1);

const
  psi        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cPascal; FValue: 6894.75729316836); {$ELSE} (6894.75729316836); {$ENDIF}

const
  kpsi       : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cPascal; FValue: 6894.75729316836 * 1E+03); {$ELSE} (6894.75729316836 * 1E+03); {$ENDIF}

type
  TJoulePerCubicMeterUnit = record
    class operator *(const AValue: double; const ASelf: TJoulePerCubicMeterUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TJoulePerCubicMeterUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TJoulePerCubicMeterUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TJoulePerCubicMeterUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsJoulePerCubicMeterSymbol     = '%sJ/%sm3';
  rsJoulePerCubicMeterName       = '%sjoule per cubic %smeter';
  rsJoulePerCubicMeterPluralName = '%sjoules per cubic %smeter';

const
  cJoulePerCubicMeter                       = (0);
  cJoulePerCubicMeterPrefixes  : TPrefixes  = (pNone, pNone);
  cJoulePerCubicMeterExponents : TExponents = (1, -3);

type
  TKilogramPerMeterPerSquareSecondUnit = record
    class operator *(const AValue: double; const ASelf: TKilogramPerMeterPerSquareSecondUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TKilogramPerMeterPerSquareSecondUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TKilogramPerMeterPerSquareSecondUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TKilogramPerMeterPerSquareSecondUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsKilogramPerMeterPerSquareSecondSymbol     = '%sg/%sm/%ss2';
  rsKilogramPerMeterPerSquareSecondName       = '%sgram per %smeter per square %ssecond';
  rsKilogramPerMeterPerSquareSecondPluralName = '%sgrams per %smeter per square %ssecond';

const
  cKilogramPerMeterPerSquareSecond                       = (0);
  cKilogramPerMeterPerSquareSecondPrefixes  : TPrefixes  = (pKilo, pNone, pNone);
  cKilogramPerMeterPerSquareSecondExponents : TExponents = (1, -1, -2);

type
  TJouleUnit = record
    class operator *(const AValue: double; const ASelf: TJouleUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TJouleUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TJouleUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TJouleUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsJouleSymbol     = '%sJ';
  rsJouleName       = '%sjoule';
  rsJoulePluralName = '%sjoules';

const
  cJoule                       = (0);
  cJoulePrefixes  : TPrefixes  = (pNone);
  cJouleExponents : TExponents = (1);

var
  J          : TJouleUnit;

const
  TJ         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cJoule; FValue: 1E+12); {$ELSE} (1E+12); {$ENDIF}
  GJ         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cJoule; FValue: 1E+09); {$ELSE} (1E+09); {$ENDIF}
  MJ         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cJoule; FValue: 1E+06); {$ELSE} (1E+06); {$ENDIF}
  kJ         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cJoule; FValue: 1E+03); {$ELSE} (1E+03); {$ENDIF}

type
  TWattHourUnit = record
    class operator *(const AValue: double; const ASelf: TWattHourUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TWattHourUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TWattHourUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TWattHourUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsWattHourSymbol     = '%sW.h';
  rsWattHourName       = '%swatt hour';
  rsWattHourPluralName = '%swatt hours';

const
  cWattHour                       = (0);
  cWattHourPrefixes  : TPrefixes  = (pNone);
  cWattHourExponents : TExponents = (1);

type
  TWattSecondUnit = record
    class operator *(const AValue: double; const ASelf: TWattSecondUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TWattSecondUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TWattSecondUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TWattSecondUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsWattSecondSymbol     = '%sW.%ss';
  rsWattSecondName       = '%swatt %ssecond';
  rsWattSecondPluralName = '%swatt %sseconds';

const
  cWattSecond                       = (0);
  cWattSecondPrefixes  : TPrefixes  = (pNone, pNone);
  cWattSecondExponents : TExponents = (1, 1);

type
  TWattPerHertzUnit = record
    class operator *(const AValue: double; const ASelf: TWattPerHertzUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TWattPerHertzUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TWattPerHertzUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TWattPerHertzUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsWattPerHertzSymbol     = '%sW/%shz';
  rsWattPerHertzName       = '%swatt per %shertz';
  rsWattPerHertzPluralName = '%swatts per %shertz';

const
  cWattPerHertz                       = (0);
  cWattPerHertzPrefixes  : TPrefixes  = (pNone, pNone);
  cWattPerHertzExponents : TExponents = (1, -1);

type
  TElectronvoltUnit = record
    class operator *(const AValue: double; const ASelf: TElectronvoltUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TElectronvoltUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TElectronvoltUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TElectronvoltUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsElectronvoltSymbol     = '%seV';
  rsElectronvoltName       = '%selectronvolt';
  rsElectronvoltPluralName = '%selectronvolts';

const
  cElectronvolt                       = (0);
  cElectronvoltPrefixes  : TPrefixes  = (pNone);
  cElectronvoltExponents : TExponents = (1);

const
  eV         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cJoule; FValue: 1.602176634E-019); {$ELSE} (1.602176634E-019); {$ENDIF}

const
  TeV        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cJoule; FValue: 1.602176634E-019 * 1E+12); {$ELSE} (1.602176634E-019 * 1E+12); {$ENDIF}
  GeV        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cJoule; FValue: 1.602176634E-019 * 1E+09); {$ELSE} (1.602176634E-019 * 1E+09); {$ENDIF}
  MeV        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cJoule; FValue: 1.602176634E-019 * 1E+06); {$ELSE} (1.602176634E-019 * 1E+06); {$ENDIF}
  keV        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cJoule; FValue: 1.602176634E-019 * 1E+03); {$ELSE} (1.602176634E-019 * 1E+03); {$ENDIF}

type
  TNewtonMeterUnit = record
    class operator *(const AValue: double; const ASelf: TNewtonMeterUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TNewtonMeterUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TNewtonMeterUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TNewtonMeterUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsNewtonMeterSymbol     = '%sN.%sm';
  rsNewtonMeterName       = '%snewton %smeter';
  rsNewtonMeterPluralName = '%snewton %smeters';

const
  cNewtonMeter                       = (0);
  cNewtonMeterPrefixes  : TPrefixes  = (pNone, pNone);
  cNewtonMeterExponents : TExponents = (1, 1);

type
  TPoundForceInchUnit = record
    class operator *(const AValue: double; const ASelf: TPoundForceInchUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TPoundForceInchUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TPoundForceInchUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TPoundForceInchUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsPoundForceInchSymbol     = 'lbf.in';
  rsPoundForceInchName       = 'pound-force inch';
  rsPoundForceInchPluralName = 'pound-force inches';

const
  cPoundForceInch                       = (0);
  cPoundForceInchPrefixes  : TPrefixes  = ();
  cPoundForceInchExponents : TExponents = ();

type
  TRydbergUnit = record
    class operator *(const AValue: double; const ASelf: TRydbergUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TRydbergUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TRydbergUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TRydbergUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsRydbergSymbol     = '%sRy';
  rsRydbergName       = '%srydberg';
  rsRydbergPluralName = '%srydbergs';

const
  cRydberg                       = (0);
  cRydbergPrefixes  : TPrefixes  = (pNone);
  cRydbergExponents : TExponents = (1);

const
  Ry         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cJoule; FValue: 2.1798723611035E-18); {$ELSE} (2.1798723611035E-18); {$ENDIF}

type
  TCalorieUnit = record
    class operator *(const AValue: double; const ASelf: TCalorieUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TCalorieUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TCalorieUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TCalorieUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsCalorieSymbol     = '%scal';
  rsCalorieName       = '%scalorie';
  rsCaloriePluralName = '%scalories';

const
  cCalorie                       = (0);
  cCaloriePrefixes  : TPrefixes  = (pNone);
  cCalorieExponents : TExponents = (1);

const
  cal        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cJoule; FValue: 4.184); {$ELSE} (4.184); {$ENDIF}

const
  Mcal       : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cJoule; FValue: 4.184 * 1E+06); {$ELSE} (4.184 * 1E+06); {$ENDIF}
  kcal       : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cJoule; FValue: 4.184 * 1E+03); {$ELSE} (4.184 * 1E+03); {$ENDIF}

type
  TKilogramSquareMeterPerSquareSecondUnit = record
    class operator *(const AValue: double; const ASelf: TKilogramSquareMeterPerSquareSecondUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TKilogramSquareMeterPerSquareSecondUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TKilogramSquareMeterPerSquareSecondUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TKilogramSquareMeterPerSquareSecondUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsKilogramSquareMeterPerSquareSecondSymbol     = '%sg.%sm2/%ss2';
  rsKilogramSquareMeterPerSquareSecondName       = '%sgram square %smeter per square %ssecond';
  rsKilogramSquareMeterPerSquareSecondPluralName = '%sgram square %smeters per square %ssecond';

const
  cKilogramSquareMeterPerSquareSecond                       = (0);
  cKilogramSquareMeterPerSquareSecondPrefixes  : TPrefixes  = (pKilo, pNone, pNone);
  cKilogramSquareMeterPerSquareSecondExponents : TExponents = (1, 2, -2);

type
  TJoulePerRadianUnit = record
    class operator *(const AValue: double; const ASelf: TJoulePerRadianUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TJoulePerRadianUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TJoulePerRadianUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TJoulePerRadianUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsJoulePerRadianSymbol     = '%sJ/rad';
  rsJoulePerRadianName       = '%sjoule per radian';
  rsJoulePerRadianPluralName = '%sjoules per radian';

const
  cJoulePerRadian                       = (0);
  cJoulePerRadianPrefixes  : TPrefixes  = (pNone);
  cJoulePerRadianExponents : TExponents = (1);

type
  TJoulePerDegreeUnit = record
    class operator *(const AValue: double; const ASelf: TJoulePerDegreeUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TJoulePerDegreeUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TJoulePerDegreeUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TJoulePerDegreeUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsJoulePerDegreeSymbol     = '%sJ/deg';
  rsJoulePerDegreeName       = '%sjoule per degree';
  rsJoulePerDegreePluralName = '%sjoules per degree';

const
  cJoulePerDegree                       = (0);
  cJoulePerDegreePrefixes  : TPrefixes  = (pNone);
  cJoulePerDegreeExponents : TExponents = (1);

type
  TNewtonMeterPerRadianUnit = record
    class operator *(const AValue: double; const ASelf: TNewtonMeterPerRadianUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TNewtonMeterPerRadianUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TNewtonMeterPerRadianUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TNewtonMeterPerRadianUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsNewtonMeterPerRadianSymbol     = '%sN.%sm/rad';
  rsNewtonMeterPerRadianName       = '%snewton %smeter per radian';
  rsNewtonMeterPerRadianPluralName = '%snewton %smeters per radian';

const
  cNewtonMeterPerRadian                       = (0);
  cNewtonMeterPerRadianPrefixes  : TPrefixes  = (pNone, pNone);
  cNewtonMeterPerRadianExponents : TExponents = (1, 1);

type
  TNewtonMeterPerDegreeUnit = record
    class operator *(const AValue: double; const ASelf: TNewtonMeterPerDegreeUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TNewtonMeterPerDegreeUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TNewtonMeterPerDegreeUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TNewtonMeterPerDegreeUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsNewtonMeterPerDegreeSymbol     = '%sN.%sm/deg';
  rsNewtonMeterPerDegreeName       = '%snewton %smeter per degree';
  rsNewtonMeterPerDegreePluralName = '%snewton %smeters per degree';

const
  cNewtonMeterPerDegree                       = (0);
  cNewtonMeterPerDegreePrefixes  : TPrefixes  = (pNone, pNone);
  cNewtonMeterPerDegreeExponents : TExponents = (1, 1);

type
  TKilogramSquareMeterPerSquareSecondPerRadianUnit = record
    class operator *(const AValue: double; const ASelf: TKilogramSquareMeterPerSquareSecondPerRadianUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TKilogramSquareMeterPerSquareSecondPerRadianUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TKilogramSquareMeterPerSquareSecondPerRadianUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TKilogramSquareMeterPerSquareSecondPerRadianUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsKilogramSquareMeterPerSquareSecondPerRadianSymbol     = '%sg.%sm2/%ss2/rad';
  rsKilogramSquareMeterPerSquareSecondPerRadianName       = '%sgram square %smeter per square %ssecond per radian';
  rsKilogramSquareMeterPerSquareSecondPerRadianPluralName = '%sgram square %smeters per square %ssecond per radian';

const
  cKilogramSquareMeterPerSquareSecondPerRadian                       = (0);
  cKilogramSquareMeterPerSquareSecondPerRadianPrefixes  : TPrefixes  = (pKilo, pNone, pNone);
  cKilogramSquareMeterPerSquareSecondPerRadianExponents : TExponents = (1, 2, -2);

type
  TWattUnit = record
    class operator *(const AValue: double; const ASelf: TWattUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TWattUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TWattUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TWattUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsWattSymbol     = '%sW';
  rsWattName       = '%swatt';
  rsWattPluralName = '%swatts';

const
  cWatt                       = (0);
  cWattPrefixes  : TPrefixes  = (pNone);
  cWattExponents : TExponents = (1);

var
  W          : TWattUnit;

const
  TW         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cWatt; FValue: 1E+12); {$ELSE} (1E+12); {$ENDIF}
  GW         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cWatt; FValue: 1E+09); {$ELSE} (1E+09); {$ENDIF}
  MW         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cWatt; FValue: 1E+06); {$ELSE} (1E+06); {$ENDIF}
  kW         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cWatt; FValue: 1E+03); {$ELSE} (1E+03); {$ENDIF}
  milliW     : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cWatt; FValue: 1E-03); {$ELSE} (1E-03); {$ENDIF}

type
  TKilogramSquareMeterPerCubicSecondUnit = record
    class operator *(const AValue: double; const ASelf: TKilogramSquareMeterPerCubicSecondUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TKilogramSquareMeterPerCubicSecondUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TKilogramSquareMeterPerCubicSecondUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TKilogramSquareMeterPerCubicSecondUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsKilogramSquareMeterPerCubicSecondSymbol     = '%sg.%sm2/%ss3';
  rsKilogramSquareMeterPerCubicSecondName       = '%sgram square %smeter per cubic %ssecond';
  rsKilogramSquareMeterPerCubicSecondPluralName = '%sgram square %smeters per cubic %ssecond';

const
  cKilogramSquareMeterPerCubicSecond                       = (0);
  cKilogramSquareMeterPerCubicSecondPrefixes  : TPrefixes  = (pKilo, pNone, pNone);
  cKilogramSquareMeterPerCubicSecondExponents : TExponents = (1, 2, -3);

type
  TCoulombUnit = record
    class operator *(const AValue: double; const ASelf: TCoulombUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TCoulombUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TCoulombUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TCoulombUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsCoulombSymbol     = '%sC';
  rsCoulombName       = '%scoulomb';
  rsCoulombPluralName = '%scoulombs';

const
  cCoulomb                       = (0);
  cCoulombPrefixes  : TPrefixes  = (pNone);
  cCoulombExponents : TExponents = (1);

var
  C          : TCoulombUnit;

const
  kC         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cCoulomb; FValue: 1E+03); {$ELSE} (1E+03); {$ENDIF}
  hC         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cCoulomb; FValue: 1E+02); {$ELSE} (1E+02); {$ENDIF}
  daC        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cCoulomb; FValue: 1E+01); {$ELSE} (1E+01); {$ENDIF}
  dC         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cCoulomb; FValue: 1E-01); {$ELSE} (1E-01); {$ENDIF}
  cC         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cCoulomb; FValue: 1E-02); {$ELSE} (1E-02); {$ENDIF}
  mC         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cCoulomb; FValue: 1E-03); {$ELSE} (1E-03); {$ENDIF}
  miC        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cCoulomb; FValue: 1E-06); {$ELSE} (1E-06); {$ENDIF}
  nC         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cCoulomb; FValue: 1E-09); {$ELSE} (1E-09); {$ENDIF}
  pC         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cCoulomb; FValue: 1E-12); {$ELSE} (1E-12); {$ENDIF}

type
  TAmpereHourUnit = record
    class operator *(const AValue: double; const ASelf: TAmpereHourUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TAmpereHourUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TAmpereHourUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TAmpereHourUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsAmpereHourSymbol     = '%sA.h';
  rsAmpereHourName       = '%sampere hour';
  rsAmpereHourPluralName = '%sampere hours';

const
  cAmpereHour                       = (0);
  cAmpereHourPrefixes  : TPrefixes  = (pNone);
  cAmpereHourExponents : TExponents = (1);

type
  TAmpereSecondUnit = record
    class operator *(const AValue: double; const ASelf: TAmpereSecondUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TAmpereSecondUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TAmpereSecondUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TAmpereSecondUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsAmpereSecondSymbol     = '%sA.%ss';
  rsAmpereSecondName       = '%sampere %ssecond';
  rsAmpereSecondPluralName = '%sampere %sseconds';

const
  cAmpereSecond                       = (0);
  cAmpereSecondPrefixes  : TPrefixes  = (pNone, pNone);
  cAmpereSecondExponents : TExponents = (1, 1);

type
  TSquareCoulombUnit = record
    class operator *(const AValue: double; const ASelf: TSquareCoulombUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TSquareCoulombUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TSquareCoulombUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TSquareCoulombUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsSquareCoulombSymbol     = '%sC2';
  rsSquareCoulombName       = 'square %scoulomb';
  rsSquareCoulombPluralName = 'square %scoulombs';

const
  cSquareCoulomb                       = (0);
  cSquareCoulombPrefixes  : TPrefixes  = (pNone);
  cSquareCoulombExponents : TExponents = (2);

var
  C2         : TSquareCoulombUnit;

const
  kC2        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSquareCoulomb; FValue: 1E+06); {$ELSE} (1E+06); {$ENDIF}
  hC2        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSquareCoulomb; FValue: 1E+04); {$ELSE} (1E+04); {$ENDIF}
  daC2       : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSquareCoulomb; FValue: 1E+02); {$ELSE} (1E+02); {$ENDIF}
  dC2        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSquareCoulomb; FValue: 1E-02); {$ELSE} (1E-02); {$ENDIF}
  cC2        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSquareCoulomb; FValue: 1E-04); {$ELSE} (1E-04); {$ENDIF}
  mC2        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSquareCoulomb; FValue: 1E-06); {$ELSE} (1E-06); {$ENDIF}
  miC2       : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSquareCoulomb; FValue: 1E-12); {$ELSE} (1E-12); {$ENDIF}
  nC2        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSquareCoulomb; FValue: 1E-18); {$ELSE} (1E-18); {$ENDIF}
  pC2        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSquareCoulomb; FValue: 1E-24); {$ELSE} (1E-24); {$ENDIF}

type
  TSquareAmpereSquareSecondUnit = record
    class operator *(const AValue: double; const ASelf: TSquareAmpereSquareSecondUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TSquareAmpereSquareSecondUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TSquareAmpereSquareSecondUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TSquareAmpereSquareSecondUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsSquareAmpereSquareSecondSymbol     = '%sA2.%ss2';
  rsSquareAmpereSquareSecondName       = 'square %sampere square %ssecond';
  rsSquareAmpereSquareSecondPluralName = 'square %sampere square %sseconds';

const
  cSquareAmpereSquareSecond                       = (0);
  cSquareAmpereSquareSecondPrefixes  : TPrefixes  = (pNone, pNone);
  cSquareAmpereSquareSecondExponents : TExponents = (2, 2);

type
  TCoulombMeterUnit = record
    class operator *(const AValue: double; const ASelf: TCoulombMeterUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TCoulombMeterUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TCoulombMeterUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TCoulombMeterUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsCoulombMeterSymbol     = '%sC.%sm';
  rsCoulombMeterName       = '%scoulomb %smeter';
  rsCoulombMeterPluralName = '%scoulomb %smeters';

const
  cCoulombMeter                       = (0);
  cCoulombMeterPrefixes  : TPrefixes  = (pNone, pNone);
  cCoulombMeterExponents : TExponents = (1, 1);

type
  TVoltUnit = record
    class operator *(const AValue: double; const ASelf: TVoltUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TVoltUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TVoltUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TVoltUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsVoltSymbol     = '%sV';
  rsVoltName       = '%svolt';
  rsVoltPluralName = '%svolts';

const
  cVolt                       = (0);
  cVoltPrefixes  : TPrefixes  = (pNone);
  cVoltExponents : TExponents = (1);

var
  V          : TVoltUnit;

const
  kV         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cVolt; FValue: 1E+03); {$ELSE} (1E+03); {$ENDIF}
  mV         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cVolt; FValue: 1E-03); {$ELSE} (1E-03); {$ENDIF}

type
  TJoulePerCoulombUnit = record
    class operator *(const AValue: double; const ASelf: TJoulePerCoulombUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TJoulePerCoulombUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TJoulePerCoulombUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TJoulePerCoulombUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsJoulePerCoulombSymbol     = '%sJ/%sC';
  rsJoulePerCoulombName       = '%sJoule per %scoulomb';
  rsJoulePerCoulombPluralName = '%sJoules per %scoulomb';

const
  cJoulePerCoulomb                       = (0);
  cJoulePerCoulombPrefixes  : TPrefixes  = (pNone, pNone);
  cJoulePerCoulombExponents : TExponents = (1, -1);

type
  TKilogramSquareMeterPerAmperePerCubicSecondUnit = record
    class operator *(const AValue: double; const ASelf: TKilogramSquareMeterPerAmperePerCubicSecondUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TKilogramSquareMeterPerAmperePerCubicSecondUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TKilogramSquareMeterPerAmperePerCubicSecondUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TKilogramSquareMeterPerAmperePerCubicSecondUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsKilogramSquareMeterPerAmperePerCubicSecondSymbol     = '%sg.%sm2/%sA/%ss3';
  rsKilogramSquareMeterPerAmperePerCubicSecondName       = '%sgram square %smeter per %sampere per cubic %ssecond';
  rsKilogramSquareMeterPerAmperePerCubicSecondPluralName = '%sgram square %smeters per %sampere per cubic %ssecond';

const
  cKilogramSquareMeterPerAmperePerCubicSecond                       = (0);
  cKilogramSquareMeterPerAmperePerCubicSecondPrefixes  : TPrefixes  = (pKilo, pNone, pNone, pNone);
  cKilogramSquareMeterPerAmperePerCubicSecondExponents : TExponents = (1, 2, -1, -3);

type
  TSquareVoltUnit = record
    class operator *(const AValue: double; const ASelf: TSquareVoltUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TSquareVoltUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TSquareVoltUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TSquareVoltUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsSquareVoltSymbol     = '%sV2';
  rsSquareVoltName       = 'square %svolt';
  rsSquareVoltPluralName = 'square %svolts';

const
  cSquareVolt                       = (0);
  cSquareVoltPrefixes  : TPrefixes  = (pNone);
  cSquareVoltExponents : TExponents = (2);

var
  V2         : TSquareVoltUnit;

const
  kV2        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSquareVolt; FValue: 1E+06); {$ELSE} (1E+06); {$ENDIF}
  mV2        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSquareVolt; FValue: 1E-06); {$ELSE} (1E-06); {$ENDIF}

type
  TSquareKilogramQuarticMeterPerSquareAmperePerSexticSecondUnit = record
    class operator *(const AValue: double; const ASelf: TSquareKilogramQuarticMeterPerSquareAmperePerSexticSecondUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TSquareKilogramQuarticMeterPerSquareAmperePerSexticSecondUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TSquareKilogramQuarticMeterPerSquareAmperePerSexticSecondUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TSquareKilogramQuarticMeterPerSquareAmperePerSexticSecondUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsSquareKilogramQuarticMeterPerSquareAmperePerSexticSecondSymbol     = '%sg2.%sm3/%sA2/%ss6';
  rsSquareKilogramQuarticMeterPerSquareAmperePerSexticSecondName       = 'square %sgram quartic %smeter per square %sampere per sextic %ssecond';
  rsSquareKilogramQuarticMeterPerSquareAmperePerSexticSecondPluralName = 'square %sgram quartic %smeters per square %sampere per sextic %ssecond';

const
  cSquareKilogramQuarticMeterPerSquareAmperePerSexticSecond                       = (0);
  cSquareKilogramQuarticMeterPerSquareAmperePerSexticSecondPrefixes  : TPrefixes  = (pKilo, pNone, pNone, pNone);
  cSquareKilogramQuarticMeterPerSquareAmperePerSexticSecondExponents : TExponents = (2, 3, -2, -6);

type
  TFaradUnit = record
    class operator *(const AValue: double; const ASelf: TFaradUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TFaradUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TFaradUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TFaradUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsFaradSymbol     = '%sF';
  rsFaradName       = '%sfarad';
  rsFaradPluralName = '%sfarads';

const
  cFarad                       = (0);
  cFaradPrefixes  : TPrefixes  = (pNone);
  cFaradExponents : TExponents = (1);

var
  F          : TFaradUnit;

const
  mF         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cFarad; FValue: 1E-03); {$ELSE} (1E-03); {$ENDIF}
  miF        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cFarad; FValue: 1E-06); {$ELSE} (1E-06); {$ENDIF}
  nF         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cFarad; FValue: 1E-09); {$ELSE} (1E-09); {$ENDIF}
  pF         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cFarad; FValue: 1E-12); {$ELSE} (1E-12); {$ENDIF}

type
  TCoulombPerVoltUnit = record
    class operator *(const AValue: double; const ASelf: TCoulombPerVoltUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TCoulombPerVoltUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TCoulombPerVoltUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TCoulombPerVoltUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsCoulombPerVoltSymbol     = '%sC/%sV';
  rsCoulombPerVoltName       = '%scoulomb per %svolt';
  rsCoulombPerVoltPluralName = '%scoulombs per %svolt';

const
  cCoulombPerVolt                       = (0);
  cCoulombPerVoltPrefixes  : TPrefixes  = (pNone, pNone);
  cCoulombPerVoltExponents : TExponents = (1, -1);

type
  TSquareAmpereQuarticSecondPerKilogramPerSquareMeterUnit = record
    class operator *(const AValue: double; const ASelf: TSquareAmpereQuarticSecondPerKilogramPerSquareMeterUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TSquareAmpereQuarticSecondPerKilogramPerSquareMeterUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TSquareAmpereQuarticSecondPerKilogramPerSquareMeterUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TSquareAmpereQuarticSecondPerKilogramPerSquareMeterUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsSquareAmpereQuarticSecondPerKilogramPerSquareMeterSymbol     = '%sA2.%ss4/%sg/%sm2';
  rsSquareAmpereQuarticSecondPerKilogramPerSquareMeterName       = 'square %sampere quartic %ssecond per %sgram per square %smeter';
  rsSquareAmpereQuarticSecondPerKilogramPerSquareMeterPluralName = 'square %sampere quartic %sseconds per %sgram per square %smeter';

const
  cSquareAmpereQuarticSecondPerKilogramPerSquareMeter                       = (0);
  cSquareAmpereQuarticSecondPerKilogramPerSquareMeterPrefixes  : TPrefixes  = (pNone, pNone, pKilo, pNone);
  cSquareAmpereQuarticSecondPerKilogramPerSquareMeterExponents : TExponents = (2, 4, -1, -2);

type
  TOhmUnit = record
    class operator *(const AValue: double; const ASelf: TOhmUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TOhmUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TOhmUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TOhmUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsOhmSymbol     = '%sΩ';
  rsOhmName       = '%sohm';
  rsOhmPluralName = '%sohms';

const
  cOhm                       = (0);
  cOhmPrefixes  : TPrefixes  = (pNone);
  cOhmExponents : TExponents = (1);

var
  ohm        : TOhmUnit;

const
  Gohm       : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cOhm; FValue: 1E+09); {$ELSE} (1E+09); {$ENDIF}
  megaohm    : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cOhm; FValue: 1E+06); {$ELSE} (1E+06); {$ENDIF}
  kohm       : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cOhm; FValue: 1E+03); {$ELSE} (1E+03); {$ENDIF}
  mohm       : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cOhm; FValue: 1E-03); {$ELSE} (1E-03); {$ENDIF}
  miohm      : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cOhm; FValue: 1E-06); {$ELSE} (1E-06); {$ENDIF}
  nohm       : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cOhm; FValue: 1E-09); {$ELSE} (1E-09); {$ENDIF}

type
  TKilogramSquareMeterPerSquareAmperePerCubicSecondUnit = record
    class operator *(const AValue: double; const ASelf: TKilogramSquareMeterPerSquareAmperePerCubicSecondUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TKilogramSquareMeterPerSquareAmperePerCubicSecondUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TKilogramSquareMeterPerSquareAmperePerCubicSecondUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TKilogramSquareMeterPerSquareAmperePerCubicSecondUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsKilogramSquareMeterPerSquareAmperePerCubicSecondSymbol     = '%sg.%sm2/%sA/%ss3';
  rsKilogramSquareMeterPerSquareAmperePerCubicSecondName       = '%sgram square %smeter per square %sampere per cubic %ssecond';
  rsKilogramSquareMeterPerSquareAmperePerCubicSecondPluralName = '%sgram square %smeters per square %sampere per cubic %ssecond';

const
  cKilogramSquareMeterPerSquareAmperePerCubicSecond                       = (0);
  cKilogramSquareMeterPerSquareAmperePerCubicSecondPrefixes  : TPrefixes  = (pKilo, pNone, pNone, pNone);
  cKilogramSquareMeterPerSquareAmperePerCubicSecondExponents : TExponents = (1, 2, -1, -3);

type
  TSiemensUnit = record
    class operator *(const AValue: double; const ASelf: TSiemensUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TSiemensUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TSiemensUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TSiemensUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsSiemensSymbol     = '%sS';
  rsSiemensName       = '%ssiemens';
  rsSiemensPluralName = '%ssiemens';

const
  cSiemens                       = (0);
  cSiemensPrefixes  : TPrefixes  = (pNone);
  cSiemensExponents : TExponents = (1);

var
  siemens    : TSiemensUnit;

const
  millisiemens : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSiemens; FValue: 1E-03); {$ELSE} (1E-03); {$ENDIF}
  microsiemens : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSiemens; FValue: 1E-06); {$ELSE} (1E-06); {$ENDIF}
   nanosiemens : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSiemens; FValue: 1E-09); {$ELSE} (1E-09); {$ENDIF}

type
  TSquareAmpereCubicSecondPerKilogramPerSquareMeterUnit = record
    class operator *(const AValue: double; const ASelf: TSquareAmpereCubicSecondPerKilogramPerSquareMeterUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TSquareAmpereCubicSecondPerKilogramPerSquareMeterUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TSquareAmpereCubicSecondPerKilogramPerSquareMeterUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TSquareAmpereCubicSecondPerKilogramPerSquareMeterUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsSquareAmpereCubicSecondPerKilogramPerSquareMeterSymbol     = '%sA2.%ss3/%sg/%sm2';
  rsSquareAmpereCubicSecondPerKilogramPerSquareMeterName       = 'square %sampere cubic %ssecond per %sgram per square %smeter';
  rsSquareAmpereCubicSecondPerKilogramPerSquareMeterPluralName = 'square %sampere cubic %sseconds per %sgram per square %smeter';

const
  cSquareAmpereCubicSecondPerKilogramPerSquareMeter                       = (0);
  cSquareAmpereCubicSecondPerKilogramPerSquareMeterPrefixes  : TPrefixes  = (pNone, pNone, pKilo, pNone);
  cSquareAmpereCubicSecondPerKilogramPerSquareMeterExponents : TExponents = (2, 3, -1, -2);

type
  TSiemensPerMeterUnit = record
    class operator *(const AValue: double; const ASelf: TSiemensPerMeterUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TSiemensPerMeterUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TSiemensPerMeterUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TSiemensPerMeterUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsSiemensPerMeterSymbol     = '%sS/%sm';
  rsSiemensPerMeterName       = '%ssiemens per %smeter';
  rsSiemensPerMeterPluralName = '%ssiemens per %smeter';

const
  cSiemensPerMeter                       = (0);
  cSiemensPerMeterPrefixes  : TPrefixes  = (pNone, pNone);
  cSiemensPerMeterExponents : TExponents = (1, -1);

type
  TTeslaUnit = record
    class operator *(const AValue: double; const ASelf: TTeslaUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TTeslaUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TTeslaUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TTeslaUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsTeslaSymbol     = '%sT';
  rsTeslaName       = '%stesla';
  rsTeslaPluralName = '%steslas';

const
  cTesla                       = (0);
  cTeslaPrefixes  : TPrefixes  = (pNone);
  cTeslaExponents : TExponents = (1);

var
  T          : TTeslaUnit;

const
  mT         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cTesla; FValue: 1E-03); {$ELSE} (1E-03); {$ENDIF}
  miT        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cTesla; FValue: 1E-06); {$ELSE} (1E-06); {$ENDIF}
  nT         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cTesla; FValue: 1E-09); {$ELSE} (1E-09); {$ENDIF}

type
  TWeberPerSquareMeterUnit = record
    class operator *(const AValue: double; const ASelf: TWeberPerSquareMeterUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TWeberPerSquareMeterUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TWeberPerSquareMeterUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TWeberPerSquareMeterUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsWeberPerSquareMeterSymbol     = '%sWb/%m2';
  rsWeberPerSquareMeterName       = '%sweber per square %smeter';
  rsWeberPerSquareMeterPluralName = '%swebers per square %smeter';

const
  cWeberPerSquareMeter                       = (0);
  cWeberPerSquareMeterPrefixes  : TPrefixes  = (pNone);
  cWeberPerSquareMeterExponents : TExponents = (1);

type
  TKilogramPerAmperePerSquareSecondUnit = record
    class operator *(const AValue: double; const ASelf: TKilogramPerAmperePerSquareSecondUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TKilogramPerAmperePerSquareSecondUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TKilogramPerAmperePerSquareSecondUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TKilogramPerAmperePerSquareSecondUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsKilogramPerAmperePerSquareSecondSymbol     = '%sg/%sA/%ss2';
  rsKilogramPerAmperePerSquareSecondName       = '%sgram per %sampere per square %ssecond';
  rsKilogramPerAmperePerSquareSecondPluralName = '%sgrams per %sampere per square %ssecond';

const
  cKilogramPerAmperePerSquareSecond                       = (0);
  cKilogramPerAmperePerSquareSecondPrefixes  : TPrefixes  = (pKilo, pNone, pNone);
  cKilogramPerAmperePerSquareSecondExponents : TExponents = (1, -1, -2);

type
  TWeberUnit = record
    class operator *(const AValue: double; const ASelf: TWeberUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TWeberUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TWeberUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TWeberUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsWeberSymbol     = '%sWb';
  rsWeberName       = '%sweber';
  rsWeberPluralName = '%swebers';

const
  cWeber                       = (0);
  cWeberPrefixes  : TPrefixes  = (pNone);
  cWeberExponents : TExponents = (1);

var
  Wb         : TWeberUnit;

type
  TKilogramSquareMeterPerAmperePerSquareSecondUnit = record
    class operator *(const AValue: double; const ASelf: TKilogramSquareMeterPerAmperePerSquareSecondUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TKilogramSquareMeterPerAmperePerSquareSecondUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TKilogramSquareMeterPerAmperePerSquareSecondUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TKilogramSquareMeterPerAmperePerSquareSecondUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsKilogramSquareMeterPerAmperePerSquareSecondSymbol     = '%sg.%sm2/%sA/%ss2';
  rsKilogramSquareMeterPerAmperePerSquareSecondName       = '%sgram square %smeter per %sampere per square %ssecond';
  rsKilogramSquareMeterPerAmperePerSquareSecondPluralName = '%sgram square %smeters per %sampere per square %ssecond';

const
  cKilogramSquareMeterPerAmperePerSquareSecond                       = (0);
  cKilogramSquareMeterPerAmperePerSquareSecondPrefixes  : TPrefixes  = (pKilo, pNone, pNone, pNone);
  cKilogramSquareMeterPerAmperePerSquareSecondExponents : TExponents = (1, 2, -1, -2);

type
  THenryUnit = record
    class operator *(const AValue: double; const ASelf: THenryUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: THenryUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: THenryUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: THenryUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsHenrySymbol     = '%sH';
  rsHenryName       = '%shenry';
  rsHenryPluralName = '%shenries';

const
  cHenry                       = (0);
  cHenryPrefixes  : TPrefixes  = (pNone);
  cHenryExponents : TExponents = (1);

var
  H          : THenryUnit;

const
  mH         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cHenry; FValue: 1E-03); {$ELSE} (1E-03); {$ENDIF}
  miH        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cHenry; FValue: 1E-06); {$ELSE} (1E-06); {$ENDIF}
  nH         : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cHenry; FValue: 1E-09); {$ELSE} (1E-09); {$ENDIF}

type
  TKilogramSquareMeterPerSquareAmperePerSquareSecondUnit = record
    class operator *(const AValue: double; const ASelf: TKilogramSquareMeterPerSquareAmperePerSquareSecondUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TKilogramSquareMeterPerSquareAmperePerSquareSecondUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TKilogramSquareMeterPerSquareAmperePerSquareSecondUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TKilogramSquareMeterPerSquareAmperePerSquareSecondUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsKilogramSquareMeterPerSquareAmperePerSquareSecondSymbol     = '%sg.%sm2/%sA2/%ss2';
  rsKilogramSquareMeterPerSquareAmperePerSquareSecondName       = '%sgram square %smeter per square %sampere per square %ssecond';
  rsKilogramSquareMeterPerSquareAmperePerSquareSecondPluralName = '%sgram square %smeters per square %sampere per square %ssecond';

const
  cKilogramSquareMeterPerSquareAmperePerSquareSecond                       = (0);
  cKilogramSquareMeterPerSquareAmperePerSquareSecondPrefixes  : TPrefixes  = (pKilo, pNone, pNone, pNone);
  cKilogramSquareMeterPerSquareAmperePerSquareSecondExponents : TExponents = (1, 2, -2, -2);

type
  TReciprocalHenryUnit = record
    class operator *(const AValue: double; const ASelf: TReciprocalHenryUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TReciprocalHenryUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TReciprocalHenryUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TReciprocalHenryUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsReciprocalHenrySymbol     = '1/%sH';
  rsReciprocalHenryName       = 'reciprocal %shenry';
  rsReciprocalHenryPluralName = 'reciprocal %shenries';

const
  cReciprocalHenry                       = (0);
  cReciprocalHenryPrefixes  : TPrefixes  = (pNone);
  cReciprocalHenryExponents : TExponents = (-1);

type
  TLumenUnit = record
    class operator *(const AValue: double; const ASelf: TLumenUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TLumenUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TLumenUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TLumenUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsLumenSymbol     = '%slm';
  rsLumenName       = '%slumen';
  rsLumenPluralName = '%slumens';

const
  cLumen                       = (0);
  cLumenPrefixes  : TPrefixes  = (pNone);
  cLumenExponents : TExponents = (1);

var
  lm         : TLumenUnit;

type
  TCandelaSteradianUnit = record
    class operator *(const AValue: double; const ASelf: TCandelaSteradianUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TCandelaSteradianUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TCandelaSteradianUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TCandelaSteradianUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsCandelaSteradianSymbol     = '%scd.%ssr';
  rsCandelaSteradianName       = '%scandela %ssteradian';
  rsCandelaSteradianPluralName = '%scandela %ssteradians';

const
  cCandelaSteradian                       = (0);
  cCandelaSteradianPrefixes  : TPrefixes  = (pNone, pNone);
  cCandelaSteradianExponents : TExponents = (1, 1);

type
  TLumenSecondUnit = record
    class operator *(const AValue: double; const ASelf: TLumenSecondUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TLumenSecondUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TLumenSecondUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TLumenSecondUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsLumenSecondSymbol     = '%slm.%ss';
  rsLumenSecondName       = '%slumen %ssecond';
  rsLumenSecondPluralName = '%slumen %sseconds';

const
  cLumenSecond                       = (0);
  cLumenSecondPrefixes  : TPrefixes  = (pNone, pNone);
  cLumenSecondExponents : TExponents = (1, 1);

type
  TLumenSecondPerCubicMeterUnit = record
    class operator *(const AValue: double; const ASelf: TLumenSecondPerCubicMeterUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TLumenSecondPerCubicMeterUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TLumenSecondPerCubicMeterUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TLumenSecondPerCubicMeterUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsLumenSecondPerCubicMeterSymbol     = '%slm.%ss/%sm3';
  rsLumenSecondPerCubicMeterName       = '%slumen %ssecond per cubic meter';
  rsLumenSecondPerCubicMeterPluralName = '%slumen %sseconds per cubic meter';

const
  cLumenSecondPerCubicMeter                       = (0);
  cLumenSecondPerCubicMeterPrefixes  : TPrefixes  = (pNone, pNone, pNone);
  cLumenSecondPerCubicMeterExponents : TExponents = (1, 1, -3);

type
  TLuxUnit = record
    class operator *(const AValue: double; const ASelf: TLuxUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TLuxUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TLuxUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TLuxUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsLuxSymbol     = '%slx';
  rsLuxName       = '%slux';
  rsLuxPluralName = '%slux';

const
  cLux                       = (0);
  cLuxPrefixes  : TPrefixes  = (pNone);
  cLuxExponents : TExponents = (1);

var
  lx         : TLuxUnit;

type
  TCandelaSteradianPerSquareMeterUnit = record
    class operator *(const AValue: double; const ASelf: TCandelaSteradianPerSquareMeterUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TCandelaSteradianPerSquareMeterUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TCandelaSteradianPerSquareMeterUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TCandelaSteradianPerSquareMeterUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsCandelaSteradianPerSquareMeterSymbol     = '%scd.%ssr/%sm2';
  rsCandelaSteradianPerSquareMeterName       = '%scandela %ssteradian per square %smeter';
  rsCandelaSteradianPerSquareMeterPluralName = '%scandela %ssteradians per square %smeter';

const
  cCandelaSteradianPerSquareMeter                       = (0);
  cCandelaSteradianPerSquareMeterPrefixes  : TPrefixes  = (pNone, pNone, pNone);
  cCandelaSteradianPerSquareMeterExponents : TExponents = (1, 1, -2);

type
  TLuxSecondUnit = record
    class operator *(const AValue: double; const ASelf: TLuxSecondUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TLuxSecondUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TLuxSecondUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TLuxSecondUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsLuxSecondSymbol     = '%slx.%ss';
  rsLuxSecondName       = '%slux %ssecond';
  rsLuxSecondPluralName = '%slux %sseconds';

const
  cLuxSecond                       = (0);
  cLuxSecondPrefixes  : TPrefixes  = (pNone, pNone);
  cLuxSecondExponents : TExponents = (1, 1);

type
  TBequerelUnit = record
    class operator *(const AValue: double; const ASelf: TBequerelUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TBequerelUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TBequerelUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TBequerelUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsBequerelSymbol     = '%sBq';
  rsBequerelName       = '%sbequerel';
  rsBequerelPluralName = '%sbequerels';

const
  cBequerel                       = (0);
  cBequerelPrefixes  : TPrefixes  = (pNone);
  cBequerelExponents : TExponents = (1);

var
  Bq         : TBequerelUnit;

const
  kBq        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cHertz; FValue: 1E+03); {$ELSE} (1E+03); {$ENDIF}
  mBq        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cHertz; FValue: 1E-03); {$ELSE} (1E-03); {$ENDIF}
  miBq       : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cHertz; FValue: 1E-06); {$ELSE} (1E-06); {$ENDIF}
  nBq        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cHertz; FValue: 1E-09); {$ELSE} (1E-09); {$ENDIF}
  pBq        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cHertz; FValue: 1E-12); {$ELSE} (1E-12); {$ENDIF}

type
  TKatalUnit = record
    class operator *(const AValue: double; const ASelf: TKatalUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TKatalUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TKatalUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TKatalUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsKatalSymbol     = '%skat';
  rsKatalName       = '%skatal';
  rsKatalPluralName = '%skatals';

const
  cKatal                       = (0);
  cKatalPrefixes  : TPrefixes  = (pNone);
  cKatalExponents : TExponents = (1);

var
  kat        : TKatalUnit;

type
  TMolePerSecondUnit = record
    class operator *(const AValue: double; const ASelf: TMolePerSecondUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TMolePerSecondUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TMolePerSecondUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TMolePerSecondUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsMolePerSecondSymbol     = '%smol/%ss';
  rsMolePerSecondName       = '%smole per %ssecond';
  rsMolePerSecondPluralName = '%smoles per %ssecond';

const
  cMolePerSecond                       = (0);
  cMolePerSecondPrefixes  : TPrefixes  = (pNone, pNone);
  cMolePerSecondExponents : TExponents = (1, -1);

type
  TNewtonPerCubicMeterUnit = record
    class operator *(const AValue: double; const ASelf: TNewtonPerCubicMeterUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TNewtonPerCubicMeterUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TNewtonPerCubicMeterUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TNewtonPerCubicMeterUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsNewtonPerCubicMeterSymbol     = '%sN/%sm3';
  rsNewtonPerCubicMeterName       = '%snewton per cubic %smeter';
  rsNewtonPerCubicMeterPluralName = '%snewtons per cubic %smeter';

const
  cNewtonPerCubicMeter                       = (0);
  cNewtonPerCubicMeterPrefixes  : TPrefixes  = (pNone, pNone);
  cNewtonPerCubicMeterExponents : TExponents = (1, -3);

type
  TPascalPerMeterUnit = record
    class operator *(const AValue: double; const ASelf: TPascalPerMeterUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TPascalPerMeterUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TPascalPerMeterUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TPascalPerMeterUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsPascalPerMeterSymbol     = '%sPa/%sm';
  rsPascalPerMeterName       = '%spascal per %smeter';
  rsPascalPerMeterPluralName = '%spascals per %smeter';

const
  cPascalPerMeter                       = (0);
  cPascalPerMeterPrefixes  : TPrefixes  = (pNone, pNone);
  cPascalPerMeterExponents : TExponents = (1, -1);

type
  TKilogramPerSquareMeterPerSquareSecondUnit = record
    class operator *(const AValue: double; const ASelf: TKilogramPerSquareMeterPerSquareSecondUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TKilogramPerSquareMeterPerSquareSecondUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TKilogramPerSquareMeterPerSquareSecondUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TKilogramPerSquareMeterPerSquareSecondUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsKilogramPerSquareMeterPerSquareSecondSymbol     = '%sg/%sm2/%ss2';
  rsKilogramPerSquareMeterPerSquareSecondName       = '%sgram per square %smeter per square %ssecond';
  rsKilogramPerSquareMeterPerSquareSecondPluralName = '%sgrams per square %smeter per square %ssecond';

const
  cKilogramPerSquareMeterPerSquareSecond                       = (0);
  cKilogramPerSquareMeterPerSquareSecondPrefixes  : TPrefixes  = (pKilo, pNone, pNone);
  cKilogramPerSquareMeterPerSquareSecondExponents : TExponents = (1, -2, -2);

type
  TNewtonPerMeterUnit = record
    class operator *(const AValue: double; const ASelf: TNewtonPerMeterUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TNewtonPerMeterUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TNewtonPerMeterUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TNewtonPerMeterUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsNewtonPerMeterSymbol     = '%sN/%sm';
  rsNewtonPerMeterName       = '%snewton per %smeter';
  rsNewtonPerMeterPluralName = '%snewtons per %smeter';

const
  cNewtonPerMeter                       = (0);
  cNewtonPerMeterPrefixes  : TPrefixes  = (pNone, pNone);
  cNewtonPerMeterExponents : TExponents = (1, -1);

type
  TJoulePerSquareMeterUnit = record
    class operator *(const AValue: double; const ASelf: TJoulePerSquareMeterUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TJoulePerSquareMeterUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TJoulePerSquareMeterUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TJoulePerSquareMeterUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsJoulePerSquareMeterSymbol     = '%sJ/%sm2';
  rsJoulePerSquareMeterName       = '%sjoule per square %smeter';
  rsJoulePerSquareMeterPluralName = '%sjoules per square %smeter';

const
  cJoulePerSquareMeter                       = (0);
  cJoulePerSquareMeterPrefixes  : TPrefixes  = (pNone, pNone);
  cJoulePerSquareMeterExponents : TExponents = (1, -2);

type
  TWattPerSquareMeterPerHertzUnit = record
    class operator *(const AValue: double; const ASelf: TWattPerSquareMeterPerHertzUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TWattPerSquareMeterPerHertzUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TWattPerSquareMeterPerHertzUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TWattPerSquareMeterPerHertzUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsWattPerSquareMeterPerHertzSymbol     = '%sW/%sm2/%sHz';
  rsWattPerSquareMeterPerHertzName       = '%swatt per square %smeter per %shertz';
  rsWattPerSquareMeterPerHertzPluralName = '%swatts per square %smeter per %shertz';

const
  cWattPerSquareMeterPerHertz                       = (0);
  cWattPerSquareMeterPerHertzPrefixes  : TPrefixes  = (pNone, pNone, pNone);
  cWattPerSquareMeterPerHertzExponents : TExponents = (1, -2, -1);

type
  TPoundForcePerInchUnit = record
    class operator *(const AValue: double; const ASelf: TPoundForcePerInchUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TPoundForcePerInchUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TPoundForcePerInchUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TPoundForcePerInchUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsPoundForcePerInchSymbol     = 'lbf/in';
  rsPoundForcePerInchName       = 'pound-force per inch';
  rsPoundForcePerInchPluralName = 'pounds-force per inch';

const
  cPoundForcePerInch                       = (0);
  cPoundForcePerInchPrefixes  : TPrefixes  = ();
  cPoundForcePerInchExponents : TExponents = ();

type
  TKilogramPerSquareSecondUnit = record
    class operator *(const AValue: double; const ASelf: TKilogramPerSquareSecondUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TKilogramPerSquareSecondUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TKilogramPerSquareSecondUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TKilogramPerSquareSecondUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsKilogramPerSquareSecondSymbol     = '%sg/%ss2';
  rsKilogramPerSquareSecondName       = '%sgram per square %ssecond';
  rsKilogramPerSquareSecondPluralName = '%sgrams per square %ssecond';

const
  cKilogramPerSquareSecond                       = (0);
  cKilogramPerSquareSecondPrefixes  : TPrefixes  = (pKilo, pNone);
  cKilogramPerSquareSecondExponents : TExponents = (1, -2);

type
  TCubicMeterPerSecondUnit = record
    class operator *(const AValue: double; const ASelf: TCubicMeterPerSecondUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TCubicMeterPerSecondUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TCubicMeterPerSecondUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TCubicMeterPerSecondUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsCubicMeterPerSecondSymbol     = '%sm3/%ss';
  rsCubicMeterPerSecondName       = 'cubic %smeter per %ssecond';
  rsCubicMeterPerSecondPluralName = 'cubic %smeters per %ssecond';

const
  cCubicMeterPerSecond                       = (0);
  cCubicMeterPerSecondPrefixes  : TPrefixes  = (pNone, pNone);
  cCubicMeterPerSecondExponents : TExponents = (3, -1);

type
  TPoiseuilleUnit = record
    class operator *(const AValue: double; const ASelf: TPoiseuilleUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TPoiseuilleUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TPoiseuilleUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TPoiseuilleUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsPoiseuilleSymbol     = '%sPl';
  rsPoiseuilleName       = '%spoiseuille';
  rsPoiseuillePluralName = '%spoiseuilles';

const
  cPoiseuille                       = (0);
  cPoiseuillePrefixes  : TPrefixes  = (pNone);
  cPoiseuilleExponents : TExponents = (1);

var
  Pl         : TPoiseuilleUnit;

const
  cPl        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cPoiseuille; FValue: 1E-02); {$ELSE} (1E-02); {$ENDIF}
  mPl        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cPoiseuille; FValue: 1E-03); {$ELSE} (1E-03); {$ENDIF}
  miPl       : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cPoiseuille; FValue: 1E-06); {$ELSE} (1E-06); {$ENDIF}

type
  TPascalSecondUnit = record
    class operator *(const AValue: double; const ASelf: TPascalSecondUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TPascalSecondUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TPascalSecondUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TPascalSecondUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsPascalSecondSymbol     = '%sPa.%ss';
  rsPascalSecondName       = '%spascal %ssecond';
  rsPascalSecondPluralName = '%spascal %sseconds';

const
  cPascalSecond                       = (0);
  cPascalSecondPrefixes  : TPrefixes  = (pNone, pNone);
  cPascalSecondExponents : TExponents = (1, 1);

type
  TKilogramPerMeterPerSecondUnit = record
    class operator *(const AValue: double; const ASelf: TKilogramPerMeterPerSecondUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TKilogramPerMeterPerSecondUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TKilogramPerMeterPerSecondUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TKilogramPerMeterPerSecondUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsKilogramPerMeterPerSecondSymbol     = '%sg/%sm/%ss';
  rsKilogramPerMeterPerSecondName       = '%sgram per %smeter per %ssecond';
  rsKilogramPerMeterPerSecondPluralName = '%sgrams per %smeter per %ssecond';

const
  cKilogramPerMeterPerSecond                       = (0);
  cKilogramPerMeterPerSecondPrefixes  : TPrefixes  = (pKilo, pNone, pNone);
  cKilogramPerMeterPerSecondExponents : TExponents = (1, -1, -1);

type
  TSquareMeterPerSecondUnit = record
    class operator *(const AValue: double; const ASelf: TSquareMeterPerSecondUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TSquareMeterPerSecondUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TSquareMeterPerSecondUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TSquareMeterPerSecondUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsSquareMeterPerSecondSymbol     = '%sm2/%ss';
  rsSquareMeterPerSecondName       = 'square %smeter per %ssecond';
  rsSquareMeterPerSecondPluralName = 'square %smeters per %ssecond';

const
  cSquareMeterPerSecond                       = (0);
  cSquareMeterPerSecondPrefixes  : TPrefixes  = (pNone, pNone);
  cSquareMeterPerSecondExponents : TExponents = (2, -1);

type
  TKilogramPerQuarticMeterUnit = record
    class operator *(const AValue: double; const ASelf: TKilogramPerQuarticMeterUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TKilogramPerQuarticMeterUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TKilogramPerQuarticMeterUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TKilogramPerQuarticMeterUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsKilogramPerQuarticMeterSymbol     = '%sg/%sm4';
  rsKilogramPerQuarticMeterName       = '%sgram per quartic %smeter';
  rsKilogramPerQuarticMeterPluralName = '%sgrams per quartic %smeter';

const
  cKilogramPerQuarticMeter                       = (0);
  cKilogramPerQuarticMeterPrefixes  : TPrefixes  = (pKilo, pNone);
  cKilogramPerQuarticMeterExponents : TExponents = (1, -4);

type
  TQuarticMeterSecondUnit = record
    class operator *(const AValue: double; const ASelf: TQuarticMeterSecondUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TQuarticMeterSecondUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TQuarticMeterSecondUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TQuarticMeterSecondUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsQuarticMeterSecondSymbol     = '%sm4.%ss';
  rsQuarticMeterSecondName       = 'quartic %smeter %ssecond';
  rsQuarticMeterSecondPluralName = 'quartic %smeter %sseconds';

const
  cQuarticMeterSecond                       = (0);
  cQuarticMeterSecondPrefixes  : TPrefixes  = (pNone, pNone);
  cQuarticMeterSecondExponents : TExponents = (4, 1);

type
  TKilogramPerQuarticMeterPerSecondUnit = record
    class operator *(const AValue: double; const ASelf: TKilogramPerQuarticMeterPerSecondUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TKilogramPerQuarticMeterPerSecondUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TKilogramPerQuarticMeterPerSecondUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TKilogramPerQuarticMeterPerSecondUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsKilogramPerQuarticMeterPerSecondSymbol     = '%sg/%sm4/%ss';
  rsKilogramPerQuarticMeterPerSecondName       = '%sgram per quartic %smeter per %ssecond';
  rsKilogramPerQuarticMeterPerSecondPluralName = '%sgrams per quartic %smeter per %ssecond';

const
  cKilogramPerQuarticMeterPerSecond                       = (0);
  cKilogramPerQuarticMeterPerSecondPrefixes  : TPrefixes  = (pKilo, pNone, pNone);
  cKilogramPerQuarticMeterPerSecondExponents : TExponents = (1, -4, -1);

type
  TCubicMeterPerKilogramUnit = record
    class operator *(const AValue: double; const ASelf: TCubicMeterPerKilogramUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TCubicMeterPerKilogramUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TCubicMeterPerKilogramUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TCubicMeterPerKilogramUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsCubicMeterPerKilogramSymbol     = '%sm3/%sg';
  rsCubicMeterPerKilogramName       = 'cubic %smeter per %sgram';
  rsCubicMeterPerKilogramPluralName = 'cubic %smeters per %sgram';

const
  cCubicMeterPerKilogram                       = (0);
  cCubicMeterPerKilogramPrefixes  : TPrefixes  = (pNone, pKilo);
  cCubicMeterPerKilogramExponents : TExponents = (3, -1);

type
  TKilogramSquareSecondUnit = record
    class operator *(const AValue: double; const ASelf: TKilogramSquareSecondUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TKilogramSquareSecondUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TKilogramSquareSecondUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TKilogramSquareSecondUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsKilogramSquareSecondSymbol     = '%sg.%ss2';
  rsKilogramSquareSecondName       = '%sgram square %ssecond';
  rsKilogramSquareSecondPluralName = '%sgram square %sseconds';

const
  cKilogramSquareSecond                       = (0);
  cKilogramSquareSecondPrefixes  : TPrefixes  = (pKilo, pNone);
  cKilogramSquareSecondExponents : TExponents = (1, 2);

type
  TCubicMeterPerSquareSecondUnit = record
    class operator *(const AValue: double; const ASelf: TCubicMeterPerSquareSecondUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TCubicMeterPerSquareSecondUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TCubicMeterPerSquareSecondUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TCubicMeterPerSquareSecondUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsCubicMeterPerSquareSecondSymbol     = '%sm3/%ss2';
  rsCubicMeterPerSquareSecondName       = 'cubic %smeter per square %ssecond';
  rsCubicMeterPerSquareSecondPluralName = 'cubic %smeters per square %ssecond';

const
  cCubicMeterPerSquareSecond                       = (0);
  cCubicMeterPerSquareSecondPrefixes  : TPrefixes  = (pNone, pNone);
  cCubicMeterPerSquareSecondExponents : TExponents = (3, -2);

type
  TNewtonSquareMeterUnit = record
    class operator *(const AValue: double; const ASelf: TNewtonSquareMeterUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TNewtonSquareMeterUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TNewtonSquareMeterUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TNewtonSquareMeterUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsNewtonSquareMeterSymbol     = '%sN.%sm2';
  rsNewtonSquareMeterName       = '%snewton square %smeter';
  rsNewtonSquareMeterPluralName = '%snewton square %smeters';

const
  cNewtonSquareMeter                       = (0);
  cNewtonSquareMeterPrefixes  : TPrefixes  = (pNone, pNone);
  cNewtonSquareMeterExponents : TExponents = (1, 2);

type
  TKilogramCubicMeterPerSquareSecondUnit = record
    class operator *(const AValue: double; const ASelf: TKilogramCubicMeterPerSquareSecondUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TKilogramCubicMeterPerSquareSecondUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TKilogramCubicMeterPerSquareSecondUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TKilogramCubicMeterPerSquareSecondUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsKilogramCubicMeterPerSquareSecondSymbol     = '%sg.%sm3/%ss2';
  rsKilogramCubicMeterPerSquareSecondName       = '%sgram cubic %smeter per square %ssecond';
  rsKilogramCubicMeterPerSquareSecondPluralName = '%sgram cubic %smeters per square %ssecond';

const
  cKilogramCubicMeterPerSquareSecond                       = (0);
  cKilogramCubicMeterPerSquareSecondPrefixes  : TPrefixes  = (pKilo, pNone, pNone);
  cKilogramCubicMeterPerSquareSecondExponents : TExponents = (1, 3, -2);

type
  TNewtonCubicMeterUnit = record
    class operator *(const AValue: double; const ASelf: TNewtonCubicMeterUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TNewtonCubicMeterUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TNewtonCubicMeterUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TNewtonCubicMeterUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsNewtonCubicMeterSymbol     = '%sN.%sm3';
  rsNewtonCubicMeterName       = '%snewton cubic %smeter';
  rsNewtonCubicMeterPluralName = '%snewton cubic %smeters';

const
  cNewtonCubicMeter                       = (0);
  cNewtonCubicMeterPrefixes  : TPrefixes  = (pNone, pNone);
  cNewtonCubicMeterExponents : TExponents = (1, 3);

type
  TKilogramQuarticMeterPerSquareSecondUnit = record
    class operator *(const AValue: double; const ASelf: TKilogramQuarticMeterPerSquareSecondUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TKilogramQuarticMeterPerSquareSecondUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TKilogramQuarticMeterPerSquareSecondUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TKilogramQuarticMeterPerSquareSecondUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsKilogramQuarticMeterPerSquareSecondSymbol     = '%sg.%sm4/%ss2';
  rsKilogramQuarticMeterPerSquareSecondName       = '%sgram quartic %smeter per square %ssecond';
  rsKilogramQuarticMeterPerSquareSecondPluralName = '%sgram quartic %smeters per square %ssecond';

const
  cKilogramQuarticMeterPerSquareSecond                       = (0);
  cKilogramQuarticMeterPerSquareSecondPrefixes  : TPrefixes  = (pKilo, pNone, pNone);
  cKilogramQuarticMeterPerSquareSecondExponents : TExponents = (1, 4, -2);

type
  TNewtonPerSquareKilogramUnit = record
    class operator *(const AValue: double; const ASelf: TNewtonPerSquareKilogramUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TNewtonPerSquareKilogramUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TNewtonPerSquareKilogramUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TNewtonPerSquareKilogramUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsNewtonPerSquareKilogramSymbol     = '%sN/%sg2';
  rsNewtonPerSquareKilogramName       = '%snewton per square %sgram';
  rsNewtonPerSquareKilogramPluralName = '%snewtons per square %sgram';

const
  cNewtonPerSquareKilogram                       = (0);
  cNewtonPerSquareKilogramPrefixes  : TPrefixes  = (pNone, pKilo);
  cNewtonPerSquareKilogramExponents : TExponents = (1, -2);

type
  TMeterPerKilogramPerSquareSecondUnit = record
    class operator *(const AValue: double; const ASelf: TMeterPerKilogramPerSquareSecondUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TMeterPerKilogramPerSquareSecondUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TMeterPerKilogramPerSquareSecondUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TMeterPerKilogramPerSquareSecondUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsMeterPerKilogramPerSquareSecondSymbol     = '%sm/%sg/%ss2';
  rsMeterPerKilogramPerSquareSecondName       = '%smeter per %sgram per square %ssecond';
  rsMeterPerKilogramPerSquareSecondPluralName = '%smeters per %sgram per square %ssecond';

const
  cMeterPerKilogramPerSquareSecond                       = (0);
  cMeterPerKilogramPerSquareSecondPrefixes  : TPrefixes  = (pNone, pKilo, pNone);
  cMeterPerKilogramPerSquareSecondExponents : TExponents = (1, -1, -2);

type
  TSquareKilogramPerMeterUnit = record
    class operator *(const AValue: double; const ASelf: TSquareKilogramPerMeterUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TSquareKilogramPerMeterUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TSquareKilogramPerMeterUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TSquareKilogramPerMeterUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsSquareKilogramPerMeterSymbol     = '%sg2/%sm';
  rsSquareKilogramPerMeterName       = 'square %sgram per %smeter';
  rsSquareKilogramPerMeterPluralName = 'square %sgrams per %smeter';

const
  cSquareKilogramPerMeter                       = (0);
  cSquareKilogramPerMeterPrefixes  : TPrefixes  = (pKilo, pNone);
  cSquareKilogramPerMeterExponents : TExponents = (2, -1);

type
  TSquareKilogramPerSquareMeterUnit = record
    class operator *(const AValue: double; const ASelf: TSquareKilogramPerSquareMeterUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TSquareKilogramPerSquareMeterUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TSquareKilogramPerSquareMeterUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TSquareKilogramPerSquareMeterUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsSquareKilogramPerSquareMeterSymbol     = '%sg2/%sm2';
  rsSquareKilogramPerSquareMeterName       = 'square %sgram per square %smeter';
  rsSquareKilogramPerSquareMeterPluralName = 'square %sgrams per square %smeter';

const
  cSquareKilogramPerSquareMeter                       = (0);
  cSquareKilogramPerSquareMeterPrefixes  : TPrefixes  = (pKilo, pNone);
  cSquareKilogramPerSquareMeterExponents : TExponents = (2, -2);

type
  TSquareMeterPerSquareKilogramUnit = record
    class operator *(const AValue: double; const ASelf: TSquareMeterPerSquareKilogramUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TSquareMeterPerSquareKilogramUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TSquareMeterPerSquareKilogramUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TSquareMeterPerSquareKilogramUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsSquareMeterPerSquareKilogramSymbol     = '%sm2/%sg2';
  rsSquareMeterPerSquareKilogramName       = 'square %smeter per square %sgram';
  rsSquareMeterPerSquareKilogramPluralName = 'square %smeters per square %sgram';

const
  cSquareMeterPerSquareKilogram                       = (0);
  cSquareMeterPerSquareKilogramPrefixes  : TPrefixes  = (pNone, pKilo);
  cSquareMeterPerSquareKilogramExponents : TExponents = (2, -2);

type
  TNewtonSquareMeterPerSquareKilogramUnit = record
    class operator *(const AValue: double; const ASelf: TNewtonSquareMeterPerSquareKilogramUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TNewtonSquareMeterPerSquareKilogramUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TNewtonSquareMeterPerSquareKilogramUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TNewtonSquareMeterPerSquareKilogramUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsNewtonSquareMeterPerSquareKilogramSymbol     = '%sN.%sm2/%sg2';
  rsNewtonSquareMeterPerSquareKilogramName       = '%snewton square %smeter per square %sgram';
  rsNewtonSquareMeterPerSquareKilogramPluralName = '%snewton square %smeters per square %sgram';

const
  cNewtonSquareMeterPerSquareKilogram                       = (0);
  cNewtonSquareMeterPerSquareKilogramPrefixes  : TPrefixes  = (pNone, pNone, pKilo);
  cNewtonSquareMeterPerSquareKilogramExponents : TExponents = (1, 2, -2);

type
  TCubicMeterPerKilogramPerSquareSecondUnit = record
    class operator *(const AValue: double; const ASelf: TCubicMeterPerKilogramPerSquareSecondUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TCubicMeterPerKilogramPerSquareSecondUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TCubicMeterPerKilogramPerSquareSecondUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TCubicMeterPerKilogramPerSquareSecondUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsCubicMeterPerKilogramPerSquareSecondSymbol     = '%sm3/%sg/%ss2';
  rsCubicMeterPerKilogramPerSquareSecondName       = 'cubic %smeter per %sgram per square %ssecond';
  rsCubicMeterPerKilogramPerSquareSecondPluralName = 'cubic %smeters per %sgram per square %ssecond';

const
  cCubicMeterPerKilogramPerSquareSecond                       = (0);
  cCubicMeterPerKilogramPerSquareSecondPrefixes  : TPrefixes  = (pNone, pKilo, pNone);
  cCubicMeterPerKilogramPerSquareSecondExponents : TExponents = (3, -1, -2);

type
  TReciprocalKelvinUnit = record
    class operator *(const AValue: double; const ASelf: TReciprocalKelvinUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TReciprocalKelvinUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TReciprocalKelvinUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TReciprocalKelvinUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsReciprocalKelvinSymbol     = '1/%sK';
  rsReciprocalKelvinName       = 'reciprocal %skelvin';
  rsReciprocalKelvinPluralName = 'reciprocal %skelvin';

const
  cReciprocalKelvin                       = (0);
  cReciprocalKelvinPrefixes  : TPrefixes  = (pNone);
  cReciprocalKelvinExponents : TExponents = (-1);

type
  TKilogramKelvinUnit = record
    class operator *(const AValue: double; const ASelf: TKilogramKelvinUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TKilogramKelvinUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TKilogramKelvinUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TKilogramKelvinUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsKilogramKelvinSymbol     = '%sg.%sK';
  rsKilogramKelvinName       = '%sgram %skelvin';
  rsKilogramKelvinPluralName = '%sgram %skelvins';

const
  cKilogramKelvin                       = (0);
  cKilogramKelvinPrefixes  : TPrefixes  = (pKilo, pNone);
  cKilogramKelvinExponents : TExponents = (1, 1);

type
  TJoulePerKelvinUnit = record
    class operator *(const AValue: double; const ASelf: TJoulePerKelvinUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TJoulePerKelvinUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TJoulePerKelvinUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TJoulePerKelvinUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsJoulePerKelvinSymbol     = '%sJ/%sK';
  rsJoulePerKelvinName       = '%sjoule per %skelvin';
  rsJoulePerKelvinPluralName = '%sjoules per %skelvin';

const
  cJoulePerKelvin                       = (0);
  cJoulePerKelvinPrefixes  : TPrefixes  = (pNone, pNone);
  cJoulePerKelvinExponents : TExponents = (1, -1);

type
  TKilogramSquareMeterPerSquareSecondPerKelvinUnit = record
    class operator *(const AValue: double; const ASelf: TKilogramSquareMeterPerSquareSecondPerKelvinUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TKilogramSquareMeterPerSquareSecondPerKelvinUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TKilogramSquareMeterPerSquareSecondPerKelvinUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TKilogramSquareMeterPerSquareSecondPerKelvinUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsKilogramSquareMeterPerSquareSecondPerKelvinSymbol     = '%sg.%sm2/%ss2/%sK';
  rsKilogramSquareMeterPerSquareSecondPerKelvinName       = '%sgram square %smeter per square %ssecond per %skelvin';
  rsKilogramSquareMeterPerSquareSecondPerKelvinPluralName = '%sgram square %smeters per square %ssecond per %skelvin';

const
  cKilogramSquareMeterPerSquareSecondPerKelvin                       = (0);
  cKilogramSquareMeterPerSquareSecondPerKelvinPrefixes  : TPrefixes  = (pKilo, pNone, pNone, pNone);
  cKilogramSquareMeterPerSquareSecondPerKelvinExponents : TExponents = (1, 2, -2, -1);

type
  TJoulePerKilogramPerKelvinUnit = record
    class operator *(const AValue: double; const ASelf: TJoulePerKilogramPerKelvinUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TJoulePerKilogramPerKelvinUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TJoulePerKilogramPerKelvinUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TJoulePerKilogramPerKelvinUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsJoulePerKilogramPerKelvinSymbol     = '%sJ/%sg/%sK';
  rsJoulePerKilogramPerKelvinName       = '%sjoule per %sgram per %skelvin';
  rsJoulePerKilogramPerKelvinPluralName = '%sjoules per %sgram per %skelvin';

const
  cJoulePerKilogramPerKelvin                       = (0);
  cJoulePerKilogramPerKelvinPrefixes  : TPrefixes  = (pNone, pKilo, pNone);
  cJoulePerKilogramPerKelvinExponents : TExponents = (1, -1, -1);

type
  TSquareMeterPerSquareSecondPerKelvinUnit = record
    class operator *(const AValue: double; const ASelf: TSquareMeterPerSquareSecondPerKelvinUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TSquareMeterPerSquareSecondPerKelvinUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TSquareMeterPerSquareSecondPerKelvinUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TSquareMeterPerSquareSecondPerKelvinUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsSquareMeterPerSquareSecondPerKelvinSymbol     = '%sm2/%ss2/%sK';
  rsSquareMeterPerSquareSecondPerKelvinName       = 'square %smeter per square %ssecond per %skelvin';
  rsSquareMeterPerSquareSecondPerKelvinPluralName = 'square %smeters per square %ssecond per %skelvin';

const
  cSquareMeterPerSquareSecondPerKelvin                       = (0);
  cSquareMeterPerSquareSecondPerKelvinPrefixes  : TPrefixes  = (pNone, pNone, pNone);
  cSquareMeterPerSquareSecondPerKelvinExponents : TExponents = (2, -2, -1);

type
  TMeterKelvinUnit = record
    class operator *(const AValue: double; const ASelf: TMeterKelvinUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TMeterKelvinUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TMeterKelvinUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TMeterKelvinUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsMeterKelvinSymbol     = '%sm.%sK';
  rsMeterKelvinName       = '%smeter %skelvin';
  rsMeterKelvinPluralName = '%smeter %skelvins';

const
  cMeterKelvin                       = (0);
  cMeterKelvinPrefixes  : TPrefixes  = (pNone, pNone);
  cMeterKelvinExponents : TExponents = (1, 1);

type
  TKelvinPerMeterUnit = record
    class operator *(const AValue: double; const ASelf: TKelvinPerMeterUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TKelvinPerMeterUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TKelvinPerMeterUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TKelvinPerMeterUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsKelvinPerMeterSymbol     = '%sK/%sm';
  rsKelvinPerMeterName       = '%skelvin per %smeter';
  rsKelvinPerMeterPluralName = '%skelvins per %smeter';

const
  cKelvinPerMeter                       = (0);
  cKelvinPerMeterPrefixes  : TPrefixes  = (pNone, pNone);
  cKelvinPerMeterExponents : TExponents = (1, -1);

type
  TWattPerMeterUnit = record
    class operator *(const AValue: double; const ASelf: TWattPerMeterUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TWattPerMeterUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TWattPerMeterUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TWattPerMeterUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsWattPerMeterSymbol     = '%sW/%sm';
  rsWattPerMeterName       = '%swatt per %smeter';
  rsWattPerMeterPluralName = '%swatts per %smeter';

const
  cWattPerMeter                       = (0);
  cWattPerMeterPrefixes  : TPrefixes  = (pNone, pNone);
  cWattPerMeterExponents : TExponents = (1, -1);

type
  TKilogramMeterPerCubicSecondUnit = record
    class operator *(const AValue: double; const ASelf: TKilogramMeterPerCubicSecondUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TKilogramMeterPerCubicSecondUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TKilogramMeterPerCubicSecondUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TKilogramMeterPerCubicSecondUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsKilogramMeterPerCubicSecondSymbol     = '%sg.%sm/%ss3';
  rsKilogramMeterPerCubicSecondName       = '%sgram %smeter per cubic %ssecond';
  rsKilogramMeterPerCubicSecondPluralName = '%sgram %smeters per cubic %ssecond';

const
  cKilogramMeterPerCubicSecond                       = (0);
  cKilogramMeterPerCubicSecondPrefixes  : TPrefixes  = (pKilo, pNone, pNone);
  cKilogramMeterPerCubicSecondExponents : TExponents = (1, 1, -3);

type
  TWattPerSquareMeterUnit = record
    class operator *(const AValue: double; const ASelf: TWattPerSquareMeterUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TWattPerSquareMeterUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TWattPerSquareMeterUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TWattPerSquareMeterUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsWattPerSquareMeterSymbol     = '%sW/%sm2';
  rsWattPerSquareMeterName       = '%swatt per square %smeter';
  rsWattPerSquareMeterPluralName = '%swatts per square %smeter';

const
  cWattPerSquareMeter                       = (0);
  cWattPerSquareMeterPrefixes  : TPrefixes  = (pNone, pNone);
  cWattPerSquareMeterExponents : TExponents = (1, -2);

type
  TKilogramPerCubicSecondUnit = record
    class operator *(const AValue: double; const ASelf: TKilogramPerCubicSecondUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TKilogramPerCubicSecondUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TKilogramPerCubicSecondUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TKilogramPerCubicSecondUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsKilogramPerCubicSecondSymbol     = '%sg/%ss3';
  rsKilogramPerCubicSecondName       = '%sgram per cubic %ssecond';
  rsKilogramPerCubicSecondPluralName = '%sgrams per cubic %ssecond';

const
  cKilogramPerCubicSecond                       = (0);
  cKilogramPerCubicSecondPrefixes  : TPrefixes  = (pKilo, pNone);
  cKilogramPerCubicSecondExponents : TExponents = (1, -3);

type
  TWattPerCubicMeterUnit = record
    class operator *(const AValue: double; const ASelf: TWattPerCubicMeterUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TWattPerCubicMeterUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TWattPerCubicMeterUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TWattPerCubicMeterUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsWattPerCubicMeterSymbol     = '%sW/%sm3';
  rsWattPerCubicMeterName       = '%swatt per cubic %smeter';
  rsWattPerCubicMeterPluralName = '%swatts per cubic %smeter';

const
  cWattPerCubicMeter                       = (0);
  cWattPerCubicMeterPrefixes  : TPrefixes  = (pNone, pNone);
  cWattPerCubicMeterExponents : TExponents = (1, -3);

type
  TWattPerKelvinUnit = record
    class operator *(const AValue: double; const ASelf: TWattPerKelvinUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TWattPerKelvinUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TWattPerKelvinUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TWattPerKelvinUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsWattPerKelvinSymbol     = '%sW/%sK';
  rsWattPerKelvinName       = '%swatt per %skelvin';
  rsWattPerKelvinPluralName = '%swatts per %skelvin';

const
  cWattPerKelvin                       = (0);
  cWattPerKelvinPrefixes  : TPrefixes  = (pNone, pNone);
  cWattPerKelvinExponents : TExponents = (1, -1);

type
  TKilogramSquareMeterPerCubicSecondPerKelvinUnit = record
    class operator *(const AValue: double; const ASelf: TKilogramSquareMeterPerCubicSecondPerKelvinUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TKilogramSquareMeterPerCubicSecondPerKelvinUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TKilogramSquareMeterPerCubicSecondPerKelvinUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TKilogramSquareMeterPerCubicSecondPerKelvinUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsKilogramSquareMeterPerCubicSecondPerKelvinSymbol     = '%sg.%sm2/%ss3/%sK';
  rsKilogramSquareMeterPerCubicSecondPerKelvinName       = '%sgram square %smeter per cubic %ssecond per %skelvin';
  rsKilogramSquareMeterPerCubicSecondPerKelvinPluralName = '%sgram square %smeters per cubic %ssecond per %skelvin';

const
  cKilogramSquareMeterPerCubicSecondPerKelvin                       = (0);
  cKilogramSquareMeterPerCubicSecondPerKelvinPrefixes  : TPrefixes  = (pKilo, pNone, pNone, pNone);
  cKilogramSquareMeterPerCubicSecondPerKelvinExponents : TExponents = (1, 2, -3, -1);

type
  TWattPerMeterPerKelvinUnit = record
    class operator *(const AValue: double; const ASelf: TWattPerMeterPerKelvinUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TWattPerMeterPerKelvinUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TWattPerMeterPerKelvinUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TWattPerMeterPerKelvinUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsWattPerMeterPerKelvinSymbol     = '%sW/%sm/%sK';
  rsWattPerMeterPerKelvinName       = '%swatt per %smeter per %skelvin';
  rsWattPerMeterPerKelvinPluralName = '%swatts per %smeter per %skelvin';

const
  cWattPerMeterPerKelvin                       = (0);
  cWattPerMeterPerKelvinPrefixes  : TPrefixes  = (pNone, pNone, pNone);
  cWattPerMeterPerKelvinExponents : TExponents = (1, -1, -1);

type
  TKilogramMeterPerCubicSecondPerKelvinUnit = record
    class operator *(const AValue: double; const ASelf: TKilogramMeterPerCubicSecondPerKelvinUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TKilogramMeterPerCubicSecondPerKelvinUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TKilogramMeterPerCubicSecondPerKelvinUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TKilogramMeterPerCubicSecondPerKelvinUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsKilogramMeterPerCubicSecondPerKelvinSymbol     = '%sg.%sm/%ss3/%sK';
  rsKilogramMeterPerCubicSecondPerKelvinName       = '%sgram %smeter per cubic %ssecond per %skelvin';
  rsKilogramMeterPerCubicSecondPerKelvinPluralName = '%sgram %smeters per cubic %ssecond per %skelvin';

const
  cKilogramMeterPerCubicSecondPerKelvin                       = (0);
  cKilogramMeterPerCubicSecondPerKelvinPrefixes  : TPrefixes  = (pKilo, pNone, pNone, pNone);
  cKilogramMeterPerCubicSecondPerKelvinExponents : TExponents = (1, 1, -3, -1);

type
  TKelvinPerWattUnit = record
    class operator *(const AValue: double; const ASelf: TKelvinPerWattUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TKelvinPerWattUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TKelvinPerWattUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TKelvinPerWattUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsKelvinPerWattSymbol     = '%sK/%sW';
  rsKelvinPerWattName       = '%skelvin per %swatt';
  rsKelvinPerWattPluralName = '%skelvins per %swatt';

const
  cKelvinPerWatt                       = (0);
  cKelvinPerWattPrefixes  : TPrefixes  = (pNone, pNone);
  cKelvinPerWattExponents : TExponents = (1, -1);

type
  TMeterPerWattUnit = record
    class operator *(const AValue: double; const ASelf: TMeterPerWattUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TMeterPerWattUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TMeterPerWattUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TMeterPerWattUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsMeterPerWattSymbol     = '%sm/%sW';
  rsMeterPerWattName       = '%smeter per %swatt';
  rsMeterPerWattPluralName = '%smeters per %swatts';

const
  cMeterPerWatt                       = (0);
  cMeterPerWattPrefixes  : TPrefixes  = (pNone, pNone);
  cMeterPerWattExponents : TExponents = (1, -1);

type
  TMeterKelvinPerWattUnit = record
    class operator *(const AValue: double; const ASelf: TMeterKelvinPerWattUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TMeterKelvinPerWattUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TMeterKelvinPerWattUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TMeterKelvinPerWattUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsMeterKelvinPerWattSymbol     = '%sK.%sm/%sW';
  rsMeterKelvinPerWattName       = '%skelvin %smeter per %swatt';
  rsMeterKelvinPerWattPluralName = '%skelvin %smeters per %swatt';

const
  cMeterKelvinPerWatt                       = (0);
  cMeterKelvinPerWattPrefixes  : TPrefixes  = (pNone, pNone, pNone);
  cMeterKelvinPerWattExponents : TExponents = (1, 1, -1);

type
  TSquareMeterKelvinUnit = record
    class operator *(const AValue: double; const ASelf: TSquareMeterKelvinUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TSquareMeterKelvinUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TSquareMeterKelvinUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TSquareMeterKelvinUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsSquareMeterKelvinSymbol     = '%sm2.%sK';
  rsSquareMeterKelvinName       = 'square %smeter %skelvin';
  rsSquareMeterKelvinPluralName = 'square %smeter %skelvins';

const
  cSquareMeterKelvin                       = (0);
  cSquareMeterKelvinPrefixes  : TPrefixes  = (pNone, pNone);
  cSquareMeterKelvinExponents : TExponents = (2, 1);

type
  TWattPerSquareMeterPerKelvinUnit = record
    class operator *(const AValue: double; const ASelf: TWattPerSquareMeterPerKelvinUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TWattPerSquareMeterPerKelvinUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TWattPerSquareMeterPerKelvinUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TWattPerSquareMeterPerKelvinUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsWattPerSquareMeterPerKelvinSymbol     = '%sW/%sm2/%sK';
  rsWattPerSquareMeterPerKelvinName       = '%swatt per square %smeter per %skelvin';
  rsWattPerSquareMeterPerKelvinPluralName = '%swatts per square %smeter per %skelvin';

const
  cWattPerSquareMeterPerKelvin                       = (0);
  cWattPerSquareMeterPerKelvinPrefixes  : TPrefixes  = (pNone, pNone, pNone);
  cWattPerSquareMeterPerKelvinExponents : TExponents = (1, -2, -1);

type
  TKilogramPerCubicSecondPerKelvinUnit = record
    class operator *(const AValue: double; const ASelf: TKilogramPerCubicSecondPerKelvinUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TKilogramPerCubicSecondPerKelvinUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TKilogramPerCubicSecondPerKelvinUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TKilogramPerCubicSecondPerKelvinUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsKilogramPerCubicSecondPerKelvinSymbol     = '%sg/%ss3/%sK';
  rsKilogramPerCubicSecondPerKelvinName       = '%sgram per cubic %ssecond per %skelvin';
  rsKilogramPerCubicSecondPerKelvinPluralName = '%sgrams per cubic %ssecond per %skelvin';

const
  cKilogramPerCubicSecondPerKelvin                       = (0);
  cKilogramPerCubicSecondPerKelvinPrefixes  : TPrefixes  = (pKilo, pNone, pNone);
  cKilogramPerCubicSecondPerKelvinExponents : TExponents = (1, -3, -1);

type
  TSquareMeterQuarticKelvinUnit = record
    class operator *(const AValue: double; const ASelf: TSquareMeterQuarticKelvinUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TSquareMeterQuarticKelvinUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TSquareMeterQuarticKelvinUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TSquareMeterQuarticKelvinUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsSquareMeterQuarticKelvinSymbol     = '%sm2.%sK4';
  rsSquareMeterQuarticKelvinName       = 'square %smeter quartic %skelvin';
  rsSquareMeterQuarticKelvinPluralName = 'square %smeter quartic %skelvins';

const
  cSquareMeterQuarticKelvin                       = (0);
  cSquareMeterQuarticKelvinPrefixes  : TPrefixes  = (pNone, pNone);
  cSquareMeterQuarticKelvinExponents : TExponents = (2, 4);

type
  TWattPerQuarticKelvinUnit = record
    class operator *(const AValue: double; const ASelf: TWattPerQuarticKelvinUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TWattPerQuarticKelvinUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TWattPerQuarticKelvinUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TWattPerQuarticKelvinUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsWattPerQuarticKelvinSymbol     = '%sW/%sK4';
  rsWattPerQuarticKelvinName       = '%swatt per quartic %skelvin';
  rsWattPerQuarticKelvinPluralName = '%swatts per quartic %skelvin';

const
  cWattPerQuarticKelvin                       = (0);
  cWattPerQuarticKelvinPrefixes  : TPrefixes  = (pNone, pNone);
  cWattPerQuarticKelvinExponents : TExponents = (1, -4);

type
  TWattPerSquareMeterPerQuarticKelvinUnit = record
    class operator *(const AValue: double; const ASelf: TWattPerSquareMeterPerQuarticKelvinUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TWattPerSquareMeterPerQuarticKelvinUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TWattPerSquareMeterPerQuarticKelvinUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TWattPerSquareMeterPerQuarticKelvinUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsWattPerSquareMeterPerQuarticKelvinSymbol     = '%sW/%sm2/%sK4';
  rsWattPerSquareMeterPerQuarticKelvinName       = '%swatt per square %smeter per quartic %skelvin';
  rsWattPerSquareMeterPerQuarticKelvinPluralName = '%swatts per square %smeter per quartic %skelvin';

const
  cWattPerSquareMeterPerQuarticKelvin                       = (0);
  cWattPerSquareMeterPerQuarticKelvinPrefixes  : TPrefixes  = (pNone, pNone, pNone);
  cWattPerSquareMeterPerQuarticKelvinExponents : TExponents = (1, -2, -4);

type
  TJoulePerMoleUnit = record
    class operator *(const AValue: double; const ASelf: TJoulePerMoleUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TJoulePerMoleUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TJoulePerMoleUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TJoulePerMoleUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsJoulePerMoleSymbol     = '%sJ/%smol';
  rsJoulePerMoleName       = '%sjoule per %smole';
  rsJoulePerMolePluralName = '%sjoules per %smole';

const
  cJoulePerMole                       = (0);
  cJoulePerMolePrefixes  : TPrefixes  = (pNone, pNone);
  cJoulePerMoleExponents : TExponents = (1, -1);

type
  TMoleKelvinUnit = record
    class operator *(const AValue: double; const ASelf: TMoleKelvinUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TMoleKelvinUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TMoleKelvinUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TMoleKelvinUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsMoleKelvinSymbol     = '%smol.%sK';
  rsMoleKelvinName       = '%smole %skelvin';
  rsMoleKelvinPluralName = '%smole %skelvins';

const
  cMoleKelvin                       = (0);
  cMoleKelvinPrefixes  : TPrefixes  = (pNone, pNone);
  cMoleKelvinExponents : TExponents = (1, 1);

type
  TJoulePerMolePerKelvinUnit = record
    class operator *(const AValue: double; const ASelf: TJoulePerMolePerKelvinUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TJoulePerMolePerKelvinUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TJoulePerMolePerKelvinUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TJoulePerMolePerKelvinUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsJoulePerMolePerKelvinSymbol     = '%sJ/%smol/%sK';
  rsJoulePerMolePerKelvinName       = '%sjoule per %smole per %skelvin';
  rsJoulePerMolePerKelvinPluralName = '%sjoules per %smole per %skelvin';

const
  cJoulePerMolePerKelvin                       = (0);
  cJoulePerMolePerKelvinPrefixes  : TPrefixes  = (pNone, pNone, pNone);
  cJoulePerMolePerKelvinExponents : TExponents = (1, -1, -1);

type
  TOhmMeterUnit = record
    class operator *(const AValue: double; const ASelf: TOhmMeterUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TOhmMeterUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TOhmMeterUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TOhmMeterUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsOhmMeterSymbol     = '%sΩ.%sm';
  rsOhmMeterName       = '%sohm %smeter';
  rsOhmMeterPluralName = '%sohm %smeters';

const
  cOhmMeter                       = (0);
  cOhmMeterPrefixes  : TPrefixes  = (pNone, pNone);
  cOhmMeterExponents : TExponents = (1, 1);

type
  TVoltPerMeterUnit = record
    class operator *(const AValue: double; const ASelf: TVoltPerMeterUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TVoltPerMeterUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TVoltPerMeterUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TVoltPerMeterUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsVoltPerMeterSymbol     = '%sV/%sm';
  rsVoltPerMeterName       = '%svolt per %smeter';
  rsVoltPerMeterPluralName = '%svolts per %smeter';

const
  cVoltPerMeter                       = (0);
  cVoltPerMeterPrefixes  : TPrefixes  = (pNone, pNone);
  cVoltPerMeterExponents : TExponents = (1, -1);

type
  TNewtonPerCoulombUnit = record
    class operator *(const AValue: double; const ASelf: TNewtonPerCoulombUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TNewtonPerCoulombUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TNewtonPerCoulombUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TNewtonPerCoulombUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsNewtonPerCoulombSymbol     = '%sN/%sC';
  rsNewtonPerCoulombName       = '%snewton per %scoulomb';
  rsNewtonPerCoulombPluralName = '%snewtons per %scoulomb';

const
  cNewtonPerCoulomb                       = (0);
  cNewtonPerCoulombPrefixes  : TPrefixes  = (pNone, pNone);
  cNewtonPerCoulombExponents : TExponents = (1, -1);

type
  TCoulombPerMeterUnit = record
    class operator *(const AValue: double; const ASelf: TCoulombPerMeterUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TCoulombPerMeterUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TCoulombPerMeterUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TCoulombPerMeterUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsCoulombPerMeterSymbol     = '%sC/%sm';
  rsCoulombPerMeterName       = '%scoulomb per %smeter';
  rsCoulombPerMeterPluralName = '%scoulombs per %smeter';

const
  cCoulombPerMeter                       = (0);
  cCoulombPerMeterPrefixes  : TPrefixes  = (pNone, pNone);
  cCoulombPerMeterExponents : TExponents = (1, -1);

type
  TSquareCoulombPerMeterUnit = record
    class operator *(const AValue: double; const ASelf: TSquareCoulombPerMeterUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TSquareCoulombPerMeterUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TSquareCoulombPerMeterUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TSquareCoulombPerMeterUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsSquareCoulombPerMeterSymbol     = '%sC2/%sm';
  rsSquareCoulombPerMeterName       = 'square %scoulomb per %smeter';
  rsSquareCoulombPerMeterPluralName = 'square %scoulombs per %smeter';

const
  cSquareCoulombPerMeter                       = (0);
  cSquareCoulombPerMeterPrefixes  : TPrefixes  = (pNone, pNone);
  cSquareCoulombPerMeterExponents : TExponents = (2, -1);

type
  TCoulombPerSquareMeterUnit = record
    class operator *(const AValue: double; const ASelf: TCoulombPerSquareMeterUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TCoulombPerSquareMeterUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TCoulombPerSquareMeterUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TCoulombPerSquareMeterUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsCoulombPerSquareMeterSymbol     = '%sC/%sm2';
  rsCoulombPerSquareMeterName       = '%scoulomb per square %smeter';
  rsCoulombPerSquareMeterPluralName = '%scoulombs per square %smeter';

const
  cCoulombPerSquareMeter                       = (0);
  cCoulombPerSquareMeterPrefixes  : TPrefixes  = (pNone, pNone);
  cCoulombPerSquareMeterExponents : TExponents = (1, -2);

type
  TSquareMeterPerSquareCoulombUnit = record
    class operator *(const AValue: double; const ASelf: TSquareMeterPerSquareCoulombUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TSquareMeterPerSquareCoulombUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TSquareMeterPerSquareCoulombUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TSquareMeterPerSquareCoulombUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsSquareMeterPerSquareCoulombSymbol     = '%sm2/%sC2';
  rsSquareMeterPerSquareCoulombName       = 'square %smeter per square %scoulomb';
  rsSquareMeterPerSquareCoulombPluralName = 'square %smeters per square %scoulomb';

const
  cSquareMeterPerSquareCoulomb                       = (0);
  cSquareMeterPerSquareCoulombPrefixes  : TPrefixes  = (pNone, pNone);
  cSquareMeterPerSquareCoulombExponents : TExponents = (2, -2);

type
  TNewtonPerSquareCoulombUnit = record
    class operator *(const AValue: double; const ASelf: TNewtonPerSquareCoulombUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TNewtonPerSquareCoulombUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TNewtonPerSquareCoulombUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TNewtonPerSquareCoulombUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsNewtonPerSquareCoulombSymbol     = '%sN/%sC2';
  rsNewtonPerSquareCoulombName       = '%snewton per square %scoulomb';
  rsNewtonPerSquareCoulombPluralName = '%snewtons per square %scoulomb';

const
  cNewtonPerSquareCoulomb                       = (0);
  cNewtonPerSquareCoulombPrefixes  : TPrefixes  = (pNone, pNone);
  cNewtonPerSquareCoulombExponents : TExponents = (1, -2);

type
  TNewtonSquareMeterPerSquareCoulombUnit = record
    class operator *(const AValue: double; const ASelf: TNewtonSquareMeterPerSquareCoulombUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TNewtonSquareMeterPerSquareCoulombUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TNewtonSquareMeterPerSquareCoulombUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TNewtonSquareMeterPerSquareCoulombUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsNewtonSquareMeterPerSquareCoulombSymbol     = '%sN.%sm2/%sC2';
  rsNewtonSquareMeterPerSquareCoulombName       = '%snewton square %smeter per square %scoulomb';
  rsNewtonSquareMeterPerSquareCoulombPluralName = '%snewton square %smeters per square %scoulomb';

const
  cNewtonSquareMeterPerSquareCoulomb                       = (0);
  cNewtonSquareMeterPerSquareCoulombPrefixes  : TPrefixes  = (pNone, pNone, pNone);
  cNewtonSquareMeterPerSquareCoulombExponents : TExponents = (1, 2, -2);

type
  TVoltMeterUnit = record
    class operator *(const AValue: double; const ASelf: TVoltMeterUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TVoltMeterUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TVoltMeterUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TVoltMeterUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsVoltMeterSymbol     = '%sV.%sm';
  rsVoltMeterName       = '%svolt %smeter';
  rsVoltMeterPluralName = '%svolt %smeters';

const
  cVoltMeter                       = (0);
  cVoltMeterPrefixes  : TPrefixes  = (pNone, pNone);
  cVoltMeterExponents : TExponents = (1, 1);

type
  TNewtonSquareMeterPerCoulombUnit = record
    class operator *(const AValue: double; const ASelf: TNewtonSquareMeterPerCoulombUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TNewtonSquareMeterPerCoulombUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TNewtonSquareMeterPerCoulombUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TNewtonSquareMeterPerCoulombUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsNewtonSquareMeterPerCoulombSymbol     = '%sN.%sm2/%sC';
  rsNewtonSquareMeterPerCoulombName       = '%snewton square %smeter per %scoulomb';
  rsNewtonSquareMeterPerCoulombPluralName = '%snewton square %smeters per %scoulomb';

const
  cNewtonSquareMeterPerCoulomb                       = (0);
  cNewtonSquareMeterPerCoulombPrefixes  : TPrefixes  = (pNone, pNone, pNone);
  cNewtonSquareMeterPerCoulombExponents : TExponents = (1, 2, -1);

type
  TVoltMeterPerSecondUnit = record
    class operator *(const AValue: double; const ASelf: TVoltMeterPerSecondUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TVoltMeterPerSecondUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TVoltMeterPerSecondUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TVoltMeterPerSecondUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsVoltMeterPerSecondSymbol     = '%sV.%sm/%ss';
  rsVoltMeterPerSecondName       = '%svolt %smeter per %ssecond';
  rsVoltMeterPerSecondPluralName = '%svolt %smeters per %ssecond';

const
  cVoltMeterPerSecond                       = (0);
  cVoltMeterPerSecondPrefixes  : TPrefixes  = (pNone, pNone, pNone);
  cVoltMeterPerSecondExponents : TExponents = (1, 1, -1);

type
  TFaradPerMeterUnit = record
    class operator *(const AValue: double; const ASelf: TFaradPerMeterUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TFaradPerMeterUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TFaradPerMeterUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TFaradPerMeterUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsFaradPerMeterSymbol     = '%sF/%sm';
  rsFaradPerMeterName       = '%sfarad per %smeter';
  rsFaradPerMeterPluralName = '%sfarads per %smeter';

const
  cFaradPerMeter                       = (0);
  cFaradPerMeterPrefixes  : TPrefixes  = (pNone, pNone);
  cFaradPerMeterExponents : TExponents = (1, -1);

type
  TAmperePerMeterUnit = record
    class operator *(const AValue: double; const ASelf: TAmperePerMeterUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TAmperePerMeterUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TAmperePerMeterUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TAmperePerMeterUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsAmperePerMeterSymbol     = '%sA/%sm';
  rsAmperePerMeterName       = '%sampere per %smeter';
  rsAmperePerMeterPluralName = '%samperes per %smeter';

const
  cAmperePerMeter                       = (0);
  cAmperePerMeterPrefixes  : TPrefixes  = (pNone, pNone);
  cAmperePerMeterExponents : TExponents = (1, -1);

type
  TMeterPerAmpereUnit = record
    class operator *(const AValue: double; const ASelf: TMeterPerAmpereUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TMeterPerAmpereUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TMeterPerAmpereUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TMeterPerAmpereUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsMeterPerAmpereSymbol     = '%sm/%sA';
  rsMeterPerAmpereName       = '%smeter per %sampere';
  rsMeterPerAmperePluralName = '%smeters per %sampere';

const
  cMeterPerAmpere                       = (0);
  cMeterPerAmperePrefixes  : TPrefixes  = (pNone, pNone);
  cMeterPerAmpereExponents : TExponents = (1, -1);

type
  TTeslaMeterUnit = record
    class operator *(const AValue: double; const ASelf: TTeslaMeterUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TTeslaMeterUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TTeslaMeterUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TTeslaMeterUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsTeslaMeterSymbol     = '%sT.%sm';
  rsTeslaMeterName       = '%stesla %smeter';
  rsTeslaMeterPluralName = '%stesla %smeters';

const
  cTeslaMeter                       = (0);
  cTeslaMeterPrefixes  : TPrefixes  = (pNone, pNone);
  cTeslaMeterExponents : TExponents = (1, 1);

type
  TNewtonPerAmpereUnit = record
    class operator *(const AValue: double; const ASelf: TNewtonPerAmpereUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TNewtonPerAmpereUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TNewtonPerAmpereUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TNewtonPerAmpereUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsNewtonPerAmpereSymbol     = '%sN/%sA';
  rsNewtonPerAmpereName       = '%snewton per %sampere';
  rsNewtonPerAmperePluralName = '%snewtons per %sampere';

const
  cNewtonPerAmpere                       = (0);
  cNewtonPerAmperePrefixes  : TPrefixes  = (pNone, pNone);
  cNewtonPerAmpereExponents : TExponents = (1, -1);

type
  TTeslaPerAmpereUnit = record
    class operator *(const AValue: double; const ASelf: TTeslaPerAmpereUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TTeslaPerAmpereUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TTeslaPerAmpereUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TTeslaPerAmpereUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsTeslaPerAmpereSymbol     = '%sT/%sA';
  rsTeslaPerAmpereName       = '%stesla per %sampere';
  rsTeslaPerAmperePluralName = '%steslas per %sampere';

const
  cTeslaPerAmpere                       = (0);
  cTeslaPerAmperePrefixes  : TPrefixes  = (pNone, pNone);
  cTeslaPerAmpereExponents : TExponents = (1, -1);

type
  THenryPerMeterUnit = record
    class operator *(const AValue: double; const ASelf: THenryPerMeterUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: THenryPerMeterUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: THenryPerMeterUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: THenryPerMeterUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsHenryPerMeterSymbol     = '%sH/%sm';
  rsHenryPerMeterName       = '%shenry per %smeter';
  rsHenryPerMeterPluralName = '%shenries per %smeter';

const
  cHenryPerMeter                       = (0);
  cHenryPerMeterPrefixes  : TPrefixes  = (pNone, pNone);
  cHenryPerMeterExponents : TExponents = (1, -1);

type
  TTeslaMeterPerAmpereUnit = record
    class operator *(const AValue: double; const ASelf: TTeslaMeterPerAmpereUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TTeslaMeterPerAmpereUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TTeslaMeterPerAmpereUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TTeslaMeterPerAmpereUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsTeslaMeterPerAmpereSymbol     = '%sT.%sm/%sA';
  rsTeslaMeterPerAmpereName       = '%stesla %smeter per %sampere';
  rsTeslaMeterPerAmperePluralName = '%stesla %smeters per %sampere';

const
  cTeslaMeterPerAmpere                       = (0);
  cTeslaMeterPerAmperePrefixes  : TPrefixes  = (pNone, pNone, pNone);
  cTeslaMeterPerAmpereExponents : TExponents = (1, 1, -1);

type
  TNewtonPerSquareAmpereUnit = record
    class operator *(const AValue: double; const ASelf: TNewtonPerSquareAmpereUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TNewtonPerSquareAmpereUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TNewtonPerSquareAmpereUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TNewtonPerSquareAmpereUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsNewtonPerSquareAmpereSymbol     = '%sN/%sA2';
  rsNewtonPerSquareAmpereName       = '%snewton per square %sampere';
  rsNewtonPerSquareAmperePluralName = '%snewtons per square %sampere';

const
  cNewtonPerSquareAmpere                       = (0);
  cNewtonPerSquareAmperePrefixes  : TPrefixes  = (pNone, pNone);
  cNewtonPerSquareAmpereExponents : TExponents = (1, -2);

type
  TRadianPerMeterUnit = record
    class operator *(const AValue: double; const ASelf: TRadianPerMeterUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TRadianPerMeterUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TRadianPerMeterUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TRadianPerMeterUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsRadianPerMeterSymbol     = 'rad/%sm';
  rsRadianPerMeterName       = 'radian per %smeter';
  rsRadianPerMeterPluralName = 'radians per %smeter';

const
  cRadianPerMeter                       = (0);
  cRadianPerMeterPrefixes  : TPrefixes  = (pNone);
  cRadianPerMeterExponents : TExponents = (-1);

type
  TSquareKilogramPerSquareSecondUnit = record
    class operator *(const AValue: double; const ASelf: TSquareKilogramPerSquareSecondUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TSquareKilogramPerSquareSecondUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TSquareKilogramPerSquareSecondUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TSquareKilogramPerSquareSecondUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsSquareKilogramPerSquareSecondSymbol     = '%sg2/%ss2';
  rsSquareKilogramPerSquareSecondName       = 'square %sgram per square %ssecond';
  rsSquareKilogramPerSquareSecondPluralName = 'square %sgrams per square %ssecond';

const
  cSquareKilogramPerSquareSecond                       = (0);
  cSquareKilogramPerSquareSecondPrefixes  : TPrefixes  = (pKilo, pNone);
  cSquareKilogramPerSquareSecondExponents : TExponents = (2, -2);

type
  TSquareSecondPerSquareMeterUnit = record
    class operator *(const AValue: double; const ASelf: TSquareSecondPerSquareMeterUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TSquareSecondPerSquareMeterUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TSquareSecondPerSquareMeterUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TSquareSecondPerSquareMeterUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsSquareSecondPerSquareMeterSymbol     = '%ss2/%sm2';
  rsSquareSecondPerSquareMeterName       = 'square %ssecond per square %smeter';
  rsSquareSecondPerSquareMeterPluralName = 'square %sseconds per square %smeter';

const
  cSquareSecondPerSquareMeter                       = (0);
  cSquareSecondPerSquareMeterPrefixes  : TPrefixes  = (pNone, pNone);
  cSquareSecondPerSquareMeterExponents : TExponents = (2, -2);

type
  TSquareJouleUnit = record
    class operator *(const AValue: double; const ASelf: TSquareJouleUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TSquareJouleUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TSquareJouleUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TSquareJouleUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsSquareJouleSymbol     = '%sJ2';
  rsSquareJouleName       = 'square %sjoule';
  rsSquareJoulePluralName = 'square %sjoules';

const
  cSquareJoule                       = (0);
  cSquareJoulePrefixes  : TPrefixes  = (pNone);
  cSquareJouleExponents : TExponents = (2);

var
  J2         : TSquareJouleUnit;

const
  TJ2        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSquareJoule; FValue: 1E+24); {$ELSE} (1E+24); {$ENDIF}
  GJ2        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSquareJoule; FValue: 1E+18); {$ELSE} (1E+18); {$ENDIF}
  MJ2        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSquareJoule; FValue: 1E+12); {$ELSE} (1E+12); {$ENDIF}
  kJ2        : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSquareJoule; FValue: 1E+06); {$ELSE} (1E+06); {$ENDIF}

type
  TJouleSecondUnit = record
    class operator *(const AValue: double; const ASelf: TJouleSecondUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TJouleSecondUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TJouleSecondUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TJouleSecondUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsJouleSecondSymbol     = '%sJ.%ss';
  rsJouleSecondName       = '%sjoule %ssecond';
  rsJouleSecondPluralName = '%sjoule %sseconds';

const
  cJouleSecond                       = (0);
  cJouleSecondPrefixes  : TPrefixes  = (pNone, pNone);
  cJouleSecondExponents : TExponents = (1, 1);

type
  TJoulePerHertzUnit = record
    class operator *(const AValue: double; const ASelf: TJoulePerHertzUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TJoulePerHertzUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TJoulePerHertzUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TJoulePerHertzUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsJoulePerHertzSymbol     = '%sJ/%sHz';
  rsJoulePerHertzName       = '%sjoule per %shertz';
  rsJoulePerHertzPluralName = '%sjoules per %shertz';

const
  cJoulePerHertz                       = (0);
  cJoulePerHertzPrefixes  : TPrefixes  = (pNone, pNone);
  cJoulePerHertzExponents : TExponents = (1, -1);

type
  TElectronvoltSecondUnit = record
    class operator *(const AValue: double; const ASelf: TElectronvoltSecondUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TElectronvoltSecondUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TElectronvoltSecondUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TElectronvoltSecondUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsElectronvoltSecondSymbol     = '%seV.%ss';
  rsElectronvoltSecondName       = '%selectronvolt %ssecond';
  rsElectronvoltSecondPluralName = '%selectronvolt %sseconds';

const
  cElectronvoltSecond                       = (0);
  cElectronvoltSecondPrefixes  : TPrefixes  = (pNone, pNone);
  cElectronvoltSecondExponents : TExponents = (1, 1);

type
  TElectronvoltMeterPerSpeedOfLightUnit = record
    class operator *(const AValue: double; const ASelf: TElectronvoltMeterPerSpeedOfLightUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TElectronvoltMeterPerSpeedOfLightUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TElectronvoltMeterPerSpeedOfLightUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TElectronvoltMeterPerSpeedOfLightUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsElectronvoltMeterPerSpeedOfLightSymbol     = '%seV.%sm/c';
  rsElectronvoltMeterPerSpeedOfLightName       = '%selectronvolt %smeter per speed of  light';
  rsElectronvoltMeterPerSpeedOfLightPluralName = '%selectronvolt %smeters per speed of  light';

const
  cElectronvoltMeterPerSpeedOfLight                       = (0);
  cElectronvoltMeterPerSpeedOfLightPrefixes  : TPrefixes  = (pNone, pNone);
  cElectronvoltMeterPerSpeedOfLightExponents : TExponents = (1, 1);

type
  TSquareJouleSquareSecondUnit = record
    class operator *(const AValue: double; const ASelf: TSquareJouleSquareSecondUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TSquareJouleSquareSecondUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TSquareJouleSquareSecondUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TSquareJouleSquareSecondUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsSquareJouleSquareSecondSymbol     = '%sJ2.%ss2';
  rsSquareJouleSquareSecondName       = 'square %sjoule square %ssecond';
  rsSquareJouleSquareSecondPluralName = 'square %sjoule square %sseconds';

const
  cSquareJouleSquareSecond                       = (0);
  cSquareJouleSquareSecondPrefixes  : TPrefixes  = (pNone, pNone);
  cSquareJouleSquareSecondExponents : TExponents = (2, 2);

type
  TCoulombPerKilogramUnit = record
    class operator *(const AValue: double; const ASelf: TCoulombPerKilogramUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TCoulombPerKilogramUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TCoulombPerKilogramUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TCoulombPerKilogramUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsCoulombPerKilogramSymbol     = '%sC/%sg';
  rsCoulombPerKilogramName       = '%scoulomb per %sgram';
  rsCoulombPerKilogramPluralName = '%scoulombs per %sgram';

const
  cCoulombPerKilogram                       = (0);
  cCoulombPerKilogramPrefixes  : TPrefixes  = (pNone, pKilo);
  cCoulombPerKilogramExponents : TExponents = (1, -1);

type
  TSquareMeterAmpereUnit = record
    class operator *(const AValue: double; const ASelf: TSquareMeterAmpereUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TSquareMeterAmpereUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TSquareMeterAmpereUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TSquareMeterAmpereUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsSquareMeterAmpereSymbol     = '%sm2.%sA';
  rsSquareMeterAmpereName       = 'square %smeter %sampere';
  rsSquareMeterAmperePluralName = 'square %smeter %samperes';

const
  cSquareMeterAmpere                       = (0);
  cSquareMeterAmperePrefixes  : TPrefixes  = (pNone, pNone);
  cSquareMeterAmpereExponents : TExponents = (2, 1);

type
  TJoulePerTeslaUnit = record
    class operator *(const AValue: double; const ASelf: TJoulePerTeslaUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TJoulePerTeslaUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TJoulePerTeslaUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TJoulePerTeslaUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsJoulePerTeslaSymbol     = '%sJ/%sT';
  rsJoulePerTeslaName       = '%sjoule per %stesla';
  rsJoulePerTeslaPluralName = '%sjoules per %stesla';

const
  cJoulePerTesla                       = (0);
  cJoulePerTeslaPrefixes  : TPrefixes  = (pNone, pNone);
  cJoulePerTeslaExponents : TExponents = (1, -1);

type
  TLumenPerWattUnit = record
    class operator *(const AValue: double; const ASelf: TLumenPerWattUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TLumenPerWattUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TLumenPerWattUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TLumenPerWattUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsLumenPerWattSymbol     = '%slm/%sW';
  rsLumenPerWattName       = '%slumen per %swatt';
  rsLumenPerWattPluralName = '%slumens per %swatt';

const
  cLumenPerWatt                       = (0);
  cLumenPerWattPrefixes  : TPrefixes  = (pNone, pNone);
  cLumenPerWattExponents : TExponents = (1, -1);

type
  TReciprocalMoleUnit = record
    class operator *(const AValue: double; const ASelf: TReciprocalMoleUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TReciprocalMoleUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TReciprocalMoleUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TReciprocalMoleUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsReciprocalMoleSymbol     = '1/%smol';
  rsReciprocalMoleName       = 'reciprocal %smole';
  rsReciprocalMolePluralName = 'reciprocal %smoles';

const
  cReciprocalMole                       = (0);
  cReciprocalMolePrefixes  : TPrefixes  = (pNone);
  cReciprocalMoleExponents : TExponents = (-1);

type
  TAmperePerSquareMeterUnit = record
    class operator *(const AValue: double; const ASelf: TAmperePerSquareMeterUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TAmperePerSquareMeterUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TAmperePerSquareMeterUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TAmperePerSquareMeterUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsAmperePerSquareMeterSymbol     = '%sA/%sm2';
  rsAmperePerSquareMeterName       = '%sampere per square %smeter';
  rsAmperePerSquareMeterPluralName = '%samperes per square %smeter';

const
  cAmperePerSquareMeter                       = (0);
  cAmperePerSquareMeterPrefixes  : TPrefixes  = (pNone, pNone);
  cAmperePerSquareMeterExponents : TExponents = (1, -2);

type
  TMolePerCubicMeterUnit = record
    class operator *(const AValue: double; const ASelf: TMolePerCubicMeterUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TMolePerCubicMeterUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TMolePerCubicMeterUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TMolePerCubicMeterUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsMolePerCubicMeterSymbol     = '%smol/%sm3';
  rsMolePerCubicMeterName       = '%smole per cubic %smeter';
  rsMolePerCubicMeterPluralName = '%smoles per cubic %smeter';

const
  cMolePerCubicMeter                       = (0);
  cMolePerCubicMeterPrefixes  : TPrefixes  = (pNone, pNone);
  cMolePerCubicMeterExponents : TExponents = (1, -3);

type
  TCandelaPerSquareMeterUnit = record
    class operator *(const AValue: double; const ASelf: TCandelaPerSquareMeterUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TCandelaPerSquareMeterUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TCandelaPerSquareMeterUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TCandelaPerSquareMeterUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsCandelaPerSquareMeterSymbol     = '%scd/%sm2';
  rsCandelaPerSquareMeterName       = '%scandela per square %smeter';
  rsCandelaPerSquareMeterPluralName = '%scandelas per square %smeter';

const
  cCandelaPerSquareMeter                       = (0);
  cCandelaPerSquareMeterPrefixes  : TPrefixes  = (pNone, pNone);
  cCandelaPerSquareMeterExponents : TExponents = (1, -2);

type
  TCoulombPerCubicMeterUnit = record
    class operator *(const AValue: double; const ASelf: TCoulombPerCubicMeterUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TCoulombPerCubicMeterUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TCoulombPerCubicMeterUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TCoulombPerCubicMeterUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsCoulombPerCubicMeterSymbol     = '%sC/%sm3';
  rsCoulombPerCubicMeterName       = '%scoulomb per cubic %smeter';
  rsCoulombPerCubicMeterPluralName = '%scoulombs per cubic %smeter';

const
  cCoulombPerCubicMeter                       = (0);
  cCoulombPerCubicMeterPrefixes  : TPrefixes  = (pNone, pNone);
  cCoulombPerCubicMeterExponents : TExponents = (1, -3);

type
  TGrayPerSecondUnit = record
    class operator *(const AValue: double; const ASelf: TGrayPerSecondUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TGrayPerSecondUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TGrayPerSecondUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TGrayPerSecondUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsGrayPerSecondSymbol     = '%sGy/%ss';
  rsGrayPerSecondName       = '%sgray per %ssecond';
  rsGrayPerSecondPluralName = '%sgrays per %ssecond';

const
  cGrayPerSecond                       = (0);
  cGrayPerSecondPrefixes  : TPrefixes  = (pNone, pNone);
  cGrayPerSecondExponents : TExponents = (1, -1);

type
  TSteradianHertzUnit = record
    class operator *(const AValue: double; const ASelf: TSteradianHertzUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TSteradianHertzUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TSteradianHertzUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TSteradianHertzUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsSteradianHertzSymbol     = 'sr.%sHz';
  rsSteradianHertzName       = 'steradian %shertz';
  rsSteradianHertzPluralName = 'steradian %shertz';

const
  cSteradianHertz                       = (0);
  cSteradianHertzPrefixes  : TPrefixes  = (pNone);
  cSteradianHertzExponents : TExponents = (1);

type
  TMeterSteradianUnit = record
    class operator *(const AValue: double; const ASelf: TMeterSteradianUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TMeterSteradianUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TMeterSteradianUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TMeterSteradianUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsMeterSteradianSymbol     = '%sm.sr';
  rsMeterSteradianName       = '%smeter steradian';
  rsMeterSteradianPluralName = '%smeter steradians';

const
  cMeterSteradian                       = (0);
  cMeterSteradianPrefixes  : TPrefixes  = (pNone);
  cMeterSteradianExponents : TExponents = (1);

type
  TSquareMeterSteradianUnit = record
    class operator *(const AValue: double; const ASelf: TSquareMeterSteradianUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TSquareMeterSteradianUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TSquareMeterSteradianUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TSquareMeterSteradianUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsSquareMeterSteradianSymbol     = '%sm2.sr';
  rsSquareMeterSteradianName       = 'square %smeter steradian';
  rsSquareMeterSteradianPluralName = 'square %smeter steradians';

const
  cSquareMeterSteradian                       = (0);
  cSquareMeterSteradianPrefixes  : TPrefixes  = (pNone);
  cSquareMeterSteradianExponents : TExponents = (2);

type
  TCubicMeterSteradianUnit = record
    class operator *(const AValue: double; const ASelf: TCubicMeterSteradianUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TCubicMeterSteradianUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TCubicMeterSteradianUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TCubicMeterSteradianUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsCubicMeterSteradianSymbol     = '%sm3.sr';
  rsCubicMeterSteradianName       = 'cubic %smeter steradian';
  rsCubicMeterSteradianPluralName = 'cubic %smeter steradians';

const
  cCubicMeterSteradian                       = (0);
  cCubicMeterSteradianPrefixes  : TPrefixes  = (pNone);
  cCubicMeterSteradianExponents : TExponents = (3);

type
  TSquareMeterSteradianHertzUnit = record
    class operator *(const AValue: double; const ASelf: TSquareMeterSteradianHertzUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TSquareMeterSteradianHertzUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TSquareMeterSteradianHertzUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TSquareMeterSteradianHertzUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsSquareMeterSteradianHertzSymbol     = '%sm2.sr.%shertz';
  rsSquareMeterSteradianHertzName       = 'square %smeter steradian %shertz';
  rsSquareMeterSteradianHertzPluralName = 'square %smeter steradian %shertz';

const
  cSquareMeterSteradianHertz                       = (0);
  cSquareMeterSteradianHertzPrefixes  : TPrefixes  = (pNone, pNone);
  cSquareMeterSteradianHertzExponents : TExponents = (2, 1);

type
  TWattPerSteradianUnit = record
    class operator *(const AValue: double; const ASelf: TWattPerSteradianUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TWattPerSteradianUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TWattPerSteradianUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TWattPerSteradianUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsWattPerSteradianSymbol     = '%sW/sr';
  rsWattPerSteradianName       = '%swatt per steradian';
  rsWattPerSteradianPluralName = '%swatts per steradian';

const
  cWattPerSteradian                       = (0);
  cWattPerSteradianPrefixes  : TPrefixes  = (pNone);
  cWattPerSteradianExponents : TExponents = (1);

type
  TWattPerSteradianPerHertzUnit = record
    class operator *(const AValue: double; const ASelf: TWattPerSteradianPerHertzUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TWattPerSteradianPerHertzUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TWattPerSteradianPerHertzUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TWattPerSteradianPerHertzUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsWattPerSteradianPerHertzSymbol     = '%sW/sr/%sHz';
  rsWattPerSteradianPerHertzName       = '%swatt per steradian per %shertz';
  rsWattPerSteradianPerHertzPluralName = '%swatts per steradian per %shertz';

const
  cWattPerSteradianPerHertz                       = (0);
  cWattPerSteradianPerHertzPrefixes  : TPrefixes  = (pNone, pNone);
  cWattPerSteradianPerHertzExponents : TExponents = (1, -1);

type
  TWattPerMeterPerSteradianUnit = record
    class operator *(const AValue: double; const ASelf: TWattPerMeterPerSteradianUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TWattPerMeterPerSteradianUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TWattPerMeterPerSteradianUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TWattPerMeterPerSteradianUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsWattPerMeterPerSteradianSymbol     = '%sW/sr/%sm';
  rsWattPerMeterPerSteradianName       = '%swatt per steradian per %smeter';
  rsWattPerMeterPerSteradianPluralName = '%swatts per steradian per %smeter';

const
  cWattPerMeterPerSteradian                       = (0);
  cWattPerMeterPerSteradianPrefixes  : TPrefixes  = (pNone, pNone);
  cWattPerMeterPerSteradianExponents : TExponents = (1, -1);

type
  TWattPerSquareMeterPerSteradianUnit = record
    class operator *(const AValue: double; const ASelf: TWattPerSquareMeterPerSteradianUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TWattPerSquareMeterPerSteradianUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TWattPerSquareMeterPerSteradianUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TWattPerSquareMeterPerSteradianUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsWattPerSquareMeterPerSteradianSymbol     = '%sW/%sm2/sr';
  rsWattPerSquareMeterPerSteradianName       = '%swatt per square %smeter per steradian';
  rsWattPerSquareMeterPerSteradianPluralName = '%swatts per square %smeter per steradian';

const
  cWattPerSquareMeterPerSteradian                       = (0);
  cWattPerSquareMeterPerSteradianPrefixes  : TPrefixes  = (pNone, pNone);
  cWattPerSquareMeterPerSteradianExponents : TExponents = (1, -2);

type
  TWattPerCubicMeterPerSteradianUnit = record
    class operator *(const AValue: double; const ASelf: TWattPerCubicMeterPerSteradianUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TWattPerCubicMeterPerSteradianUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TWattPerCubicMeterPerSteradianUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TWattPerCubicMeterPerSteradianUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsWattPerCubicMeterPerSteradianSymbol     = '%sW/%sm3/sr';
  rsWattPerCubicMeterPerSteradianName       = '%swatt per cubic %smeter per steradian';
  rsWattPerCubicMeterPerSteradianPluralName = '%swatts per cubic %smeter per steradian';

const
  cWattPerCubicMeterPerSteradian                       = (0);
  cWattPerCubicMeterPerSteradianPrefixes  : TPrefixes  = (pNone, pNone);
  cWattPerCubicMeterPerSteradianExponents : TExponents = (1, -3);

type
  TWattPerSquareMeterPerSteradianPerHertzUnit = record
    class operator *(const AValue: double; const ASelf: TWattPerSquareMeterPerSteradianPerHertzUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TWattPerSquareMeterPerSteradianPerHertzUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TWattPerSquareMeterPerSteradianPerHertzUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TWattPerSquareMeterPerSteradianPerHertzUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsWattPerSquareMeterPerSteradianPerHertzSymbol     = '%sW/%sm2/sr/%sHz';
  rsWattPerSquareMeterPerSteradianPerHertzName       = '%swatt per square %smeter per steradian per %shertz';
  rsWattPerSquareMeterPerSteradianPerHertzPluralName = '%swatts per square %smeter per steradian per %shertz';

const
  cWattPerSquareMeterPerSteradianPerHertz                       = (0);
  cWattPerSquareMeterPerSteradianPerHertzPrefixes  : TPrefixes  = (pNone, pNone, pNone);
  cWattPerSquareMeterPerSteradianPerHertzExponents : TExponents = (1, -2, -1);

type
  TKatalPerCubicMeterUnit = record
    class operator *(const AValue: double; const ASelf: TKatalPerCubicMeterUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TKatalPerCubicMeterUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TKatalPerCubicMeterUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TKatalPerCubicMeterUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsKatalPerCubicMeterSymbol     = '%skat/%sm3';
  rsKatalPerCubicMeterName       = '%skatal per cubic %smeter';
  rsKatalPerCubicMeterPluralName = '%skatals per cubic %smeter';

const
  cKatalPerCubicMeter                       = (0);
  cKatalPerCubicMeterPrefixes  : TPrefixes  = (pNone, pNone);
  cKatalPerCubicMeterExponents : TExponents = (1, -3);

type
  TCoulombPerMoleUnit = record
    class operator *(const AValue: double; const ASelf: TCoulombPerMoleUnit): TQuantity; inline;
    class operator /(const AValue: double; const ASelf: TCoulombPerMoleUnit): TQuantity; inline;
  {$IFOPT D+}
    class operator *(const AValue: TQuantity; const ASelf: TCoulombPerMoleUnit): TQuantity; inline;
    class operator /(const AValue: TQuantity; const ASelf: TCoulombPerMoleUnit): TQuantity; inline;
  {$ENDIF}
  end;

const
  rsCoulombPerMoleSymbol     = '%sC/%smol';
  rsCoulombPerMoleName       = '%scoulomb per %smole';
  rsCoulombPerMolePluralName = '%scoulombs per %smole';

const
  cCoulombPerMole                       = (0);
  cCoulombPerMolePrefixes  : TPrefixes  = (pNone, pNone);
  cCoulombPerMoleExponents : TExponents = (1, -1);

const
  AvogadroConstant               : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cReciprocalMole;                     FValue:       6.02214076E+23); {$ELSE} (      6.02214076E+23); {$ENDIF}
  BohrMagneton                   : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSquareMeterAmpere;                  FValue:     9.2740100657E-24); {$ELSE} (    9.2740100657E-24); {$ENDIF}
  BohrRadius                     : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cMeter;                              FValue:    5.29177210903E-11); {$ELSE} (   5.29177210903E-11); {$ENDIF}
  BoltzmannConstant              : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cJoulePerKelvin;                     FValue:         1.380649E-23); {$ELSE} (        1.380649E-23); {$ENDIF}
  ComptonWaveLength              : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cMeter;                              FValue:    2.42631023867E-12); {$ELSE} (   2.42631023867E-12); {$ENDIF}
  CoulombConstant                : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cNewtonSquareMeterPerSquareCoulomb;  FValue:      8.9875517923E+9); {$ELSE} (     8.9875517923E+9); {$ENDIF}
  DeuteronMass                   : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cKilogram;                           FValue:     3.3435837768E-27); {$ELSE} (    3.3435837768E-27); {$ENDIF}
  ElectricPermittivity           : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cFaradPerMeter;                      FValue:     8.8541878128E-12); {$ELSE} (    8.8541878128E-12); {$ENDIF}
  ElectronMass                   : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cKilogram;                           FValue:     9.1093837015E-31); {$ELSE} (    9.1093837015E-31); {$ENDIF}
  ElectronCharge                 : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cCoulomb;                            FValue:      1.602176634E-19); {$ELSE} (     1.602176634E-19); {$ENDIF}
  MagneticPermeability           : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cHenryPerMeter;                      FValue:     1.25663706212E-6); {$ELSE} (    1.25663706212E-6); {$ENDIF}
  MolarGasConstant               : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cJoulePerMolePerKelvin;              FValue:          8.314462618); {$ELSE} (         8.314462618); {$ENDIF}
  NeutronMass                    : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cKilogram;                           FValue:    1.67492750056E-27); {$ELSE} (   1.67492750056E-27); {$ENDIF}
  NewtonianConstantOfGravitation : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cNewtonSquareMeterPerSquareKilogram; FValue:          6.67430E-11); {$ELSE} (         6.67430E-11); {$ENDIF}
  PlanckConstant                 : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cKilogramSquareMeterPerSecond;       FValue:       6.62607015E-34); {$ELSE} (      6.62607015E-34); {$ENDIF}
  ProtonMass                     : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cKilogram;                           FValue:    1.67262192595E-27); {$ELSE} (   1.67262192595E-27); {$ENDIF}
  RydbergConstant                : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cReciprocalMeter;                    FValue:      10973731.568157); {$ELSE} (     10973731.568157); {$ENDIF}
  SpeedOfLight                   : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cMeterPerSecond;                     FValue:            299792458); {$ELSE} (           299792458); {$ENDIF}
  SquaredSpeedOfLight            : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cSquareMeterPerSquareSecond;         FValue: 8.98755178736818E+16); {$ELSE} (8.98755178736818E+16); {$ENDIF}
  StandardAccelerationOfGravity  : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cMeterPerSquareSecond;               FValue:              9.80665); {$ELSE} (             9.80665); {$ENDIF}
  ReducedPlanckConstant          : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cKilogramSquareMeterPerSecond;       FValue:  6.62607015E-34/2/pi); {$ELSE} ( 6.62607015E-34/2/pi); {$ENDIF}
  UnifiedAtomicMassUnit          : TQuantity = {$IFOPT D+} (FUnitOfMeasurement: cKilogram;                           FValue:    1.66053906892E-27); {$ELSE} (   1.66053906892E-27); {$ENDIF}

const
  PrefixTable: array[pQuetta..pQuecto] of
    record  Symbol, Name: string; Exponent: longint end = (
    (Symbol: 'Q';   Name: 'quetta';  Exponent: +30),
    (Symbol: 'R';   Name: 'ronna';   Exponent: +27),
    (Symbol: 'Y';   Name: 'yotta';   Exponent: +24),
    (Symbol: 'Z';   Name: 'zetta';   Exponent: +21),
    (Symbol: 'E';   Name: 'exa';     Exponent: +18),
    (Symbol: 'P';   Name: 'peta';    Exponent: +15),
    (Symbol: 'T';   Name: 'tera';    Exponent: +12),
    (Symbol: 'G';   Name: 'giga';    Exponent: +09),
    (Symbol: 'M';   Name: 'mega';    Exponent: +06),
    (Symbol: 'k';   Name: 'kilo';    Exponent: +03),
    (Symbol: 'h';   Name: 'hecto';   Exponent: +02),
    (Symbol: 'da';  Name: 'deca';    Exponent: +01),
    (Symbol: '';    Name: '';        Exponent:  00),
    (Symbol: 'd';   Name: 'deci';    Exponent: -01),
    (Symbol: 'c';   Name: 'centi';   Exponent: -02),
    (Symbol: 'm';   Name: 'milli';   Exponent: -03),
    (Symbol: 'μ';   Name: 'micro';   Exponent: -06),
    (Symbol: 'n';   Name: 'nano';    Exponent: -09),
    (Symbol: 'p';   Name: 'pico';    Exponent: -12),
    (Symbol: 'f';   Name: 'femto';   Exponent: -15),
    (Symbol: 'a';   Name: 'atto';    Exponent: -18),
    (Symbol: 'z';   Name: 'zepto';   Exponent: -21),
    (Symbol: 'y';   Name: 'yocto';   Exponent: -24),
    (Symbol: 'r';   Name: 'ronto';   Exponent: -27),
    (Symbol: 'q';   Name: 'quecto';  Exponent: -30)
  );

{ Helpers }

function ScalarToString(const AValue: TQuantity): string;
function ScalarToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ScalarToVerboseString(const AValue: TQuantity): string;
function ScalarToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ScalarToFloat(const AValue: TQuantity): double;
function RadianToString(const AValue: TQuantity): string;
function RadianToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function RadianToVerboseString(const AValue: TQuantity): string;
function RadianToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function RadianToFloat(const AValue: TQuantity): double;
function DegreeToString(const AValue: TQuantity): string;
function DegreeToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function DegreeToVerboseString(const AValue: TQuantity): string;
function DegreeToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function DegreeToFloat(const AValue: TQuantity): double;
function SteradianToString(const AValue: TQuantity): string;
function SteradianToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SteradianToVerboseString(const AValue: TQuantity): string;
function SteradianToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SteradianToFloat(const AValue: TQuantity): double;
function SquareDegreeToString(const AValue: TQuantity): string;
function SquareDegreeToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareDegreeToVerboseString(const AValue: TQuantity): string;
function SquareDegreeToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareDegreeToFloat(const AValue: TQuantity): double;
function SecondToString(const AValue: TQuantity): string;
function SecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SecondToVerboseString(const AValue: TQuantity): string;
function SecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SecondToFloat(const AValue: TQuantity): double;
function DayToString(const AValue: TQuantity): string;
function DayToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function DayToVerboseString(const AValue: TQuantity): string;
function DayToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function DayToFloat(const AValue: TQuantity): double;
function HourToString(const AValue: TQuantity): string;
function HourToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function HourToVerboseString(const AValue: TQuantity): string;
function HourToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function HourToFloat(const AValue: TQuantity): double;
function MinuteToString(const AValue: TQuantity): string;
function MinuteToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MinuteToVerboseString(const AValue: TQuantity): string;
function MinuteToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MinuteToFloat(const AValue: TQuantity): double;
function SquareSecondToString(const AValue: TQuantity): string;
function SquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareSecondToVerboseString(const AValue: TQuantity): string;
function SquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareSecondToFloat(const AValue: TQuantity): double;
function SquareDayToString(const AValue: TQuantity): string;
function SquareDayToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareDayToVerboseString(const AValue: TQuantity): string;
function SquareDayToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareDayToFloat(const AValue: TQuantity): double;
function SquareHourToString(const AValue: TQuantity): string;
function SquareHourToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareHourToVerboseString(const AValue: TQuantity): string;
function SquareHourToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareHourToFloat(const AValue: TQuantity): double;
function SquareMinuteToString(const AValue: TQuantity): string;
function SquareMinuteToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareMinuteToVerboseString(const AValue: TQuantity): string;
function SquareMinuteToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareMinuteToFloat(const AValue: TQuantity): double;
function CubicSecondToString(const AValue: TQuantity): string;
function CubicSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CubicSecondToVerboseString(const AValue: TQuantity): string;
function CubicSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CubicSecondToFloat(const AValue: TQuantity): double;
function QuarticSecondToString(const AValue: TQuantity): string;
function QuarticSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function QuarticSecondToVerboseString(const AValue: TQuantity): string;
function QuarticSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function QuarticSecondToFloat(const AValue: TQuantity): double;
function QuinticSecondToString(const AValue: TQuantity): string;
function QuinticSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function QuinticSecondToVerboseString(const AValue: TQuantity): string;
function QuinticSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function QuinticSecondToFloat(const AValue: TQuantity): double;
function SexticSecondToString(const AValue: TQuantity): string;
function SexticSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SexticSecondToVerboseString(const AValue: TQuantity): string;
function SexticSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SexticSecondToFloat(const AValue: TQuantity): double;
function MeterToString(const AValue: TQuantity): string;
function MeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterToVerboseString(const AValue: TQuantity): string;
function MeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterToFloat(const AValue: TQuantity): double;
function AstronomicalToString(const AValue: TQuantity): string;
function AstronomicalToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function AstronomicalToVerboseString(const AValue: TQuantity): string;
function AstronomicalToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function AstronomicalToFloat(const AValue: TQuantity): double;
function InchToString(const AValue: TQuantity): string;
function InchToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function InchToVerboseString(const AValue: TQuantity): string;
function InchToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function InchToFloat(const AValue: TQuantity): double;
function FootToString(const AValue: TQuantity): string;
function FootToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function FootToVerboseString(const AValue: TQuantity): string;
function FootToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function FootToFloat(const AValue: TQuantity): double;
function YardToString(const AValue: TQuantity): string;
function YardToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function YardToVerboseString(const AValue: TQuantity): string;
function YardToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function YardToFloat(const AValue: TQuantity): double;
function MileToString(const AValue: TQuantity): string;
function MileToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MileToVerboseString(const AValue: TQuantity): string;
function MileToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MileToFloat(const AValue: TQuantity): double;
function NauticalMileToString(const AValue: TQuantity): string;
function NauticalMileToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NauticalMileToVerboseString(const AValue: TQuantity): string;
function NauticalMileToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NauticalMileToFloat(const AValue: TQuantity): double;
function AngstromToString(const AValue: TQuantity): string;
function AngstromToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function AngstromToVerboseString(const AValue: TQuantity): string;
function AngstromToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function AngstromToFloat(const AValue: TQuantity): double;
function SquareRootMeterToString(const AValue: TQuantity): string;
function SquareRootMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareRootMeterToVerboseString(const AValue: TQuantity): string;
function SquareRootMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareRootMeterToFloat(const AValue: TQuantity): double;
function SquareMeterToString(const AValue: TQuantity): string;
function SquareMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareMeterToVerboseString(const AValue: TQuantity): string;
function SquareMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareMeterToFloat(const AValue: TQuantity): double;
function SquareInchToString(const AValue: TQuantity): string;
function SquareInchToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareInchToVerboseString(const AValue: TQuantity): string;
function SquareInchToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareInchToFloat(const AValue: TQuantity): double;
function SquareFootToString(const AValue: TQuantity): string;
function SquareFootToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareFootToVerboseString(const AValue: TQuantity): string;
function SquareFootToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareFootToFloat(const AValue: TQuantity): double;
function SquareYardToString(const AValue: TQuantity): string;
function SquareYardToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareYardToVerboseString(const AValue: TQuantity): string;
function SquareYardToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareYardToFloat(const AValue: TQuantity): double;
function SquareMileToString(const AValue: TQuantity): string;
function SquareMileToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareMileToVerboseString(const AValue: TQuantity): string;
function SquareMileToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareMileToFloat(const AValue: TQuantity): double;
function CubicMeterToString(const AValue: TQuantity): string;
function CubicMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CubicMeterToVerboseString(const AValue: TQuantity): string;
function CubicMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CubicMeterToFloat(const AValue: TQuantity): double;
function CubicInchToString(const AValue: TQuantity): string;
function CubicInchToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CubicInchToVerboseString(const AValue: TQuantity): string;
function CubicInchToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CubicInchToFloat(const AValue: TQuantity): double;
function CubicFootToString(const AValue: TQuantity): string;
function CubicFootToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CubicFootToVerboseString(const AValue: TQuantity): string;
function CubicFootToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CubicFootToFloat(const AValue: TQuantity): double;
function CubicYardToString(const AValue: TQuantity): string;
function CubicYardToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CubicYardToVerboseString(const AValue: TQuantity): string;
function CubicYardToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CubicYardToFloat(const AValue: TQuantity): double;
function LitreToString(const AValue: TQuantity): string;
function LitreToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function LitreToVerboseString(const AValue: TQuantity): string;
function LitreToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function LitreToFloat(const AValue: TQuantity): double;
function GallonToString(const AValue: TQuantity): string;
function GallonToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function GallonToVerboseString(const AValue: TQuantity): string;
function GallonToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function GallonToFloat(const AValue: TQuantity): double;
function QuarticMeterToString(const AValue: TQuantity): string;
function QuarticMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function QuarticMeterToVerboseString(const AValue: TQuantity): string;
function QuarticMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function QuarticMeterToFloat(const AValue: TQuantity): double;
function QuinticMeterToString(const AValue: TQuantity): string;
function QuinticMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function QuinticMeterToVerboseString(const AValue: TQuantity): string;
function QuinticMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function QuinticMeterToFloat(const AValue: TQuantity): double;
function SexticMeterToString(const AValue: TQuantity): string;
function SexticMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SexticMeterToVerboseString(const AValue: TQuantity): string;
function SexticMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SexticMeterToFloat(const AValue: TQuantity): double;
function KilogramToString(const AValue: TQuantity): string;
function KilogramToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramToVerboseString(const AValue: TQuantity): string;
function KilogramToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramToFloat(const AValue: TQuantity): double;
function TonneToString(const AValue: TQuantity): string;
function TonneToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function TonneToVerboseString(const AValue: TQuantity): string;
function TonneToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function TonneToFloat(const AValue: TQuantity): double;
function PoundToString(const AValue: TQuantity): string;
function PoundToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function PoundToVerboseString(const AValue: TQuantity): string;
function PoundToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function PoundToFloat(const AValue: TQuantity): double;
function OunceToString(const AValue: TQuantity): string;
function OunceToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function OunceToVerboseString(const AValue: TQuantity): string;
function OunceToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function OunceToFloat(const AValue: TQuantity): double;
function StoneToString(const AValue: TQuantity): string;
function StoneToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function StoneToVerboseString(const AValue: TQuantity): string;
function StoneToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function StoneToFloat(const AValue: TQuantity): double;
function TonToString(const AValue: TQuantity): string;
function TonToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function TonToVerboseString(const AValue: TQuantity): string;
function TonToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function TonToFloat(const AValue: TQuantity): double;
function ElectronvoltPerSquareSpeedOfLightToString(const AValue: TQuantity): string;
function ElectronvoltPerSquareSpeedOfLightToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ElectronvoltPerSquareSpeedOfLightToVerboseString(const AValue: TQuantity): string;
function ElectronvoltPerSquareSpeedOfLightToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ElectronvoltPerSquareSpeedOfLightToFloat(const AValue: TQuantity): double;
function SquareKilogramToString(const AValue: TQuantity): string;
function SquareKilogramToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareKilogramToVerboseString(const AValue: TQuantity): string;
function SquareKilogramToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareKilogramToFloat(const AValue: TQuantity): double;
function AmpereToString(const AValue: TQuantity): string;
function AmpereToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function AmpereToVerboseString(const AValue: TQuantity): string;
function AmpereToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function AmpereToFloat(const AValue: TQuantity): double;
function SquareAmpereToString(const AValue: TQuantity): string;
function SquareAmpereToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareAmpereToVerboseString(const AValue: TQuantity): string;
function SquareAmpereToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareAmpereToFloat(const AValue: TQuantity): double;
function KelvinToString(const AValue: TQuantity): string;
function KelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KelvinToVerboseString(const AValue: TQuantity): string;
function KelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KelvinToFloat(const AValue: TQuantity): double;
function DegreeCelsiusToString(const AValue: TQuantity): string;
function DegreeCelsiusToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function DegreeCelsiusToVerboseString(const AValue: TQuantity): string;
function DegreeCelsiusToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function DegreeCelsiusToFloat(const AValue: TQuantity): double;
function DegreeFahrenheitToString(const AValue: TQuantity): string;
function DegreeFahrenheitToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function DegreeFahrenheitToVerboseString(const AValue: TQuantity): string;
function DegreeFahrenheitToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function DegreeFahrenheitToFloat(const AValue: TQuantity): double;
function SquareKelvinToString(const AValue: TQuantity): string;
function SquareKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareKelvinToVerboseString(const AValue: TQuantity): string;
function SquareKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareKelvinToFloat(const AValue: TQuantity): double;
function CubicKelvinToString(const AValue: TQuantity): string;
function CubicKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CubicKelvinToVerboseString(const AValue: TQuantity): string;
function CubicKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CubicKelvinToFloat(const AValue: TQuantity): double;
function QuarticKelvinToString(const AValue: TQuantity): string;
function QuarticKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function QuarticKelvinToVerboseString(const AValue: TQuantity): string;
function QuarticKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function QuarticKelvinToFloat(const AValue: TQuantity): double;
function MoleToString(const AValue: TQuantity): string;
function MoleToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MoleToVerboseString(const AValue: TQuantity): string;
function MoleToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MoleToFloat(const AValue: TQuantity): double;
function CandelaToString(const AValue: TQuantity): string;
function CandelaToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CandelaToVerboseString(const AValue: TQuantity): string;
function CandelaToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CandelaToFloat(const AValue: TQuantity): double;
function HertzToString(const AValue: TQuantity): string;
function HertzToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function HertzToVerboseString(const AValue: TQuantity): string;
function HertzToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function HertzToFloat(const AValue: TQuantity): double;
function ReciprocalSecondToString(const AValue: TQuantity): string;
function ReciprocalSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ReciprocalSecondToVerboseString(const AValue: TQuantity): string;
function ReciprocalSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ReciprocalSecondToFloat(const AValue: TQuantity): double;
function RadianPerSecondToString(const AValue: TQuantity): string;
function RadianPerSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function RadianPerSecondToVerboseString(const AValue: TQuantity): string;
function RadianPerSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function RadianPerSecondToFloat(const AValue: TQuantity): double;
function SquareHertzToString(const AValue: TQuantity): string;
function SquareHertzToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareHertzToVerboseString(const AValue: TQuantity): string;
function SquareHertzToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareHertzToFloat(const AValue: TQuantity): double;
function ReciprocalSquareSecondToString(const AValue: TQuantity): string;
function ReciprocalSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ReciprocalSquareSecondToVerboseString(const AValue: TQuantity): string;
function ReciprocalSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ReciprocalSquareSecondToFloat(const AValue: TQuantity): double;
function RadianPerSquareSecondToString(const AValue: TQuantity): string;
function RadianPerSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function RadianPerSquareSecondToVerboseString(const AValue: TQuantity): string;
function RadianPerSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function RadianPerSquareSecondToFloat(const AValue: TQuantity): double;
function SteradianPerSquareSecondToString(const AValue: TQuantity): string;
function SteradianPerSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SteradianPerSquareSecondToVerboseString(const AValue: TQuantity): string;
function SteradianPerSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SteradianPerSquareSecondToFloat(const AValue: TQuantity): double;
function MeterPerSecondToString(const AValue: TQuantity): string;
function MeterPerSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterPerSecondToVerboseString(const AValue: TQuantity): string;
function MeterPerSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterPerSecondToFloat(const AValue: TQuantity): double;
function MeterPerHourToString(const AValue: TQuantity): string;
function MeterPerHourToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterPerHourToVerboseString(const AValue: TQuantity): string;
function MeterPerHourToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterPerHourToFloat(const AValue: TQuantity): double;
function MilePerHourToString(const AValue: TQuantity): string;
function MilePerHourToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MilePerHourToVerboseString(const AValue: TQuantity): string;
function MilePerHourToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MilePerHourToFloat(const AValue: TQuantity): double;
function NauticalMilePerHourToString(const AValue: TQuantity): string;
function NauticalMilePerHourToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NauticalMilePerHourToVerboseString(const AValue: TQuantity): string;
function NauticalMilePerHourToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NauticalMilePerHourToFloat(const AValue: TQuantity): double;
function MeterPerSquareSecondToString(const AValue: TQuantity): string;
function MeterPerSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterPerSquareSecondToVerboseString(const AValue: TQuantity): string;
function MeterPerSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterPerSquareSecondToFloat(const AValue: TQuantity): double;
function MeterPerSecondPerSecondToString(const AValue: TQuantity): string;
function MeterPerSecondPerSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterPerSecondPerSecondToVerboseString(const AValue: TQuantity): string;
function MeterPerSecondPerSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterPerSecondPerSecondToFloat(const AValue: TQuantity): double;
function MeterPerHourPerSecondToString(const AValue: TQuantity): string;
function MeterPerHourPerSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterPerHourPerSecondToVerboseString(const AValue: TQuantity): string;
function MeterPerHourPerSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterPerHourPerSecondToFloat(const AValue: TQuantity): double;
function MeterPerCubicSecondToString(const AValue: TQuantity): string;
function MeterPerCubicSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterPerCubicSecondToVerboseString(const AValue: TQuantity): string;
function MeterPerCubicSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterPerCubicSecondToFloat(const AValue: TQuantity): double;
function MeterPerQuarticSecondToString(const AValue: TQuantity): string;
function MeterPerQuarticSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterPerQuarticSecondToVerboseString(const AValue: TQuantity): string;
function MeterPerQuarticSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterPerQuarticSecondToFloat(const AValue: TQuantity): double;
function MeterPerQuinticSecondToString(const AValue: TQuantity): string;
function MeterPerQuinticSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterPerQuinticSecondToVerboseString(const AValue: TQuantity): string;
function MeterPerQuinticSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterPerQuinticSecondToFloat(const AValue: TQuantity): double;
function MeterPerSexticSecondToString(const AValue: TQuantity): string;
function MeterPerSexticSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterPerSexticSecondToVerboseString(const AValue: TQuantity): string;
function MeterPerSexticSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterPerSexticSecondToFloat(const AValue: TQuantity): double;
function SquareMeterPerSquareSecondToString(const AValue: TQuantity): string;
function SquareMeterPerSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareMeterPerSquareSecondToVerboseString(const AValue: TQuantity): string;
function SquareMeterPerSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareMeterPerSquareSecondToFloat(const AValue: TQuantity): double;
function JoulePerKilogramToString(const AValue: TQuantity): string;
function JoulePerKilogramToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function JoulePerKilogramToVerboseString(const AValue: TQuantity): string;
function JoulePerKilogramToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function JoulePerKilogramToFloat(const AValue: TQuantity): double;
function GrayToString(const AValue: TQuantity): string;
function GrayToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function GrayToVerboseString(const AValue: TQuantity): string;
function GrayToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function GrayToFloat(const AValue: TQuantity): double;
function SievertToString(const AValue: TQuantity): string;
function SievertToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SievertToVerboseString(const AValue: TQuantity): string;
function SievertToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SievertToFloat(const AValue: TQuantity): double;
function MeterSecondToString(const AValue: TQuantity): string;
function MeterSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterSecondToVerboseString(const AValue: TQuantity): string;
function MeterSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterSecondToFloat(const AValue: TQuantity): double;
function KilogramMeterToString(const AValue: TQuantity): string;
function KilogramMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramMeterToVerboseString(const AValue: TQuantity): string;
function KilogramMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramMeterToFloat(const AValue: TQuantity): double;
function KilogramPerSecondToString(const AValue: TQuantity): string;
function KilogramPerSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramPerSecondToVerboseString(const AValue: TQuantity): string;
function KilogramPerSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramPerSecondToFloat(const AValue: TQuantity): double;
function JoulePerSquareMeterPerHertzToString(const AValue: TQuantity): string;
function JoulePerSquareMeterPerHertzToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function JoulePerSquareMeterPerHertzToVerboseString(const AValue: TQuantity): string;
function JoulePerSquareMeterPerHertzToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function JoulePerSquareMeterPerHertzToFloat(const AValue: TQuantity): double;
function KilogramMeterPerSecondToString(const AValue: TQuantity): string;
function KilogramMeterPerSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramMeterPerSecondToVerboseString(const AValue: TQuantity): string;
function KilogramMeterPerSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramMeterPerSecondToFloat(const AValue: TQuantity): double;
function NewtonSecondToString(const AValue: TQuantity): string;
function NewtonSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonSecondToVerboseString(const AValue: TQuantity): string;
function NewtonSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonSecondToFloat(const AValue: TQuantity): double;
function SquareKilogramSquareMeterPerSquareSecondToString(const AValue: TQuantity): string;
function SquareKilogramSquareMeterPerSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareKilogramSquareMeterPerSquareSecondToVerboseString(const AValue: TQuantity): string;
function SquareKilogramSquareMeterPerSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareKilogramSquareMeterPerSquareSecondToFloat(const AValue: TQuantity): double;
function ReciprocalSquareRootMeterToString(const AValue: TQuantity): string;
function ReciprocalSquareRootMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ReciprocalSquareRootMeterToVerboseString(const AValue: TQuantity): string;
function ReciprocalSquareRootMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ReciprocalSquareRootMeterToFloat(const AValue: TQuantity): double;
function ReciprocalMeterToString(const AValue: TQuantity): string;
function ReciprocalMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ReciprocalMeterToVerboseString(const AValue: TQuantity): string;
function ReciprocalMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ReciprocalMeterToFloat(const AValue: TQuantity): double;
function DioptreToString(const AValue: TQuantity): string;
function DioptreToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function DioptreToVerboseString(const AValue: TQuantity): string;
function DioptreToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function DioptreToFloat(const AValue: TQuantity): double;
function ReciprocalSquareRootCubicMeterToString(const AValue: TQuantity): string;
function ReciprocalSquareRootCubicMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ReciprocalSquareRootCubicMeterToVerboseString(const AValue: TQuantity): string;
function ReciprocalSquareRootCubicMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ReciprocalSquareRootCubicMeterToFloat(const AValue: TQuantity): double;
function ReciprocalSquareMeterToString(const AValue: TQuantity): string;
function ReciprocalSquareMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ReciprocalSquareMeterToVerboseString(const AValue: TQuantity): string;
function ReciprocalSquareMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ReciprocalSquareMeterToFloat(const AValue: TQuantity): double;
function ReciprocalCubicMeterToString(const AValue: TQuantity): string;
function ReciprocalCubicMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ReciprocalCubicMeterToVerboseString(const AValue: TQuantity): string;
function ReciprocalCubicMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ReciprocalCubicMeterToFloat(const AValue: TQuantity): double;
function ReciprocalQuarticMeterToString(const AValue: TQuantity): string;
function ReciprocalQuarticMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ReciprocalQuarticMeterToVerboseString(const AValue: TQuantity): string;
function ReciprocalQuarticMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ReciprocalQuarticMeterToFloat(const AValue: TQuantity): double;
function KilogramSquareMeterToString(const AValue: TQuantity): string;
function KilogramSquareMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramSquareMeterToVerboseString(const AValue: TQuantity): string;
function KilogramSquareMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramSquareMeterToFloat(const AValue: TQuantity): double;
function KilogramSquareMeterPerSecondToString(const AValue: TQuantity): string;
function KilogramSquareMeterPerSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramSquareMeterPerSecondToVerboseString(const AValue: TQuantity): string;
function KilogramSquareMeterPerSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramSquareMeterPerSecondToFloat(const AValue: TQuantity): double;
function NewtonMeterSecondToString(const AValue: TQuantity): string;
function NewtonMeterSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonMeterSecondToVerboseString(const AValue: TQuantity): string;
function NewtonMeterSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonMeterSecondToFloat(const AValue: TQuantity): double;
function SecondPerMeterToString(const AValue: TQuantity): string;
function SecondPerMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SecondPerMeterToVerboseString(const AValue: TQuantity): string;
function SecondPerMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SecondPerMeterToFloat(const AValue: TQuantity): double;
function KilogramPerMeterToString(const AValue: TQuantity): string;
function KilogramPerMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramPerMeterToVerboseString(const AValue: TQuantity): string;
function KilogramPerMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramPerMeterToFloat(const AValue: TQuantity): double;
function KilogramPerSquareMeterToString(const AValue: TQuantity): string;
function KilogramPerSquareMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramPerSquareMeterToVerboseString(const AValue: TQuantity): string;
function KilogramPerSquareMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramPerSquareMeterToFloat(const AValue: TQuantity): double;
function KilogramPerCubicMeterToString(const AValue: TQuantity): string;
function KilogramPerCubicMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramPerCubicMeterToVerboseString(const AValue: TQuantity): string;
function KilogramPerCubicMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramPerCubicMeterToFloat(const AValue: TQuantity): double;
function PoundPerCubicInchToString(const AValue: TQuantity): string;
function PoundPerCubicInchToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function PoundPerCubicInchToVerboseString(const AValue: TQuantity): string;
function PoundPerCubicInchToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function PoundPerCubicInchToFloat(const AValue: TQuantity): double;
function NewtonToString(const AValue: TQuantity): string;
function NewtonToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonToVerboseString(const AValue: TQuantity): string;
function NewtonToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonToFloat(const AValue: TQuantity): double;
function PoundForceToString(const AValue: TQuantity): string;
function PoundForceToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function PoundForceToVerboseString(const AValue: TQuantity): string;
function PoundForceToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function PoundForceToFloat(const AValue: TQuantity): double;
function KilogramMeterPerSquareSecondToString(const AValue: TQuantity): string;
function KilogramMeterPerSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramMeterPerSquareSecondToVerboseString(const AValue: TQuantity): string;
function KilogramMeterPerSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramMeterPerSquareSecondToFloat(const AValue: TQuantity): double;
function NewtonRadianToString(const AValue: TQuantity): string;
function NewtonRadianToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonRadianToVerboseString(const AValue: TQuantity): string;
function NewtonRadianToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonRadianToFloat(const AValue: TQuantity): double;
function SquareNewtonToString(const AValue: TQuantity): string;
function SquareNewtonToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareNewtonToVerboseString(const AValue: TQuantity): string;
function SquareNewtonToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareNewtonToFloat(const AValue: TQuantity): double;
function SquareKilogramSquareMeterPerQuarticSecondToString(const AValue: TQuantity): string;
function SquareKilogramSquareMeterPerQuarticSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareKilogramSquareMeterPerQuarticSecondToVerboseString(const AValue: TQuantity): string;
function SquareKilogramSquareMeterPerQuarticSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareKilogramSquareMeterPerQuarticSecondToFloat(const AValue: TQuantity): double;
function PascalToString(const AValue: TQuantity): string;
function PascalToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function PascalToVerboseString(const AValue: TQuantity): string;
function PascalToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function PascalToFloat(const AValue: TQuantity): double;
function NewtonPerSquareMeterToString(const AValue: TQuantity): string;
function NewtonPerSquareMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonPerSquareMeterToVerboseString(const AValue: TQuantity): string;
function NewtonPerSquareMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonPerSquareMeterToFloat(const AValue: TQuantity): double;
function BarToString(const AValue: TQuantity): string;
function BarToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function BarToVerboseString(const AValue: TQuantity): string;
function BarToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function BarToFloat(const AValue: TQuantity): double;
function PoundPerSquareInchToString(const AValue: TQuantity): string;
function PoundPerSquareInchToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function PoundPerSquareInchToVerboseString(const AValue: TQuantity): string;
function PoundPerSquareInchToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function PoundPerSquareInchToFloat(const AValue: TQuantity): double;
function JoulePerCubicMeterToString(const AValue: TQuantity): string;
function JoulePerCubicMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function JoulePerCubicMeterToVerboseString(const AValue: TQuantity): string;
function JoulePerCubicMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function JoulePerCubicMeterToFloat(const AValue: TQuantity): double;
function KilogramPerMeterPerSquareSecondToString(const AValue: TQuantity): string;
function KilogramPerMeterPerSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramPerMeterPerSquareSecondToVerboseString(const AValue: TQuantity): string;
function KilogramPerMeterPerSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramPerMeterPerSquareSecondToFloat(const AValue: TQuantity): double;
function JouleToString(const AValue: TQuantity): string;
function JouleToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function JouleToVerboseString(const AValue: TQuantity): string;
function JouleToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function JouleToFloat(const AValue: TQuantity): double;
function WattHourToString(const AValue: TQuantity): string;
function WattHourToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattHourToVerboseString(const AValue: TQuantity): string;
function WattHourToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattHourToFloat(const AValue: TQuantity): double;
function WattSecondToString(const AValue: TQuantity): string;
function WattSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattSecondToVerboseString(const AValue: TQuantity): string;
function WattSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattSecondToFloat(const AValue: TQuantity): double;
function WattPerHertzToString(const AValue: TQuantity): string;
function WattPerHertzToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerHertzToVerboseString(const AValue: TQuantity): string;
function WattPerHertzToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerHertzToFloat(const AValue: TQuantity): double;
function ElectronvoltToString(const AValue: TQuantity): string;
function ElectronvoltToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ElectronvoltToVerboseString(const AValue: TQuantity): string;
function ElectronvoltToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ElectronvoltToFloat(const AValue: TQuantity): double;
function NewtonMeterToString(const AValue: TQuantity): string;
function NewtonMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonMeterToVerboseString(const AValue: TQuantity): string;
function NewtonMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonMeterToFloat(const AValue: TQuantity): double;
function PoundForceInchToString(const AValue: TQuantity): string;
function PoundForceInchToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function PoundForceInchToVerboseString(const AValue: TQuantity): string;
function PoundForceInchToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function PoundForceInchToFloat(const AValue: TQuantity): double;
function RydbergToString(const AValue: TQuantity): string;
function RydbergToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function RydbergToVerboseString(const AValue: TQuantity): string;
function RydbergToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function RydbergToFloat(const AValue: TQuantity): double;
function CalorieToString(const AValue: TQuantity): string;
function CalorieToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CalorieToVerboseString(const AValue: TQuantity): string;
function CalorieToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CalorieToFloat(const AValue: TQuantity): double;
function KilogramSquareMeterPerSquareSecondToString(const AValue: TQuantity): string;
function KilogramSquareMeterPerSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramSquareMeterPerSquareSecondToVerboseString(const AValue: TQuantity): string;
function KilogramSquareMeterPerSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramSquareMeterPerSquareSecondToFloat(const AValue: TQuantity): double;
function JoulePerRadianToString(const AValue: TQuantity): string;
function JoulePerRadianToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function JoulePerRadianToVerboseString(const AValue: TQuantity): string;
function JoulePerRadianToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function JoulePerRadianToFloat(const AValue: TQuantity): double;
function JoulePerDegreeToString(const AValue: TQuantity): string;
function JoulePerDegreeToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function JoulePerDegreeToVerboseString(const AValue: TQuantity): string;
function JoulePerDegreeToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function JoulePerDegreeToFloat(const AValue: TQuantity): double;
function NewtonMeterPerRadianToString(const AValue: TQuantity): string;
function NewtonMeterPerRadianToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonMeterPerRadianToVerboseString(const AValue: TQuantity): string;
function NewtonMeterPerRadianToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonMeterPerRadianToFloat(const AValue: TQuantity): double;
function NewtonMeterPerDegreeToString(const AValue: TQuantity): string;
function NewtonMeterPerDegreeToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonMeterPerDegreeToVerboseString(const AValue: TQuantity): string;
function NewtonMeterPerDegreeToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonMeterPerDegreeToFloat(const AValue: TQuantity): double;
function KilogramSquareMeterPerSquareSecondPerRadianToString(const AValue: TQuantity): string;
function KilogramSquareMeterPerSquareSecondPerRadianToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramSquareMeterPerSquareSecondPerRadianToVerboseString(const AValue: TQuantity): string;
function KilogramSquareMeterPerSquareSecondPerRadianToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramSquareMeterPerSquareSecondPerRadianToFloat(const AValue: TQuantity): double;
function WattToString(const AValue: TQuantity): string;
function WattToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattToVerboseString(const AValue: TQuantity): string;
function WattToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattToFloat(const AValue: TQuantity): double;
function KilogramSquareMeterPerCubicSecondToString(const AValue: TQuantity): string;
function KilogramSquareMeterPerCubicSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramSquareMeterPerCubicSecondToVerboseString(const AValue: TQuantity): string;
function KilogramSquareMeterPerCubicSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramSquareMeterPerCubicSecondToFloat(const AValue: TQuantity): double;
function CoulombToString(const AValue: TQuantity): string;
function CoulombToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CoulombToVerboseString(const AValue: TQuantity): string;
function CoulombToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CoulombToFloat(const AValue: TQuantity): double;
function AmpereHourToString(const AValue: TQuantity): string;
function AmpereHourToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function AmpereHourToVerboseString(const AValue: TQuantity): string;
function AmpereHourToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function AmpereHourToFloat(const AValue: TQuantity): double;
function AmpereSecondToString(const AValue: TQuantity): string;
function AmpereSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function AmpereSecondToVerboseString(const AValue: TQuantity): string;
function AmpereSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function AmpereSecondToFloat(const AValue: TQuantity): double;
function SquareCoulombToString(const AValue: TQuantity): string;
function SquareCoulombToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareCoulombToVerboseString(const AValue: TQuantity): string;
function SquareCoulombToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareCoulombToFloat(const AValue: TQuantity): double;
function SquareAmpereSquareSecondToString(const AValue: TQuantity): string;
function SquareAmpereSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareAmpereSquareSecondToVerboseString(const AValue: TQuantity): string;
function SquareAmpereSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareAmpereSquareSecondToFloat(const AValue: TQuantity): double;
function CoulombMeterToString(const AValue: TQuantity): string;
function CoulombMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CoulombMeterToVerboseString(const AValue: TQuantity): string;
function CoulombMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CoulombMeterToFloat(const AValue: TQuantity): double;
function VoltToString(const AValue: TQuantity): string;
function VoltToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function VoltToVerboseString(const AValue: TQuantity): string;
function VoltToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function VoltToFloat(const AValue: TQuantity): double;
function JoulePerCoulombToString(const AValue: TQuantity): string;
function JoulePerCoulombToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function JoulePerCoulombToVerboseString(const AValue: TQuantity): string;
function JoulePerCoulombToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function JoulePerCoulombToFloat(const AValue: TQuantity): double;
function KilogramSquareMeterPerAmperePerCubicSecondToString(const AValue: TQuantity): string;
function KilogramSquareMeterPerAmperePerCubicSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramSquareMeterPerAmperePerCubicSecondToVerboseString(const AValue: TQuantity): string;
function KilogramSquareMeterPerAmperePerCubicSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramSquareMeterPerAmperePerCubicSecondToFloat(const AValue: TQuantity): double;
function SquareVoltToString(const AValue: TQuantity): string;
function SquareVoltToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareVoltToVerboseString(const AValue: TQuantity): string;
function SquareVoltToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareVoltToFloat(const AValue: TQuantity): double;
function SquareKilogramQuarticMeterPerSquareAmperePerSexticSecondToString(const AValue: TQuantity): string;
function SquareKilogramQuarticMeterPerSquareAmperePerSexticSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareKilogramQuarticMeterPerSquareAmperePerSexticSecondToVerboseString(const AValue: TQuantity): string;
function SquareKilogramQuarticMeterPerSquareAmperePerSexticSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareKilogramQuarticMeterPerSquareAmperePerSexticSecondToFloat(const AValue: TQuantity): double;
function FaradToString(const AValue: TQuantity): string;
function FaradToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function FaradToVerboseString(const AValue: TQuantity): string;
function FaradToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function FaradToFloat(const AValue: TQuantity): double;
function CoulombPerVoltToString(const AValue: TQuantity): string;
function CoulombPerVoltToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CoulombPerVoltToVerboseString(const AValue: TQuantity): string;
function CoulombPerVoltToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CoulombPerVoltToFloat(const AValue: TQuantity): double;
function SquareAmpereQuarticSecondPerKilogramPerSquareMeterToString(const AValue: TQuantity): string;
function SquareAmpereQuarticSecondPerKilogramPerSquareMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareAmpereQuarticSecondPerKilogramPerSquareMeterToVerboseString(const AValue: TQuantity): string;
function SquareAmpereQuarticSecondPerKilogramPerSquareMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareAmpereQuarticSecondPerKilogramPerSquareMeterToFloat(const AValue: TQuantity): double;
function OhmToString(const AValue: TQuantity): string;
function OhmToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function OhmToVerboseString(const AValue: TQuantity): string;
function OhmToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function OhmToFloat(const AValue: TQuantity): double;
function KilogramSquareMeterPerSquareAmperePerCubicSecondToString(const AValue: TQuantity): string;
function KilogramSquareMeterPerSquareAmperePerCubicSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramSquareMeterPerSquareAmperePerCubicSecondToVerboseString(const AValue: TQuantity): string;
function KilogramSquareMeterPerSquareAmperePerCubicSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramSquareMeterPerSquareAmperePerCubicSecondToFloat(const AValue: TQuantity): double;
function SiemensToString(const AValue: TQuantity): string;
function SiemensToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SiemensToVerboseString(const AValue: TQuantity): string;
function SiemensToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SiemensToFloat(const AValue: TQuantity): double;
function SquareAmpereCubicSecondPerKilogramPerSquareMeterToString(const AValue: TQuantity): string;
function SquareAmpereCubicSecondPerKilogramPerSquareMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareAmpereCubicSecondPerKilogramPerSquareMeterToVerboseString(const AValue: TQuantity): string;
function SquareAmpereCubicSecondPerKilogramPerSquareMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareAmpereCubicSecondPerKilogramPerSquareMeterToFloat(const AValue: TQuantity): double;
function SiemensPerMeterToString(const AValue: TQuantity): string;
function SiemensPerMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SiemensPerMeterToVerboseString(const AValue: TQuantity): string;
function SiemensPerMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SiemensPerMeterToFloat(const AValue: TQuantity): double;
function TeslaToString(const AValue: TQuantity): string;
function TeslaToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function TeslaToVerboseString(const AValue: TQuantity): string;
function TeslaToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function TeslaToFloat(const AValue: TQuantity): double;
function WeberPerSquareMeterToString(const AValue: TQuantity): string;
function WeberPerSquareMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WeberPerSquareMeterToVerboseString(const AValue: TQuantity): string;
function WeberPerSquareMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WeberPerSquareMeterToFloat(const AValue: TQuantity): double;
function KilogramPerAmperePerSquareSecondToString(const AValue: TQuantity): string;
function KilogramPerAmperePerSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramPerAmperePerSquareSecondToVerboseString(const AValue: TQuantity): string;
function KilogramPerAmperePerSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramPerAmperePerSquareSecondToFloat(const AValue: TQuantity): double;
function WeberToString(const AValue: TQuantity): string;
function WeberToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WeberToVerboseString(const AValue: TQuantity): string;
function WeberToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WeberToFloat(const AValue: TQuantity): double;
function KilogramSquareMeterPerAmperePerSquareSecondToString(const AValue: TQuantity): string;
function KilogramSquareMeterPerAmperePerSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramSquareMeterPerAmperePerSquareSecondToVerboseString(const AValue: TQuantity): string;
function KilogramSquareMeterPerAmperePerSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramSquareMeterPerAmperePerSquareSecondToFloat(const AValue: TQuantity): double;
function HenryToString(const AValue: TQuantity): string;
function HenryToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function HenryToVerboseString(const AValue: TQuantity): string;
function HenryToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function HenryToFloat(const AValue: TQuantity): double;
function KilogramSquareMeterPerSquareAmperePerSquareSecondToString(const AValue: TQuantity): string;
function KilogramSquareMeterPerSquareAmperePerSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramSquareMeterPerSquareAmperePerSquareSecondToVerboseString(const AValue: TQuantity): string;
function KilogramSquareMeterPerSquareAmperePerSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramSquareMeterPerSquareAmperePerSquareSecondToFloat(const AValue: TQuantity): double;
function ReciprocalHenryToString(const AValue: TQuantity): string;
function ReciprocalHenryToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ReciprocalHenryToVerboseString(const AValue: TQuantity): string;
function ReciprocalHenryToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ReciprocalHenryToFloat(const AValue: TQuantity): double;
function LumenToString(const AValue: TQuantity): string;
function LumenToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function LumenToVerboseString(const AValue: TQuantity): string;
function LumenToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function LumenToFloat(const AValue: TQuantity): double;
function CandelaSteradianToString(const AValue: TQuantity): string;
function CandelaSteradianToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CandelaSteradianToVerboseString(const AValue: TQuantity): string;
function CandelaSteradianToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CandelaSteradianToFloat(const AValue: TQuantity): double;
function LumenSecondToString(const AValue: TQuantity): string;
function LumenSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function LumenSecondToVerboseString(const AValue: TQuantity): string;
function LumenSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function LumenSecondToFloat(const AValue: TQuantity): double;
function LumenSecondPerCubicMeterToString(const AValue: TQuantity): string;
function LumenSecondPerCubicMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function LumenSecondPerCubicMeterToVerboseString(const AValue: TQuantity): string;
function LumenSecondPerCubicMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function LumenSecondPerCubicMeterToFloat(const AValue: TQuantity): double;
function LuxToString(const AValue: TQuantity): string;
function LuxToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function LuxToVerboseString(const AValue: TQuantity): string;
function LuxToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function LuxToFloat(const AValue: TQuantity): double;
function CandelaSteradianPerSquareMeterToString(const AValue: TQuantity): string;
function CandelaSteradianPerSquareMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CandelaSteradianPerSquareMeterToVerboseString(const AValue: TQuantity): string;
function CandelaSteradianPerSquareMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CandelaSteradianPerSquareMeterToFloat(const AValue: TQuantity): double;
function LuxSecondToString(const AValue: TQuantity): string;
function LuxSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function LuxSecondToVerboseString(const AValue: TQuantity): string;
function LuxSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function LuxSecondToFloat(const AValue: TQuantity): double;
function BequerelToString(const AValue: TQuantity): string;
function BequerelToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function BequerelToVerboseString(const AValue: TQuantity): string;
function BequerelToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function BequerelToFloat(const AValue: TQuantity): double;
function KatalToString(const AValue: TQuantity): string;
function KatalToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KatalToVerboseString(const AValue: TQuantity): string;
function KatalToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KatalToFloat(const AValue: TQuantity): double;
function MolePerSecondToString(const AValue: TQuantity): string;
function MolePerSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MolePerSecondToVerboseString(const AValue: TQuantity): string;
function MolePerSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MolePerSecondToFloat(const AValue: TQuantity): double;
function NewtonPerCubicMeterToString(const AValue: TQuantity): string;
function NewtonPerCubicMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonPerCubicMeterToVerboseString(const AValue: TQuantity): string;
function NewtonPerCubicMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonPerCubicMeterToFloat(const AValue: TQuantity): double;
function PascalPerMeterToString(const AValue: TQuantity): string;
function PascalPerMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function PascalPerMeterToVerboseString(const AValue: TQuantity): string;
function PascalPerMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function PascalPerMeterToFloat(const AValue: TQuantity): double;
function KilogramPerSquareMeterPerSquareSecondToString(const AValue: TQuantity): string;
function KilogramPerSquareMeterPerSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramPerSquareMeterPerSquareSecondToVerboseString(const AValue: TQuantity): string;
function KilogramPerSquareMeterPerSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramPerSquareMeterPerSquareSecondToFloat(const AValue: TQuantity): double;
function NewtonPerMeterToString(const AValue: TQuantity): string;
function NewtonPerMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonPerMeterToVerboseString(const AValue: TQuantity): string;
function NewtonPerMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonPerMeterToFloat(const AValue: TQuantity): double;
function JoulePerSquareMeterToString(const AValue: TQuantity): string;
function JoulePerSquareMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function JoulePerSquareMeterToVerboseString(const AValue: TQuantity): string;
function JoulePerSquareMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function JoulePerSquareMeterToFloat(const AValue: TQuantity): double;
function WattPerSquareMeterPerHertzToString(const AValue: TQuantity): string;
function WattPerSquareMeterPerHertzToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerSquareMeterPerHertzToVerboseString(const AValue: TQuantity): string;
function WattPerSquareMeterPerHertzToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerSquareMeterPerHertzToFloat(const AValue: TQuantity): double;
function PoundForcePerInchToString(const AValue: TQuantity): string;
function PoundForcePerInchToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function PoundForcePerInchToVerboseString(const AValue: TQuantity): string;
function PoundForcePerInchToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function PoundForcePerInchToFloat(const AValue: TQuantity): double;
function KilogramPerSquareSecondToString(const AValue: TQuantity): string;
function KilogramPerSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramPerSquareSecondToVerboseString(const AValue: TQuantity): string;
function KilogramPerSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramPerSquareSecondToFloat(const AValue: TQuantity): double;
function CubicMeterPerSecondToString(const AValue: TQuantity): string;
function CubicMeterPerSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CubicMeterPerSecondToVerboseString(const AValue: TQuantity): string;
function CubicMeterPerSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CubicMeterPerSecondToFloat(const AValue: TQuantity): double;
function PoiseuilleToString(const AValue: TQuantity): string;
function PoiseuilleToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function PoiseuilleToVerboseString(const AValue: TQuantity): string;
function PoiseuilleToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function PoiseuilleToFloat(const AValue: TQuantity): double;
function PascalSecondToString(const AValue: TQuantity): string;
function PascalSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function PascalSecondToVerboseString(const AValue: TQuantity): string;
function PascalSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function PascalSecondToFloat(const AValue: TQuantity): double;
function KilogramPerMeterPerSecondToString(const AValue: TQuantity): string;
function KilogramPerMeterPerSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramPerMeterPerSecondToVerboseString(const AValue: TQuantity): string;
function KilogramPerMeterPerSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramPerMeterPerSecondToFloat(const AValue: TQuantity): double;
function SquareMeterPerSecondToString(const AValue: TQuantity): string;
function SquareMeterPerSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareMeterPerSecondToVerboseString(const AValue: TQuantity): string;
function SquareMeterPerSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareMeterPerSecondToFloat(const AValue: TQuantity): double;
function KilogramPerQuarticMeterToString(const AValue: TQuantity): string;
function KilogramPerQuarticMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramPerQuarticMeterToVerboseString(const AValue: TQuantity): string;
function KilogramPerQuarticMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramPerQuarticMeterToFloat(const AValue: TQuantity): double;
function QuarticMeterSecondToString(const AValue: TQuantity): string;
function QuarticMeterSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function QuarticMeterSecondToVerboseString(const AValue: TQuantity): string;
function QuarticMeterSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function QuarticMeterSecondToFloat(const AValue: TQuantity): double;
function KilogramPerQuarticMeterPerSecondToString(const AValue: TQuantity): string;
function KilogramPerQuarticMeterPerSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramPerQuarticMeterPerSecondToVerboseString(const AValue: TQuantity): string;
function KilogramPerQuarticMeterPerSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramPerQuarticMeterPerSecondToFloat(const AValue: TQuantity): double;
function CubicMeterPerKilogramToString(const AValue: TQuantity): string;
function CubicMeterPerKilogramToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CubicMeterPerKilogramToVerboseString(const AValue: TQuantity): string;
function CubicMeterPerKilogramToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CubicMeterPerKilogramToFloat(const AValue: TQuantity): double;
function KilogramSquareSecondToString(const AValue: TQuantity): string;
function KilogramSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramSquareSecondToVerboseString(const AValue: TQuantity): string;
function KilogramSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramSquareSecondToFloat(const AValue: TQuantity): double;
function CubicMeterPerSquareSecondToString(const AValue: TQuantity): string;
function CubicMeterPerSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CubicMeterPerSquareSecondToVerboseString(const AValue: TQuantity): string;
function CubicMeterPerSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CubicMeterPerSquareSecondToFloat(const AValue: TQuantity): double;
function NewtonSquareMeterToString(const AValue: TQuantity): string;
function NewtonSquareMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonSquareMeterToVerboseString(const AValue: TQuantity): string;
function NewtonSquareMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonSquareMeterToFloat(const AValue: TQuantity): double;
function KilogramCubicMeterPerSquareSecondToString(const AValue: TQuantity): string;
function KilogramCubicMeterPerSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramCubicMeterPerSquareSecondToVerboseString(const AValue: TQuantity): string;
function KilogramCubicMeterPerSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramCubicMeterPerSquareSecondToFloat(const AValue: TQuantity): double;
function NewtonCubicMeterToString(const AValue: TQuantity): string;
function NewtonCubicMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonCubicMeterToVerboseString(const AValue: TQuantity): string;
function NewtonCubicMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonCubicMeterToFloat(const AValue: TQuantity): double;
function KilogramQuarticMeterPerSquareSecondToString(const AValue: TQuantity): string;
function KilogramQuarticMeterPerSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramQuarticMeterPerSquareSecondToVerboseString(const AValue: TQuantity): string;
function KilogramQuarticMeterPerSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramQuarticMeterPerSquareSecondToFloat(const AValue: TQuantity): double;
function NewtonPerSquareKilogramToString(const AValue: TQuantity): string;
function NewtonPerSquareKilogramToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonPerSquareKilogramToVerboseString(const AValue: TQuantity): string;
function NewtonPerSquareKilogramToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonPerSquareKilogramToFloat(const AValue: TQuantity): double;
function MeterPerKilogramPerSquareSecondToString(const AValue: TQuantity): string;
function MeterPerKilogramPerSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterPerKilogramPerSquareSecondToVerboseString(const AValue: TQuantity): string;
function MeterPerKilogramPerSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterPerKilogramPerSquareSecondToFloat(const AValue: TQuantity): double;
function SquareKilogramPerMeterToString(const AValue: TQuantity): string;
function SquareKilogramPerMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareKilogramPerMeterToVerboseString(const AValue: TQuantity): string;
function SquareKilogramPerMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareKilogramPerMeterToFloat(const AValue: TQuantity): double;
function SquareKilogramPerSquareMeterToString(const AValue: TQuantity): string;
function SquareKilogramPerSquareMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareKilogramPerSquareMeterToVerboseString(const AValue: TQuantity): string;
function SquareKilogramPerSquareMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareKilogramPerSquareMeterToFloat(const AValue: TQuantity): double;
function SquareMeterPerSquareKilogramToString(const AValue: TQuantity): string;
function SquareMeterPerSquareKilogramToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareMeterPerSquareKilogramToVerboseString(const AValue: TQuantity): string;
function SquareMeterPerSquareKilogramToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareMeterPerSquareKilogramToFloat(const AValue: TQuantity): double;
function NewtonSquareMeterPerSquareKilogramToString(const AValue: TQuantity): string;
function NewtonSquareMeterPerSquareKilogramToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonSquareMeterPerSquareKilogramToVerboseString(const AValue: TQuantity): string;
function NewtonSquareMeterPerSquareKilogramToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonSquareMeterPerSquareKilogramToFloat(const AValue: TQuantity): double;
function CubicMeterPerKilogramPerSquareSecondToString(const AValue: TQuantity): string;
function CubicMeterPerKilogramPerSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CubicMeterPerKilogramPerSquareSecondToVerboseString(const AValue: TQuantity): string;
function CubicMeterPerKilogramPerSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CubicMeterPerKilogramPerSquareSecondToFloat(const AValue: TQuantity): double;
function ReciprocalKelvinToString(const AValue: TQuantity): string;
function ReciprocalKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ReciprocalKelvinToVerboseString(const AValue: TQuantity): string;
function ReciprocalKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ReciprocalKelvinToFloat(const AValue: TQuantity): double;
function KilogramKelvinToString(const AValue: TQuantity): string;
function KilogramKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramKelvinToVerboseString(const AValue: TQuantity): string;
function KilogramKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramKelvinToFloat(const AValue: TQuantity): double;
function JoulePerKelvinToString(const AValue: TQuantity): string;
function JoulePerKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function JoulePerKelvinToVerboseString(const AValue: TQuantity): string;
function JoulePerKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function JoulePerKelvinToFloat(const AValue: TQuantity): double;
function KilogramSquareMeterPerSquareSecondPerKelvinToString(const AValue: TQuantity): string;
function KilogramSquareMeterPerSquareSecondPerKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramSquareMeterPerSquareSecondPerKelvinToVerboseString(const AValue: TQuantity): string;
function KilogramSquareMeterPerSquareSecondPerKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramSquareMeterPerSquareSecondPerKelvinToFloat(const AValue: TQuantity): double;
function JoulePerKilogramPerKelvinToString(const AValue: TQuantity): string;
function JoulePerKilogramPerKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function JoulePerKilogramPerKelvinToVerboseString(const AValue: TQuantity): string;
function JoulePerKilogramPerKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function JoulePerKilogramPerKelvinToFloat(const AValue: TQuantity): double;
function SquareMeterPerSquareSecondPerKelvinToString(const AValue: TQuantity): string;
function SquareMeterPerSquareSecondPerKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareMeterPerSquareSecondPerKelvinToVerboseString(const AValue: TQuantity): string;
function SquareMeterPerSquareSecondPerKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareMeterPerSquareSecondPerKelvinToFloat(const AValue: TQuantity): double;
function MeterKelvinToString(const AValue: TQuantity): string;
function MeterKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterKelvinToVerboseString(const AValue: TQuantity): string;
function MeterKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterKelvinToFloat(const AValue: TQuantity): double;
function KelvinPerMeterToString(const AValue: TQuantity): string;
function KelvinPerMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KelvinPerMeterToVerboseString(const AValue: TQuantity): string;
function KelvinPerMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KelvinPerMeterToFloat(const AValue: TQuantity): double;
function WattPerMeterToString(const AValue: TQuantity): string;
function WattPerMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerMeterToVerboseString(const AValue: TQuantity): string;
function WattPerMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerMeterToFloat(const AValue: TQuantity): double;
function KilogramMeterPerCubicSecondToString(const AValue: TQuantity): string;
function KilogramMeterPerCubicSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramMeterPerCubicSecondToVerboseString(const AValue: TQuantity): string;
function KilogramMeterPerCubicSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramMeterPerCubicSecondToFloat(const AValue: TQuantity): double;
function WattPerSquareMeterToString(const AValue: TQuantity): string;
function WattPerSquareMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerSquareMeterToVerboseString(const AValue: TQuantity): string;
function WattPerSquareMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerSquareMeterToFloat(const AValue: TQuantity): double;
function KilogramPerCubicSecondToString(const AValue: TQuantity): string;
function KilogramPerCubicSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramPerCubicSecondToVerboseString(const AValue: TQuantity): string;
function KilogramPerCubicSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramPerCubicSecondToFloat(const AValue: TQuantity): double;
function WattPerCubicMeterToString(const AValue: TQuantity): string;
function WattPerCubicMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerCubicMeterToVerboseString(const AValue: TQuantity): string;
function WattPerCubicMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerCubicMeterToFloat(const AValue: TQuantity): double;
function WattPerKelvinToString(const AValue: TQuantity): string;
function WattPerKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerKelvinToVerboseString(const AValue: TQuantity): string;
function WattPerKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerKelvinToFloat(const AValue: TQuantity): double;
function KilogramSquareMeterPerCubicSecondPerKelvinToString(const AValue: TQuantity): string;
function KilogramSquareMeterPerCubicSecondPerKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramSquareMeterPerCubicSecondPerKelvinToVerboseString(const AValue: TQuantity): string;
function KilogramSquareMeterPerCubicSecondPerKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramSquareMeterPerCubicSecondPerKelvinToFloat(const AValue: TQuantity): double;
function WattPerMeterPerKelvinToString(const AValue: TQuantity): string;
function WattPerMeterPerKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerMeterPerKelvinToVerboseString(const AValue: TQuantity): string;
function WattPerMeterPerKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerMeterPerKelvinToFloat(const AValue: TQuantity): double;
function KilogramMeterPerCubicSecondPerKelvinToString(const AValue: TQuantity): string;
function KilogramMeterPerCubicSecondPerKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramMeterPerCubicSecondPerKelvinToVerboseString(const AValue: TQuantity): string;
function KilogramMeterPerCubicSecondPerKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramMeterPerCubicSecondPerKelvinToFloat(const AValue: TQuantity): double;
function KelvinPerWattToString(const AValue: TQuantity): string;
function KelvinPerWattToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KelvinPerWattToVerboseString(const AValue: TQuantity): string;
function KelvinPerWattToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KelvinPerWattToFloat(const AValue: TQuantity): double;
function MeterPerWattToString(const AValue: TQuantity): string;
function MeterPerWattToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterPerWattToVerboseString(const AValue: TQuantity): string;
function MeterPerWattToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterPerWattToFloat(const AValue: TQuantity): double;
function MeterKelvinPerWattToString(const AValue: TQuantity): string;
function MeterKelvinPerWattToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterKelvinPerWattToVerboseString(const AValue: TQuantity): string;
function MeterKelvinPerWattToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterKelvinPerWattToFloat(const AValue: TQuantity): double;
function SquareMeterKelvinToString(const AValue: TQuantity): string;
function SquareMeterKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareMeterKelvinToVerboseString(const AValue: TQuantity): string;
function SquareMeterKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareMeterKelvinToFloat(const AValue: TQuantity): double;
function WattPerSquareMeterPerKelvinToString(const AValue: TQuantity): string;
function WattPerSquareMeterPerKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerSquareMeterPerKelvinToVerboseString(const AValue: TQuantity): string;
function WattPerSquareMeterPerKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerSquareMeterPerKelvinToFloat(const AValue: TQuantity): double;
function KilogramPerCubicSecondPerKelvinToString(const AValue: TQuantity): string;
function KilogramPerCubicSecondPerKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramPerCubicSecondPerKelvinToVerboseString(const AValue: TQuantity): string;
function KilogramPerCubicSecondPerKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KilogramPerCubicSecondPerKelvinToFloat(const AValue: TQuantity): double;
function SquareMeterQuarticKelvinToString(const AValue: TQuantity): string;
function SquareMeterQuarticKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareMeterQuarticKelvinToVerboseString(const AValue: TQuantity): string;
function SquareMeterQuarticKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareMeterQuarticKelvinToFloat(const AValue: TQuantity): double;
function WattPerQuarticKelvinToString(const AValue: TQuantity): string;
function WattPerQuarticKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerQuarticKelvinToVerboseString(const AValue: TQuantity): string;
function WattPerQuarticKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerQuarticKelvinToFloat(const AValue: TQuantity): double;
function WattPerSquareMeterPerQuarticKelvinToString(const AValue: TQuantity): string;
function WattPerSquareMeterPerQuarticKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerSquareMeterPerQuarticKelvinToVerboseString(const AValue: TQuantity): string;
function WattPerSquareMeterPerQuarticKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerSquareMeterPerQuarticKelvinToFloat(const AValue: TQuantity): double;
function JoulePerMoleToString(const AValue: TQuantity): string;
function JoulePerMoleToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function JoulePerMoleToVerboseString(const AValue: TQuantity): string;
function JoulePerMoleToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function JoulePerMoleToFloat(const AValue: TQuantity): double;
function MoleKelvinToString(const AValue: TQuantity): string;
function MoleKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MoleKelvinToVerboseString(const AValue: TQuantity): string;
function MoleKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MoleKelvinToFloat(const AValue: TQuantity): double;
function JoulePerMolePerKelvinToString(const AValue: TQuantity): string;
function JoulePerMolePerKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function JoulePerMolePerKelvinToVerboseString(const AValue: TQuantity): string;
function JoulePerMolePerKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function JoulePerMolePerKelvinToFloat(const AValue: TQuantity): double;
function OhmMeterToString(const AValue: TQuantity): string;
function OhmMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function OhmMeterToVerboseString(const AValue: TQuantity): string;
function OhmMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function OhmMeterToFloat(const AValue: TQuantity): double;
function VoltPerMeterToString(const AValue: TQuantity): string;
function VoltPerMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function VoltPerMeterToVerboseString(const AValue: TQuantity): string;
function VoltPerMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function VoltPerMeterToFloat(const AValue: TQuantity): double;
function NewtonPerCoulombToString(const AValue: TQuantity): string;
function NewtonPerCoulombToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonPerCoulombToVerboseString(const AValue: TQuantity): string;
function NewtonPerCoulombToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonPerCoulombToFloat(const AValue: TQuantity): double;
function CoulombPerMeterToString(const AValue: TQuantity): string;
function CoulombPerMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CoulombPerMeterToVerboseString(const AValue: TQuantity): string;
function CoulombPerMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CoulombPerMeterToFloat(const AValue: TQuantity): double;
function SquareCoulombPerMeterToString(const AValue: TQuantity): string;
function SquareCoulombPerMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareCoulombPerMeterToVerboseString(const AValue: TQuantity): string;
function SquareCoulombPerMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareCoulombPerMeterToFloat(const AValue: TQuantity): double;
function CoulombPerSquareMeterToString(const AValue: TQuantity): string;
function CoulombPerSquareMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CoulombPerSquareMeterToVerboseString(const AValue: TQuantity): string;
function CoulombPerSquareMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CoulombPerSquareMeterToFloat(const AValue: TQuantity): double;
function SquareMeterPerSquareCoulombToString(const AValue: TQuantity): string;
function SquareMeterPerSquareCoulombToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareMeterPerSquareCoulombToVerboseString(const AValue: TQuantity): string;
function SquareMeterPerSquareCoulombToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareMeterPerSquareCoulombToFloat(const AValue: TQuantity): double;
function NewtonPerSquareCoulombToString(const AValue: TQuantity): string;
function NewtonPerSquareCoulombToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonPerSquareCoulombToVerboseString(const AValue: TQuantity): string;
function NewtonPerSquareCoulombToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonPerSquareCoulombToFloat(const AValue: TQuantity): double;
function NewtonSquareMeterPerSquareCoulombToString(const AValue: TQuantity): string;
function NewtonSquareMeterPerSquareCoulombToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonSquareMeterPerSquareCoulombToVerboseString(const AValue: TQuantity): string;
function NewtonSquareMeterPerSquareCoulombToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonSquareMeterPerSquareCoulombToFloat(const AValue: TQuantity): double;
function VoltMeterToString(const AValue: TQuantity): string;
function VoltMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function VoltMeterToVerboseString(const AValue: TQuantity): string;
function VoltMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function VoltMeterToFloat(const AValue: TQuantity): double;
function NewtonSquareMeterPerCoulombToString(const AValue: TQuantity): string;
function NewtonSquareMeterPerCoulombToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonSquareMeterPerCoulombToVerboseString(const AValue: TQuantity): string;
function NewtonSquareMeterPerCoulombToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonSquareMeterPerCoulombToFloat(const AValue: TQuantity): double;
function VoltMeterPerSecondToString(const AValue: TQuantity): string;
function VoltMeterPerSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function VoltMeterPerSecondToVerboseString(const AValue: TQuantity): string;
function VoltMeterPerSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function VoltMeterPerSecondToFloat(const AValue: TQuantity): double;
function FaradPerMeterToString(const AValue: TQuantity): string;
function FaradPerMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function FaradPerMeterToVerboseString(const AValue: TQuantity): string;
function FaradPerMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function FaradPerMeterToFloat(const AValue: TQuantity): double;
function AmperePerMeterToString(const AValue: TQuantity): string;
function AmperePerMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function AmperePerMeterToVerboseString(const AValue: TQuantity): string;
function AmperePerMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function AmperePerMeterToFloat(const AValue: TQuantity): double;
function MeterPerAmpereToString(const AValue: TQuantity): string;
function MeterPerAmpereToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterPerAmpereToVerboseString(const AValue: TQuantity): string;
function MeterPerAmpereToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterPerAmpereToFloat(const AValue: TQuantity): double;
function TeslaMeterToString(const AValue: TQuantity): string;
function TeslaMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function TeslaMeterToVerboseString(const AValue: TQuantity): string;
function TeslaMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function TeslaMeterToFloat(const AValue: TQuantity): double;
function NewtonPerAmpereToString(const AValue: TQuantity): string;
function NewtonPerAmpereToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonPerAmpereToVerboseString(const AValue: TQuantity): string;
function NewtonPerAmpereToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonPerAmpereToFloat(const AValue: TQuantity): double;
function TeslaPerAmpereToString(const AValue: TQuantity): string;
function TeslaPerAmpereToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function TeslaPerAmpereToVerboseString(const AValue: TQuantity): string;
function TeslaPerAmpereToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function TeslaPerAmpereToFloat(const AValue: TQuantity): double;
function HenryPerMeterToString(const AValue: TQuantity): string;
function HenryPerMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function HenryPerMeterToVerboseString(const AValue: TQuantity): string;
function HenryPerMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function HenryPerMeterToFloat(const AValue: TQuantity): double;
function TeslaMeterPerAmpereToString(const AValue: TQuantity): string;
function TeslaMeterPerAmpereToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function TeslaMeterPerAmpereToVerboseString(const AValue: TQuantity): string;
function TeslaMeterPerAmpereToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function TeslaMeterPerAmpereToFloat(const AValue: TQuantity): double;
function NewtonPerSquareAmpereToString(const AValue: TQuantity): string;
function NewtonPerSquareAmpereToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonPerSquareAmpereToVerboseString(const AValue: TQuantity): string;
function NewtonPerSquareAmpereToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function NewtonPerSquareAmpereToFloat(const AValue: TQuantity): double;
function RadianPerMeterToString(const AValue: TQuantity): string;
function RadianPerMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function RadianPerMeterToVerboseString(const AValue: TQuantity): string;
function RadianPerMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function RadianPerMeterToFloat(const AValue: TQuantity): double;
function SquareKilogramPerSquareSecondToString(const AValue: TQuantity): string;
function SquareKilogramPerSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareKilogramPerSquareSecondToVerboseString(const AValue: TQuantity): string;
function SquareKilogramPerSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareKilogramPerSquareSecondToFloat(const AValue: TQuantity): double;
function SquareSecondPerSquareMeterToString(const AValue: TQuantity): string;
function SquareSecondPerSquareMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareSecondPerSquareMeterToVerboseString(const AValue: TQuantity): string;
function SquareSecondPerSquareMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareSecondPerSquareMeterToFloat(const AValue: TQuantity): double;
function SquareJouleToString(const AValue: TQuantity): string;
function SquareJouleToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareJouleToVerboseString(const AValue: TQuantity): string;
function SquareJouleToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareJouleToFloat(const AValue: TQuantity): double;
function JouleSecondToString(const AValue: TQuantity): string;
function JouleSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function JouleSecondToVerboseString(const AValue: TQuantity): string;
function JouleSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function JouleSecondToFloat(const AValue: TQuantity): double;
function JoulePerHertzToString(const AValue: TQuantity): string;
function JoulePerHertzToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function JoulePerHertzToVerboseString(const AValue: TQuantity): string;
function JoulePerHertzToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function JoulePerHertzToFloat(const AValue: TQuantity): double;
function ElectronvoltSecondToString(const AValue: TQuantity): string;
function ElectronvoltSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ElectronvoltSecondToVerboseString(const AValue: TQuantity): string;
function ElectronvoltSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ElectronvoltSecondToFloat(const AValue: TQuantity): double;
function ElectronvoltMeterPerSpeedOfLightToString(const AValue: TQuantity): string;
function ElectronvoltMeterPerSpeedOfLightToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ElectronvoltMeterPerSpeedOfLightToVerboseString(const AValue: TQuantity): string;
function ElectronvoltMeterPerSpeedOfLightToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ElectronvoltMeterPerSpeedOfLightToFloat(const AValue: TQuantity): double;
function SquareJouleSquareSecondToString(const AValue: TQuantity): string;
function SquareJouleSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareJouleSquareSecondToVerboseString(const AValue: TQuantity): string;
function SquareJouleSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareJouleSquareSecondToFloat(const AValue: TQuantity): double;
function CoulombPerKilogramToString(const AValue: TQuantity): string;
function CoulombPerKilogramToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CoulombPerKilogramToVerboseString(const AValue: TQuantity): string;
function CoulombPerKilogramToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CoulombPerKilogramToFloat(const AValue: TQuantity): double;
function SquareMeterAmpereToString(const AValue: TQuantity): string;
function SquareMeterAmpereToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareMeterAmpereToVerboseString(const AValue: TQuantity): string;
function SquareMeterAmpereToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareMeterAmpereToFloat(const AValue: TQuantity): double;
function JoulePerTeslaToString(const AValue: TQuantity): string;
function JoulePerTeslaToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function JoulePerTeslaToVerboseString(const AValue: TQuantity): string;
function JoulePerTeslaToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function JoulePerTeslaToFloat(const AValue: TQuantity): double;
function LumenPerWattToString(const AValue: TQuantity): string;
function LumenPerWattToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function LumenPerWattToVerboseString(const AValue: TQuantity): string;
function LumenPerWattToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function LumenPerWattToFloat(const AValue: TQuantity): double;
function ReciprocalMoleToString(const AValue: TQuantity): string;
function ReciprocalMoleToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ReciprocalMoleToVerboseString(const AValue: TQuantity): string;
function ReciprocalMoleToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function ReciprocalMoleToFloat(const AValue: TQuantity): double;
function AmperePerSquareMeterToString(const AValue: TQuantity): string;
function AmperePerSquareMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function AmperePerSquareMeterToVerboseString(const AValue: TQuantity): string;
function AmperePerSquareMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function AmperePerSquareMeterToFloat(const AValue: TQuantity): double;
function MolePerCubicMeterToString(const AValue: TQuantity): string;
function MolePerCubicMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MolePerCubicMeterToVerboseString(const AValue: TQuantity): string;
function MolePerCubicMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MolePerCubicMeterToFloat(const AValue: TQuantity): double;
function CandelaPerSquareMeterToString(const AValue: TQuantity): string;
function CandelaPerSquareMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CandelaPerSquareMeterToVerboseString(const AValue: TQuantity): string;
function CandelaPerSquareMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CandelaPerSquareMeterToFloat(const AValue: TQuantity): double;
function CoulombPerCubicMeterToString(const AValue: TQuantity): string;
function CoulombPerCubicMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CoulombPerCubicMeterToVerboseString(const AValue: TQuantity): string;
function CoulombPerCubicMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CoulombPerCubicMeterToFloat(const AValue: TQuantity): double;
function GrayPerSecondToString(const AValue: TQuantity): string;
function GrayPerSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function GrayPerSecondToVerboseString(const AValue: TQuantity): string;
function GrayPerSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function GrayPerSecondToFloat(const AValue: TQuantity): double;
function SteradianHertzToString(const AValue: TQuantity): string;
function SteradianHertzToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SteradianHertzToVerboseString(const AValue: TQuantity): string;
function SteradianHertzToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SteradianHertzToFloat(const AValue: TQuantity): double;
function MeterSteradianToString(const AValue: TQuantity): string;
function MeterSteradianToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterSteradianToVerboseString(const AValue: TQuantity): string;
function MeterSteradianToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function MeterSteradianToFloat(const AValue: TQuantity): double;
function SquareMeterSteradianToString(const AValue: TQuantity): string;
function SquareMeterSteradianToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareMeterSteradianToVerboseString(const AValue: TQuantity): string;
function SquareMeterSteradianToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareMeterSteradianToFloat(const AValue: TQuantity): double;
function CubicMeterSteradianToString(const AValue: TQuantity): string;
function CubicMeterSteradianToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CubicMeterSteradianToVerboseString(const AValue: TQuantity): string;
function CubicMeterSteradianToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CubicMeterSteradianToFloat(const AValue: TQuantity): double;
function SquareMeterSteradianHertzToString(const AValue: TQuantity): string;
function SquareMeterSteradianHertzToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareMeterSteradianHertzToVerboseString(const AValue: TQuantity): string;
function SquareMeterSteradianHertzToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function SquareMeterSteradianHertzToFloat(const AValue: TQuantity): double;
function WattPerSteradianToString(const AValue: TQuantity): string;
function WattPerSteradianToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerSteradianToVerboseString(const AValue: TQuantity): string;
function WattPerSteradianToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerSteradianToFloat(const AValue: TQuantity): double;
function WattPerSteradianPerHertzToString(const AValue: TQuantity): string;
function WattPerSteradianPerHertzToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerSteradianPerHertzToVerboseString(const AValue: TQuantity): string;
function WattPerSteradianPerHertzToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerSteradianPerHertzToFloat(const AValue: TQuantity): double;
function WattPerMeterPerSteradianToString(const AValue: TQuantity): string;
function WattPerMeterPerSteradianToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerMeterPerSteradianToVerboseString(const AValue: TQuantity): string;
function WattPerMeterPerSteradianToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerMeterPerSteradianToFloat(const AValue: TQuantity): double;
function WattPerSquareMeterPerSteradianToString(const AValue: TQuantity): string;
function WattPerSquareMeterPerSteradianToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerSquareMeterPerSteradianToVerboseString(const AValue: TQuantity): string;
function WattPerSquareMeterPerSteradianToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerSquareMeterPerSteradianToFloat(const AValue: TQuantity): double;
function WattPerCubicMeterPerSteradianToString(const AValue: TQuantity): string;
function WattPerCubicMeterPerSteradianToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerCubicMeterPerSteradianToVerboseString(const AValue: TQuantity): string;
function WattPerCubicMeterPerSteradianToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerCubicMeterPerSteradianToFloat(const AValue: TQuantity): double;
function WattPerSquareMeterPerSteradianPerHertzToString(const AValue: TQuantity): string;
function WattPerSquareMeterPerSteradianPerHertzToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerSquareMeterPerSteradianPerHertzToVerboseString(const AValue: TQuantity): string;
function WattPerSquareMeterPerSteradianPerHertzToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function WattPerSquareMeterPerSteradianPerHertzToFloat(const AValue: TQuantity): double;
function KatalPerCubicMeterToString(const AValue: TQuantity): string;
function KatalPerCubicMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KatalPerCubicMeterToVerboseString(const AValue: TQuantity): string;
function KatalPerCubicMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function KatalPerCubicMeterToFloat(const AValue: TQuantity): double;
function CoulombPerMoleToString(const AValue: TQuantity): string;
function CoulombPerMoleToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CoulombPerMoleToVerboseString(const AValue: TQuantity): string;
function CoulombPerMoleToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
function CoulombPerMoleToFloat(const AValue: TQuantity): double;

{ Power functions }

implementation

uses
  Math;

const

  { Mul Table }

  MulTable : array[0..159, 0..159] of longint = (
    (0, 5, 9, 13, 14, 15, 16, 17, 25, 26, 31, 37, 38, 39, 40, 47, 48, 49, 50, 53, 54, 55, 56, 57, 58, 61, 61, 65, 69, 72, 73, 74, 75, 76, 80, 81, 82, 84, 86, 87, 88, 90, 91, 92, 93, 94, 95, 97, 98, 99, 100, 102, 102, 106, 108, 114, 114, 129, 131, 134, 136, 137, 140, 142, 145, 147, 149, 150, 153, 155, 157, 57, 160, 161, 162, 164, 166, 168, 171, 176, 177, 180, 181, 182, 183, 184, 185, 186, 187, 189, 191, 193, 194, 195, 196, 198, 199, 200, 202, 204, 205, 206, 208, 210, 211, 213, 215, 216, 217, 218, 219, 221, 222, 223, 224, 225, 226, 227, 228, 230, 231, 232, 233, 234, 235, 236, 238, 239, 240, 241, 242, 244, 245, 88, 249, 250, 251, 256, 257, 258, 260, 261, 262, 263, 162, 265, 266, 58, 17, 26, 31, 180, 129, 114, 206, 208, 210, 171, 278, 279),
    (5, 9, 13, 14, 15, 16, -1, 80, -1, -1, -1, 182, -1, -1, -1, -1, 131, -1, -1, -1, -1, -1, -1, 160, 0, 58, 58, 17, 65, 69, 72, 73, 74, 180, -1, -1, 40, 81, -1, -1, 97, -1, -1, -1, -1, -1, 94, -1, -1, -1, -1, 84, 84, -1, 177, 95, 95, 114, -1, -1, -1, 153, -1, -1, 155, 142, 239, -1, -1, -1, 147, 160, -1, -1, 164, -1, 56, -1, 82, 31, 98, 26, -1, -1, 181, -1, -1, 176, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 102, 171, 108, 200, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 242, -1, -1, -1, -1, -1, 227, -1, 236, -1, 230, -1, -1, -1, -1, 97, -1, -1, -1, -1, -1, -1, -1, -1, 232, -1, 164, -1, 76, 0, 80, -1, -1, 26, 114, 95, 102, 171, 108, 82, 263, -1),
    (9, 13, 14, 15, 16, -1, -1, -1, -1, -1, -1, -1, -1, -1, 185, -1, -1, 134, -1, -1, -1, -1, -1, -1, 5, 0, 0, 80, 17, 65, 69, 72, 73, 26, -1, -1, -1, -1, -1, -1, -1, -1, 250, -1, -1, -1, -1, -1, -1, -1, -1, 81, 81, 86, 98, 94, 94, 95, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 142, -1, -1, -1, -1, -1, -1, 99, 40, -1, -1, -1, -1, -1, -1, -1, -1, 31, -1, -1, -1, -1, -1, -1, 184, -1, -1, -1, 218, -1, -1, 84, 82, 177, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 245, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 47, -1, 256, -1, -1, -1, -1, -1, -1, -1, -1, -1, 180, 5, -1, -1, -1, -1, 95, 94, 84, 82, 177, 40, -1, -1),
    (13, 14, 15, 16, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 5, 5, -1, 80, 17, 65, 69, 72, -1, -1, -1, 185, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 94, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 81, 40, 98, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 26, 9, -1, -1, -1, -1, 94, -1, 81, 40, 98, -1, -1, -1),
    (14, 15, 16, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 13, 9, 9, -1, -1, 80, 17, 65, 69, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 185, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 13, -1, -1, -1, -1, -1, -1, -1, -1, -1, 185, -1, -1),
    (15, 16, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 14, 13, 13, -1, -1, -1, 80, 17, 65, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 185, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 14, -1, -1, -1, -1, -1, -1, -1, 185, -1, -1, -1, -1),
    (16, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 15, 14, 14, -1, -1, -1, -1, 80, 17, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (17, 80, -1, -1, -1, -1, -1, 26, -1, 31, 37, 38, 39, -1, 81, -1, -1, -1, 204, -1, -1, -1, -1, -1, 65, 69, 69, 180, 76, 266, -1, -1, -1, 186, -1, 94, 84, 95, -1, 25, 0, 87, 88, 91, 92, -1, -1, 5, 40, 98, 99, 114, 114, -1, 171, 187, 187, -1, 136, -1, -1, 236, -1, -1, 227, -1, 147, 242, -1, -1, -1, -1, -1, 164, -1, -1, -1, 108, 102, -1, 82, 176, 100, -1, -1, -1, -1, -1, 189, -1, -1, 47, 193, -1, -1, -1, -1, -1, -1, -1, 50, 129, 206, 208, -1, 211, 217, -1, -1, -1, 213, -1, -1, -1, -1, -1, -1, -1, 137, 131, 134, 230, -1, -1, -1, -1, -1, 142, 48, -1, 153, 245, 155, 0, -1, -1, -1, -1, -1, -1, -1, -1, 240, -1, -1, 232, -1, 65, 26, 31, 37, 176, -1, 187, 129, 206, 208, 102, -1, -1),
    (25, -1, -1, -1, -1, -1, -1, -1, 17, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 87, 88, 90, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 87, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (26, -1, -1, -1, -1, -1, -1, 31, -1, 37, 38, 39, -1, -1, 94, -1, 258, -1, -1, -1, -1, 221, -1, -1, 180, 76, 76, 176, 186, -1, -1, -1, -1, -1, -1, -1, 95, -1, 256, -1, 17, 25, 0, 88, 91, -1, -1, 80, 81, 40, 98, 187, 187, 251, 102, 189, 189, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 153, -1, -1, -1, -1, -1, -1, 57, 160, -1, 171, 114, -1, 84, -1, 99, -1, -1, -1, -1, -1, -1, -1, 196, -1, 47, -1, -1, 218, -1, -1, -1, -1, 204, -1, 129, 206, -1, -1, -1, -1, -1, -1, 211, -1, -1, -1, -1, -1, -1, -1, 236, 136, -1, 131, -1, 235, -1, -1, -1, -1, -1, -1, -1, 155, -1, 17, 86, 9, -1, -1, -1, -1, -1, -1, 48, -1, 57, 230, -1, 180, 31, 37, 38, -1, -1, 189, -1, 129, 206, 114, -1, -1),
    (31, -1, -1, -1, -1, -1, -1, 37, -1, 38, 39, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 176, 186, 186, -1, -1, -1, -1, -1, -1, -1, 182, -1, -1, -1, -1, -1, 26, -1, 17, 0, 88, -1, -1, -1, 94, 81, 40, 189, 189, -1, 114, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 160, -1, -1, -1, 102, 187, -1, 95, -1, 98, -1, 177, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 129, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 136, -1, -1, -1, -1, -1, -1, 258, -1, -1, -1, -1, 26, -1, -1, -1, -1, -1, -1, -1, -1, -1, 56, -1, 131, -1, 176, 37, 38, 39, -1, -1, -1, -1, -1, 129, 187, 166, -1),
    (37, 182, -1, -1, -1, -1, -1, 38, -1, 39, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 31, -1, 26, 17, 0, -1, -1, -1, -1, 94, 81, -1, -1, -1, 187, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 114, 189, -1, -1, -1, 40, -1, 82, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 31, 256, -1, -1, -1, -1, -1, -1, -1, 258, -1, -1, 136, -1, -1, 38, 39, -1, -1, -1, -1, -1, -1, -1, 189, -1, -1),
    (38, -1, -1, -1, -1, -1, -1, 39, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 37, -1, 31, 26, 17, -1, -1, 182, -1, -1, 94, -1, -1, -1, 189, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 187, -1, -1, -1, -1, 81, -1, 84, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 37, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 39, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (39, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 38, -1, 37, 31, 26, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 189, -1, -1, -1, -1, 94, -1, 95, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 38, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (40, -1, 185, -1, -1, -1, -1, 81, -1, 94, -1, -1, -1, -1, 47, -1, -1, -1, 199, -1, -1, -1, -1, -1, 82, 171, 171, 84, 102, 206, -1, -1, -1, 114, -1, -1, -1, -1, -1, -1, 98, -1, 99, 100, 181, -1, -1, -1, 193, 194, -1, -1, -1, -1, -1, 86, 86, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 249, -1, -1, 95, -1, -1, -1, 31, -1, 187, -1, 256, 69, -1, -1, -1, 186, -1, -1, -1, 200, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 155, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 98, -1, -1, -1, -1, 131, -1, -1, -1, -1, -1, -1, -1, 129, 82, 81, 94, -1, 95, -1, 86, -1, -1, -1, 249, -1, -1),
    (47, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 249, 249, -1, -1, -1, -1, -1, -1, 86, -1, -1, -1, -1, -1, -1, 193, -1, 194, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 102, -1, -1, 26, 187, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 193, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (48, 131, -1, -1, -1, -1, -1, -1, -1, 258, -1, -1, -1, -1, -1, -1, 49, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 136, -1, -1, -1, -1, -1, 240, -1, 262, -1, -1, -1, -1, 230, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 129, -1, -1, 137, -1, -1, 171, 114, 153, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 236, 206, -1, -1, -1, -1, -1, 238, -1, -1, -1, -1, 17, 102, 150, 242, 240, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 258, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (49, -1, 134, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 129, -1, -1, -1, -1, 114, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 76, -1, -1, -1, -1, -1, -1, -1, -1, 171, 102, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (50, -1, -1, -1, -1, -1, -1, 204, -1, -1, -1, -1, -1, -1, 199, -1, -1, -1, 53, 54, 55, -1, 225, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 205, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, -1, 114, 76, -1, -1, -1, -1, -1, 129, 206, -1, 217, -1, 26, 208, -1, -1, -1, -1, -1, 224, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 205, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 204, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (53, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 54, 55, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 50, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (54, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 55, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 53, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 211, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (55, -1, -1, -1, -1, -1, -1, -1, -1, 221, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 54, -1, -1, -1, -1, -1, -1, 223, -1, -1, -1, -1, -1, -1, -1, -1, -1, 129, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 221, -1, -1, -1, -1, -1, 223, -1, -1, -1, -1),
    (56, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 225, -1, -1, -1, -1, -1, 166, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 263, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 114, -1, 200, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, -1, -1, -1, -1, -1, 166, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 131),
    (57, 160, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 162, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (58, 0, 5, 9, 13, 14, 15, 65, -1, 180, 176, -1, -1, -1, 82, -1, -1, -1, -1, -1, -1, -1, 166, -1, 61, -1, -1, 69, 72, 73, 74, 75, -1, 266, 17, 84, 171, 102, -1, -1, -1, -1, -1, -1, -1, 95, 114, 88, 177, -1, -1, 206, 206, -1, 210, 129, 129, -1, 48, -1, -1, -1, -1, 147, -1, 157, -1, -1, 137, 145, -1, -1, 57, -1, -1, 162, -1, -1, 208, 186, 108, 76, 183, 37, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 211, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 235, -1, 240, -1, 262, -1, -1, -1, 238, -1, 149, -1, -1, 228, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 278, -1, -1, -1, 61, 65, 180, 176, 76, -1, 129, -1, -1, -1, 208, -1, -1),
    (61, 58, 0, 5, 9, 13, 14, 69, -1, 76, 186, -1, -1, -1, 171, 249, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 72, 73, 74, 75, -1, -1, -1, 65, 102, 208, 206, 106, -1, -1, -1, -1, -1, -1, 114, 129, -1, 108, 168, -1, -1, -1, -1, -1, -1, -1, -1, -1, 49, -1, -1, -1, 157, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 210, 266, -1, -1, -1, 196, 40, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 202, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 234, -1, -1, 91, -1, 251, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 69, 76, 186, 266, -1, -1, -1, -1, -1, -1, -1, -1),
    (61, 58, 0, 5, 9, 13, 14, 69, -1, 76, 186, -1, -1, -1, 171, 249, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 72, 73, 74, 75, -1, -1, -1, 65, 102, 208, 206, 106, -1, -1, -1, -1, -1, -1, 114, 129, -1, 108, 168, -1, -1, -1, -1, -1, -1, -1, -1, -1, 49, -1, -1, -1, 157, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 210, 266, -1, -1, -1, 196, 40, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 202, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 234, -1, -1, 91, -1, 251, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 69, 76, 186, 266, -1, -1, -1, -1, -1, -1, -1, -1),
    (65, 17, 80, -1, -1, -1, -1, 180, -1, 176, -1, -1, -1, -1, 84, -1, -1, -1, -1, -1, -1, -1, -1, -1, 69, 72, 72, 76, 266, -1, -1, -1, -1, -1, 26, 95, 102, 114, -1, -1, 58, -1, -1, -1, -1, -1, 187, 0, 82, 177, -1, 129, 129, -1, 208, -1, -1, -1, -1, -1, 258, 238, -1, -1, 235, -1, 157, 228, 236, 227, -1, -1, -1, 162, -1, -1, -1, 210, 206, -1, 171, 186, -1, 38, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 48, -1, 240, -1, -1, -1, -1, -1, 147, -1, -1, 137, -1, 145, 58, -1, 97, -1, -1, -1, -1, -1, -1, -1, -1, -1, 262, -1, 69, 180, 176, -1, 186, -1, -1, -1, -1, -1, 206, -1, -1),
    (69, 65, 17, 80, -1, -1, -1, 76, -1, 186, -1, -1, -1, -1, 102, -1, -1, -1, -1, -1, -1, -1, -1, -1, 72, 73, 73, 266, -1, -1, -1, -1, -1, -1, 180, 114, 206, 129, -1, -1, 61, -1, -1, -1, -1, 187, -1, 58, 171, 108, 168, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 238, 235, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 208, -1, -1, -1, -1, -1, 81, -1, -1, -1, -1, 249, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 49, -1, -1, -1, -1, -1, -1, 157, -1, -1, -1, 234, -1, 61, -1, 88, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 72, 76, 186, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (72, 69, 65, 17, 80, -1, -1, 266, -1, -1, -1, -1, -1, -1, 206, -1, -1, -1, -1, -1, -1, -1, -1, -1, 73, 74, 74, -1, -1, -1, -1, -1, -1, -1, 76, 129, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 61, 208, 210, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 84, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 73, 266, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (73, 72, 69, 65, 17, 80, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 74, 75, 75, -1, -1, -1, -1, -1, -1, -1, 266, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 102, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 74, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (74, 73, 72, 69, 65, 17, 80, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 75, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 206, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 75, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (75, 74, 73, 72, 69, 65, 17, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (76, 180, 26, -1, -1, -1, -1, 186, -1, -1, -1, -1, -1, -1, 114, 86, -1, -1, -1, -1, -1, -1, -1, -1, 266, -1, -1, -1, -1, -1, -1, -1, -1, -1, 176, 187, 129, -1, 251, -1, 69, -1, 61, -1, -1, 189, -1, 65, 102, 171, 108, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 206, -1, 168, -1, -1, -1, 94, -1, -1, -1, -1, -1, 249, -1, -1, 202, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 238, -1, 235, 69, 106, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 266, 186, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (80, -1, -1, -1, -1, -1, -1, -1, -1, -1, 182, -1, -1, -1, -1, -1, 136, -1, -1, -1, -1, -1, -1, -1, 17, 65, 65, 26, 180, 76, 266, -1, -1, 176, -1, -1, 81, 94, -1, -1, 5, -1, 97, -1, -1, -1, -1, 9, -1, -1, -1, 95, 95, -1, 82, -1, -1, 187, -1, -1, -1, -1, -1, -1, -1, -1, 142, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 177, 84, 37, 40, 31, -1, -1, 100, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 114, 102, 171, -1, 200, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 153, -1, -1, -1, -1, 145, -1, -1, -1, -1, 131, -1, -1, -1, -1, 5, -1, -1, -1, -1, -1, -1, -1, -1, 230, -1, -1, -1, 186, 17, -1, -1, 182, 31, 187, -1, 114, 102, 171, 84, -1, -1),
    (81, -1, -1, -1, -1, -1, -1, 94, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 84, 102, 102, 95, 114, 129, -1, -1, -1, 187, -1, -1, -1, -1, -1, -1, 40, -1, 98, 99, 100, -1, -1, -1, 47, 193, 194, 86, 86, -1, 249, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 231, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 37, -1, 189, 256, -1, 76, -1, -1, 184, -1, -1, -1, -1, -1, -1, 199, -1, -1, -1, -1, -1, -1, 13, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 40, -1, -1, -1, -1, 136, -1, -1, -1, -1, -1, -1, -1, -1, 84, 94, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (82, 40, -1, 185, -1, -1, -1, 84, -1, 95, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 171, 208, 208, 102, 206, -1, -1, -1, -1, 129, 81, -1, 249, -1, -1, -1, 177, -1, -1, -1, 183, -1, 86, 98, -1, -1, -1, -1, -1, -1, -1, -1, -1, 106, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 187, -1, 114, -1, -1, -1, 176, -1, -1, -1, -1, 72, -1, -1, -1, -1, -1, -1, -1, 211, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 145, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 177, -1, -1, -1, -1, 48, -1, -1, -1, -1, -1, -1, -1, -1, 171, 84, 95, -1, 114, 106, -1, -1, -1, -1, -1, -1, -1),
    (84, 81, -1, -1, -1, -1, -1, 95, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 102, 206, 206, 114, 129, -1, -1, -1, -1, -1, 94, -1, -1, 86, -1, -1, 82, -1, 177, -1, -1, -1, -1, 40, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 231, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 189, 249, 187, -1, -1, -1, -1, -1, -1, -1, -1, 266, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 106, -1, -1, -1, -1, -1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 227, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 82, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 102, 95, -1, -1, 187, -1, -1, 106, -1, -1, -1, -1, -1),
    (86, -1, -1, -1, -1, -1, -1, -1, -1, 256, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 106, 106, -1, -1, -1, -1, -1, -1, 251, -1, -1, -1, -1, -1, -1, -1, -1, 249, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 47, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 256, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (87, -1, -1, -1, -1, -1, -1, 25, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 88, 90, 91, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 90, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 25, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (88, 97, -1, -1, -1, -1, -1, 0, 87, 17, 26, 31, 37, 38, 98, 193, 240, -1, 205, -1, -1, -1, -1, -1, -1, -1, -1, 58, 61, -1, -1, -1, -1, 69, 5, 40, 177, 82, -1, 90, 91, -1, 92, 93, -1, 81, 84, -1, 99, 100, 181, 171, 171, -1, 168, 102, 102, 206, 230, 231, 131, 228, -1, 239, -1, 149, -1, -1, 242, 245, -1, -1, -1, -1, -1, 161, -1, -1, 108, 180, -1, 65, -1, -1, -1, -1, -1, 76, 114, 187, -1, 194, -1, -1, -1, -1, -1, -1, -1, 50, -1, 208, 210, -1, 213, 219, -1, -1, 215, -1, -1, -1, -1, -1, -1, -1, -1, 145, -1, 232, -1, 265, -1, -1, -1, 137, -1, -1, 262, -1, 150, -1, 244, 91, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 72, -1, 0, 17, 26, 65, 206, 102, 208, 210, -1, 108, -1, -1),
    (90, -1, -1, -1, -1, -1, -1, 87, 88, 25, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 91, -1, 92, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 87, 25, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (91, -1, 250, -1, -1, -1, -1, 88, 90, 0, 17, 26, 31, 37, 99, 194, 262, -1, -1, -1, -1, -1, -1, 162, -1, -1, -1, -1, -1, -1, -1, -1, -1, 61, 97, 98, -1, 177, 249, -1, 92, -1, 93, -1, -1, 40, 82, -1, 100, 181, -1, 108, 108, -1, -1, 171, 171, 208, 232, -1, 230, -1, -1, -1, -1, -1, -1, -1, 150, 244, -1, 162, 164, -1, -1, -1, -1, -1, 168, 65, -1, 58, -1, -1, -1, -1, -1, 69, 102, 114, -1, -1, -1, -1, 191, -1, -1, -1, -1, 205, -1, 210, -1, -1, 219, -1, -1, -1, -1, 198, -1, 55, -1, -1, -1, -1, -1, -1, -1, 265, -1, -1, -1, -1, 234, 228, -1, -1, -1, -1, -1, -1, -1, 92, -1, -1, 106, 86, -1, 48, -1, -1, -1, -1, -1, -1, -1, -1, 88, 0, 17, 58, 208, 171, 210, -1, -1, 168, -1, -1),
    (92, -1, -1, -1, -1, -1, -1, 91, -1, 88, 0, 17, 26, 31, 100, -1, -1, -1, -1, -1, -1, -1, 263, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 99, -1, -1, -1, -1, 93, -1, -1, -1, -1, 98, 177, -1, 181, -1, -1, 168, 168, -1, -1, 108, 108, 210, 265, -1, 232, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 161, -1, -1, -1, 278, -1, -1, 58, 183, -1, -1, 80, -1, -1, -1, 61, 171, 102, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 93, -1, -1, -1, -1, -1, 240, -1, -1, -1, -1, -1, -1, -1, -1, 91, 88, 0, -1, 210, 108, -1, -1, -1, -1, -1, -1),
    (93, -1, -1, -1, -1, -1, -1, 92, -1, 91, 88, 0, 17, 26, 181, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 100, 183, -1, -1, -1, -1, -1, -1, -1, -1, 99, -1, -1, -1, -1, -1, -1, -1, -1, -1, 168, 168, -1, -1, -1, 265, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5, -1, -1, -1, -1, 108, 171, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 249, -1, 262, -1, -1, -1, -1, -1, -1, -1, -1, 92, 91, 88, -1, -1, 168, -1, -1, -1, -1, -1, -1),
    (94, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 95, 114, 114, -1, 187, -1, -1, -1, -1, 189, -1, -1, -1, -1, -1, -1, 81, -1, 40, 98, 99, -1, -1, -1, -1, 47, 193, -1, -1, -1, -1, 256, 256, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 134, -1, -1, -1, -1, -1, -1, 249, 86, -1, -1, -1, 194, -1, -1, 38, -1, -1, -1, -1, 186, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 81, -1, 185, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 95, -1, -1, -1, -1, -1, 256, -1, -1, -1, 86, -1, -1),
    (95, 94, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 114, 129, 129, 187, -1, -1, -1, -1, -1, -1, -1, -1, 86, -1, -1, -1, 84, -1, 82, 177, -1, -1, 256, 81, -1, -1, -1, -1, -1, -1, -1, -1, -1, 251, -1, -1, -1, -1, -1, -1, -1, 134, 231, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 189, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 106, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 84, -1, -1, -1, -1, 258, -1, -1, -1, -1, -1, -1, -1, -1, 114, -1, -1, -1, 189, 251, -1, -1, 106, -1, -1, -1, -1),
    (97, -1, -1, -1, -1, -1, -1, 5, -1, 80, -1, -1, 182, -1, -1, -1, 230, -1, -1, -1, -1, -1, -1, -1, 88, -1, -1, 0, 58, 61, -1, -1, -1, 65, 9, -1, 98, 40, -1, -1, -1, -1, -1, -1, -1, -1, 81, 250, -1, -1, -1, 82, 82, -1, -1, 84, 84, 102, -1, -1, -1, 242, -1, -1, 245, 239, -1, -1, -1, -1, 149, -1, -1, -1, 161, -1, -1, -1, 177, 26, 99, 17, -1, -1, -1, -1, -1, 180, 95, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 171, 108, 168, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 155, 150, -1, -1, -1, -1, -1, 145, 153, 137, -1, 232, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 136, -1, -1, 265, -1, 161, -1, 69, 88, 5, 80, -1, 17, 102, 84, 171, 108, 168, 177, -1, -1),
    (98, -1, -1, -1, -1, -1, -1, 40, -1, 81, 94, -1, -1, -1, 193, -1, -1, -1, -1, -1, -1, -1, -1, -1, 177, 108, 108, 82, 171, 208, -1, -1, -1, 102, -1, 47, -1, -1, -1, -1, 99, -1, 100, 181, -1, -1, -1, -1, 194, -1, -1, 249, 249, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 95, -1, 84, -1, -1, -1, 26, -1, 114, 86, -1, 61, -1, -1, -1, 76, -1, -1, -1, -1, 199, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 245, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 99, -1, -1, -1, -1, 230, -1, -1, -1, -1, -1, -1, -1, 206, 177, 40, 81, 94, 84, -1, -1, -1, -1, -1, -1, -1, -1),
    (99, -1, -1, -1, -1, -1, -1, 98, -1, 40, 81, 94, -1, -1, 194, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 168, 168, 177, 108, 210, -1, -1, -1, 171, -1, 193, -1, -1, -1, -1, 100, -1, 181, -1, -1, 47, -1, -1, -1, -1, -1, -1, -1, -1, -1, 249, 249, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 84, -1, 82, -1, -1, -1, 17, -1, 102, -1, 86, -1, -1, -1, -1, 69, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 244, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 100, -1, -1, -1, -1, 232, -1, -1, -1, -1, -1, -1, -1, 208, -1, 98, 40, 81, 82, -1, 249, -1, -1, -1, -1, -1, -1),
    (100, -1, -1, -1, -1, -1, -1, 99, -1, 98, 40, 81, 94, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 168, -1, -1, -1, -1, 108, -1, 194, -1, -1, -1, -1, 181, -1, -1, -1, -1, 193, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 82, -1, 177, -1, -1, -1, 0, -1, 171, 249, -1, -1, -1, -1, -1, 61, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 181, -1, -1, -1, -1, 265, -1, -1, -1, -1, -1, -1, -1, 210, -1, 99, 98, 40, 177, -1, -1, -1, -1, -1, -1, -1, -1),
    (102, 84, 81, -1, -1, -1, -1, 114, -1, 187, 189, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 206, -1, -1, 129, -1, -1, -1, -1, -1, -1, 95, 86, -1, -1, -1, -1, 171, -1, 108, 168, -1, -1, -1, 82, 249, -1, -1, 106, 106, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 231, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 251, -1, -1, -1, -1, 196, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 235, -1, 140, -1, -1, -1, -1, 153, -1, -1, -1, 171, -1, 98, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 206, 114, 187, 189, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (102, 84, 81, -1, -1, -1, -1, 114, -1, 187, 189, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 206, -1, -1, 129, -1, -1, -1, -1, -1, -1, 95, 86, -1, -1, -1, -1, 171, -1, 108, 168, -1, -1, -1, 82, 249, -1, -1, 106, 106, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 231, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 251, -1, -1, -1, -1, 196, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 235, -1, 140, -1, -1, -1, -1, 153, -1, -1, -1, 171, -1, 98, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 206, 114, 187, 189, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (106, -1, 86, -1, -1, -1, -1, -1, -1, 251, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 84, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 140, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 249, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 251, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (108, 177, 98, -1, -1, -1, -1, 171, -1, 102, 114, 187, 189, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 210, -1, -1, 208, -1, -1, -1, -1, -1, -1, 82, 249, -1, -1, -1, -1, 168, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 129, -1, 206, -1, -1, -1, 76, 193, -1, 106, -1, -1, -1, -1, 191, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 234, -1, -1, -1, -1, -1, -1, 150, -1, -1, -1, 168, -1, 100, -1, -1, -1, -1, 161, -1, -1, -1, -1, -1, -1, 210, 171, 102, 114, 206, -1, -1, -1, -1, -1, -1, -1, -1),
    (114, 95, 94, -1, -1, -1, -1, 187, -1, 189, -1, -1, -1, -1, 86, -1, -1, -1, -1, -1, -1, -1, -1, -1, 129, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 102, -1, 171, 108, 168, 256, -1, 84, -1, 249, -1, -1, -1, -1, -1, 251, 251, -1, -1, -1, -1, -1, -1, 134, -1, -1, -1, -1, -1, -1, 49, -1, -1, -1, -1, -1, -1, -1, 106, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 200, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 80, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 231, -1, -1, -1, -1, -1, 102, -1, 40, -1, -1, -1, -1, 160, 224, -1, -1, -1, -1, -1, 129, 187, 189, -1, -1, -1, 251, -1, -1, -1, 106, -1, -1),
    (114, 95, 94, -1, -1, -1, -1, 187, -1, 189, -1, -1, -1, -1, 86, -1, -1, -1, -1, -1, -1, -1, -1, -1, 129, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 102, -1, 171, 108, 168, 256, -1, 84, -1, 249, -1, -1, -1, -1, -1, 251, 251, -1, -1, -1, -1, -1, -1, 134, -1, -1, -1, -1, -1, -1, 49, -1, -1, -1, -1, -1, -1, -1, 106, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 200, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 80, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 231, -1, -1, -1, -1, -1, 102, -1, 40, -1, -1, -1, -1, 160, 224, -1, -1, -1, -1, -1, 129, 187, 189, -1, -1, -1, 251, -1, -1, -1, 106, -1, -1),
    (129, 114, 95, 94, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 187, -1, 106, -1, -1, -1, 206, -1, 208, 210, -1, -1, 251, 102, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 140, 49, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 211, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 50, 17, 204, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 236, -1, -1, -1, 206, -1, 82, -1, -1, -1, -1, 57, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (131, -1, -1, -1, -1, -1, -1, 136, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 48, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 230, -1, 232, 265, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 134, -1, -1, 114, -1, -1, 153, -1, -1, 82, 95, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 258, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 102, 231, -1, -1, -1, 228, 236, 187, -1, -1, -1, 80, 84, -1, -1, 230, -1, -1, -1, -1, -1, -1, -1, 279, -1, -1, -1, -1, -1, 48, 136, -1, -1, 258, -1, -1, -1, -1, -1, -1, -1, -1),
    (134, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 49, 49, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 231, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 251, -1, 95, -1, -1, -1, -1, 94, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 26, 102, 187, -1, -1, -1, -1, -1, -1, 40, 81, 231, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (136, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 258, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 131, -1, 230, 232, 265, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 187, -1, -1, -1, -1, -1, 84, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 114, 134, -1, 231, -1, 137, -1, 189, -1, -1, -1, -1, 95, -1, -1, 131, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (137, 153, -1, -1, -1, -1, -1, 236, -1, -1, -1, -1, -1, -1, -1, -1, 129, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 238, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 228, -1, -1, -1, -1, -1, -1, 242, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 114, -1, 187, 140, -1, 131, -1, 48, 240, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 241, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 102, -1, 171, -1, -1, -1, -1, -1, 230, 206, 227, -1, -1, -1, 228, -1, -1, -1, -1, 76, -1, -1, -1, 208, -1, -1, 108, -1, -1, 236, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 224),
    (140, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 251, -1, -1, -1, 114, -1, 129, 206, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 227, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 102, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (142, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 147, 157, 157, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 239, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 231, 231, -1, -1, 134, 134, -1, -1, -1, -1, 131, 114, -1, 5, -1, -1, -1, -1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 80, 230, -1, -1, -1, -1, 88, 17, 136, -1, -1, -1, -1, -1, 250, -1, 239, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 147, -1, -1, -1, -1, -1, 134, -1, -1, -1, -1, -1, -1),
    (145, 155, -1, -1, -1, -1, -1, 227, -1, -1, -1, -1, -1, -1, -1, -1, 137, 129, -1, -1, -1, -1, -1, -1, -1, -1, -1, 235, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 245, -1, -1, -1, -1, -1, -1, -1, -1, -1, 140, 153, 95, -1, -1, -1, 5, -1, 0, 88, -1, -1, -1, 58, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 242, 84, 150, -1, -1, -1, -1, -1, 97, 228, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 227, -1, -1, -1, 140, -1, -1, -1, -1, -1, -1, -1),
    (147, 142, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 157, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 231, -1, -1, 149, -1, -1, -1, -1, -1, 134, 239, -1, -1, -1, -1, -1, -1, -1, -1, -1, 49, -1, -1, -1, 48, 129, -1, 0, -1, -1, 232, 131, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 17, 240, -1, -1, -1, -1, -1, 65, -1, -1, -1, -1, -1, 230, -1, 97, 149, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 157, -1, -1, -1, -1, 49, -1, -1, -1, -1, -1, -1, -1),
    (149, 239, -1, -1, -1, -1, -1, 147, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 157, -1, -1, -1, -1, -1, -1, 142, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 231, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 240, 206, -1, 88, -1, -1, 265, 230, 97, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 262, -1, -1, -1, -1, -1, 58, 48, -1, -1, -1, -1, 232, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 147, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (150, -1, -1, -1, -1, -1, -1, 242, -1, 153, -1, -1, -1, -1, -1, -1, 171, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 228, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 82, -1, 84, -1, -1, -1, -1, 232, 265, -1, -1, -1, 262, -1, -1, -1, -1, -1, -1, -1, -1, 236, -1, 137, -1, -1, -1, -1, -1, 238, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 177, -1, -1, -1, -1, -1, -1, -1, -1, 108, 245, -1, -1, -1, -1, -1, -1, -1, -1, 58, 114, -1, -1, 168, -1, -1, -1, -1, -1, 242, 153, -1, 137, -1, -1, -1, -1, -1, -1, -1, -1),
    (153, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 114, -1, -1, -1, -1, -1, -1, -1, 137, -1, -1, 236, 238, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 242, -1, 150, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 95, -1, -1, -1, -1, -1, -1, 131, 230, -1, -1, -1, 48, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 84, -1, 82, -1, -1, -1, -1, -1, -1, 102, -1, -1, -1, -1, 242, -1, -1, -1, -1, 180, 189, -1, -1, 171, -1, -1, 177, -1, 137, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (155, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 153, 114, -1, -1, -1, -1, -1, -1, 145, -1, -1, 227, 235, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 245, -1, 244, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 94, -1, -1, -1, 9, -1, 5, 97, -1, -1, -1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 81, -1, -1, -1, -1, -1, -1, -1, 242, -1, -1, -1, -1, 245, -1, -1, -1, -1, -1, -1, -1, -1, 150, -1, -1, -1, -1, 145, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (157, 147, 142, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 231, -1, -1, -1, -1, -1, -1, -1, -1, -1, 134, -1, 149, -1, -1, -1, -1, -1, -1, -1, 49, 49, -1, -1, -1, -1, -1, -1, -1, 58, -1, -1, 262, 48, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 65, -1, -1, -1, -1, -1, -1, 69, -1, -1, -1, -1, -1, 240, 91, 88, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 49, -1, -1, -1, -1, -1, -1),
    (57, 160, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 162, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (160, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 57, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 164, 161, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 57, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (161, -1, -1, -1, -1, -1, -1, 164, -1, -1, 160, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 162, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 57, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 164, -1, 160, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (162, 164, -1, -1, -1, -1, -1, -1, -1, 57, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 161, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 57, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (164, -1, -1, -1, -1, -1, -1, -1, -1, 160, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 162, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 161, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 57, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 161, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 162, -1, 160, -1, 57, -1, -1, -1, -1, -1, -1, -1, -1),
    (166, 56, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 278, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 129, -1, 211, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 58, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 48),
    (168, -1, 99, -1, -1, -1, -1, 108, -1, 171, 102, 114, 187, 189, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 210, -1, -1, -1, -1, -1, -1, 177, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 249, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 206, -1, 208, -1, 95, -1, 69, 194, -1, -1, 106, -1, -1, -1, -1, 73, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 181, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 108, 171, 102, 208, -1, -1, -1, -1, -1, -1, -1, -1),
    (171, 82, 40, -1, 185, -1, -1, 102, -1, 114, 187, 189, -1, -1, 249, -1, -1, -1, -1, -1, -1, -1, -1, -1, 208, -1, -1, 206, -1, -1, -1, -1, -1, -1, 84, -1, -1, -1, -1, -1, 108, -1, 168, -1, -1, 86, -1, 177, -1, -1, -1, -1, -1, -1, -1, 106, 106, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 129, -1, -1, -1, 186, 47, -1, -1, 251, 73, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 97, -1, 200, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 242, -1, -1, -1, 108, -1, 99, -1, -1, -1, -1, 164, -1, -1, -1, -1, -1, -1, 208, 102, 114, 187, 129, -1, 106, -1, -1, -1, -1, -1, -1),
    (176, 31, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 186, -1, -1, -1, -1, -1, -1, -1, -1, -1, 37, -1, 187, 189, -1, -1, 180, -1, 65, 58, -1, -1, -1, 26, 95, 84, 82, -1, -1, -1, 129, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 236, -1, -1, -1, -1, -1, 57, -1, -1, -1, 206, -1, -1, 114, -1, 177, -1, 108, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 258, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 227, -1, 180, -1, 80, -1, -1, -1, -1, -1, -1, -1, 166, -1, 48, -1, 186, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (177, 98, -1, -1, -1, -1, -1, 82, -1, 84, 95, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 108, 210, 210, 171, 208, -1, -1, -1, -1, 206, 40, -1, -1, 249, -1, -1, -1, -1, -1, 183, -1, -1, -1, 99, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 114, -1, 102, -1, -1, -1, 180, -1, 129, -1, -1, -1, -1, -1, -1, 266, -1, -1, -1, 213, -1, -1, -1, -1, -1, -1, -1, -1, 250, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 240, -1, -1, -1, -1, -1, -1, -1, -1, 108, 82, 84, 95, 102, -1, -1, -1, -1, -1, -1, -1, -1),
    (180, 26, -1, -1, -1, -1, -1, 176, -1, -1, -1, -1, -1, -1, 95, -1, -1, -1, -1, -1, -1, -1, -1, -1, 76, 266, 266, 186, -1, -1, -1, -1, -1, -1, 31, -1, 114, 187, -1, -1, 65, -1, 58, -1, -1, -1, 189, 17, 84, 82, 177, -1, -1, -1, 206, -1, -1, -1, 258, -1, -1, -1, -1, -1, -1, -1, -1, 137, -1, -1, -1, -1, -1, -1, -1, 57, -1, 208, 129, -1, 102, -1, -1, 39, 168, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 238, -1, -1, 48, -1, -1, -1, -1, -1, -1, -1, -1, 236, 145, 227, 65, -1, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, 240, -1, 76, 176, -1, -1, -1, -1, -1, -1, -1, -1, 129, -1, -1),
    (181, -1, -1, -1, -1, -1, -1, 100, -1, 99, 98, 40, 81, 94, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 183, -1, -1, -1, -1, -1, -1, -1, -1, 168, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 194, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 177, -1, -1, -1, -1, -1, 88, -1, 108, -1, 249, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 183, 100, 99, 98, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (182, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 37, -1, -1, 38, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 80, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 95, -1, -1, -1, 39, -1, -1, 40, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 189, 187, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 37, -1, -1, -1, 39, -1, -1, -1, 189, 187, -1, -1, -1),
    (183, 181, -1, -1, -1, -1, -1, -1, -1, -1, 177, 82, 84, 95, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 100, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 108, -1, 168, -1, 40, -1, -1, -1, 210, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 177, 168, -1, -1, -1, -1, -1, -1, -1, -1),
    (184, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 31, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 196, 196, -1, -1, -1, -1, -1, -1, -1, -1, 37, 176, -1, -1, -1, -1, -1, -1, -1, -1, 38, -1, -1, 26, 17, 0, -1, -1, -1, 76, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 69, 186, -1, 180, -1, 88, -1, -1, -1, -1, -1, -1, -1, -1, 94, 81, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 266, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 187, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 257, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 266, 186, -1, -1),
    (185, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 40, 40, -1, 81, 84, 102, 206, -1, 94, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 193, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 194, 47, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 17, -1, -1, -1, 31, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 95, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 47, -1, -1),
    (186, 176, 31, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 187, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 189, -1, -1, -1, -1, 76, -1, 69, 61, -1, -1, -1, 180, 114, 102, 171, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 238, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 129, -1, 108, -1, 210, -1, -1, -1, -1, -1, -1, 86, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 235, -1, 76, -1, 17, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (187, -1, -1, -1, -1, -1, -1, 189, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 256, -1, -1, -1, -1, 114, -1, 102, 171, 108, -1, -1, 95, 86, -1, 249, 251, 251, -1, 106, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 140, -1, -1, -1, 134, -1, -1, -1, -1, -1, 114, -1, 81, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 189, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (189, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 256, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 187, -1, 114, 102, 171, -1, -1, -1, -1, 86, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 106, 251, -1, -1, -1, 249, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 187, -1, 94, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 251, -1, -1),
    (191, -1, -1, -1, -1, -1, -1, -1, -1, 196, -1, -1, -1, -1, 69, 102, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 76, 72, 266, -1, -1, -1, -1, -1, -1, -1, 186, -1, -1, 61, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 73, -1, -1, -1, -1, -1, -1, -1, 17, -1, -1, -1, -1, 171, 108, -1, -1, -1, -1, -1, -1, -1, -1, -1, 74, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 196, -1, -1, -1, -1, -1, 74, -1, 73, -1, -1),
    (193, -1, -1, -1, -1, -1, -1, 47, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 249, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 194, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 94, -1, 86, -1, -1, 171, -1, -1, 17, 114, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 194, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 47, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (194, -1, -1, -1, -1, -1, -1, 193, -1, 47, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 249, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 81, -1, -1, -1, -1, 108, -1, -1, 0, 102, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 193, 47, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (195, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 26, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 184, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 196, 196, -1, 191, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 17, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 76, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (196, -1, 184, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 186, 187, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 191, -1, -1, -1, -1, -1, 76, 69, 61, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 73, -1, -1, 266, -1, -1, -1, -1, -1, 31, -1, -1, -1, -1, 114, 102, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (198, -1, -1, -1, -1, -1, -1, -1, -1, 218, -1, -1, -1, -1, -1, -1, -1, -1, 0, 50, 53, 54, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 202, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 200, 200, 211, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 40, -1, -1, 17, 88, 213, 219, -1, -1, -1, -1, -1, 216, -1, -1, -1, -1, -1, 226, 56, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 218, -1, -1, 211, 200, 213, 219, -1, -1, -1, -1),
    (199, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 40, -1, 86, 114, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 94, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (200, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 114, -1, -1, -1, -1, -1, 211, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 86, -1, -1, 187, 102, -1, -1, -1, -1, -1, 5, -1, 80, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 226, -1, -1, -1, -1, -1, 211, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (202, -1, 218, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 200, -1, -1, -1, 76, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 211, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 213, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 114, -1, -1, 186, 69, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 198, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (204, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 50, -1, 205, -1, -1, -1, -1, -1, 199, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 17, -1, 187, 186, -1, 53, -1, -1, -1, -1, 129, -1, -1, -1, 31, 206, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 50, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (205, -1, -1, -1, -1, -1, -1, 50, -1, 204, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 199, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 88, -1, 102, 69, 53, -1, -1, -1, -1, 206, 208, -1, 215, -1, 17, 210, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 50, 204, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (206, 102, 84, 81, -1, -1, -1, 129, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 114, -1, -1, 106, -1, -1, 208, -1, 210, -1, -1, -1, -1, 171, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 213, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 205, 0, 50, -1, -1, -1, -1, -1, -1, -1, -1, 140, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 137, -1, -1, -1, 208, -1, 177, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 129, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (208, 171, 82, 40, -1, 185, -1, 206, -1, 129, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 223, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 102, -1, -1, -1, -1, -1, 210, -1, -1, -1, -1, -1, 106, 108, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 189, -1, -1, -1, -1, -1, -1, 74, -1, -1, -1, -1, 219, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 88, 205, 211, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 228, -1, -1, -1, 210, -1, -1, -1, -1, -1, -1, 162, -1, -1, -1, -1, -1, -1, -1, 206, 129, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (210, 108, 177, 98, -1, -1, -1, 208, -1, 206, 129, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 171, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 168, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 187, -1, 266, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 91, -1, 213, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 208, 206, 129, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (211, 200, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 129, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 213, -1, 219, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 206, -1, -1, -1, -1, -1, 0, -1, 17, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 213, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (213, -1, -1, -1, -1, -1, -1, 211, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 206, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 200, -1, -1, -1, -1, -1, 219, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 129, 208, -1, -1, -1, -1, -1, 88, 198, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 219, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 211, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (215, -1, -1, -1, -1, -1, -1, 217, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 50, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5, -1, -1, -1, 205, -1, -1, 0, 88, -1, -1, -1, -1, 91, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 217, -1, -1, -1, 50, -1, 205, -1, -1, -1, -1, -1),
    (216, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 217, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 13, -1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5, 5, 84, -1, 80, 80, 17, -1, -1, -1, 241, 227, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 97, -1, 250, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 215, 0, 88, 91, -1, 198, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 17, 80, 0, 88, 91, 97, -1, -1),
    (217, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 215, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 204, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 216, -1, 80, -1, -1, -1, 50, 205, -1, 17, 0, -1, -1, -1, -1, 88, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 215, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 204, -1, 50, 205, -1, -1, -1, -1),
    (218, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 26, -1, -1, -1, -1, -1, -1, 202, 202, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 198, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 200, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 94, -1, -1, 31, 17, -1, 211, 213, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 211, 213, 200, -1, -1),
    (219, -1, -1, -1, -1, -1, -1, 213, -1, 211, -1, -1, -1, -1, -1, -1, -1, -1, 208, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 206, 210, -1, -1, -1, -1, -1, 91, -1, 88, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 213, 211, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (221, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 55, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (222, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 211, 129, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (223, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (224, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 114, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 129, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 226, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 108, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 210, -1),
    (225, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 56, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 114, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 50, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (226, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 224, -1, -1, -1, 200, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 211, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 114, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (227, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 236, -1, -1, -1, -1, -1, -1, -1, 235, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 145, -1, -1, -1, -1, -1, -1, 155, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 80, -1, 17, 0, -1, -1, -1, 65, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 140, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 153, 95, 242, -1, -1, -1, -1, -1, 5, 137, -1, -1, -1, -1, 145, -1, -1, -1, -1, -1, -1, -1, -1, 228, -1, -1, 150, -1, 235, -1, -1, -1, -1, -1, -1, 140, -1, -1, -1, -1, -1),
    (228, 242, -1, -1, -1, -1, -1, 137, -1, 236, -1, -1, -1, -1, -1, -1, 206, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 153, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 150, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 102, -1, 114, -1, -1, 230, -1, 240, 262, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 238, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 171, -1, 108, -1, -1, -1, 140, -1, 232, 208, 145, -1, -1, -1, -1, -1, -1, -1, -1, 69, -1, -1, -1, 210, -1, -1, 168, -1, -1, 137, 236, -1, 238, -1, -1, -1, -1, -1, -1, -1, -1),
    (230, -1, -1, -1, -1, -1, -1, 131, -1, 136, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 240, -1, -1, 48, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 232, -1, 265, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 231, -1, 134, 102, -1, -1, 242, -1, -1, 177, 84, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 258, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 153, 171, -1, -1, -1, -1, -1, 137, 114, 129, -1, -1, 5, 82, -1, -1, 232, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 240, 131, 136, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (231, -1, -1, -1, -1, -1, -1, 134, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 49, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 84, -1, -1, -1, -1, 81, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 95, -1, -1, -1, -1, 17, 171, 114, -1, -1, -1, -1, -1, -1, 98, 40, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 134, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (232, -1, -1, -1, -1, -1, -1, 230, -1, 131, 136, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 262, -1, -1, 240, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 265, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 231, 171, -1, -1, 150, -1, -1, -1, 82, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 48, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 242, 108, -1, -1, -1, -1, -1, 228, 102, 206, -1, -1, 97, 177, -1, -1, 265, -1, -1, -1, -1, 157, -1, -1, -1, -1, -1, -1, -1, -1, 262, 230, 131, 136, 48, -1, -1, -1, -1, -1, -1, -1, -1),
    (233, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 155, -1, -1, 76, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 145, 227, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 245, 244, -1, 235, 235, 140, 234, -1, -1, -1, -1, 26, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 17, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (234, -1, 245, -1, -1, -1, -1, -1, -1, 235, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 145, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 228, 102, 137, -1, -1, 88, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 140, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 171, -1, -1, -1, -1, -1, -1, 91, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 238, -1, -1, -1, -1, -1, -1, -1, -1, -1, 235, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (235, 227, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 238, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 234, -1, -1, -1, -1, 145, -1, -1, -1, 140, 140, -1, -1, -1, -1, -1, 236, 187, -1, -1, -1, 17, -1, 65, 58, -1, -1, -1, 69, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 137, 114, 228, -1, -1, -1, -1, -1, 0, -1, -1, -1, -1, -1, -1, -1, 245, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (236, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 238, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 137, -1, 228, -1, -1, -1, -1, 153, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 187, -1, 189, -1, -1, 136, -1, -1, 48, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 140, 114, -1, 102, -1, -1, -1, -1, -1, 131, 129, -1, -1, -1, -1, 137, -1, -1, -1, -1, 186, -1, -1, -1, 206, -1, -1, 171, -1, 238, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (238, 236, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 137, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 129, -1, 206, -1, -1, -1, -1, -1, 48, -1, -1, 140, -1, -1, -1, -1, 242, -1, -1, -1, -1, -1, -1, -1, -1, -1, 208, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (239, -1, -1, -1, -1, -1, -1, 142, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 149, -1, -1, 147, 157, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 231, 231, -1, -1, -1, -1, 230, 102, -1, 97, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 134, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5, 232, -1, -1, -1, -1, 91, 0, 131, 48, -1, -1, -1, -1, -1, 250, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 149, 142, -1, -1, -1, -1, 231, -1, -1, -1, -1, -1, -1),
    (240, 230, -1, -1, -1, -1, -1, 48, -1, -1, 258, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 131, -1, -1, -1, -1, -1, 262, -1, -1, -1, -1, -1, -1, 232, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 206, -1, -1, 228, -1, -1, 108, 102, 242, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 137, 208, -1, -1, -1, -1, -1, -1, 129, -1, -1, -1, 0, 171, -1, 150, 262, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 48, -1, 258, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (241, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 17, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 153, 153, -1, 150, -1, -1, 236, 80, -1, -1, 227, -1, -1, -1, -1, -1, 245, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 242, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 137, 228, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 145, 5, -1, 97, -1, -1, -1, -1, -1, -1, 0, -1, 155, -1, -1, -1, -1, -1, -1, -1, -1, 31, -1, -1, 88, -1, -1, -1, -1, -1, -1, -1, -1, -1, 236, -1, 137, 228, -1, 242, -1, -1),
    (242, -1, -1, -1, -1, -1, -1, 153, -1, -1, -1, -1, -1, -1, -1, -1, 102, -1, -1, -1, -1, -1, -1, -1, 228, -1, -1, 137, -1, -1, -1, -1, -1, 238, -1, -1, -1, -1, -1, -1, 150, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 84, -1, 95, -1, -1, -1, -1, 230, 232, -1, -1, -1, 240, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 236, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 82, -1, 177, -1, -1, -1, -1, 140, -1, 171, 155, -1, -1, -1, 150, -1, -1, -1, -1, 65, 187, -1, -1, 108, -1, -1, -1, -1, 228, 153, -1, -1, 236, -1, -1, -1, -1, -1, -1, -1, -1),
    (244, -1, -1, -1, -1, -1, -1, 245, -1, 155, -1, -1, -1, -1, -1, -1, 150, 171, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 234, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 40, -1, -1, -1, 250, -1, -1, -1, -1, -1, -1, 91, -1, -1, -1, -1, -1, -1, -1, -1, 227, -1, 145, -1, -1, -1, -1, -1, 235, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 98, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 153, -1, -1, -1, -1, -1, -1, -1, -1, 245, 155, -1, 145, -1, -1, -1, -1, -1, -1, -1, -1),
    (245, -1, -1, -1, -1, -1, -1, 155, -1, -1, -1, -1, -1, -1, -1, -1, 242, 102, -1, -1, -1, -1, -1, -1, -1, 234, 234, 145, -1, -1, -1, -1, -1, 235, -1, -1, -1, -1, -1, -1, 244, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 81, -1, -1, -1, -1, -1, 97, -1, -1, -1, -1, 88, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 227, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 40, -1, -1, -1, -1, -1, -1, 250, 150, -1, -1, -1, -1, 244, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 155, -1, -1, 227, -1, -1, -1, -1, -1, -1, -1, -1),
    (88, 97, -1, -1, -1, -1, -1, 0, 87, 17, 26, 31, 37, 38, 98, 193, 240, -1, 205, -1, -1, -1, -1, -1, -1, -1, -1, 58, 61, -1, -1, -1, -1, 69, 5, 40, 177, 82, -1, 90, 91, -1, 92, 93, -1, 81, 84, -1, 99, 100, 181, 171, 171, -1, 168, 102, 102, 206, 230, 231, 131, 228, -1, 239, -1, 149, -1, -1, 242, 245, -1, -1, -1, -1, -1, 161, -1, -1, 108, 180, -1, 65, -1, -1, -1, -1, -1, 76, 114, 187, -1, 194, -1, -1, -1, -1, -1, -1, -1, 50, -1, 208, 210, -1, 213, 219, -1, -1, 215, -1, -1, -1, -1, -1, -1, -1, -1, 145, -1, 232, -1, 265, -1, -1, -1, 137, -1, -1, 262, -1, 150, -1, 244, 91, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 72, -1, 0, 17, 26, 65, 206, 102, 208, 210, -1, 108, -1, -1),
    (249, -1, 47, -1, -1, -1, -1, -1, -1, 86, -1, 256, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 106, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 187, -1, -1, -1, -1, -1, -1, -1, 76, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 194, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 86, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (250, -1, -1, -1, -1, -1, -1, -1, -1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 91, 91, 97, 88, -1, -1, -1, -1, 0, -1, -1, -1, -1, 47, -1, -1, -1, -1, -1, -1, 185, -1, -1, -1, -1, -1, 98, 98, 249, 100, 40, 40, 82, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 181, 99, 80, -1, 5, -1, -1, -1, -1, -1, 17, 81, 94, -1, -1, -1, -1, -1, -1, -1, -1, 198, -1, -1, 177, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 245, -1, 242, -1, -1, -1, -1, -1, -1, -1, 194, -1, 86, -1, -1, -1, -1, -1, -1, -1, -1, -1, 58, -1, -1, 9, -1, 5, 82, 40, 177, -1, -1, 99, -1, -1),
    (251, -1, 256, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 106, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 86, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (256, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 251, 251, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 86, -1, 249, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (257, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 131, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 136, 48, -1, -1, -1, -1, -1, -1, -1, -1, -1, 258, -1, 230, 232, 265, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 76, -1, -1, -1, -1, -1, 58, 180, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 240, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 69, -1, -1, 157, -1, -1, -1, 186, -1, -1, -1, -1, 65, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (258, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 48, 240, 262, -1, -1, 136, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 114, 189, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 238, -1, -1, -1, -1, -1, 31, 187, 153, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 49, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (260, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 161, 160, 160, 57, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 164, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 162, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 57, 160, -1, 162, -1, 164, -1, -1),
    (261, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 224, 224, -1, 279, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 58, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 226, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 50, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 92, -1, -1, -1, -1, -1, -1, -1, -1, -1, 224, -1, -1, -1, -1, -1, -1),
    (262, 232, -1, -1, -1, -1, -1, 240, -1, 48, -1, 258, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 230, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 265, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 208, -1, -1, -1, -1, -1, 168, 171, 150, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 228, 210, -1, -1, -1, -1, -1, -1, 206, -1, -1, -1, 88, 108, -1, -1, -1, -1, -1, -1, -1, -1, 49, -1, -1, -1, -1, -1, -1, -1, -1, 240, 48, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (263, -1, -1, -1, -1, -1, -1, -1, -1, -1, 56, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 278, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 166, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 108, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 92, -1, -1, -1, -1, -1, 278, -1, -1, 56, -1, -1, -1, -1, -1, -1, -1, -1, 265),
    (162, 164, -1, -1, -1, -1, -1, -1, -1, 57, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 161, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 57, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (265, -1, -1, -1, -1, -1, -1, 232, -1, 230, 131, 136, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 262, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 108, -1, -1, -1, -1, -1, -1, 177, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 48, -1, 240, -1, -1, -1, 257, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 150, 168, -1, -1, -1, -1, -1, -1, 171, 208, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 232, 230, 131, 240, -1, -1, -1, -1, -1, -1, -1, -1),
    (266, 76, 180, 26, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 129, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 186, -1, -1, -1, -1, -1, 72, -1, -1, -1, -1, -1, -1, 69, 206, 208, 210, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 95, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 72, -1, 58, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (58, 0, 5, 9, 13, 14, 15, 65, -1, 180, 176, -1, -1, -1, 82, -1, -1, -1, -1, -1, -1, -1, 166, -1, 61, -1, -1, 69, 72, 73, 74, 75, -1, 266, 17, 84, 171, 102, -1, -1, -1, -1, -1, -1, -1, 95, 114, 88, 177, -1, -1, 206, 206, -1, 210, 129, 129, -1, 48, -1, -1, -1, -1, 147, -1, 157, -1, -1, 137, 145, -1, -1, 57, -1, -1, 162, -1, -1, 208, 186, 108, 76, 183, 37, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 211, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 235, -1, 240, -1, 262, -1, -1, -1, 238, -1, 149, -1, -1, 228, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 278, -1, -1, -1, 61, 65, 180, 176, 76, -1, 129, -1, -1, -1, 208, -1, -1),
    (17, 80, -1, -1, -1, -1, -1, 26, -1, 31, 37, 38, 39, -1, 81, -1, -1, -1, 204, -1, -1, -1, -1, -1, 65, 69, 69, 180, 76, 266, -1, -1, -1, 186, -1, 94, 84, 95, -1, 25, 0, 87, 88, 91, 92, -1, -1, 5, 40, 98, 99, 114, 114, -1, 171, 187, 187, -1, 136, -1, -1, 236, -1, -1, 227, -1, 147, 242, -1, -1, -1, -1, -1, 164, -1, -1, -1, 108, 102, -1, 82, 176, 100, -1, -1, -1, -1, -1, 189, -1, -1, 47, 193, -1, -1, -1, -1, -1, -1, -1, 50, 129, 206, 208, -1, 211, 217, -1, -1, -1, 213, -1, -1, -1, -1, -1, -1, -1, 137, 131, 134, 230, -1, -1, -1, -1, -1, 142, 48, -1, 153, 245, 155, 0, -1, -1, -1, -1, -1, -1, -1, -1, 240, -1, -1, 232, -1, 65, 26, 31, 37, 176, -1, 187, 129, 206, 208, 102, -1, -1),
    (26, -1, -1, -1, -1, -1, -1, 31, -1, 37, 38, 39, -1, -1, 94, -1, 258, -1, -1, -1, -1, 221, -1, -1, 180, 76, 76, 176, 186, -1, -1, -1, -1, -1, -1, -1, 95, -1, 256, -1, 17, 25, 0, 88, 91, -1, -1, 80, 81, 40, 98, 187, 187, 251, 102, 189, 189, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 153, -1, -1, -1, -1, -1, -1, 57, 160, -1, 171, 114, -1, 84, -1, 99, -1, -1, -1, -1, -1, -1, -1, 196, -1, 47, -1, -1, 218, -1, -1, -1, -1, 204, -1, 129, 206, -1, -1, -1, -1, -1, -1, 211, -1, -1, -1, -1, -1, -1, -1, 236, 136, -1, 131, -1, 235, -1, -1, -1, -1, -1, -1, -1, 155, -1, 17, 86, 9, -1, -1, -1, -1, -1, -1, 48, -1, 57, 230, -1, 180, 31, 37, 38, -1, -1, 189, -1, 129, 206, 114, -1, -1),
    (31, -1, -1, -1, -1, -1, -1, 37, -1, 38, 39, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 176, 186, 186, -1, -1, -1, -1, -1, -1, -1, 182, -1, -1, -1, -1, -1, 26, -1, 17, 0, 88, -1, -1, -1, 94, 81, 40, 189, 189, -1, 114, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 160, -1, -1, -1, 102, 187, -1, 95, -1, 98, -1, 177, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 129, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 136, -1, -1, -1, -1, -1, -1, 258, -1, -1, -1, -1, 26, -1, -1, -1, -1, -1, -1, -1, -1, -1, 56, -1, 131, -1, 176, 37, 38, 39, -1, -1, -1, -1, -1, 129, 187, 166, -1),
    (180, 26, -1, -1, -1, -1, -1, 176, -1, -1, -1, -1, -1, -1, 95, -1, -1, -1, -1, -1, -1, -1, -1, -1, 76, 266, 266, 186, -1, -1, -1, -1, -1, -1, 31, -1, 114, 187, -1, -1, 65, -1, 58, -1, -1, -1, 189, 17, 84, 82, 177, -1, -1, -1, 206, -1, -1, -1, 258, -1, -1, -1, -1, -1, -1, -1, -1, 137, -1, -1, -1, -1, -1, -1, -1, 57, -1, 208, 129, -1, 102, -1, -1, 39, 168, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 238, -1, -1, 48, -1, -1, -1, -1, -1, -1, -1, -1, 236, 145, 227, 65, -1, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, 240, -1, 76, 176, -1, -1, -1, -1, -1, -1, -1, -1, 129, -1, -1),
    (129, 114, 95, 94, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 187, -1, 106, -1, -1, -1, 206, -1, 208, 210, -1, -1, 251, 102, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 140, 49, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 211, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 50, 17, 204, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 236, -1, -1, -1, 206, -1, 82, -1, -1, -1, -1, 57, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (114, 95, 94, -1, -1, -1, -1, 187, -1, 189, -1, -1, -1, -1, 86, -1, -1, -1, -1, -1, -1, -1, -1, -1, 129, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 102, -1, 171, 108, 168, 256, -1, 84, -1, 249, -1, -1, -1, -1, -1, 251, 251, -1, -1, -1, -1, -1, -1, 134, -1, -1, -1, -1, -1, -1, 49, -1, -1, -1, -1, -1, -1, -1, 106, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 200, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 80, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 231, -1, -1, -1, -1, -1, 102, -1, 40, -1, -1, -1, -1, 160, 224, -1, -1, -1, -1, -1, 129, 187, 189, -1, -1, -1, 251, -1, -1, -1, 106, -1, -1),
    (206, 102, 84, 81, -1, -1, -1, 129, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 114, -1, -1, 106, -1, -1, 208, -1, 210, -1, -1, -1, -1, 171, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 213, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 205, 0, 50, -1, -1, -1, -1, -1, -1, -1, -1, 140, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 137, -1, -1, -1, 208, -1, 177, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 129, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (208, 171, 82, 40, -1, 185, -1, 206, -1, 129, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 223, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 102, -1, -1, -1, -1, -1, 210, -1, -1, -1, -1, -1, 106, 108, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 189, -1, -1, -1, -1, -1, -1, 74, -1, -1, -1, -1, 219, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 88, 205, 211, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 228, -1, -1, -1, 210, -1, -1, -1, -1, -1, -1, 162, -1, -1, -1, -1, -1, -1, -1, 206, 129, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (210, 108, 177, 98, -1, -1, -1, 208, -1, 206, 129, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 171, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 168, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 187, -1, 266, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 91, -1, 213, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 208, 206, 129, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (171, 82, 40, -1, 185, -1, -1, 102, -1, 114, 187, 189, -1, -1, 249, -1, -1, -1, -1, -1, -1, -1, -1, -1, 208, -1, -1, 206, -1, -1, -1, -1, -1, -1, 84, -1, -1, -1, -1, -1, 108, -1, 168, -1, -1, 86, -1, 177, -1, -1, -1, -1, -1, -1, -1, 106, 106, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 129, -1, -1, -1, 186, 47, -1, -1, 251, 73, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 97, -1, 200, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 242, -1, -1, -1, 108, -1, 99, -1, -1, -1, -1, 164, -1, -1, -1, -1, -1, -1, 208, 102, 114, 187, 129, -1, 106, -1, -1, -1, -1, -1, -1),
    (278, 263, -1, -1, -1, -1, -1, -1, -1, -1, 166, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 210, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 166, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (279, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 131, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 224, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 48, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 265, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1)
  );

  { Div Table }

  DivTable : array[0..159, 0..159] of longint = (
    (0, 58, 61, -1, -1, -1, -1, 88, 87, 91, 92, 93, -1, -1, -1, -1, -1, -1, 198, -1, -1, -1, 261, -1, 5, 9, 9, 97, -1, -1, -1, -1, -1, 250, -1, -1, -1, -1, -1, 25, 17, -1, 26, 31, 37, -1, -1, 65, -1, -1, 184, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 147, 145, 227, -1, -1, 157, 155, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 100, -1, -1, -1, -1, -1, -1, 195, 194, -1, 50, -1, -1, -1, -1, -1, 216, -1, -1, 215, 217, 211, 206, 213, -1, -1, -1, -1, -1, -1, -1, -1, 149, -1, -1, -1, -1, -1, -1, 239, -1, -1, 235, 241, 240, -1, -1, -1, 17, -1, 76, -1, -1, -1, -1, -1, 56, -1, -1, -1, -1, -1, 5, 88, 91, 92, -1, -1, -1, 216, -1, -1, -1, -1, -1),
    (5, 0, 58, 61, -1, -1, -1, 97, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 13, 13, -1, -1, -1, -1, -1, -1, -1, 88, -1, -1, -1, -1, -1, 80, -1, -1, -1, 182, -1, -1, 17, -1, -1, -1, 216, 216, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 145, 142, 155, -1, -1, -1, 147, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 250, -1, 93, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 215, -1, -1, -1, -1, -1, -1, -1, -1, 200, 102, -1, -1, -1, -1, -1, -1, -1, -1, -1, 239, -1, 241, -1, -1, -1, -1, -1, -1, -1, 227, -1, 230, -1, -1, -1, 80, -1, 180, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 97, -1, -1, 250, -1, -1, -1, -1, -1, -1, -1, -1),
    (9, 5, 0, 58, 61, -1, -1, -1, -1, 250, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 13, 14, 14, -1, -1, -1, -1, -1, -1, -1, 97, -1, -1, 216, -1, -1, -1, -1, -1, -1, -1, -1, -1, 80, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 155, -1, -1, -1, -1, -1, 142, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 84, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 26, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 13, -1, 250, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (13, 9, 5, 0, 58, 61, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 14, 15, 15, -1, -1, -1, -1, -1, -1, -1, -1, 216, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 81, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 14, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (14, 13, 9, 5, 0, 58, 61, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 15, 16, 16, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (15, 14, 13, 9, 5, 0, 58, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 16, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 16, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (16, 15, 14, 13, 9, 5, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (17, 65, 69, 72, 73, 74, 75, 0, 25, 88, 91, 92, 93, -1, -1, -1, 241, -1, -1, -1, -1, -1, -1, -1, 80, -1, -1, 5, 9, 13, 14, 15, 16, -1, 58, -1, -1, -1, -1, -1, 26, -1, 31, 37, 38, -1, -1, 180, -1, 184, -1, -1, -1, -1, -1, -1, -1, 216, -1, -1, -1, -1, -1, 235, -1, 227, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 97, -1, -1, -1, 99, 191, 250, -1, -1, 185, 195, -1, 193, -1, 204, -1, -1, -1, 198, 218, -1, -1, -1, 217, -1, -1, 129, 211, 205, -1, -1, -1, -1, -1, -1, -1, 147, -1, -1, 233, -1, 231, -1, 142, -1, -1, -1, -1, 48, -1, -1, -1, 26, -1, 186, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 80, 0, 88, 91, 97, 216, -1, -1, -1, -1, -1, -1, -1),
    (25, -1, -1, -1, -1, -1, -1, 87, 0, 90, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 17, -1, 26, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 87, 90, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (26, 180, 76, 266, -1, -1, -1, 17, -1, 0, 88, 91, 92, 93, -1, 195, -1, -1, 218, -1, -1, -1, -1, -1, -1, -1, -1, 80, -1, -1, -1, -1, -1, 9, 65, -1, -1, -1, -1, -1, 31, -1, 37, 38, 39, -1, -1, 176, 184, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 233, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 97, -1, 5, -1, -1, -1, 98, -1, -1, -1, -1, -1, -1, -1, 47, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 50, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 134, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 31, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 13, -1, 17, 0, 88, 5, -1, -1, -1, -1, -1, -1, -1, -1),
    (31, 176, 186, -1, -1, -1, -1, 26, -1, 17, 0, 88, 91, 92, 184, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 180, -1, -1, -1, -1, -1, 37, -1, 38, 39, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5, -1, 80, -1, -1, -1, 40, 196, 9, -1, -1, -1, -1, -1, -1, 185, -1, -1, -1, -1, 218, -1, -1, -1, -1, -1, -1, -1, -1, -1, 204, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 258, -1, -1, -1, 37, -1, -1, -1, -1, -1, 241, -1, -1, -1, -1, -1, -1, -1, -1, 26, 17, 0, 80, -1, -1, -1, -1, -1, -1, -1, -1),
    (37, -1, -1, -1, -1, -1, -1, 31, -1, 26, 17, 0, 88, 91, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 182, -1, -1, -1, -1, -1, -1, -1, -1, -1, 176, 184, -1, -1, -1, -1, 38, -1, 39, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 80, -1, -1, -1, 58, -1, 81, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 38, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 182, 31, 26, 17, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (38, -1, -1, -1, -1, -1, -1, 37, -1, 31, 26, 17, 0, 88, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 182, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 39, -1, -1, -1, -1, 184, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 65, -1, 94, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 39, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 37, 31, 26, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (39, -1, -1, -1, -1, -1, -1, 38, -1, 37, 31, 26, 17, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 182, -1, 180, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 38, 37, 31, 182, -1, -1, -1, -1, -1, -1, -1, -1),
    (40, 82, 171, 208, -1, -1, -1, 98, -1, 99, 100, 181, -1, -1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 185, 185, -1, -1, -1, -1, -1, -1, -1, 177, 88, 5, 97, -1, -1, 81, -1, 94, -1, -1, 91, -1, 84, 17, 26, 31, -1, -1, -1, -1, 250, 250, -1, -1, 244, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, -1, 80, -1, 37, 183, 182, -1, 61, -1, -1, -1, -1, -1, -1, -1, -1, 199, 198, -1, -1, -1, -1, -1, 13, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 245, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 134, 231, 81, -1, 114, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 98, 99, 100, -1, -1, 250, -1, 13, -1, 9, -1, -1),
    (47, -1, 249, -1, -1, -1, -1, 193, -1, 194, -1, -1, -1, -1, 40, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 98, -1, -1, 250, -1, -1, -1, -1, -1, -1, 99, -1, -1, 81, 94, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 185, -1, -1, -1, -1, -1, -1, -1, 171, -1, -1, -1, -1, 17, 26, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 86, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 193, 194, -1, -1, -1, -1, -1, -1, -1, 185, -1, -1),
    (48, -1, -1, -1, -1, -1, -1, 240, -1, 262, -1, -1, -1, -1, -1, -1, 0, -1, -1, -1, -1, -1, -1, -1, 131, -1, -1, 230, -1, -1, -1, -1, -1, -1, -1, -1, 257, -1, -1, -1, -1, -1, 258, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 58, -1, -1, 147, -1, -1, -1, 137, 236, -1, 157, -1, 153, -1, -1, -1, -1, -1, 279, -1, -1, 265, -1, 232, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 65, -1, 180, -1, -1, -1, 149, 239, 238, 17, -1, -1, -1, -1, -1, -1, -1, -1, -1, 82, 91, -1, -1, 26, -1, -1, 176, -1, 131, 240, 262, -1, 232, -1, -1, -1, -1, -1, -1, -1, 166),
    (49, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 48, 0, -1, -1, -1, -1, -1, -1, -1, 134, 134, -1, 231, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 157, 157, 147, -1, 61, -1, -1, -1, -1, -1, 129, -1, -1, -1, -1, 114, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 69, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 262, -1, -1, 258, -1, -1, -1, -1, -1, -1, -1, -1, -1, 147, 157, -1, -1, -1, -1, -1, -1),
    (50, -1, -1, -1, -1, -1, -1, 205, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 198, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 204, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 215, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 53, -1, -1, -1, 88, 17, 217, -1, -1, -1, -1, 129, -1, 206, -1, -1, -1, -1, -1, -1, 261, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 204, -1, -1, -1, -1, -1, -1, -1, 225, -1, -1, -1, -1, -1, -1, 205, -1, -1, -1, 215, -1, 217, -1, -1, -1, -1, -1),
    (53, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 50, 0, 198, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 54, -1, -1, -1, 205, 204, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (54, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 53, 50, 0, 198, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 55, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (55, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 54, 53, 50, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 221, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 91, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (56, 166, -1, -1, -1, -1, -1, -1, -1, -1, 263, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 225, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 198, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 31, -1, -1, -1, -1, -1, -1, 263, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (57, -1, -1, -1, -1, -1, -1, -1, -1, 162, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 160, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 260, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 58, 176, 26, 180, -1, -1, -1, 161, -1, 164, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 129, -1, -1, -1, 26, -1, -1, 160, -1, 162, -1, 164, 260, -1, -1, -1, -1, -1, -1, -1),
    (58, 61, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 5, 5, 88, 97, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 65, -1, 180, 176, -1, -1, -1, 69, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 157, -1, 235, 257, -1, -1, 145, -1, -1, -1, -1, -1, 261, -1, -1, 92, -1, 91, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 149, -1, -1, -1, -1, -1, -1, -1, -1, 65, -1, 266, -1, -1, 150, -1, -1, 166, -1, -1, -1, -1, 250, 0, -1, -1, -1, 91, -1, -1, -1, -1, -1, -1, -1, -1),
    (61, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 58, 0, 0, -1, 88, 97, -1, -1, -1, 91, -1, -1, -1, -1, -1, -1, 69, -1, 76, 186, -1, -1, -1, 72, 191, -1, 196, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 92, -1, -1, 98, -1, -1, -1, 100, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 69, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 58, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (61, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 58, 0, 0, -1, 88, 97, -1, -1, -1, 91, -1, -1, -1, -1, -1, -1, 69, -1, 76, 186, -1, -1, -1, 72, 191, -1, 196, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 92, -1, -1, 98, -1, -1, -1, 100, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 69, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 58, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (65, 69, 72, 73, 74, 75, -1, 58, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 17, 80, 80, 0, 5, 9, 13, 14, 15, 97, 61, -1, -1, -1, -1, -1, 180, -1, 176, -1, -1, -1, -1, 76, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 235, -1, -1, -1, -1, 227, -1, -1, -1, -1, -1, -1, -1, -1, 91, -1, 88, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 157, -1, -1, -1, -1, -1, -1, 147, -1, -1, -1, -1, -1, 257, -1, -1, 180, -1, -1, -1, -1, 242, -1, -1, -1, -1, -1, -1, -1, -1, 17, 58, -1, -1, 88, -1, -1, -1, -1, -1, -1, -1, -1),
    (69, 72, 73, 74, 75, -1, -1, 61, -1, -1, -1, -1, -1, -1, 191, -1, -1, -1, -1, -1, -1, -1, -1, -1, 65, 17, 17, 58, 0, 5, 9, 13, 14, 88, -1, -1, -1, -1, -1, -1, 76, -1, 186, -1, -1, -1, -1, 266, -1, 196, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 235, -1, -1, -1, -1, -1, -1, 184, -1, -1, -1, -1, -1, -1, -1, 168, -1, 91, -1, -1, 40, -1, -1, -1, 99, -1, -1, -1, 205, -1, 202, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 257, -1, -1, -1, -1, -1, 157, -1, -1, -1, -1, -1, -1, -1, -1, 76, -1, -1, -1, -1, 228, -1, -1, -1, -1, -1, -1, -1, 97, 65, 61, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (72, 73, 74, 75, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 69, 65, 65, 61, 58, 0, 5, 9, 13, -1, -1, -1, 191, -1, -1, -1, 266, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 82, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 266, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 88, 69, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (73, 74, 75, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 72, 69, 69, -1, 61, 58, 0, 5, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 196, 191, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 171, -1, -1, -1, 168, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 72, -1, -1, -1, -1, -1, -1, -1, -1, -1, 191, -1, -1),
    (74, 75, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 73, 72, 72, -1, -1, 61, 58, 0, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 208, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 191, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 73, -1, -1, -1, -1, -1, -1, -1, 191, -1, -1, -1, -1),
    (75, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 74, 73, 73, -1, -1, -1, 61, 58, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 74, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (76, 266, -1, -1, -1, -1, -1, 69, -1, 61, -1, -1, -1, -1, -1, -1, -1, 233, 202, -1, -1, -1, -1, -1, 180, 26, 26, 65, 17, 80, -1, -1, -1, 0, 72, 191, -1, -1, -1, -1, 186, -1, -1, -1, -1, -1, -1, -1, 196, -1, -1, -1, -1, -1, 184, -1, -1, -1, -1, -1, -1, 257, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 58, -1, -1, -1, 108, -1, 88, -1, -1, 81, -1, -1, 249, 98, -1, -1, -1, 50, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 49, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 186, 195, -1, -1, -1, 137, -1, -1, -1, -1, -1, -1, -1, 5, 180, 69, 61, -1, 58, -1, -1, -1, -1, -1, -1, -1, -1),
    (80, 17, 65, 69, 72, 73, 74, 5, -1, 97, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 13, 14, 15, 16, -1, -1, 0, -1, -1, -1, -1, -1, -1, -1, -1, 182, -1, -1, -1, 26, -1, -1, -1, -1, -1, -1, -1, 216, 216, -1, 241, -1, -1, -1, -1, 227, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 250, -1, -1, -1, 92, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 217, -1, -1, -1, -1, -1, -1, -1, -1, -1, 114, 200, -1, -1, -1, -1, -1, -1, -1, -1, 142, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 131, -1, -1, -1, -1, -1, 176, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5, 97, -1, -1, -1, 216, -1, -1, -1, -1, -1, -1),
    (81, 84, 102, 206, -1, -1, -1, 40, -1, 98, 99, 100, 181, -1, 17, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 185, -1, -1, -1, -1, -1, 82, 0, 80, 5, -1, -1, 94, -1, -1, -1, -1, 88, 97, 95, 26, 31, 37, 9, 9, -1, -1, -1, -1, -1, -1, 245, -1, -1, -1, -1, -1, -1, -1, -1, -1, 231, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 38, -1, -1, 194, 69, -1, 250, -1, -1, -1, 184, -1, -1, -1, -1, -1, -1, -1, -1, 13, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 155, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 134, 94, -1, 187, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 40, 98, 99, -1, -1, -1, 13, -1, -1, -1, -1, -1),
    (82, 171, 208, -1, -1, -1, -1, 177, -1, -1, -1, 183, -1, -1, 58, -1, -1, -1, -1, -1, -1, -1, -1, -1, 40, -1, -1, 98, -1, -1, -1, -1, -1, -1, 108, -1, 0, 88, -1, -1, 84, -1, 95, -1, -1, -1, 91, 102, 65, 180, 176, 97, 97, -1, 80, -1, -1, 250, 150, -1, -1, -1, -1, -1, -1, -1, -1, 131, 232, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5, 100, 17, 99, -1, -1, 37, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 242, -1, 153, -1, -1, -1, -1, -1, -1, -1, -1, 230, -1, -1, 84, -1, 129, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 40, 177, -1, -1, 99, 250, -1, -1, 9, -1, 5, -1, -1),
    (84, 102, 206, -1, -1, -1, -1, 82, -1, 177, -1, -1, 183, -1, 65, -1, -1, -1, -1, -1, -1, -1, -1, -1, 81, -1, -1, 40, -1, 185, -1, -1, -1, -1, 171, 58, 17, 0, -1, -1, 95, -1, -1, -1, -1, -1, 88, 114, 180, 176, -1, 5, 5, 216, -1, 97, 97, -1, 242, -1, 150, -1, -1, -1, 231, -1, -1, 136, 230, -1, -1, -1, -1, -1, -1, -1, -1, -1, 80, 99, 26, 98, -1, -1, 38, -1, 72, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, -1, -1, -1, -1, -1, 106, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 153, 145, -1, -1, -1, -1, -1, -1, -1, -1, -1, 131, -1, -1, 95, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 81, 82, 177, -1, 98, -1, 97, 9, -1, -1, 80, -1, -1),
    (86, -1, 106, -1, -1, -1, -1, -1, -1, 249, -1, -1, -1, -1, 114, 76, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 47, -1, 102, 95, 84, 0, -1, -1, -1, 256, -1, -1, 171, 82, -1, 187, 189, -1, 81, 81, 9, -1, 40, 40, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 94, -1, -1, -1, -1, -1, -1, -1, -1, 193, 98, 99, -1, 186, -1, -1, -1, -1, 200, 199, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 26, 251, 250, 91, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 249, -1, -1, -1, 40, -1, -1, -1, 94, -1, -1),
    (87, -1, -1, -1, -1, -1, -1, 90, 88, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 25, 17, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 25, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 90, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (88, -1, -1, -1, -1, -1, -1, 91, 90, 92, 93, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 97, -1, -1, -1, 250, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 87, 0, 25, 17, 26, 31, -1, -1, 58, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 234, 149, -1, 145, -1, -1, -1, 245, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 184, -1, -1, 181, -1, -1, -1, -1, -1, -1, -1, -1, -1, 205, -1, -1, -1, -1, 198, -1, 216, -1, -1, 215, 213, 208, 219, -1, 217, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 142, -1, -1, -1, -1, -1, 262, -1, -1, 157, 0, -1, 69, -1, -1, -1, -1, -1, -1, 241, -1, -1, -1, -1, 97, 91, 92, 93, -1, -1, -1, -1, 216, -1, -1, -1, -1),
    (90, -1, -1, -1, -1, -1, -1, -1, 91, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 88, 87, 0, 25, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 87, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (91, -1, -1, -1, -1, -1, -1, 92, -1, 93, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 250, 250, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 90, 88, 87, 0, 17, 26, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 244, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 216, -1, -1, 219, 210, -1, -1, 215, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 239, -1, -1, -1, 234, -1, -1, -1, 157, -1, 88, -1, 61, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 92, 93, -1, -1, -1, -1, -1, -1, 216, -1, -1, -1),
    (92, -1, -1, -1, -1, -1, -1, 93, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 91, 90, 88, 0, 17, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 91, -1, -1, -1, -1, -1, -1, -1, 263, -1, 261, -1, -1, -1, -1, 93, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (93, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 92, -1, 91, 88, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 92, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (94, 95, 114, 129, -1, -1, -1, 81, -1, 40, 98, 99, 100, 181, 26, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 185, 84, 17, -1, 80, -1, -1, -1, -1, -1, -1, -1, 0, 5, -1, 31, 37, 38, -1, -1, -1, -1, 9, 9, 13, -1, 155, -1, -1, -1, -1, -1, -1, -1, -1, -1, 134, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 39, -1, -1, 193, 76, -1, -1, 250, -1, 184, -1, -1, -1, -1, 218, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 199, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 189, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 81, 40, 98, -1, 13, 9, -1, -1, -1, -1, -1, -1),
    (95, 114, 129, -1, -1, -1, -1, 84, -1, 82, 177, -1, -1, 183, 180, -1, -1, -1, -1, -1, -1, -1, -1, -1, 94, -1, -1, 81, -1, -1, -1, -1, -1, -1, 102, 65, 26, 17, -1, -1, -1, -1, -1, -1, -1, 58, 0, 187, 176, -1, -1, 80, 80, -1, -1, 5, 5, 9, 153, 145, 242, -1, -1, -1, 134, -1, -1, -1, 131, -1, -1, -1, -1, -1, -1, -1, -1, 182, -1, 98, 31, 40, -1, 168, 39, -1, 266, -1, 97, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 231, -1, -1, 227, -1, -1, -1, -1, -1, -1, -1, -1, -1, 136, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 185, 94, 84, 82, 177, 40, 9, 5, -1, -1, -1, -1, -1, -1),
    (97, 88, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 250, -1, -1, -1, -1, -1, -1, 91, -1, -1, -1, -1, -1, 5, -1, 80, -1, -1, -1, -1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 239, 245, 155, -1, -1, 149, -1, -1, -1, -1, -1, -1, -1, -1, 216, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 171, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 241, -1, -1, -1, -1, -1, 145, -1, 232, -1, -1, 147, 5, -1, 65, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 216, -1, -1),
    (98, 177, 108, 210, -1, -1, -1, 99, -1, 100, 181, -1, -1, -1, 88, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 91, 97, -1, -1, -1, 40, -1, 81, 94, -1, 92, -1, 82, 0, 17, 26, 250, 250, -1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5, -1, 31, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 13, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 244, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 231, -1, 40, -1, 102, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 99, 100, 181, -1, -1, -1, -1, -1, 13, -1, -1, -1),
    (99, -1, 168, -1, -1, -1, -1, 100, -1, 181, -1, -1, -1, -1, 91, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 92, -1, -1, -1, -1, 98, -1, 40, 81, 94, 93, -1, 177, 88, 0, 17, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 250, -1, 97, -1, 26, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 98, -1, 171, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 100, 181, -1, -1, -1, -1, -1, -1, -1, 250, -1, -1),
    (100, -1, -1, -1, -1, -1, -1, 181, -1, -1, -1, -1, -1, -1, 92, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 183, 93, -1, -1, -1, -1, 99, -1, 98, 40, 81, -1, -1, -1, 91, 88, 0, -1, -1, -1, 250, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 17, -1, 80, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 99, -1, 108, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 181, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (102, 206, -1, -1, -1, -1, -1, 171, -1, 108, 168, -1, -1, -1, 69, 191, 242, 245, -1, -1, -1, -1, -1, -1, 84, 81, 81, 82, 40, -1, 185, -1, -1, 98, 208, 61, 65, 58, -1, -1, 114, -1, 187, 189, -1, -1, -1, 129, 76, 186, -1, 0, 0, -1, 26, 88, 88, 97, 228, 234, -1, 230, 239, -1, -1, -1, -1, -1, 240, -1, -1, -1, -1, -1, -1, -1, -1, 31, 17, -1, 180, 177, -1, -1, -1, -1, 73, 99, 91, 92, 47, -1, 196, -1, 194, -1, -1, 205, -1, -1, 200, 5, 80, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 131, 137, -1, 236, -1, 134, -1, 232, -1, 140, 153, -1, 48, -1, 49, 114, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 84, 171, 108, 168, 177, 97, 88, 5, 80, -1, 17, -1, -1),
    (102, 206, -1, -1, -1, -1, -1, 171, -1, 108, 168, -1, -1, -1, 69, 191, 242, 245, -1, -1, -1, -1, -1, -1, 84, 81, 81, 82, 40, -1, 185, -1, -1, 98, 208, 61, 65, 58, -1, -1, 114, -1, 187, 189, -1, -1, -1, 129, 76, 186, -1, 0, 0, -1, 26, 88, 88, 97, 228, 234, -1, 230, 239, -1, -1, -1, -1, -1, 240, -1, -1, -1, -1, -1, -1, -1, -1, 31, 17, -1, 180, 177, -1, -1, -1, -1, 73, 99, 91, 92, 47, -1, 196, -1, 194, -1, -1, 205, -1, -1, 200, 5, 80, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 131, 137, -1, 236, -1, 134, -1, 232, -1, 140, 153, -1, 48, -1, 49, 114, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 84, 171, 108, 168, 177, 97, 88, 5, 80, -1, 17, -1, -1),
    (106, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 86, 86, -1, -1, -1, -1, -1, -1, 249, -1, -1, 129, 206, 61, -1, -1, -1, 251, -1, -1, -1, 208, -1, -1, -1, -1, 102, 102, 0, 187, 171, 171, 82, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 189, 114, -1, -1, -1, -1, -1, -1, -1, -1, -1, 108, 168, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 84, 95, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 76, -1, 91, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 82, 171, 84, 95, -1, 114, -1, -1),
    (108, 210, -1, -1, -1, -1, -1, 168, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 177, 98, 98, -1, 99, -1, -1, -1, -1, 100, -1, -1, -1, -1, -1, -1, 171, -1, 102, 114, 187, -1, -1, 208, 61, 69, 76, 91, 91, -1, 0, 92, 92, -1, -1, -1, -1, 265, -1, -1, -1, -1, -1, 240, -1, -1, -1, -1, -1, -1, -1, -1, -1, 17, 88, 183, 58, -1, 186, -1, 176, -1, -1, 181, 93, -1, 194, -1, 191, -1, -1, -1, -1, -1, -1, -1, -1, -1, 97, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 263, -1, -1, -1, 232, -1, -1, 228, -1, -1, -1, -1, -1, -1, 150, -1, 262, -1, -1, 171, -1, -1, -1, -1, -1, -1, -1, -1, 242, 224, -1, 137, -1, 177, 168, -1, -1, -1, -1, 92, -1, 97, 5, 88, -1, -1),
    (114, 129, -1, -1, -1, -1, -1, 102, -1, 171, 108, 168, -1, -1, 76, -1, 153, 155, 200, -1, -1, -1, 224, -1, 95, 94, 94, 84, 81, -1, -1, -1, -1, 40, 206, 69, 180, 65, -1, -1, 187, -1, 189, -1, -1, 61, 58, -1, 186, -1, -1, 17, 17, -1, 31, 0, 0, 5, 137, -1, 228, 131, 142, 140, -1, -1, -1, 258, 48, 49, -1, -1, -1, -1, -1, -1, -1, 37, 26, 177, 176, 82, -1, -1, -1, -1, -1, 98, 88, 91, -1, 196, -1, -1, 193, -1, 202, 50, 199, -1, -1, 80, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 56, 226, 225, -1, 136, 236, 235, -1, -1, -1, 231, 230, -1, -1, -1, -1, -1, -1, -1, 187, -1, -1, -1, -1, -1, 150, -1, -1, -1, -1, -1, -1, -1, 95, 102, 171, 108, 82, 5, 0, 80, -1, -1, 26, -1, -1),
    (114, 129, -1, -1, -1, -1, -1, 102, -1, 171, 108, 168, -1, -1, 76, -1, 153, 155, 200, -1, -1, -1, 224, -1, 95, 94, 94, 84, 81, -1, -1, -1, -1, 40, 206, 69, 180, 65, -1, -1, 187, -1, 189, -1, -1, 61, 58, -1, 186, -1, -1, 17, 17, -1, 31, 0, 0, 5, 137, -1, 228, 131, 142, 140, -1, -1, -1, 258, 48, 49, -1, -1, -1, -1, -1, -1, -1, 37, 26, 177, 176, 82, -1, -1, -1, -1, -1, 98, 88, 91, -1, 196, -1, -1, 193, -1, 202, 50, 199, -1, -1, 80, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 56, 226, 225, -1, 136, 236, 235, -1, -1, -1, 231, 230, -1, -1, -1, -1, -1, -1, -1, 187, -1, -1, -1, -1, -1, 150, -1, -1, -1, -1, -1, -1, -1, 95, 102, 171, 108, 82, 5, 0, 80, -1, -1, 26, -1, -1),
    (129, -1, -1, -1, -1, -1, -1, 206, -1, 208, 210, -1, -1, -1, 266, -1, 137, 145, 211, -1, -1, 222, -1, -1, 114, 95, 95, 102, 84, 81, -1, -1, -1, 82, -1, 72, 76, 69, -1, -1, -1, -1, -1, -1, -1, -1, 61, -1, -1, -1, -1, 65, 65, -1, 176, 58, 58, 0, -1, -1, -1, 48, 147, -1, 49, 140, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 224, -1, 180, 108, 186, 171, -1, -1, -1, -1, -1, 177, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 213, -1, 17, 26, 31, 50, 204, -1, -1, -1, -1, -1, -1, 55, -1, 166, -1, -1, -1, -1, 238, -1, -1, -1, -1, -1, 240, 230, -1, 236, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 40, 114, 206, 208, 210, 171, 0, 58, 17, 26, 31, 180, -1, -1),
    (131, 48, -1, -1, -1, -1, -1, 230, -1, 232, 265, -1, -1, -1, 257, -1, 5, -1, -1, -1, -1, -1, 279, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 240, -1, -1, -1, -1, -1, 136, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, -1, 88, 142, -1, 137, -1, 153, -1, -1, 147, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 17, -1, 26, -1, -1, -1, 239, -1, 236, 80, -1, -1, -1, -1, 136, -1, -1, -1, -1, 40, -1, -1, -1, -1, -1, -1, 31, -1, -1, 230, 232, 265, -1, -1, -1, -1, -1, -1, -1, -1, 56),
    (134, -1, 49, -1, -1, -1, -1, 231, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 157, 147, -1, -1, -1, -1, -1, -1, -1, -1, 142, 142, -1, 131, 0, 230, -1, -1, 114, -1, 95, -1, -1, -1, -1, 94, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 239, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 136, 17, -1, -1, -1, -1, -1, -1, 187, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 231, -1, -1, -1, -1, 142, -1, -1, -1, -1, -1, -1),
    (136, -1, -1, -1, -1, -1, -1, 131, -1, 230, 232, 265, -1, -1, -1, -1, 80, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 48, 257, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 258, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 17, -1, 0, -1, -1, 236, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 26, -1, 31, -1, -1, -1, 142, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 81, 97, -1, -1, -1, -1, -1, 37, -1, -1, 131, 230, 232, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (137, -1, -1, -1, -1, -1, -1, 228, -1, -1, -1, -1, -1, -1, -1, -1, 145, -1, -1, -1, -1, -1, -1, -1, 153, -1, -1, 242, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 236, -1, -1, -1, -1, -1, -1, 238, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 234, 0, -1, -1, 48, -1, -1, 180, 58, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 150, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 241, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 240, 17, 235, -1, -1, -1, 136, 230, 88, 97, -1, 227, 206, 65, -1, -1, 236, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 153, 228, -1, -1, 150, -1, -1, 241, -1, -1, -1, -1, -1),
    (140, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 235, 235, 233, -1, -1, -1, 145, -1, -1, -1, 137, 0, -1, 129, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 234, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 227, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 206, 236, -1, -1, -1, 106, 187, 102, 228, 242, -1, -1, -1, 238, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 145, -1, 227, -1, -1, -1, -1, -1),
    (142, 147, 157, -1, -1, -1, -1, 239, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 149, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, -1, 5, 80, -1, -1, -1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 17, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 239, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (145, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 155, -1, -1, 245, -1, -1, -1, -1, -1, -1, 234, -1, 233, -1, -1, -1, 227, -1, -1, -1, -1, -1, -1, 235, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, -1, -1, -1, -1, 58, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 244, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 88, 241, -1, -1, -1, 82, 80, 97, -1, -1, -1, -1, 228, -1, 180, 65, 227, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 155, -1, -1, -1, 244, -1, -1, -1, -1, -1, -1, -1, -1),
    (147, 157, -1, -1, -1, -1, -1, 149, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 142, -1, -1, 239, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 58, -1, 0, 17, -1, -1, -1, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 65, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 142, 149, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (149, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 239, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 147, -1, -1, -1, -1, -1, -1, 157, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 88, 0, -1, -1, -1, 97, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 58, -1, -1, -1, -1, -1, 147, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 239, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (150, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 244, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 242, -1, 153, -1, -1, -1, -1, 228, -1, -1, -1, -1, -1, -1, 241, -1, -1, -1, -1, -1, -1, -1, -1, -1, 232, -1, -1, 0, 91, 262, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 265, 97, -1, -1, 145, -1, -1, -1, -1, -1, -1, 245, 108, 88, 48, 240, 242, -1, -1, -1, -1, -1, -1, -1, -1, 155, -1, -1, 227, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (153, 137, -1, -1, -1, -1, -1, 242, -1, 150, -1, -1, -1, -1, -1, -1, 155, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 228, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 236, -1, -1, -1, 241, 241, -1, -1, -1, -1, -1, 145, -1, -1, 5, -1, -1, 131, -1, -1, 26, 0, 48, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 230, 80, 227, -1, -1, -1, -1, -1, 97, -1, -1, -1, 102, 17, 258, -1, -1, -1, -1, -1, -1, -1, 244, -1, -1, -1, -1, -1, -1, -1, -1, 242, 150, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (155, 145, -1, -1, -1, -1, -1, 245, -1, 244, -1, -1, -1, -1, 233, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 227, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5, -1, -1, -1, -1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 97, -1, -1, -1, -1, 40, -1, -1, -1, -1, -1, -1, 242, 241, 26, 17, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 245, 244, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (157, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 147, 142, 142, 149, 239, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 61, -1, 58, 65, -1, -1, -1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 257, -1, -1, -1, -1, -1, 69, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 232, -1, -1, -1, -1, -1, -1, -1, -1, 147, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (57, -1, -1, -1, -1, -1, -1, -1, -1, 162, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 160, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 260, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 58, 176, 26, 180, -1, -1, -1, 161, -1, 164, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 129, -1, -1, -1, 26, -1, -1, 160, -1, 162, -1, 164, 260, -1, -1, -1, -1, -1, -1, -1),
    (160, 57, -1, -1, -1, -1, -1, -1, -1, 164, 161, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 260, 260, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5, 0, 31, -1, 26, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 114, -1, -1, -1, -1, -1, -1, -1, -1, 164, 161, -1, -1, 260, -1, -1, -1, -1, -1, -1),
    (161, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 164, -1, -1, 160, -1, -1, -1, 162, -1, -1, -1, -1, -1, -1, 260, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 92, 0, 97, 88, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 164, -1, -1, -1, -1, -1, -1, 108, -1, -1, -1, 97, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (162, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 91, 164, -1, -1, 161, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 57, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 91, -1, 65, 0, 58, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 260, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 208, -1, -1, -1, 0, -1, -1, 164, -1, -1, -1, -1, -1, -1, -1, 260, -1, -1, -1, -1),
    (164, 162, -1, -1, -1, -1, -1, 161, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 160, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 91, 17, 5, 0, -1, -1, 260, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 171, -1, -1, -1, 5, -1, -1, -1, 161, -1, -1, -1, -1, -1, -1, -1, -1, 260, -1, -1),
    (166, -1, -1, -1, -1, -1, -1, -1, -1, -1, 278, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 58, -1, 56, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, -1, -1, 263, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 176, -1, -1, -1, 56, -1, -1, 278, -1, -1, -1, -1, -1, -1, -1, 31, -1),
    (168, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 99, 99, -1, 100, -1, -1, -1, -1, 181, -1, -1, -1, -1, -1, -1, 108, -1, 171, 102, 114, -1, -1, 210, -1, 61, 69, 92, 92, -1, 88, 93, 93, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 262, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 91, -1, -1, 183, 76, -1, 180, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 97, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 265, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 108, -1, -1, -1, -1, -1, -1, -1, -1, 150, -1, -1, 228, -1, -1, -1, -1, -1, 183, -1, 93, -1, -1, 97, 91, -1, -1),
    (171, 208, -1, -1, -1, -1, -1, 108, -1, 168, -1, -1, -1, -1, 61, -1, 150, 244, -1, -1, -1, -1, -1, -1, 82, 40, 40, 177, 98, -1, -1, -1, -1, 99, 210, -1, 58, -1, -1, -1, 102, -1, 114, 187, 189, -1, -1, 206, 69, 76, 186, 88, 88, -1, 17, 91, 91, -1, -1, -1, -1, 232, -1, -1, -1, -1, -1, 48, 262, -1, -1, -1, -1, -1, -1, -1, -1, 26, 0, -1, 65, -1, -1, -1, -1, -1, -1, 100, 92, 93, 193, 191, -1, -1, -1, -1, -1, -1, -1, -1, -1, 97, 5, 80, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 230, 228, 234, 137, -1, 231, -1, 265, -1, -1, 242, -1, 240, 49, -1, 102, -1, -1, -1, -1, -1, -1, -1, -1, 153, -1, -1, 236, -1, 82, 108, 168, -1, -1, -1, 91, 97, 5, 80, 0, -1, -1),
    (176, 186, -1, -1, -1, -1, -1, 180, -1, 65, 58, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 31, -1, -1, 26, -1, -1, -1, -1, -1, 80, 76, -1, 184, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, -1, 17, -1, -1, -1, 82, -1, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 31, 180, 65, 58, 17, -1, -1, -1, -1, -1, -1, -1, -1),
    (177, 108, 210, -1, -1, -1, -1, -1, -1, -1, 183, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 98, -1, -1, 99, -1, -1, -1, -1, -1, -1, 168, -1, 88, 91, -1, -1, 82, -1, 84, 95, -1, -1, 92, 171, 58, 65, 180, -1, -1, -1, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 230, 265, -1, -1, -1, -1, -1, -1, -1, -1, 80, 97, 181, 0, 100, 176, -1, 31, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 250, -1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 150, -1, 242, -1, -1, -1, -1, -1, -1, -1, -1, 232, -1, -1, 82, -1, 206, -1, -1, -1, -1, -1, -1, -1, -1, -1, 153, -1, 98, -1, -1, 183, 100, -1, -1, 250, -1, 9, 97, -1, -1),
    (180, 76, 266, -1, -1, -1, -1, 65, -1, 58, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 26, -1, -1, 17, 80, -1, -1, -1, -1, 5, 69, -1, -1, -1, -1, -1, 176, -1, -1, -1, -1, -1, -1, 186, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 257, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 88, 184, 0, -1, -1, -1, 177, -1, 97, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 176, -1, -1, -1, -1, 153, -1, -1, -1, -1, -1, -1, -1, 9, 26, 65, 58, -1, 0, -1, -1, -1, -1, -1, -1, -1, -1),
    (181, 183, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 93, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 100, -1, 99, 98, 40, -1, -1, -1, 92, 91, 88, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 250, -1, -1, -1, -1, 0, -1, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 100, -1, 168, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (182, 37, -1, -1, -1, -1, -1, -1, -1, -1, 80, 5, 97, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 31, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 38, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 80, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (183, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 181, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 93, -1, -1, -1, -1, -1, -1, 177, 82, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 92, -1, 58, -1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 181, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (184, -1, 196, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 195, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, -1, -1, -1, -1, -1, -1, -1, 81, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (185, -1, 40, 82, 171, 208, -1, -1, -1, -1, -1, -1, -1, -1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 13, -1, -1, -1, -1, -1, -1, -1, -1, 250, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 14, -1, -1, -1, -1, -1, -1, -1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 94, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 15, -1, 14, -1, -1),
    (186, -1, -1, -1, -1, -1, -1, 76, -1, 69, 61, -1, -1, -1, 196, -1, -1, -1, -1, -1, -1, -1, -1, -1, 176, 31, 31, 180, 26, -1, -1, -1, -1, 17, 266, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 191, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 184, 58, -1, 65, -1, -1, -1, 171, -1, 0, -1, -1, 94, -1, -1, -1, 40, -1, -1, -1, 204, 202, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 257, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 236, -1, -1, -1, -1, -1, -1, -1, 80, 176, 76, 69, 61, 65, -1, -1, -1, -1, -1, 184, -1, -1),
    (187, -1, -1, -1, -1, -1, -1, 114, -1, 102, 171, 108, 168, -1, 186, 196, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 95, 94, -1, -1, -1, -1, 81, 129, 76, 176, 180, -1, -1, 189, -1, -1, -1, -1, 69, 65, -1, -1, -1, -1, 26, 26, -1, 37, 17, 17, 80, 236, 235, 137, 136, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 38, 31, 82, -1, 84, -1, 210, -1, 249, -1, 40, 0, 88, -1, -1, -1, -1, 47, -1, -1, 204, -1, 200, -1, -1, -1, 182, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 134, 131, -1, -1, -1, -1, 258, -1, -1, 189, 184, -1, -1, -1, -1, 242, -1, -1, -1, -1, -1, -1, -1, -1, 114, 102, 171, 84, 80, 17, -1, -1, 182, 31, -1, -1),
    (189, -1, -1, -1, -1, -1, -1, 187, -1, 114, 102, 171, 108, 168, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 94, -1, 186, -1, 176, -1, -1, -1, -1, -1, -1, -1, 76, 180, -1, -1, -1, -1, 31, 31, -1, 38, 26, 26, -1, -1, -1, 236, -1, -1, -1, -1, -1, -1, -1, 258, -1, -1, -1, -1, -1, -1, -1, -1, 39, 37, 84, -1, 95, -1, 208, -1, -1, -1, 81, 17, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 182, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 136, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 153, -1, -1, -1, -1, -1, -1, -1, -1, 187, 114, 102, 95, -1, 26, -1, 182, -1, 37, -1, -1),
    (191, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 196, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 195, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, -1, -1, 108, 91, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (193, -1, -1, -1, -1, -1, -1, 194, -1, -1, -1, -1, -1, -1, 98, 88, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 99, -1, -1, -1, -1, 47, -1, -1, -1, -1, 100, -1, -1, 40, 81, 94, -1, -1, -1, 185, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 108, -1, -1, -1, -1, 0, 17, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 47, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 194, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (194, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 99, 91, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 100, -1, -1, -1, -1, 193, -1, 47, -1, -1, 181, -1, -1, 98, 40, 81, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 185, -1, -1, -1, -1, 94, -1, -1, -1, 168, -1, -1, -1, -1, 88, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 193, 250, 249, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (195, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (196, -1, -1, -1, -1, -1, -1, -1, -1, 191, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 184, 184, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 195, 195, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 61, -1, -1, -1, -1, 26, -1, -1, 102, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 191, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (198, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 218, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, -1, -1, 250, -1, -1, -1, -1, -1, -1, 216, -1, 213, -1, 91, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 202, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (199, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 50, -1, -1, -1, 40, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 205, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 204, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, -1, -1, 98, 81, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (200, 211, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 202, -1, -1, -1, -1, -1, -1, -1, 226, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 213, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 198, 198, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 218, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 114, -1, 0, 40, -1, -1, -1, -1, -1, 5, 80, -1, -1, -1, 171, -1, -1, -1, -1, -1, -1, 56, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 198, -1, -1, -1, 218, -1, -1),
    (202, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 218, 218, -1, -1, -1, -1, -1, -1, 198, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 76, -1, -1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 61, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (204, -1, -1, -1, -1, -1, -1, 50, -1, 205, -1, -1, -1, -1, -1, -1, -1, -1, 17, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 217, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 26, -1, -1, -1, -1, -1, -1, -1, 129, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 50, 205, -1, -1, 217, -1, -1, -1, -1, -1, -1, -1),
    (205, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 88, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 50, -1, 204, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 91, 0, 215, 217, -1, -1, -1, 206, -1, 208, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 50, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 215, 217, -1, -1, -1, -1),
    (206, -1, -1, -1, -1, -1, -1, 208, -1, 210, -1, -1, -1, -1, 72, -1, 228, -1, 213, -1, -1, -1, -1, -1, 102, 84, 84, 171, 82, 40, -1, 185, -1, 177, -1, -1, 69, 61, -1, -1, 129, -1, -1, -1, -1, -1, -1, -1, 266, -1, -1, 58, 58, -1, 180, -1, -1, 88, -1, -1, -1, 240, 149, -1, -1, -1, 140, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 176, 65, 168, 76, 108, -1, -1, -1, -1, 74, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 219, 211, 0, 17, 26, 205, 50, -1, -1, -1, -1, 204, -1, -1, -1, -1, -1, -1, -1, 48, -1, -1, 238, -1, -1, -1, 262, 232, -1, 137, -1, -1, -1, -1, 129, -1, -1, -1, -1, -1, -1, -1, -1, 236, -1, -1, -1, 98, 102, 208, 210, -1, 108, 88, -1, 0, 17, 26, 65, -1, -1),
    (208, -1, -1, -1, -1, -1, -1, 210, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 219, -1, -1, -1, -1, -1, 171, 82, 82, 108, 177, 98, -1, -1, -1, -1, -1, -1, 61, -1, -1, -1, 206, -1, 129, -1, -1, -1, -1, -1, 72, 266, -1, -1, -1, -1, 65, -1, -1, 91, -1, -1, -1, 262, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 180, 58, -1, 69, 168, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 213, 88, 0, 17, -1, 205, -1, -1, -1, -1, 50, -1, -1, -1, -1, -1, -1, -1, 240, -1, -1, -1, -1, -1, -1, -1, 265, -1, 228, -1, -1, -1, -1, 206, -1, -1, -1, -1, -1, -1, -1, -1, 137, -1, -1, 238, 99, 171, 210, -1, -1, 168, 91, -1, 88, 0, 17, 58, -1, -1),
    (210, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 108, 177, 177, 168, -1, 99, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 208, -1, 206, 129, -1, -1, -1, -1, -1, 72, 266, -1, -1, -1, 58, -1, -1, 92, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 65, -1, -1, 61, -1, -1, -1, 186, -1, -1, 183, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 219, 91, 88, 0, -1, -1, -1, -1, -1, -1, 205, -1, -1, -1, 278, -1, -1, -1, 262, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 208, -1, -1, -1, -1, -1, -1, -1, -1, 228, -1, -1, -1, 100, 108, -1, -1, -1, -1, 92, -1, 91, 88, 0, -1, 224, -1),
    (211, -1, -1, -1, -1, -1, -1, 213, -1, 219, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 222, -1, -1, -1, 200, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 202, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 198, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 226, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 129, -1, 58, 82, -1, -1, -1, 218, -1, 0, 17, -1, -1, -1, 208, 26, -1, 54, -1, -1, -1, 166, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 200, 213, 219, -1, -1, 198, -1, -1, 218, -1, -1, -1, -1),
    (213, -1, -1, -1, -1, -1, -1, 219, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 211, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 202, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 206, -1, -1, 177, -1, -1, 198, -1, 218, 88, 0, -1, -1, -1, 210, 17, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 211, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 219, -1, -1, -1, -1, -1, 198, -1, 218, -1, -1, -1),
    (215, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 217, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 216, -1, -1, -1, -1, -1, 0, 205, 88, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 217, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (216, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 217, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 198, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (217, -1, -1, -1, -1, -1, -1, 215, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 216, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 17, 50, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 215, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (218, -1, 202, -1, -1, -1, -1, -1, -1, 198, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 26, -1, -1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 198, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (219, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 213, -1, 211, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 208, -1, -1, -1, -1, -1, -1, 198, -1, 91, 88, -1, -1, -1, -1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 213, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 198, -1, -1, -1, -1),
    (221, -1, -1, -1, -1, -1, -1, -1, -1, 55, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 26, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 55, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (222, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (223, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 208, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 55, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 55, -1, -1, -1, -1),
    (224, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 226, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 261, 261, -1, -1, -1, -1, 279, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, -1, 50, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 114, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 261, -1, -1, -1, -1, -1, 137),
    (225, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 56, -1, -1, -1, 50, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (226, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 224, -1, 261, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 198, -1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 200, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (227, 235, -1, -1, -1, -1, -1, 145, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 155, -1, -1, -1, -1, -1, -1, -1, -1, -1, 233, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 241, 216, -1, 17, -1, -1, -1, -1, 65, -1, -1, -1, -1, -1, -1, -1, -1, -1, 244, -1, 245, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 140, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, -1, -1, -1, -1, 84, -1, 5, -1, -1, -1, -1, 137, -1, 176, 180, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 145, -1, -1, 245, -1, -1, -1, -1, -1, -1, -1, -1),
    (228, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 242, -1, -1, 150, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 137, -1, 236, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 234, -1, -1, 88, -1, -1, 240, -1, -1, 65, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 241, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 262, 0, -1, -1, 235, -1, 131, 232, 91, -1, -1, 145, 208, 58, -1, -1, 137, -1, -1, -1, -1, -1, -1, -1, -1, 227, -1, -1, -1, -1, 242, -1, -1, -1, -1, -1, -1, -1, 241, -1, -1, -1, -1),
    (230, 240, -1, -1, -1, -1, -1, 232, -1, 265, -1, -1, -1, -1, -1, -1, 97, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 262, -1, -1, -1, -1, -1, 131, -1, 136, -1, -1, -1, -1, 48, 257, -1, -1, -1, -1, -1, -1, -1, -1, -1, 88, -1, 91, 239, -1, 228, -1, 242, 153, -1, 149, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 142, 0, -1, 17, -1, -1, -1, -1, -1, 137, 5, -1, 147, -1, -1, 131, -1, -1, -1, -1, 98, -1, -1, -1, 80, -1, -1, 26, -1, -1, 232, 265, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (231, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 157, -1, 147, -1, -1, 134, -1, -1, -1, -1, -1, 149, -1, -1, -1, -1, 142, 142, -1, -1, 239, 239, -1, 230, 88, 232, -1, -1, 102, -1, 84, 95, -1, -1, -1, 81, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 131, 0, 136, -1, -1, -1, -1, -1, 114, -1, -1, -1, -1, -1, 134, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 239, -1, -1, -1, -1, -1, -1),
    (232, 262, -1, -1, -1, -1, -1, 265, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 230, -1, 131, 136, -1, -1, -1, 240, -1, 257, -1, -1, -1, -1, -1, -1, -1, -1, 91, -1, 92, -1, -1, -1, -1, 150, 242, 147, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 239, 88, -1, 0, -1, -1, -1, -1, -1, 228, 97, -1, 149, -1, -1, 230, -1, -1, -1, -1, 99, -1, -1, -1, 5, -1, -1, 17, -1, -1, 265, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (233, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (234, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 245, 245, -1, 244, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 235, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 233, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 108, 0, 91, -1, -1, -1, -1, -1, -1, 69, 61, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (235, -1, -1, -1, -1, -1, -1, -1, -1, 234, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 227, -1, -1, 145, 155, -1, -1, -1, -1, 245, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 233, 233, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 65, -1, -1, -1, -1, 69, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 244, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 58, -1, -1, -1, -1, 102, 26, 0, -1, -1, -1, -1, -1, -1, 186, 76, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 227, -1, 234, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (236, 238, -1, -1, -1, -1, -1, 137, -1, 228, -1, -1, -1, -1, -1, -1, 227, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 153, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 241, 235, -1, -1, 17, -1, -1, -1, -1, -1, 176, 65, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 150, -1, 242, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 48, 26, -1, -1, -1, -1, -1, 131, 0, 5, -1, -1, 129, 180, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 137, 228, -1, 242, 241, -1, -1, -1, -1, -1, -1, -1),
    (238, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 235, -1, -1, -1, -1, -1, -1, -1, 236, -1, -1, 137, 153, -1, -1, -1, -1, 242, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 65, -1, -1, -1, -1, -1, 186, 69, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 228, -1, -1, -1, -1, -1, 150, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 180, -1, -1, -1, -1, 258, 48, 58, 0, -1, -1, -1, 76, -1, -1, -1, -1, -1, -1, -1, -1, 234, -1, -1, -1, -1, -1, -1, -1, 236, -1, -1, -1, 228, -1, -1, -1, -1, -1, -1, -1, -1),
    (239, 149, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 142, -1, -1, -1, -1, -1, -1, 147, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 88, -1, 97, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, -1, -1, -1, -1, -1, 142, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (240, -1, -1, -1, -1, -1, -1, 262, -1, -1, -1, -1, -1, -1, -1, -1, 88, -1, -1, -1, -1, -1, -1, -1, 230, -1, -1, 232, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 48, -1, -1, 258, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 149, -1, -1, -1, 228, 137, -1, -1, -1, 242, -1, -1, -1, -1, -1, -1, -1, -1, -1, 257, 265, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 147, 58, -1, 65, -1, -1, -1, -1, -1, -1, 0, -1, 157, -1, -1, 48, -1, -1, -1, -1, 177, 92, -1, -1, 17, -1, -1, 180, -1, 230, 262, -1, -1, 265, -1, -1, -1, -1, -1, -1, -1, -1),
    (241, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 216, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 137, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (242, 228, -1, -1, -1, -1, -1, 150, -1, -1, -1, -1, -1, -1, -1, -1, 245, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 153, -1, -1, -1, -1, -1, -1, 137, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 97, -1, -1, 230, -1, -1, 17, 88, 240, -1, -1, -1, -1, -1, -1, -1, -1, 241, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 232, 5, 145, -1, 227, -1, -1, -1, -1, 250, -1, 155, 171, 0, -1, 48, 153, -1, 238, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 150, -1, -1, -1, -1, -1, -1, -1, -1, 241, -1, -1),
    (244, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 245, -1, 155, -1, -1, -1, -1, -1, -1, 233, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 91, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 99, -1, -1, -1, -1, -1, -1, -1, -1, 0, 88, 245, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (245, -1, 234, -1, -1, -1, -1, 244, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 155, -1, -1, -1, -1, -1, -1, 145, 233, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 97, -1, -1, 241, -1, 88, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 98, 9, 250, -1, -1, -1, -1, 150, -1, 17, 0, 155, -1, 235, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 244, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (88, -1, -1, -1, -1, -1, -1, 91, 90, 92, 93, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 97, -1, -1, -1, 250, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 87, 0, 25, 17, 26, 31, -1, -1, 58, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 234, 149, -1, 145, -1, -1, -1, 245, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 184, -1, -1, 181, -1, -1, -1, -1, -1, -1, -1, -1, -1, 205, -1, -1, -1, -1, 198, -1, 216, -1, -1, 215, 213, 208, 219, -1, 217, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 142, -1, -1, -1, -1, -1, 262, -1, -1, 157, 0, -1, 69, -1, -1, -1, -1, -1, -1, 241, -1, -1, -1, -1, 97, 91, 92, 93, -1, -1, -1, -1, 216, -1, -1, -1, -1),
    (249, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 171, 61, -1, -1, -1, -1, -1, -1, -1, -1, -1, 47, 47, -1, 193, -1, -1, -1, -1, 194, -1, 108, 82, 177, 91, -1, -1, -1, 86, -1, 256, 168, -1, -1, 102, 114, 187, 98, 98, 250, 81, 99, 99, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 94, 40, -1, 84, -1, 189, -1, -1, -1, -1, -1, 100, 181, -1, 69, 76, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 106, -1, 93, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 99, -1, -1, -1, 40, -1, -1),
    (250, -1, 91, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, -1, -1, -1, -1, 97, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 244, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 216, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 177, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 245, -1, -1, -1, 142, 239, -1, -1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (251, -1, -1, -1, -1, -1, -1, -1, -1, 106, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 256, 256, -1, -1, -1, -1, -1, -1, 86, -1, -1, -1, -1, 76, -1, -1, -1, -1, -1, -1, -1, 129, -1, -1, -1, -1, 187, 187, 26, -1, 114, 114, 95, -1, 140, -1, -1, 134, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 189, -1, -1, -1, -1, -1, -1, -1, -1, -1, 102, 171, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 61, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 106, -1, -1, 95, 114, -1, -1, -1, 189, -1, -1),
    (256, -1, 251, -1, -1, -1, -1, -1, -1, 86, -1, 249, -1, -1, 189, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 187, -1, -1, 26, -1, -1, -1, -1, -1, -1, 114, 95, -1, -1, -1, -1, -1, -1, -1, -1, 94, 94, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 81, 40, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 37, -1, 9, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 86, -1, -1, -1, 94, -1, -1, -1, -1, -1, -1),
    (257, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 265, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, -1, -1, -1, -1, -1, -1, 184, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (258, -1, -1, -1, -1, -1, -1, -1, -1, 48, 240, 262, -1, -1, -1, -1, 26, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 136, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 257, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 180, -1, 65, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 230, -1, 131, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 176, -1, -1, -1, -1, -1, -1, -1, -1, 31, -1, -1, -1, -1, -1, -1, -1, -1, -1, 95, 0, -1, -1, 37, -1, -1, -1, -1, -1, -1, 48, 240, 131, -1, -1, -1, -1, -1, -1, -1, -1),
    (260, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (261, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (262, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 91, -1, -1, -1, -1, -1, -1, -1, 232, -1, -1, 265, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 240, -1, 48, -1, 258, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 228, 157, -1, -1, 150, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 149, -1, -1, 58, -1, -1, -1, -1, -1, -1, 88, -1, -1, -1, -1, 240, -1, -1, -1, -1, -1, 93, -1, -1, 0, -1, -1, 65, -1, 232, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    (263, 278, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 92, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 56, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5, -1),
    (162, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 91, 164, -1, -1, 161, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 57, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 91, -1, 65, 0, 58, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 260, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 208, -1, -1, -1, 0, -1, -1, 164, -1, -1, -1, -1, -1, -1, -1, 260, -1, -1, -1, -1),
    (265, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 232, -1, 230, 131, 136, -1, -1, 262, -1, -1, 257, -1, -1, -1, -1, -1, -1, -1, 92, -1, 93, -1, -1, -1, -1, -1, 150, 149, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 91, -1, 88, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 232, -1, -1, -1, -1, 100, -1, -1, -1, 97, 279, -1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 263),
    (266, -1, -1, -1, -1, -1, -1, 72, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 76, 180, 180, 69, 65, 17, 80, -1, -1, 58, 73, -1, -1, 191, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 196, 61, -1, -1, -1, 210, -1, -1, -1, -1, 84, -1, -1, -1, 177, -1, -1, -1, -1, -1, -1, -1, -1, 184, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 76, 72, -1, -1, 61, -1, -1, -1, -1, 184, -1, -1, -1),
    (58, 61, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 5, 5, 88, 97, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 65, -1, 180, 176, -1, -1, -1, 69, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 157, -1, 235, 257, -1, -1, 145, -1, -1, -1, -1, -1, 261, -1, -1, 92, -1, 91, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 149, -1, -1, -1, -1, -1, -1, -1, -1, 65, -1, 266, -1, -1, 150, -1, -1, 166, -1, -1, -1, -1, 250, 0, -1, -1, -1, 91, -1, -1, -1, -1, -1, -1, -1, -1),
    (17, 65, 69, 72, 73, 74, 75, 0, 25, 88, 91, 92, 93, -1, -1, -1, 241, -1, -1, -1, -1, -1, -1, -1, 80, -1, -1, 5, 9, 13, 14, 15, 16, -1, 58, -1, -1, -1, -1, -1, 26, -1, 31, 37, 38, -1, -1, 180, -1, 184, -1, -1, -1, -1, -1, -1, -1, 216, -1, -1, -1, -1, -1, 235, -1, 227, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 97, -1, -1, -1, 99, 191, 250, -1, -1, 185, 195, -1, 193, -1, 204, -1, -1, -1, 198, 218, -1, -1, -1, 217, -1, -1, 129, 211, 205, -1, -1, -1, -1, -1, -1, -1, 147, -1, -1, 233, -1, 231, -1, 142, -1, -1, -1, -1, 48, -1, -1, -1, 26, -1, 186, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 80, 0, 88, 91, 97, 216, -1, -1, -1, -1, -1, -1, -1),
    (26, 180, 76, 266, -1, -1, -1, 17, -1, 0, 88, 91, 92, 93, -1, 195, -1, -1, 218, -1, -1, -1, -1, -1, -1, -1, -1, 80, -1, -1, -1, -1, -1, 9, 65, -1, -1, -1, -1, -1, 31, -1, 37, 38, 39, -1, -1, 176, 184, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 233, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 97, -1, 5, -1, -1, -1, 98, -1, -1, -1, -1, -1, -1, -1, 47, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 50, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 134, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 31, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 13, -1, 17, 0, 88, 5, -1, -1, -1, -1, -1, -1, -1, -1),
    (31, 176, 186, -1, -1, -1, -1, 26, -1, 17, 0, 88, 91, 92, 184, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 180, -1, -1, -1, -1, -1, 37, -1, 38, 39, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5, -1, 80, -1, -1, -1, 40, 196, 9, -1, -1, -1, -1, -1, -1, 185, -1, -1, -1, -1, 218, -1, -1, -1, -1, -1, -1, -1, -1, -1, 204, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 258, -1, -1, -1, 37, -1, -1, -1, -1, -1, 241, -1, -1, -1, -1, -1, -1, -1, -1, 26, 17, 0, 80, -1, -1, -1, -1, -1, -1, -1, -1),
    (180, 76, 266, -1, -1, -1, -1, 65, -1, 58, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 26, -1, -1, 17, 80, -1, -1, -1, -1, 5, 69, -1, -1, -1, -1, -1, 176, -1, -1, -1, -1, -1, -1, 186, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 257, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 88, 184, 0, -1, -1, -1, 177, -1, 97, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 176, -1, -1, -1, -1, 153, -1, -1, -1, -1, -1, -1, -1, 9, 26, 65, 58, -1, 0, -1, -1, -1, -1, -1, -1, -1, -1),
    (129, -1, -1, -1, -1, -1, -1, 206, -1, 208, 210, -1, -1, -1, 266, -1, 137, 145, 211, -1, -1, 222, -1, -1, 114, 95, 95, 102, 84, 81, -1, -1, -1, 82, -1, 72, 76, 69, -1, -1, -1, -1, -1, -1, -1, -1, 61, -1, -1, -1, -1, 65, 65, -1, 176, 58, 58, 0, -1, -1, -1, 48, 147, -1, 49, 140, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 224, -1, 180, 108, 186, 171, -1, -1, -1, -1, -1, 177, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 213, -1, 17, 26, 31, 50, 204, -1, -1, -1, -1, -1, -1, 55, -1, 166, -1, -1, -1, -1, 238, -1, -1, -1, -1, -1, 240, 230, -1, 236, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 40, 114, 206, 208, 210, 171, 0, 58, 17, 26, 31, 180, -1, -1),
    (114, 129, -1, -1, -1, -1, -1, 102, -1, 171, 108, 168, -1, -1, 76, -1, 153, 155, 200, -1, -1, -1, 224, -1, 95, 94, 94, 84, 81, -1, -1, -1, -1, 40, 206, 69, 180, 65, -1, -1, 187, -1, 189, -1, -1, 61, 58, -1, 186, -1, -1, 17, 17, -1, 31, 0, 0, 5, 137, -1, 228, 131, 142, 140, -1, -1, -1, 258, 48, 49, -1, -1, -1, -1, -1, -1, -1, 37, 26, 177, 176, 82, -1, -1, -1, -1, -1, 98, 88, 91, -1, 196, -1, -1, 193, -1, 202, 50, 199, -1, -1, 80, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 56, 226, 225, -1, 136, 236, 235, -1, -1, -1, 231, 230, -1, -1, -1, -1, -1, -1, -1, 187, -1, -1, -1, -1, -1, 150, -1, -1, -1, -1, -1, -1, -1, 95, 102, 171, 108, 82, 5, 0, 80, -1, -1, 26, -1, -1),
    (206, -1, -1, -1, -1, -1, -1, 208, -1, 210, -1, -1, -1, -1, 72, -1, 228, -1, 213, -1, -1, -1, -1, -1, 102, 84, 84, 171, 82, 40, -1, 185, -1, 177, -1, -1, 69, 61, -1, -1, 129, -1, -1, -1, -1, -1, -1, -1, 266, -1, -1, 58, 58, -1, 180, -1, -1, 88, -1, -1, -1, 240, 149, -1, -1, -1, 140, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 176, 65, 168, 76, 108, -1, -1, -1, -1, 74, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 219, 211, 0, 17, 26, 205, 50, -1, -1, -1, -1, 204, -1, -1, -1, -1, -1, -1, -1, 48, -1, -1, 238, -1, -1, -1, 262, 232, -1, 137, -1, -1, -1, -1, 129, -1, -1, -1, -1, -1, -1, -1, -1, 236, -1, -1, -1, 98, 102, 208, 210, -1, 108, 88, -1, 0, 17, 26, 65, -1, -1),
    (208, -1, -1, -1, -1, -1, -1, 210, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 219, -1, -1, -1, -1, -1, 171, 82, 82, 108, 177, 98, -1, -1, -1, -1, -1, -1, 61, -1, -1, -1, 206, -1, 129, -1, -1, -1, -1, -1, 72, 266, -1, -1, -1, -1, 65, -1, -1, 91, -1, -1, -1, 262, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 180, 58, -1, 69, 168, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 213, 88, 0, 17, -1, 205, -1, -1, -1, -1, 50, -1, -1, -1, -1, -1, -1, -1, 240, -1, -1, -1, -1, -1, -1, -1, 265, -1, 228, -1, -1, -1, -1, 206, -1, -1, -1, -1, -1, -1, -1, -1, 137, -1, -1, 238, 99, 171, 210, -1, -1, 168, 91, -1, 88, 0, 17, 58, -1, -1),
    (210, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 108, 177, 177, 168, -1, 99, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 208, -1, 206, 129, -1, -1, -1, -1, -1, 72, 266, -1, -1, -1, 58, -1, -1, 92, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 65, -1, -1, 61, -1, -1, -1, 186, -1, -1, 183, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 219, 91, 88, 0, -1, -1, -1, -1, -1, -1, 205, -1, -1, -1, 278, -1, -1, -1, 262, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 208, -1, -1, -1, -1, -1, -1, -1, -1, 228, -1, -1, -1, 100, 108, -1, -1, -1, -1, 92, -1, 91, 88, 0, -1, 224, -1),
    (171, 208, -1, -1, -1, -1, -1, 108, -1, 168, -1, -1, -1, -1, 61, -1, 150, 244, -1, -1, -1, -1, -1, -1, 82, 40, 40, 177, 98, -1, -1, -1, -1, 99, 210, -1, 58, -1, -1, -1, 102, -1, 114, 187, 189, -1, -1, 206, 69, 76, 186, 88, 88, -1, 17, 91, 91, -1, -1, -1, -1, 232, -1, -1, -1, -1, -1, 48, 262, -1, -1, -1, -1, -1, -1, -1, -1, 26, 0, -1, 65, -1, -1, -1, -1, -1, -1, 100, 92, 93, 193, 191, -1, -1, -1, -1, -1, -1, -1, -1, -1, 97, 5, 80, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 230, 228, 234, 137, -1, 231, -1, 265, -1, -1, 242, -1, 240, 49, -1, 102, -1, -1, -1, -1, -1, -1, -1, -1, 153, -1, -1, 236, -1, 82, 108, 168, -1, -1, -1, 91, 97, 5, 80, 0, -1, -1),
    (278, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 263, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 166, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 92, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 58, -1, -1, -1, 263, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, -1),
    (279, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 261, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 131, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0)
  );

function GetSymbol(const ASymbol: string; const Prefixes: TPrefixes): string;
var
  PrefixCount: longint;
begin
  PrefixCount := Length(Prefixes);
  case PrefixCount of
    0:  result := ASymbol;
    1:  result := Format(ASymbol, [PrefixTable[Prefixes[0]].Symbol]);
    2:  result := Format(ASymbol, [PrefixTable[Prefixes[0]].Symbol, PrefixTable[Prefixes[1]].Symbol]);
    3:  result := Format(ASymbol, [PrefixTable[Prefixes[0]].Symbol, PrefixTable[Prefixes[1]].Symbol, PrefixTable[Prefixes[2]].Symbol]);
  else raise Exception.Create('Wrong number of prefixes.');
  end;
end;

function GetName(const AName: string; const Prefixes: TPrefixes): string;
var
  PrefixCount: longint;
begin
  PrefixCount := Length(Prefixes);
  case PrefixCount of
    0:  result := AName;
    1:  result := Format(AName, [PrefixTable[Prefixes[0]].Name]);
    2:  result := Format(AName, [PrefixTable[Prefixes[0]].Name, PrefixTable[Prefixes[1]].Name]);
    3:  result := Format(AName, [PrefixTable[Prefixes[0]].Name, PrefixTable[Prefixes[1]].Name, PrefixTable[Prefixes[2]].Name]);
  else raise Exception.Create('Wrong number of prefixes.');
  end;
end;

function GetValue(const AValue: double; const APrefixes, ABasePrefixes: TPrefixes; const AExponents, ABaseExponents: TExponents): double;
var
  I: longint;
  Exponent: longint;
  PrefixCount: longint;
begin
  PrefixCount := Length(APrefixes);
  if PrefixCount = Length(ABasePrefixes) then
  begin
    Exponent := 0;
    for I := 0 to PrefixCount -1 do
      Inc(Exponent, PrefixTable[ABasePrefixes[I]].Exponent * ABaseExponents[I]);

    for I := 0 to PrefixCount -1 do
      Dec(Exponent, PrefixTable[APrefixes[I]].Exponent * ABaseExponents[I]);

    if Exponent <> 0 then
      result := AValue * IntPower(10, Exponent)
    else
      result := AValue;
  end else
    if PrefixCount = 0 then
      result := AValue
    else
      raise Exception.Create('Wrong number of prefixes.');
end;

{$IFOPT D+}
class operator TQuantity.+(const ALeft, ARight: TQuantity): TQuantity;
begin
  if ALeft.FUnitOfMeasurement <> ARight.FUnitOfMeasurement then
    raise Exception.Create('Summing operator (+) has detected wrong unit of measurements.');
  result.FValue := ALeft.FValue + ARight.FValue;
end;

class operator TQuantity.-(const ALeft, ARight: TQuantity): TQuantity;
begin
  if ALeft.FUnitOfMeasurement <> ARight.FUnitOfMeasurement then
    raise Exception.Create('Subtracting operator (-) has detected wrong unit of measurements.');
  result.FValue := ALeft.FValue - ARight.FValue;
end;

class operator TQuantity.*(const ALeft, ARight: TQuantity): TQuantity;
begin
  result.FUnitOfMeasurement := MulTable[ALeft.FUnitOfMeasurement, ARight.FUnitOfMeasurement];
  result.FValue := ALeft.FValue * ARight.FValue;
end;

class operator TQuantity./(const ALeft, ARight: TQuantity): TQuantity;
begin
  result.FUnitOfMeasurement := DivTable[ALeft.FUnitOfMeasurement, ARight.FUnitOfMeasurement];
  result.FValue := ALeft.FValue / ARight.FValue;
end;

class operator TQuantity.*(const ALeft: double; const ARight: TQuantity): TQuantity;
begin
  result.FUnitOfMeasurement := ARight.FUnitOfMeasurement;
  result.FValue:= ALeft * ARight.FValue;
end;

class operator TQuantity.*(const ALeft: TQuantity; const ARight: double): TQuantity;
begin
  result.FUnitOfMeasurement := ALeft.FUnitOfMeasurement;
  result.FValue:= ALeft.FValue * ARight;
end;

class operator TQuantity./(const ALeft: TQuantity; const ARight: double): TQuantity;
begin
  result.FUnitOfMeasurement := ALeft.FUnitOfMeasurement;
  result.FValue:= ALeft.FValue / ARight;
end;
{$ENDIF}

class operator TScalarUnit.*(const AValue: double; const ASelf: TScalarUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cScalar];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TScalarUnit./(const AValue: double; const ASelf: TScalarUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cScalar];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TScalarUnit.*(const AValue: TQuantity; const ASelf: TScalarUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cScalar];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TScalarUnit./(const AValue: TQuantity; const ASelf: TScalarUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cScalar];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TRadianUnit.*(const AValue: double; const ASelf: TRadianUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cScalar];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

class operator TRadianUnit./(const AValue: double; const ASelf: TRadianUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cScalar];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

{$IFOPT D+}
class operator TRadianUnit.*(const AValue: TQuantity; const ASelf: TRadianUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cScalar];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

{$IFOPT D+}
class operator TRadianUnit./(const AValue: TQuantity; const ASelf: TRadianUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cScalar];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

class operator TDegreeUnit.*(const AValue: double; const ASelf: TDegreeUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cScalar];
  result.FValue := AValue * Pi/180;
{$ELSE}
  result := AValue * Pi/180;
{$ENDIF}
end;

class operator TDegreeUnit./(const AValue: double; const ASelf: TDegreeUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cScalar];
  result.FValue := AValue * Pi/180;
{$ELSE}
  result := AValue * Pi/180;
{$ENDIF}
end;

{$IFOPT D+}
class operator TDegreeUnit.*(const AValue: TQuantity; const ASelf: TDegreeUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[cScalar, cScalar];
  result.FValue := AValue.FValue * Pi/180;
end;
{$ENDIF}

{$IFOPT D+}
class operator TDegreeUnit./(const AValue: TQuantity; const ASelf: TDegreeUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[cScalar, cScalar];
  result.FValue := AValue.FValue * Pi/180;
end;
{$ENDIF}

class operator TSteradianUnit.*(const AValue: double; const ASelf: TSteradianUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cScalar];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

class operator TSteradianUnit./(const AValue: double; const ASelf: TSteradianUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cScalar];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

{$IFOPT D+}
class operator TSteradianUnit.*(const AValue: TQuantity; const ASelf: TSteradianUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cScalar];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

{$IFOPT D+}
class operator TSteradianUnit./(const AValue: TQuantity; const ASelf: TSteradianUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cScalar];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

class operator TSquareDegreeUnit.*(const AValue: double; const ASelf: TSquareDegreeUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cScalar];
  result.FValue := AValue * Pi*Pi/32400;
{$ELSE}
  result := AValue * Pi*Pi/32400;
{$ENDIF}
end;

class operator TSquareDegreeUnit./(const AValue: double; const ASelf: TSquareDegreeUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cScalar];
  result.FValue := AValue * Pi*Pi/32400;
{$ELSE}
  result := AValue * Pi*Pi/32400;
{$ENDIF}
end;

{$IFOPT D+}
class operator TSquareDegreeUnit.*(const AValue: TQuantity; const ASelf: TSquareDegreeUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[cScalar, cScalar];
  result.FValue := AValue.FValue * Pi*Pi/32400;
end;
{$ENDIF}

{$IFOPT D+}
class operator TSquareDegreeUnit./(const AValue: TQuantity; const ASelf: TSquareDegreeUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[cScalar, cScalar];
  result.FValue := AValue.FValue * Pi*Pi/32400;
end;
{$ENDIF}

class operator TSecondUnit.*(const AValue: double; const ASelf: TSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cSecond];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TSecondUnit./(const AValue: double; const ASelf: TSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cSecond];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TSecondUnit.*(const AValue: TQuantity; const ASelf: TSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cSecond];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TSecondUnit./(const AValue: TQuantity; const ASelf: TSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cSecond];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TDayUnit.*(const AValue: double; const ASelf: TDayUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cSecond];
  result.FValue := AValue * 86400;
{$ELSE}
  result := AValue * 86400;
{$ENDIF}
end;

class operator TDayUnit./(const AValue: double; const ASelf: TDayUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cSecond];
  result.FValue := AValue * 86400;
{$ELSE}
  result := AValue * 86400;
{$ENDIF}
end;

{$IFOPT D+}
class operator TDayUnit.*(const AValue: TQuantity; const ASelf: TDayUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[cScalar, cSecond];
  result.FValue := AValue.FValue * 86400;
end;
{$ENDIF}

{$IFOPT D+}
class operator TDayUnit./(const AValue: TQuantity; const ASelf: TDayUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[cScalar, cSecond];
  result.FValue := AValue.FValue * 86400;
end;
{$ENDIF}

class operator THourUnit.*(const AValue: double; const ASelf: THourUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cSecond];
  result.FValue := AValue * 3600;
{$ELSE}
  result := AValue * 3600;
{$ENDIF}
end;

class operator THourUnit./(const AValue: double; const ASelf: THourUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cSecond];
  result.FValue := AValue * 3600;
{$ELSE}
  result := AValue * 3600;
{$ENDIF}
end;

{$IFOPT D+}
class operator THourUnit.*(const AValue: TQuantity; const ASelf: THourUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[cScalar, cSecond];
  result.FValue := AValue.FValue * 3600;
end;
{$ENDIF}

{$IFOPT D+}
class operator THourUnit./(const AValue: TQuantity; const ASelf: THourUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[cScalar, cSecond];
  result.FValue := AValue.FValue * 3600;
end;
{$ENDIF}

class operator TMinuteUnit.*(const AValue: double; const ASelf: TMinuteUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cSecond];
  result.FValue := AValue * 60;
{$ELSE}
  result := AValue * 60;
{$ENDIF}
end;

class operator TMinuteUnit./(const AValue: double; const ASelf: TMinuteUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cSecond];
  result.FValue := AValue * 60;
{$ELSE}
  result := AValue * 60;
{$ENDIF}
end;

{$IFOPT D+}
class operator TMinuteUnit.*(const AValue: TQuantity; const ASelf: TMinuteUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[cScalar, cSecond];
  result.FValue := AValue.FValue * 60;
end;
{$ENDIF}

{$IFOPT D+}
class operator TMinuteUnit./(const AValue: TQuantity; const ASelf: TMinuteUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[cScalar, cSecond];
  result.FValue := AValue.FValue * 60;
end;
{$ENDIF}

class operator TSquareSecondUnit.*(const AValue: double; const ASelf: TSquareSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cSquareSecond];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TSquareSecondUnit./(const AValue: double; const ASelf: TSquareSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cSquareSecond];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TSquareSecondUnit.*(const AValue: TQuantity; const ASelf: TSquareSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cSquareSecond];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TSquareSecondUnit./(const AValue: TQuantity; const ASelf: TSquareSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cSquareSecond];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TSquareDayUnit.*(const AValue: double; const ASelf: TSquareDayUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cSquareSecond];
  result.FValue := AValue * 7464960000;
{$ELSE}
  result := AValue * 7464960000;
{$ENDIF}
end;

class operator TSquareDayUnit./(const AValue: double; const ASelf: TSquareDayUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cSquareSecond];
  result.FValue := AValue * 7464960000;
{$ELSE}
  result := AValue * 7464960000;
{$ENDIF}
end;

{$IFOPT D+}
class operator TSquareDayUnit.*(const AValue: TQuantity; const ASelf: TSquareDayUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[cScalar, cSquareSecond];
  result.FValue := AValue.FValue * 7464960000;
end;
{$ENDIF}

{$IFOPT D+}
class operator TSquareDayUnit./(const AValue: TQuantity; const ASelf: TSquareDayUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[cScalar, cSquareSecond];
  result.FValue := AValue.FValue * 7464960000;
end;
{$ENDIF}

class operator TSquareHourUnit.*(const AValue: double; const ASelf: TSquareHourUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cSquareSecond];
  result.FValue := AValue * 12960000;
{$ELSE}
  result := AValue * 12960000;
{$ENDIF}
end;

class operator TSquareHourUnit./(const AValue: double; const ASelf: TSquareHourUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cSquareSecond];
  result.FValue := AValue * 12960000;
{$ELSE}
  result := AValue * 12960000;
{$ENDIF}
end;

{$IFOPT D+}
class operator TSquareHourUnit.*(const AValue: TQuantity; const ASelf: TSquareHourUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[cScalar, cSquareSecond];
  result.FValue := AValue.FValue * 12960000;
end;
{$ENDIF}

{$IFOPT D+}
class operator TSquareHourUnit./(const AValue: TQuantity; const ASelf: TSquareHourUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[cScalar, cSquareSecond];
  result.FValue := AValue.FValue * 12960000;
end;
{$ENDIF}

class operator TSquareMinuteUnit.*(const AValue: double; const ASelf: TSquareMinuteUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cSquareSecond];
  result.FValue := AValue * 3600;
{$ELSE}
  result := AValue * 3600;
{$ENDIF}
end;

class operator TSquareMinuteUnit./(const AValue: double; const ASelf: TSquareMinuteUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cSquareSecond];
  result.FValue := AValue * 3600;
{$ELSE}
  result := AValue * 3600;
{$ENDIF}
end;

{$IFOPT D+}
class operator TSquareMinuteUnit.*(const AValue: TQuantity; const ASelf: TSquareMinuteUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[cScalar, cSquareSecond];
  result.FValue := AValue.FValue * 3600;
end;
{$ENDIF}

{$IFOPT D+}
class operator TSquareMinuteUnit./(const AValue: TQuantity; const ASelf: TSquareMinuteUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[cScalar, cSquareSecond];
  result.FValue := AValue.FValue * 3600;
end;
{$ENDIF}

class operator TCubicSecondUnit.*(const AValue: double; const ASelf: TCubicSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cCubicSecond];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TCubicSecondUnit./(const AValue: double; const ASelf: TCubicSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cCubicSecond];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TCubicSecondUnit.*(const AValue: TQuantity; const ASelf: TCubicSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cCubicSecond];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TCubicSecondUnit./(const AValue: TQuantity; const ASelf: TCubicSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cCubicSecond];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TQuarticSecondUnit.*(const AValue: double; const ASelf: TQuarticSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cQuarticSecond];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TQuarticSecondUnit./(const AValue: double; const ASelf: TQuarticSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cQuarticSecond];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TQuarticSecondUnit.*(const AValue: TQuantity; const ASelf: TQuarticSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cQuarticSecond];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TQuarticSecondUnit./(const AValue: TQuantity; const ASelf: TQuarticSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cQuarticSecond];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TQuinticSecondUnit.*(const AValue: double; const ASelf: TQuinticSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cQuinticSecond];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TQuinticSecondUnit./(const AValue: double; const ASelf: TQuinticSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cQuinticSecond];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TQuinticSecondUnit.*(const AValue: TQuantity; const ASelf: TQuinticSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cQuinticSecond];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TQuinticSecondUnit./(const AValue: TQuantity; const ASelf: TQuinticSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cQuinticSecond];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TSexticSecondUnit.*(const AValue: double; const ASelf: TSexticSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cSexticSecond];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TSexticSecondUnit./(const AValue: double; const ASelf: TSexticSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cSexticSecond];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TSexticSecondUnit.*(const AValue: TQuantity; const ASelf: TSexticSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cSexticSecond];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TSexticSecondUnit./(const AValue: TQuantity; const ASelf: TSexticSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cSexticSecond];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TMeterUnit.*(const AValue: double; const ASelf: TMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TMeterUnit./(const AValue: double; const ASelf: TMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TMeterUnit.*(const AValue: TQuantity; const ASelf: TMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TMeterUnit./(const AValue: TQuantity; const ASelf: TMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TAstronomicalUnit.*(const AValue: double; const ASelf: TAstronomicalUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cMeter];
  result.FValue := AValue * 149597870691;
{$ELSE}
  result := AValue * 149597870691;
{$ENDIF}
end;

class operator TAstronomicalUnit./(const AValue: double; const ASelf: TAstronomicalUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cMeter];
  result.FValue := AValue * 149597870691;
{$ELSE}
  result := AValue * 149597870691;
{$ENDIF}
end;

{$IFOPT D+}
class operator TAstronomicalUnit.*(const AValue: TQuantity; const ASelf: TAstronomicalUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[cScalar, cMeter];
  result.FValue := AValue.FValue * 149597870691;
end;
{$ENDIF}

{$IFOPT D+}
class operator TAstronomicalUnit./(const AValue: TQuantity; const ASelf: TAstronomicalUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[cScalar, cMeter];
  result.FValue := AValue.FValue * 149597870691;
end;
{$ENDIF}

class operator TInchUnit.*(const AValue: double; const ASelf: TInchUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cMeter];
  result.FValue := AValue * 0.0254;
{$ELSE}
  result := AValue * 0.0254;
{$ENDIF}
end;

class operator TInchUnit./(const AValue: double; const ASelf: TInchUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cMeter];
  result.FValue := AValue * 0.0254;
{$ELSE}
  result := AValue * 0.0254;
{$ENDIF}
end;

{$IFOPT D+}
class operator TInchUnit.*(const AValue: TQuantity; const ASelf: TInchUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[cScalar, cMeter];
  result.FValue := AValue.FValue * 0.0254;
end;
{$ENDIF}

{$IFOPT D+}
class operator TInchUnit./(const AValue: TQuantity; const ASelf: TInchUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[cScalar, cMeter];
  result.FValue := AValue.FValue * 0.0254;
end;
{$ENDIF}

class operator TFootUnit.*(const AValue: double; const ASelf: TFootUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cMeter];
  result.FValue := AValue * 0.3048;
{$ELSE}
  result := AValue * 0.3048;
{$ENDIF}
end;

class operator TFootUnit./(const AValue: double; const ASelf: TFootUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cMeter];
  result.FValue := AValue * 0.3048;
{$ELSE}
  result := AValue * 0.3048;
{$ENDIF}
end;

{$IFOPT D+}
class operator TFootUnit.*(const AValue: TQuantity; const ASelf: TFootUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[cScalar, cMeter];
  result.FValue := AValue.FValue * 0.3048;
end;
{$ENDIF}

{$IFOPT D+}
class operator TFootUnit./(const AValue: TQuantity; const ASelf: TFootUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[cScalar, cMeter];
  result.FValue := AValue.FValue * 0.3048;
end;
{$ENDIF}

class operator TYardUnit.*(const AValue: double; const ASelf: TYardUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cMeter];
  result.FValue := AValue * 0.9144;
{$ELSE}
  result := AValue * 0.9144;
{$ENDIF}
end;

class operator TYardUnit./(const AValue: double; const ASelf: TYardUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cMeter];
  result.FValue := AValue * 0.9144;
{$ELSE}
  result := AValue * 0.9144;
{$ENDIF}
end;

{$IFOPT D+}
class operator TYardUnit.*(const AValue: TQuantity; const ASelf: TYardUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[cScalar, cMeter];
  result.FValue := AValue.FValue * 0.9144;
end;
{$ENDIF}

{$IFOPT D+}
class operator TYardUnit./(const AValue: TQuantity; const ASelf: TYardUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[cScalar, cMeter];
  result.FValue := AValue.FValue * 0.9144;
end;
{$ENDIF}

class operator TMileUnit.*(const AValue: double; const ASelf: TMileUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cMeter];
  result.FValue := AValue * 1609.344;
{$ELSE}
  result := AValue * 1609.344;
{$ENDIF}
end;

class operator TMileUnit./(const AValue: double; const ASelf: TMileUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cMeter];
  result.FValue := AValue * 1609.344;
{$ELSE}
  result := AValue * 1609.344;
{$ENDIF}
end;

{$IFOPT D+}
class operator TMileUnit.*(const AValue: TQuantity; const ASelf: TMileUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[cScalar, cMeter];
  result.FValue := AValue.FValue * 1609.344;
end;
{$ENDIF}

{$IFOPT D+}
class operator TMileUnit./(const AValue: TQuantity; const ASelf: TMileUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[cScalar, cMeter];
  result.FValue := AValue.FValue * 1609.344;
end;
{$ENDIF}

class operator TNauticalMileUnit.*(const AValue: double; const ASelf: TNauticalMileUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cMeter];
  result.FValue := AValue * 1852;
{$ELSE}
  result := AValue * 1852;
{$ENDIF}
end;

class operator TNauticalMileUnit./(const AValue: double; const ASelf: TNauticalMileUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cMeter];
  result.FValue := AValue * 1852;
{$ELSE}
  result := AValue * 1852;
{$ENDIF}
end;

{$IFOPT D+}
class operator TNauticalMileUnit.*(const AValue: TQuantity; const ASelf: TNauticalMileUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[cScalar, cMeter];
  result.FValue := AValue.FValue * 1852;
end;
{$ENDIF}

{$IFOPT D+}
class operator TNauticalMileUnit./(const AValue: TQuantity; const ASelf: TNauticalMileUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[cScalar, cMeter];
  result.FValue := AValue.FValue * 1852;
end;
{$ENDIF}

class operator TAngstromUnit.*(const AValue: double; const ASelf: TAngstromUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cMeter];
  result.FValue := AValue * 1E-10;
{$ELSE}
  result := AValue * 1E-10;
{$ENDIF}
end;

class operator TAngstromUnit./(const AValue: double; const ASelf: TAngstromUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cMeter];
  result.FValue := AValue * 1E-10;
{$ELSE}
  result := AValue * 1E-10;
{$ENDIF}
end;

{$IFOPT D+}
class operator TAngstromUnit.*(const AValue: TQuantity; const ASelf: TAngstromUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[cScalar, cMeter];
  result.FValue := AValue.FValue * 1E-10;
end;
{$ENDIF}

{$IFOPT D+}
class operator TAngstromUnit./(const AValue: TQuantity; const ASelf: TAngstromUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[cScalar, cMeter];
  result.FValue := AValue.FValue * 1E-10;
end;
{$ENDIF}

class operator TSquareRootMeterUnit.*(const AValue: double; const ASelf: TSquareRootMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cSquareRootMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TSquareRootMeterUnit./(const AValue: double; const ASelf: TSquareRootMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cSquareRootMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TSquareRootMeterUnit.*(const AValue: TQuantity; const ASelf: TSquareRootMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cSquareRootMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TSquareRootMeterUnit./(const AValue: TQuantity; const ASelf: TSquareRootMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cSquareRootMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TSquareMeterUnit.*(const AValue: double; const ASelf: TSquareMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cSquareMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TSquareMeterUnit./(const AValue: double; const ASelf: TSquareMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cSquareMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TSquareMeterUnit.*(const AValue: TQuantity; const ASelf: TSquareMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cSquareMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TSquareMeterUnit./(const AValue: TQuantity; const ASelf: TSquareMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cSquareMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TSquareInchUnit.*(const AValue: double; const ASelf: TSquareInchUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cSquareMeter];
  result.FValue := AValue * 0.00064516;
{$ELSE}
  result := AValue * 0.00064516;
{$ENDIF}
end;

class operator TSquareInchUnit./(const AValue: double; const ASelf: TSquareInchUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cSquareMeter];
  result.FValue := AValue * 0.00064516;
{$ELSE}
  result := AValue * 0.00064516;
{$ENDIF}
end;

{$IFOPT D+}
class operator TSquareInchUnit.*(const AValue: TQuantity; const ASelf: TSquareInchUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[cScalar, cSquareMeter];
  result.FValue := AValue.FValue * 0.00064516;
end;
{$ENDIF}

{$IFOPT D+}
class operator TSquareInchUnit./(const AValue: TQuantity; const ASelf: TSquareInchUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[cScalar, cSquareMeter];
  result.FValue := AValue.FValue * 0.00064516;
end;
{$ENDIF}

class operator TSquareFootUnit.*(const AValue: double; const ASelf: TSquareFootUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cSquareMeter];
  result.FValue := AValue * 0.09290304;
{$ELSE}
  result := AValue * 0.09290304;
{$ENDIF}
end;

class operator TSquareFootUnit./(const AValue: double; const ASelf: TSquareFootUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cSquareMeter];
  result.FValue := AValue * 0.09290304;
{$ELSE}
  result := AValue * 0.09290304;
{$ENDIF}
end;

{$IFOPT D+}
class operator TSquareFootUnit.*(const AValue: TQuantity; const ASelf: TSquareFootUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[cScalar, cSquareMeter];
  result.FValue := AValue.FValue * 0.09290304;
end;
{$ENDIF}

{$IFOPT D+}
class operator TSquareFootUnit./(const AValue: TQuantity; const ASelf: TSquareFootUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[cScalar, cSquareMeter];
  result.FValue := AValue.FValue * 0.09290304;
end;
{$ENDIF}

class operator TSquareYardUnit.*(const AValue: double; const ASelf: TSquareYardUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cSquareMeter];
  result.FValue := AValue * 0.83612736;
{$ELSE}
  result := AValue * 0.83612736;
{$ENDIF}
end;

class operator TSquareYardUnit./(const AValue: double; const ASelf: TSquareYardUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cSquareMeter];
  result.FValue := AValue * 0.83612736;
{$ELSE}
  result := AValue * 0.83612736;
{$ENDIF}
end;

{$IFOPT D+}
class operator TSquareYardUnit.*(const AValue: TQuantity; const ASelf: TSquareYardUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[cScalar, cSquareMeter];
  result.FValue := AValue.FValue * 0.83612736;
end;
{$ENDIF}

{$IFOPT D+}
class operator TSquareYardUnit./(const AValue: TQuantity; const ASelf: TSquareYardUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[cScalar, cSquareMeter];
  result.FValue := AValue.FValue * 0.83612736;
end;
{$ENDIF}

class operator TSquareMileUnit.*(const AValue: double; const ASelf: TSquareMileUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cSquareMeter];
  result.FValue := AValue * 2589988.110336;
{$ELSE}
  result := AValue * 2589988.110336;
{$ENDIF}
end;

class operator TSquareMileUnit./(const AValue: double; const ASelf: TSquareMileUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cSquareMeter];
  result.FValue := AValue * 2589988.110336;
{$ELSE}
  result := AValue * 2589988.110336;
{$ENDIF}
end;

{$IFOPT D+}
class operator TSquareMileUnit.*(const AValue: TQuantity; const ASelf: TSquareMileUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[cScalar, cSquareMeter];
  result.FValue := AValue.FValue * 2589988.110336;
end;
{$ENDIF}

{$IFOPT D+}
class operator TSquareMileUnit./(const AValue: TQuantity; const ASelf: TSquareMileUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[cScalar, cSquareMeter];
  result.FValue := AValue.FValue * 2589988.110336;
end;
{$ENDIF}

class operator TCubicMeterUnit.*(const AValue: double; const ASelf: TCubicMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cCubicMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TCubicMeterUnit./(const AValue: double; const ASelf: TCubicMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cCubicMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TCubicMeterUnit.*(const AValue: TQuantity; const ASelf: TCubicMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cCubicMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TCubicMeterUnit./(const AValue: TQuantity; const ASelf: TCubicMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cCubicMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TCubicInchUnit.*(const AValue: double; const ASelf: TCubicInchUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cCubicMeter];
  result.FValue := AValue * 0.000016387064;
{$ELSE}
  result := AValue * 0.000016387064;
{$ENDIF}
end;

class operator TCubicInchUnit./(const AValue: double; const ASelf: TCubicInchUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cCubicMeter];
  result.FValue := AValue * 0.000016387064;
{$ELSE}
  result := AValue * 0.000016387064;
{$ENDIF}
end;

{$IFOPT D+}
class operator TCubicInchUnit.*(const AValue: TQuantity; const ASelf: TCubicInchUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[cScalar, cCubicMeter];
  result.FValue := AValue.FValue * 0.000016387064;
end;
{$ENDIF}

{$IFOPT D+}
class operator TCubicInchUnit./(const AValue: TQuantity; const ASelf: TCubicInchUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[cScalar, cCubicMeter];
  result.FValue := AValue.FValue * 0.000016387064;
end;
{$ENDIF}

class operator TCubicFootUnit.*(const AValue: double; const ASelf: TCubicFootUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cCubicMeter];
  result.FValue := AValue * 0.028316846592;
{$ELSE}
  result := AValue * 0.028316846592;
{$ENDIF}
end;

class operator TCubicFootUnit./(const AValue: double; const ASelf: TCubicFootUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cCubicMeter];
  result.FValue := AValue * 0.028316846592;
{$ELSE}
  result := AValue * 0.028316846592;
{$ENDIF}
end;

{$IFOPT D+}
class operator TCubicFootUnit.*(const AValue: TQuantity; const ASelf: TCubicFootUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[cScalar, cCubicMeter];
  result.FValue := AValue.FValue * 0.028316846592;
end;
{$ENDIF}

{$IFOPT D+}
class operator TCubicFootUnit./(const AValue: TQuantity; const ASelf: TCubicFootUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[cScalar, cCubicMeter];
  result.FValue := AValue.FValue * 0.028316846592;
end;
{$ENDIF}

class operator TCubicYardUnit.*(const AValue: double; const ASelf: TCubicYardUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cCubicMeter];
  result.FValue := AValue * 0.764554857984;
{$ELSE}
  result := AValue * 0.764554857984;
{$ENDIF}
end;

class operator TCubicYardUnit./(const AValue: double; const ASelf: TCubicYardUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cCubicMeter];
  result.FValue := AValue * 0.764554857984;
{$ELSE}
  result := AValue * 0.764554857984;
{$ENDIF}
end;

{$IFOPT D+}
class operator TCubicYardUnit.*(const AValue: TQuantity; const ASelf: TCubicYardUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[cScalar, cCubicMeter];
  result.FValue := AValue.FValue * 0.764554857984;
end;
{$ENDIF}

{$IFOPT D+}
class operator TCubicYardUnit./(const AValue: TQuantity; const ASelf: TCubicYardUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[cScalar, cCubicMeter];
  result.FValue := AValue.FValue * 0.764554857984;
end;
{$ENDIF}

class operator TLitreUnit.*(const AValue: double; const ASelf: TLitreUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cCubicMeter];
  result.FValue := AValue * 1E-03;
{$ELSE}
  result := AValue * 1E-03;
{$ENDIF}
end;

class operator TLitreUnit./(const AValue: double; const ASelf: TLitreUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cCubicMeter];
  result.FValue := AValue * 1E-03;
{$ELSE}
  result := AValue * 1E-03;
{$ENDIF}
end;

{$IFOPT D+}
class operator TLitreUnit.*(const AValue: TQuantity; const ASelf: TLitreUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[cScalar, cCubicMeter];
  result.FValue := AValue.FValue * 1E-03;
end;
{$ENDIF}

{$IFOPT D+}
class operator TLitreUnit./(const AValue: TQuantity; const ASelf: TLitreUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[cScalar, cCubicMeter];
  result.FValue := AValue.FValue * 1E-03;
end;
{$ENDIF}

class operator TGallonUnit.*(const AValue: double; const ASelf: TGallonUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cCubicMeter];
  result.FValue := AValue * 0.0037854119678;
{$ELSE}
  result := AValue * 0.0037854119678;
{$ENDIF}
end;

class operator TGallonUnit./(const AValue: double; const ASelf: TGallonUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cCubicMeter];
  result.FValue := AValue * 0.0037854119678;
{$ELSE}
  result := AValue * 0.0037854119678;
{$ENDIF}
end;

{$IFOPT D+}
class operator TGallonUnit.*(const AValue: TQuantity; const ASelf: TGallonUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[cScalar, cCubicMeter];
  result.FValue := AValue.FValue * 0.0037854119678;
end;
{$ENDIF}

{$IFOPT D+}
class operator TGallonUnit./(const AValue: TQuantity; const ASelf: TGallonUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[cScalar, cCubicMeter];
  result.FValue := AValue.FValue * 0.0037854119678;
end;
{$ENDIF}

class operator TQuarticMeterUnit.*(const AValue: double; const ASelf: TQuarticMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cQuarticMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TQuarticMeterUnit./(const AValue: double; const ASelf: TQuarticMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cQuarticMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TQuarticMeterUnit.*(const AValue: TQuantity; const ASelf: TQuarticMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cQuarticMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TQuarticMeterUnit./(const AValue: TQuantity; const ASelf: TQuarticMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cQuarticMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TQuinticMeterUnit.*(const AValue: double; const ASelf: TQuinticMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cQuinticMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TQuinticMeterUnit./(const AValue: double; const ASelf: TQuinticMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cQuinticMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TQuinticMeterUnit.*(const AValue: TQuantity; const ASelf: TQuinticMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cQuinticMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TQuinticMeterUnit./(const AValue: TQuantity; const ASelf: TQuinticMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cQuinticMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TSexticMeterUnit.*(const AValue: double; const ASelf: TSexticMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cSexticMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TSexticMeterUnit./(const AValue: double; const ASelf: TSexticMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cSexticMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TSexticMeterUnit.*(const AValue: TQuantity; const ASelf: TSexticMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cSexticMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TSexticMeterUnit./(const AValue: TQuantity; const ASelf: TSexticMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cSexticMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TKilogramUnit.*(const AValue: double; const ASelf: TKilogramUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cKilogram];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TKilogramUnit./(const AValue: double; const ASelf: TKilogramUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cKilogram];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TKilogramUnit.*(const AValue: TQuantity; const ASelf: TKilogramUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cKilogram];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TKilogramUnit./(const AValue: TQuantity; const ASelf: TKilogramUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cKilogram];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TTonneUnit.*(const AValue: double; const ASelf: TTonneUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cKilogram];
  result.FValue := AValue * 1E+03;
{$ELSE}
  result := AValue * 1E+03;
{$ENDIF}
end;

class operator TTonneUnit./(const AValue: double; const ASelf: TTonneUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cKilogram];
  result.FValue := AValue * 1E+03;
{$ELSE}
  result := AValue * 1E+03;
{$ENDIF}
end;

{$IFOPT D+}
class operator TTonneUnit.*(const AValue: TQuantity; const ASelf: TTonneUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[cScalar, cKilogram];
  result.FValue := AValue.FValue * 1E+03;
end;
{$ENDIF}

{$IFOPT D+}
class operator TTonneUnit./(const AValue: TQuantity; const ASelf: TTonneUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[cScalar, cKilogram];
  result.FValue := AValue.FValue * 1E+03;
end;
{$ENDIF}

class operator TPoundUnit.*(const AValue: double; const ASelf: TPoundUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cKilogram];
  result.FValue := AValue * 0.45359237;
{$ELSE}
  result := AValue * 0.45359237;
{$ENDIF}
end;

class operator TPoundUnit./(const AValue: double; const ASelf: TPoundUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cKilogram];
  result.FValue := AValue * 0.45359237;
{$ELSE}
  result := AValue * 0.45359237;
{$ENDIF}
end;

{$IFOPT D+}
class operator TPoundUnit.*(const AValue: TQuantity; const ASelf: TPoundUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[cScalar, cKilogram];
  result.FValue := AValue.FValue * 0.45359237;
end;
{$ENDIF}

{$IFOPT D+}
class operator TPoundUnit./(const AValue: TQuantity; const ASelf: TPoundUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[cScalar, cKilogram];
  result.FValue := AValue.FValue * 0.45359237;
end;
{$ENDIF}

class operator TOunceUnit.*(const AValue: double; const ASelf: TOunceUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cKilogram];
  result.FValue := AValue * 0.028349523125;
{$ELSE}
  result := AValue * 0.028349523125;
{$ENDIF}
end;

class operator TOunceUnit./(const AValue: double; const ASelf: TOunceUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cKilogram];
  result.FValue := AValue * 0.028349523125;
{$ELSE}
  result := AValue * 0.028349523125;
{$ENDIF}
end;

{$IFOPT D+}
class operator TOunceUnit.*(const AValue: TQuantity; const ASelf: TOunceUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[cScalar, cKilogram];
  result.FValue := AValue.FValue * 0.028349523125;
end;
{$ENDIF}

{$IFOPT D+}
class operator TOunceUnit./(const AValue: TQuantity; const ASelf: TOunceUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[cScalar, cKilogram];
  result.FValue := AValue.FValue * 0.028349523125;
end;
{$ENDIF}

class operator TStoneUnit.*(const AValue: double; const ASelf: TStoneUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cKilogram];
  result.FValue := AValue * 6.35029318;
{$ELSE}
  result := AValue * 6.35029318;
{$ENDIF}
end;

class operator TStoneUnit./(const AValue: double; const ASelf: TStoneUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cKilogram];
  result.FValue := AValue * 6.35029318;
{$ELSE}
  result := AValue * 6.35029318;
{$ENDIF}
end;

{$IFOPT D+}
class operator TStoneUnit.*(const AValue: TQuantity; const ASelf: TStoneUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[cScalar, cKilogram];
  result.FValue := AValue.FValue * 6.35029318;
end;
{$ENDIF}

{$IFOPT D+}
class operator TStoneUnit./(const AValue: TQuantity; const ASelf: TStoneUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[cScalar, cKilogram];
  result.FValue := AValue.FValue * 6.35029318;
end;
{$ENDIF}

class operator TTonUnit.*(const AValue: double; const ASelf: TTonUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cKilogram];
  result.FValue := AValue * 907.18474;
{$ELSE}
  result := AValue * 907.18474;
{$ENDIF}
end;

class operator TTonUnit./(const AValue: double; const ASelf: TTonUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cKilogram];
  result.FValue := AValue * 907.18474;
{$ELSE}
  result := AValue * 907.18474;
{$ENDIF}
end;

{$IFOPT D+}
class operator TTonUnit.*(const AValue: TQuantity; const ASelf: TTonUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[cScalar, cKilogram];
  result.FValue := AValue.FValue * 907.18474;
end;
{$ENDIF}

{$IFOPT D+}
class operator TTonUnit./(const AValue: TQuantity; const ASelf: TTonUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[cScalar, cKilogram];
  result.FValue := AValue.FValue * 907.18474;
end;
{$ENDIF}

class operator TElectronvoltPerSquareSpeedOfLightUnit.*(const AValue: double; const ASelf: TElectronvoltPerSquareSpeedOfLightUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cKilogram];
  result.FValue := AValue * 1.7826619216279E-36;
{$ELSE}
  result := AValue * 1.7826619216279E-36;
{$ENDIF}
end;

class operator TElectronvoltPerSquareSpeedOfLightUnit./(const AValue: double; const ASelf: TElectronvoltPerSquareSpeedOfLightUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cKilogram];
  result.FValue := AValue * 1.7826619216279E-36;
{$ELSE}
  result := AValue * 1.7826619216279E-36;
{$ENDIF}
end;

{$IFOPT D+}
class operator TElectronvoltPerSquareSpeedOfLightUnit.*(const AValue: TQuantity; const ASelf: TElectronvoltPerSquareSpeedOfLightUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[cScalar, cKilogram];
  result.FValue := AValue.FValue * 1.7826619216279E-36;
end;
{$ENDIF}

{$IFOPT D+}
class operator TElectronvoltPerSquareSpeedOfLightUnit./(const AValue: TQuantity; const ASelf: TElectronvoltPerSquareSpeedOfLightUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[cScalar, cKilogram];
  result.FValue := AValue.FValue * 1.7826619216279E-36;
end;
{$ENDIF}

class operator TSquareKilogramUnit.*(const AValue: double; const ASelf: TSquareKilogramUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cSquareKilogram];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TSquareKilogramUnit./(const AValue: double; const ASelf: TSquareKilogramUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cSquareKilogram];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TSquareKilogramUnit.*(const AValue: TQuantity; const ASelf: TSquareKilogramUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cSquareKilogram];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TSquareKilogramUnit./(const AValue: TQuantity; const ASelf: TSquareKilogramUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cSquareKilogram];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TAmpereUnit.*(const AValue: double; const ASelf: TAmpereUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cAmpere];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TAmpereUnit./(const AValue: double; const ASelf: TAmpereUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cAmpere];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TAmpereUnit.*(const AValue: TQuantity; const ASelf: TAmpereUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cAmpere];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TAmpereUnit./(const AValue: TQuantity; const ASelf: TAmpereUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cAmpere];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TSquareAmpereUnit.*(const AValue: double; const ASelf: TSquareAmpereUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cSquareAmpere];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TSquareAmpereUnit./(const AValue: double; const ASelf: TSquareAmpereUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cSquareAmpere];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TSquareAmpereUnit.*(const AValue: TQuantity; const ASelf: TSquareAmpereUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cSquareAmpere];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TSquareAmpereUnit./(const AValue: TQuantity; const ASelf: TSquareAmpereUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cSquareAmpere];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TKelvinUnit.*(const AValue: double; const ASelf: TKelvinUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cKelvin];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TKelvinUnit./(const AValue: double; const ASelf: TKelvinUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cKelvin];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TKelvinUnit.*(const AValue: TQuantity; const ASelf: TKelvinUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cKelvin];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TKelvinUnit./(const AValue: TQuantity; const ASelf: TKelvinUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cKelvin];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TDegreeCelsiusUnit.*(const AValue: double; const ASelf: TDegreeCelsiusUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cKelvin];
  result.FValue := AValue + 273.15;
{$ELSE}
  result := AValue + 273.15;
{$ENDIF}
end;

class operator TDegreeCelsiusUnit./(const AValue: double; const ASelf: TDegreeCelsiusUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cKelvin];
  result.FValue := AValue + 273.15;
{$ELSE}
  result := AValue + 273.15;
{$ENDIF}
end;

{$IFOPT D+}
class operator TDegreeCelsiusUnit.*(const AValue: TQuantity; const ASelf: TDegreeCelsiusUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cKelvin];
  result.FValue := AValue.FValue + 273.15;
end;
{$ENDIF}

{$IFOPT D+}
class operator TDegreeCelsiusUnit./(const AValue: TQuantity; const ASelf: TDegreeCelsiusUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cKelvin];
  result.FValue := AValue.FValue + 273.15;
end;
{$ENDIF}

class operator TDegreeFahrenheitUnit.*(const AValue: double; const ASelf: TDegreeFahrenheitUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cKelvin];
  result.FValue := 5/9 * (AValue - 32) + 273.15;
{$ELSE}
  result := 5/9 * (AValue - 32) + 273.15;
{$ENDIF}
end;

class operator TDegreeFahrenheitUnit./(const AValue: double; const ASelf: TDegreeFahrenheitUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cKelvin];
  result.FValue := 5/9 * (AValue - 32) + 273.15;
{$ELSE}
  result := 5/9 * (AValue - 32) + 273.15;
{$ENDIF}
end;

{$IFOPT D+}
class operator TDegreeFahrenheitUnit.*(const AValue: TQuantity; const ASelf: TDegreeFahrenheitUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cKelvin];
  result.FValue := 5/9 * (AValue.FValue - 32) + 273.15;
end;
{$ENDIF}

{$IFOPT D+}
class operator TDegreeFahrenheitUnit./(const AValue: TQuantity; const ASelf: TDegreeFahrenheitUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cKelvin];
  result.FValue := 5/9 * (AValue.FValue - 32) + 273.15;
end;
{$ENDIF}

class operator TSquareKelvinUnit.*(const AValue: double; const ASelf: TSquareKelvinUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cSquareKelvin];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TSquareKelvinUnit./(const AValue: double; const ASelf: TSquareKelvinUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cSquareKelvin];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TSquareKelvinUnit.*(const AValue: TQuantity; const ASelf: TSquareKelvinUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cSquareKelvin];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TSquareKelvinUnit./(const AValue: TQuantity; const ASelf: TSquareKelvinUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cSquareKelvin];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TCubicKelvinUnit.*(const AValue: double; const ASelf: TCubicKelvinUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cCubicKelvin];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TCubicKelvinUnit./(const AValue: double; const ASelf: TCubicKelvinUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cCubicKelvin];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TCubicKelvinUnit.*(const AValue: TQuantity; const ASelf: TCubicKelvinUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cCubicKelvin];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TCubicKelvinUnit./(const AValue: TQuantity; const ASelf: TCubicKelvinUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cCubicKelvin];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TQuarticKelvinUnit.*(const AValue: double; const ASelf: TQuarticKelvinUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cQuarticKelvin];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TQuarticKelvinUnit./(const AValue: double; const ASelf: TQuarticKelvinUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cQuarticKelvin];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TQuarticKelvinUnit.*(const AValue: TQuantity; const ASelf: TQuarticKelvinUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cQuarticKelvin];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TQuarticKelvinUnit./(const AValue: TQuantity; const ASelf: TQuarticKelvinUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cQuarticKelvin];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TMoleUnit.*(const AValue: double; const ASelf: TMoleUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cMole];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TMoleUnit./(const AValue: double; const ASelf: TMoleUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cMole];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TMoleUnit.*(const AValue: TQuantity; const ASelf: TMoleUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cMole];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TMoleUnit./(const AValue: TQuantity; const ASelf: TMoleUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cMole];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TCandelaUnit.*(const AValue: double; const ASelf: TCandelaUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cCandela];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TCandelaUnit./(const AValue: double; const ASelf: TCandelaUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cCandela];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TCandelaUnit.*(const AValue: TQuantity; const ASelf: TCandelaUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cCandela];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TCandelaUnit./(const AValue: TQuantity; const ASelf: TCandelaUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cCandela];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator THertzUnit.*(const AValue: double; const ASelf: THertzUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cHertz];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator THertzUnit./(const AValue: double; const ASelf: THertzUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cHertz];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator THertzUnit.*(const AValue: TQuantity; const ASelf: THertzUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cHertz];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator THertzUnit./(const AValue: TQuantity; const ASelf: THertzUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cHertz];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TReciprocalSecondUnit.*(const AValue: double; const ASelf: TReciprocalSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cHertz];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

class operator TReciprocalSecondUnit./(const AValue: double; const ASelf: TReciprocalSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cHertz];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

{$IFOPT D+}
class operator TReciprocalSecondUnit.*(const AValue: TQuantity; const ASelf: TReciprocalSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cHertz];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

{$IFOPT D+}
class operator TReciprocalSecondUnit./(const AValue: TQuantity; const ASelf: TReciprocalSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cHertz];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

class operator TRadianPerSecondUnit.*(const AValue: double; const ASelf: TRadianPerSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cHertz];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

class operator TRadianPerSecondUnit./(const AValue: double; const ASelf: TRadianPerSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cHertz];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

{$IFOPT D+}
class operator TRadianPerSecondUnit.*(const AValue: TQuantity; const ASelf: TRadianPerSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cHertz];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

{$IFOPT D+}
class operator TRadianPerSecondUnit./(const AValue: TQuantity; const ASelf: TRadianPerSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cHertz];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

class operator TSquareHertzUnit.*(const AValue: double; const ASelf: TSquareHertzUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cSquareHertz];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TSquareHertzUnit./(const AValue: double; const ASelf: TSquareHertzUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cSquareHertz];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TSquareHertzUnit.*(const AValue: TQuantity; const ASelf: TSquareHertzUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cSquareHertz];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TSquareHertzUnit./(const AValue: TQuantity; const ASelf: TSquareHertzUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cSquareHertz];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TReciprocalSquareSecondUnit.*(const AValue: double; const ASelf: TReciprocalSquareSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cSquareHertz];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

class operator TReciprocalSquareSecondUnit./(const AValue: double; const ASelf: TReciprocalSquareSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cSquareHertz];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

{$IFOPT D+}
class operator TReciprocalSquareSecondUnit.*(const AValue: TQuantity; const ASelf: TReciprocalSquareSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cSquareHertz];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

{$IFOPT D+}
class operator TReciprocalSquareSecondUnit./(const AValue: TQuantity; const ASelf: TReciprocalSquareSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cSquareHertz];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

class operator TRadianPerSquareSecondUnit.*(const AValue: double; const ASelf: TRadianPerSquareSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cSquareHertz];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

class operator TRadianPerSquareSecondUnit./(const AValue: double; const ASelf: TRadianPerSquareSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cSquareHertz];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

{$IFOPT D+}
class operator TRadianPerSquareSecondUnit.*(const AValue: TQuantity; const ASelf: TRadianPerSquareSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cSquareHertz];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

{$IFOPT D+}
class operator TRadianPerSquareSecondUnit./(const AValue: TQuantity; const ASelf: TRadianPerSquareSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cSquareHertz];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

class operator TSteradianPerSquareSecondUnit.*(const AValue: double; const ASelf: TSteradianPerSquareSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cSteradianPerSquareSecond];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TSteradianPerSquareSecondUnit./(const AValue: double; const ASelf: TSteradianPerSquareSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cSteradianPerSquareSecond];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TSteradianPerSquareSecondUnit.*(const AValue: TQuantity; const ASelf: TSteradianPerSquareSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cSteradianPerSquareSecond];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TSteradianPerSquareSecondUnit./(const AValue: TQuantity; const ASelf: TSteradianPerSquareSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cSteradianPerSquareSecond];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TMeterPerSecondUnit.*(const AValue: double; const ASelf: TMeterPerSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cMeterPerSecond];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TMeterPerSecondUnit./(const AValue: double; const ASelf: TMeterPerSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cMeterPerSecond];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TMeterPerSecondUnit.*(const AValue: TQuantity; const ASelf: TMeterPerSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cMeterPerSecond];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TMeterPerSecondUnit./(const AValue: TQuantity; const ASelf: TMeterPerSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cMeterPerSecond];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TMeterPerHourUnit.*(const AValue: double; const ASelf: TMeterPerHourUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cMeterPerSecond];
  result.FValue := AValue * 1/3600;
{$ELSE}
  result := AValue * 1/3600;
{$ENDIF}
end;

class operator TMeterPerHourUnit./(const AValue: double; const ASelf: TMeterPerHourUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cMeterPerSecond];
  result.FValue := AValue * 1/3600;
{$ELSE}
  result := AValue * 1/3600;
{$ENDIF}
end;

{$IFOPT D+}
class operator TMeterPerHourUnit.*(const AValue: TQuantity; const ASelf: TMeterPerHourUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[cScalar, cMeterPerSecond];
  result.FValue := AValue.FValue * 1/3600;
end;
{$ENDIF}

{$IFOPT D+}
class operator TMeterPerHourUnit./(const AValue: TQuantity; const ASelf: TMeterPerHourUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[cScalar, cMeterPerSecond];
  result.FValue := AValue.FValue * 1/3600;
end;
{$ENDIF}

class operator TMilePerHourUnit.*(const AValue: double; const ASelf: TMilePerHourUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cMeterPerSecond];
  result.FValue := AValue * 0.44704;
{$ELSE}
  result := AValue * 0.44704;
{$ENDIF}
end;

class operator TMilePerHourUnit./(const AValue: double; const ASelf: TMilePerHourUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cMeterPerSecond];
  result.FValue := AValue * 0.44704;
{$ELSE}
  result := AValue * 0.44704;
{$ENDIF}
end;

{$IFOPT D+}
class operator TMilePerHourUnit.*(const AValue: TQuantity; const ASelf: TMilePerHourUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[cScalar, cMeterPerSecond];
  result.FValue := AValue.FValue * 0.44704;
end;
{$ENDIF}

{$IFOPT D+}
class operator TMilePerHourUnit./(const AValue: TQuantity; const ASelf: TMilePerHourUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[cScalar, cMeterPerSecond];
  result.FValue := AValue.FValue * 0.44704;
end;
{$ENDIF}

class operator TNauticalMilePerHourUnit.*(const AValue: double; const ASelf: TNauticalMilePerHourUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cMeterPerSecond];
  result.FValue := AValue * 463/900;
{$ELSE}
  result := AValue * 463/900;
{$ENDIF}
end;

class operator TNauticalMilePerHourUnit./(const AValue: double; const ASelf: TNauticalMilePerHourUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cMeterPerSecond];
  result.FValue := AValue * 463/900;
{$ELSE}
  result := AValue * 463/900;
{$ENDIF}
end;

{$IFOPT D+}
class operator TNauticalMilePerHourUnit.*(const AValue: TQuantity; const ASelf: TNauticalMilePerHourUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[cScalar, cMeterPerSecond];
  result.FValue := AValue.FValue * 463/900;
end;
{$ENDIF}

{$IFOPT D+}
class operator TNauticalMilePerHourUnit./(const AValue: TQuantity; const ASelf: TNauticalMilePerHourUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[cScalar, cMeterPerSecond];
  result.FValue := AValue.FValue * 463/900;
end;
{$ENDIF}

class operator TMeterPerSquareSecondUnit.*(const AValue: double; const ASelf: TMeterPerSquareSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cMeterPerSquareSecond];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TMeterPerSquareSecondUnit./(const AValue: double; const ASelf: TMeterPerSquareSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cMeterPerSquareSecond];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TMeterPerSquareSecondUnit.*(const AValue: TQuantity; const ASelf: TMeterPerSquareSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cMeterPerSquareSecond];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TMeterPerSquareSecondUnit./(const AValue: TQuantity; const ASelf: TMeterPerSquareSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cMeterPerSquareSecond];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TMeterPerSecondPerSecondUnit.*(const AValue: double; const ASelf: TMeterPerSecondPerSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cMeterPerSquareSecond];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

class operator TMeterPerSecondPerSecondUnit./(const AValue: double; const ASelf: TMeterPerSecondPerSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cMeterPerSquareSecond];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

{$IFOPT D+}
class operator TMeterPerSecondPerSecondUnit.*(const AValue: TQuantity; const ASelf: TMeterPerSecondPerSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cMeterPerSquareSecond];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

{$IFOPT D+}
class operator TMeterPerSecondPerSecondUnit./(const AValue: TQuantity; const ASelf: TMeterPerSecondPerSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cMeterPerSquareSecond];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

class operator TMeterPerHourPerSecondUnit.*(const AValue: double; const ASelf: TMeterPerHourPerSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cMeterPerSquareSecond];
  result.FValue := AValue * 1/3600;
{$ELSE}
  result := AValue * 1/3600;
{$ENDIF}
end;

class operator TMeterPerHourPerSecondUnit./(const AValue: double; const ASelf: TMeterPerHourPerSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cMeterPerSquareSecond];
  result.FValue := AValue * 1/3600;
{$ELSE}
  result := AValue * 1/3600;
{$ENDIF}
end;

{$IFOPT D+}
class operator TMeterPerHourPerSecondUnit.*(const AValue: TQuantity; const ASelf: TMeterPerHourPerSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[cScalar, cMeterPerSquareSecond];
  result.FValue := AValue.FValue * 1/3600;
end;
{$ENDIF}

{$IFOPT D+}
class operator TMeterPerHourPerSecondUnit./(const AValue: TQuantity; const ASelf: TMeterPerHourPerSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[cScalar, cMeterPerSquareSecond];
  result.FValue := AValue.FValue * 1/3600;
end;
{$ENDIF}

class operator TMeterPerCubicSecondUnit.*(const AValue: double; const ASelf: TMeterPerCubicSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cMeterPerCubicSecond];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TMeterPerCubicSecondUnit./(const AValue: double; const ASelf: TMeterPerCubicSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cMeterPerCubicSecond];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TMeterPerCubicSecondUnit.*(const AValue: TQuantity; const ASelf: TMeterPerCubicSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cMeterPerCubicSecond];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TMeterPerCubicSecondUnit./(const AValue: TQuantity; const ASelf: TMeterPerCubicSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cMeterPerCubicSecond];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TMeterPerQuarticSecondUnit.*(const AValue: double; const ASelf: TMeterPerQuarticSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cMeterPerQuarticSecond];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TMeterPerQuarticSecondUnit./(const AValue: double; const ASelf: TMeterPerQuarticSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cMeterPerQuarticSecond];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TMeterPerQuarticSecondUnit.*(const AValue: TQuantity; const ASelf: TMeterPerQuarticSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cMeterPerQuarticSecond];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TMeterPerQuarticSecondUnit./(const AValue: TQuantity; const ASelf: TMeterPerQuarticSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cMeterPerQuarticSecond];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TMeterPerQuinticSecondUnit.*(const AValue: double; const ASelf: TMeterPerQuinticSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cMeterPerQuinticSecond];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TMeterPerQuinticSecondUnit./(const AValue: double; const ASelf: TMeterPerQuinticSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cMeterPerQuinticSecond];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TMeterPerQuinticSecondUnit.*(const AValue: TQuantity; const ASelf: TMeterPerQuinticSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cMeterPerQuinticSecond];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TMeterPerQuinticSecondUnit./(const AValue: TQuantity; const ASelf: TMeterPerQuinticSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cMeterPerQuinticSecond];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TMeterPerSexticSecondUnit.*(const AValue: double; const ASelf: TMeterPerSexticSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cMeterPerSexticSecond];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TMeterPerSexticSecondUnit./(const AValue: double; const ASelf: TMeterPerSexticSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cMeterPerSexticSecond];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TMeterPerSexticSecondUnit.*(const AValue: TQuantity; const ASelf: TMeterPerSexticSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cMeterPerSexticSecond];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TMeterPerSexticSecondUnit./(const AValue: TQuantity; const ASelf: TMeterPerSexticSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cMeterPerSexticSecond];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TSquareMeterPerSquareSecondUnit.*(const AValue: double; const ASelf: TSquareMeterPerSquareSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cSquareMeterPerSquareSecond];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TSquareMeterPerSquareSecondUnit./(const AValue: double; const ASelf: TSquareMeterPerSquareSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cSquareMeterPerSquareSecond];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TSquareMeterPerSquareSecondUnit.*(const AValue: TQuantity; const ASelf: TSquareMeterPerSquareSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cSquareMeterPerSquareSecond];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TSquareMeterPerSquareSecondUnit./(const AValue: TQuantity; const ASelf: TSquareMeterPerSquareSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cSquareMeterPerSquareSecond];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TJoulePerKilogramUnit.*(const AValue: double; const ASelf: TJoulePerKilogramUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cSquareMeterPerSquareSecond];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

class operator TJoulePerKilogramUnit./(const AValue: double; const ASelf: TJoulePerKilogramUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cSquareMeterPerSquareSecond];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

{$IFOPT D+}
class operator TJoulePerKilogramUnit.*(const AValue: TQuantity; const ASelf: TJoulePerKilogramUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cSquareMeterPerSquareSecond];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

{$IFOPT D+}
class operator TJoulePerKilogramUnit./(const AValue: TQuantity; const ASelf: TJoulePerKilogramUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cSquareMeterPerSquareSecond];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

class operator TGrayUnit.*(const AValue: double; const ASelf: TGrayUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cSquareMeterPerSquareSecond];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

class operator TGrayUnit./(const AValue: double; const ASelf: TGrayUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cSquareMeterPerSquareSecond];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

{$IFOPT D+}
class operator TGrayUnit.*(const AValue: TQuantity; const ASelf: TGrayUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cSquareMeterPerSquareSecond];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

{$IFOPT D+}
class operator TGrayUnit./(const AValue: TQuantity; const ASelf: TGrayUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cSquareMeterPerSquareSecond];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

class operator TSievertUnit.*(const AValue: double; const ASelf: TSievertUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cSquareMeterPerSquareSecond];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

class operator TSievertUnit./(const AValue: double; const ASelf: TSievertUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cSquareMeterPerSquareSecond];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

{$IFOPT D+}
class operator TSievertUnit.*(const AValue: TQuantity; const ASelf: TSievertUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cSquareMeterPerSquareSecond];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

{$IFOPT D+}
class operator TSievertUnit./(const AValue: TQuantity; const ASelf: TSievertUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cSquareMeterPerSquareSecond];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

class operator TMeterSecondUnit.*(const AValue: double; const ASelf: TMeterSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cMeterSecond];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TMeterSecondUnit./(const AValue: double; const ASelf: TMeterSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cMeterSecond];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TMeterSecondUnit.*(const AValue: TQuantity; const ASelf: TMeterSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cMeterSecond];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TMeterSecondUnit./(const AValue: TQuantity; const ASelf: TMeterSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cMeterSecond];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TKilogramMeterUnit.*(const AValue: double; const ASelf: TKilogramMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cKilogramMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TKilogramMeterUnit./(const AValue: double; const ASelf: TKilogramMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cKilogramMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TKilogramMeterUnit.*(const AValue: TQuantity; const ASelf: TKilogramMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cKilogramMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TKilogramMeterUnit./(const AValue: TQuantity; const ASelf: TKilogramMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cKilogramMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TKilogramPerSecondUnit.*(const AValue: double; const ASelf: TKilogramPerSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cKilogramPerSecond];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TKilogramPerSecondUnit./(const AValue: double; const ASelf: TKilogramPerSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cKilogramPerSecond];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TKilogramPerSecondUnit.*(const AValue: TQuantity; const ASelf: TKilogramPerSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cKilogramPerSecond];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TKilogramPerSecondUnit./(const AValue: TQuantity; const ASelf: TKilogramPerSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cKilogramPerSecond];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TJoulePerSquareMeterPerHertzUnit.*(const AValue: double; const ASelf: TJoulePerSquareMeterPerHertzUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cKilogramPerSecond];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

class operator TJoulePerSquareMeterPerHertzUnit./(const AValue: double; const ASelf: TJoulePerSquareMeterPerHertzUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cKilogramPerSecond];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

{$IFOPT D+}
class operator TJoulePerSquareMeterPerHertzUnit.*(const AValue: TQuantity; const ASelf: TJoulePerSquareMeterPerHertzUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cKilogramPerSecond];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

{$IFOPT D+}
class operator TJoulePerSquareMeterPerHertzUnit./(const AValue: TQuantity; const ASelf: TJoulePerSquareMeterPerHertzUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cKilogramPerSecond];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

class operator TKilogramMeterPerSecondUnit.*(const AValue: double; const ASelf: TKilogramMeterPerSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cKilogramMeterPerSecond];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TKilogramMeterPerSecondUnit./(const AValue: double; const ASelf: TKilogramMeterPerSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cKilogramMeterPerSecond];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TKilogramMeterPerSecondUnit.*(const AValue: TQuantity; const ASelf: TKilogramMeterPerSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cKilogramMeterPerSecond];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TKilogramMeterPerSecondUnit./(const AValue: TQuantity; const ASelf: TKilogramMeterPerSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cKilogramMeterPerSecond];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TNewtonSecondUnit.*(const AValue: double; const ASelf: TNewtonSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cKilogramMeterPerSecond];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

class operator TNewtonSecondUnit./(const AValue: double; const ASelf: TNewtonSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cKilogramMeterPerSecond];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

{$IFOPT D+}
class operator TNewtonSecondUnit.*(const AValue: TQuantity; const ASelf: TNewtonSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cKilogramMeterPerSecond];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

{$IFOPT D+}
class operator TNewtonSecondUnit./(const AValue: TQuantity; const ASelf: TNewtonSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cKilogramMeterPerSecond];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

class operator TSquareKilogramSquareMeterPerSquareSecondUnit.*(const AValue: double; const ASelf: TSquareKilogramSquareMeterPerSquareSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cSquareKilogramSquareMeterPerSquareSecond];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TSquareKilogramSquareMeterPerSquareSecondUnit./(const AValue: double; const ASelf: TSquareKilogramSquareMeterPerSquareSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cSquareKilogramSquareMeterPerSquareSecond];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TSquareKilogramSquareMeterPerSquareSecondUnit.*(const AValue: TQuantity; const ASelf: TSquareKilogramSquareMeterPerSquareSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cSquareKilogramSquareMeterPerSquareSecond];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TSquareKilogramSquareMeterPerSquareSecondUnit./(const AValue: TQuantity; const ASelf: TSquareKilogramSquareMeterPerSquareSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cSquareKilogramSquareMeterPerSquareSecond];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TReciprocalSquareRootMeterUnit.*(const AValue: double; const ASelf: TReciprocalSquareRootMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cReciprocalSquareRootMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TReciprocalSquareRootMeterUnit./(const AValue: double; const ASelf: TReciprocalSquareRootMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cReciprocalSquareRootMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TReciprocalSquareRootMeterUnit.*(const AValue: TQuantity; const ASelf: TReciprocalSquareRootMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cReciprocalSquareRootMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TReciprocalSquareRootMeterUnit./(const AValue: TQuantity; const ASelf: TReciprocalSquareRootMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cReciprocalSquareRootMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TReciprocalMeterUnit.*(const AValue: double; const ASelf: TReciprocalMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cReciprocalMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TReciprocalMeterUnit./(const AValue: double; const ASelf: TReciprocalMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cReciprocalMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TReciprocalMeterUnit.*(const AValue: TQuantity; const ASelf: TReciprocalMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cReciprocalMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TReciprocalMeterUnit./(const AValue: TQuantity; const ASelf: TReciprocalMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cReciprocalMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TDioptreUnit.*(const AValue: double; const ASelf: TDioptreUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cReciprocalMeter];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

class operator TDioptreUnit./(const AValue: double; const ASelf: TDioptreUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cReciprocalMeter];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

{$IFOPT D+}
class operator TDioptreUnit.*(const AValue: TQuantity; const ASelf: TDioptreUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cReciprocalMeter];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

{$IFOPT D+}
class operator TDioptreUnit./(const AValue: TQuantity; const ASelf: TDioptreUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cReciprocalMeter];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

class operator TReciprocalSquareRootCubicMeterUnit.*(const AValue: double; const ASelf: TReciprocalSquareRootCubicMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cReciprocalSquareRootCubicMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TReciprocalSquareRootCubicMeterUnit./(const AValue: double; const ASelf: TReciprocalSquareRootCubicMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cReciprocalSquareRootCubicMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TReciprocalSquareRootCubicMeterUnit.*(const AValue: TQuantity; const ASelf: TReciprocalSquareRootCubicMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cReciprocalSquareRootCubicMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TReciprocalSquareRootCubicMeterUnit./(const AValue: TQuantity; const ASelf: TReciprocalSquareRootCubicMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cReciprocalSquareRootCubicMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TReciprocalSquareMeterUnit.*(const AValue: double; const ASelf: TReciprocalSquareMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cReciprocalSquareMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TReciprocalSquareMeterUnit./(const AValue: double; const ASelf: TReciprocalSquareMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cReciprocalSquareMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TReciprocalSquareMeterUnit.*(const AValue: TQuantity; const ASelf: TReciprocalSquareMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cReciprocalSquareMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TReciprocalSquareMeterUnit./(const AValue: TQuantity; const ASelf: TReciprocalSquareMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cReciprocalSquareMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TReciprocalCubicMeterUnit.*(const AValue: double; const ASelf: TReciprocalCubicMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cReciprocalCubicMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TReciprocalCubicMeterUnit./(const AValue: double; const ASelf: TReciprocalCubicMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cReciprocalCubicMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TReciprocalCubicMeterUnit.*(const AValue: TQuantity; const ASelf: TReciprocalCubicMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cReciprocalCubicMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TReciprocalCubicMeterUnit./(const AValue: TQuantity; const ASelf: TReciprocalCubicMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cReciprocalCubicMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TReciprocalQuarticMeterUnit.*(const AValue: double; const ASelf: TReciprocalQuarticMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cReciprocalQuarticMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TReciprocalQuarticMeterUnit./(const AValue: double; const ASelf: TReciprocalQuarticMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cReciprocalQuarticMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TReciprocalQuarticMeterUnit.*(const AValue: TQuantity; const ASelf: TReciprocalQuarticMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cReciprocalQuarticMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TReciprocalQuarticMeterUnit./(const AValue: TQuantity; const ASelf: TReciprocalQuarticMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cReciprocalQuarticMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TKilogramSquareMeterUnit.*(const AValue: double; const ASelf: TKilogramSquareMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cKilogramSquareMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TKilogramSquareMeterUnit./(const AValue: double; const ASelf: TKilogramSquareMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cKilogramSquareMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TKilogramSquareMeterUnit.*(const AValue: TQuantity; const ASelf: TKilogramSquareMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cKilogramSquareMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TKilogramSquareMeterUnit./(const AValue: TQuantity; const ASelf: TKilogramSquareMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cKilogramSquareMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TKilogramSquareMeterPerSecondUnit.*(const AValue: double; const ASelf: TKilogramSquareMeterPerSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cKilogramSquareMeterPerSecond];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TKilogramSquareMeterPerSecondUnit./(const AValue: double; const ASelf: TKilogramSquareMeterPerSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cKilogramSquareMeterPerSecond];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TKilogramSquareMeterPerSecondUnit.*(const AValue: TQuantity; const ASelf: TKilogramSquareMeterPerSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cKilogramSquareMeterPerSecond];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TKilogramSquareMeterPerSecondUnit./(const AValue: TQuantity; const ASelf: TKilogramSquareMeterPerSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cKilogramSquareMeterPerSecond];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TNewtonMeterSecondUnit.*(const AValue: double; const ASelf: TNewtonMeterSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cKilogramSquareMeterPerSecond];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

class operator TNewtonMeterSecondUnit./(const AValue: double; const ASelf: TNewtonMeterSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cKilogramSquareMeterPerSecond];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

{$IFOPT D+}
class operator TNewtonMeterSecondUnit.*(const AValue: TQuantity; const ASelf: TNewtonMeterSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cKilogramSquareMeterPerSecond];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

{$IFOPT D+}
class operator TNewtonMeterSecondUnit./(const AValue: TQuantity; const ASelf: TNewtonMeterSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cKilogramSquareMeterPerSecond];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

class operator TSecondPerMeterUnit.*(const AValue: double; const ASelf: TSecondPerMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cSecondPerMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TSecondPerMeterUnit./(const AValue: double; const ASelf: TSecondPerMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cSecondPerMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TSecondPerMeterUnit.*(const AValue: TQuantity; const ASelf: TSecondPerMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cSecondPerMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TSecondPerMeterUnit./(const AValue: TQuantity; const ASelf: TSecondPerMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cSecondPerMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TKilogramPerMeterUnit.*(const AValue: double; const ASelf: TKilogramPerMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cKilogramPerMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TKilogramPerMeterUnit./(const AValue: double; const ASelf: TKilogramPerMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cKilogramPerMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TKilogramPerMeterUnit.*(const AValue: TQuantity; const ASelf: TKilogramPerMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cKilogramPerMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TKilogramPerMeterUnit./(const AValue: TQuantity; const ASelf: TKilogramPerMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cKilogramPerMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TKilogramPerSquareMeterUnit.*(const AValue: double; const ASelf: TKilogramPerSquareMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cKilogramPerSquareMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TKilogramPerSquareMeterUnit./(const AValue: double; const ASelf: TKilogramPerSquareMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cKilogramPerSquareMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TKilogramPerSquareMeterUnit.*(const AValue: TQuantity; const ASelf: TKilogramPerSquareMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cKilogramPerSquareMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TKilogramPerSquareMeterUnit./(const AValue: TQuantity; const ASelf: TKilogramPerSquareMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cKilogramPerSquareMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TKilogramPerCubicMeterUnit.*(const AValue: double; const ASelf: TKilogramPerCubicMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cKilogramPerCubicMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TKilogramPerCubicMeterUnit./(const AValue: double; const ASelf: TKilogramPerCubicMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cKilogramPerCubicMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TKilogramPerCubicMeterUnit.*(const AValue: TQuantity; const ASelf: TKilogramPerCubicMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cKilogramPerCubicMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TKilogramPerCubicMeterUnit./(const AValue: TQuantity; const ASelf: TKilogramPerCubicMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cKilogramPerCubicMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TPoundPerCubicInchUnit.*(const AValue: double; const ASelf: TPoundPerCubicInchUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cKilogramPerCubicMeter];
  result.FValue := AValue * 27679.9047102031;
{$ELSE}
  result := AValue * 27679.9047102031;
{$ENDIF}
end;

class operator TPoundPerCubicInchUnit./(const AValue: double; const ASelf: TPoundPerCubicInchUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cKilogramPerCubicMeter];
  result.FValue := AValue * 27679.9047102031;
{$ELSE}
  result := AValue * 27679.9047102031;
{$ENDIF}
end;

{$IFOPT D+}
class operator TPoundPerCubicInchUnit.*(const AValue: TQuantity; const ASelf: TPoundPerCubicInchUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[cScalar, cKilogramPerCubicMeter];
  result.FValue := AValue.FValue * 27679.9047102031;
end;
{$ENDIF}

{$IFOPT D+}
class operator TPoundPerCubicInchUnit./(const AValue: TQuantity; const ASelf: TPoundPerCubicInchUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[cScalar, cKilogramPerCubicMeter];
  result.FValue := AValue.FValue * 27679.9047102031;
end;
{$ENDIF}

class operator TNewtonUnit.*(const AValue: double; const ASelf: TNewtonUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cNewton];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TNewtonUnit./(const AValue: double; const ASelf: TNewtonUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cNewton];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TNewtonUnit.*(const AValue: TQuantity; const ASelf: TNewtonUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cNewton];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TNewtonUnit./(const AValue: TQuantity; const ASelf: TNewtonUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cNewton];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TPoundForceUnit.*(const AValue: double; const ASelf: TPoundForceUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cNewton];
  result.FValue := AValue * 4.4482216152605;
{$ELSE}
  result := AValue * 4.4482216152605;
{$ENDIF}
end;

class operator TPoundForceUnit./(const AValue: double; const ASelf: TPoundForceUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cNewton];
  result.FValue := AValue * 4.4482216152605;
{$ELSE}
  result := AValue * 4.4482216152605;
{$ENDIF}
end;

{$IFOPT D+}
class operator TPoundForceUnit.*(const AValue: TQuantity; const ASelf: TPoundForceUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[cScalar, cNewton];
  result.FValue := AValue.FValue * 4.4482216152605;
end;
{$ENDIF}

{$IFOPT D+}
class operator TPoundForceUnit./(const AValue: TQuantity; const ASelf: TPoundForceUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[cScalar, cNewton];
  result.FValue := AValue.FValue * 4.4482216152605;
end;
{$ENDIF}

class operator TKilogramMeterPerSquareSecondUnit.*(const AValue: double; const ASelf: TKilogramMeterPerSquareSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cNewton];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

class operator TKilogramMeterPerSquareSecondUnit./(const AValue: double; const ASelf: TKilogramMeterPerSquareSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cNewton];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

{$IFOPT D+}
class operator TKilogramMeterPerSquareSecondUnit.*(const AValue: TQuantity; const ASelf: TKilogramMeterPerSquareSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cNewton];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

{$IFOPT D+}
class operator TKilogramMeterPerSquareSecondUnit./(const AValue: TQuantity; const ASelf: TKilogramMeterPerSquareSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cNewton];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

class operator TNewtonRadianUnit.*(const AValue: double; const ASelf: TNewtonRadianUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cNewtonRadian];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TNewtonRadianUnit./(const AValue: double; const ASelf: TNewtonRadianUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cNewtonRadian];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TNewtonRadianUnit.*(const AValue: TQuantity; const ASelf: TNewtonRadianUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cNewtonRadian];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TNewtonRadianUnit./(const AValue: TQuantity; const ASelf: TNewtonRadianUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cNewtonRadian];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TSquareNewtonUnit.*(const AValue: double; const ASelf: TSquareNewtonUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cSquareNewton];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TSquareNewtonUnit./(const AValue: double; const ASelf: TSquareNewtonUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cSquareNewton];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TSquareNewtonUnit.*(const AValue: TQuantity; const ASelf: TSquareNewtonUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cSquareNewton];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TSquareNewtonUnit./(const AValue: TQuantity; const ASelf: TSquareNewtonUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cSquareNewton];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TSquareKilogramSquareMeterPerQuarticSecondUnit.*(const AValue: double; const ASelf: TSquareKilogramSquareMeterPerQuarticSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cSquareNewton];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

class operator TSquareKilogramSquareMeterPerQuarticSecondUnit./(const AValue: double; const ASelf: TSquareKilogramSquareMeterPerQuarticSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cSquareNewton];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

{$IFOPT D+}
class operator TSquareKilogramSquareMeterPerQuarticSecondUnit.*(const AValue: TQuantity; const ASelf: TSquareKilogramSquareMeterPerQuarticSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cSquareNewton];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

{$IFOPT D+}
class operator TSquareKilogramSquareMeterPerQuarticSecondUnit./(const AValue: TQuantity; const ASelf: TSquareKilogramSquareMeterPerQuarticSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cSquareNewton];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

class operator TPascalUnit.*(const AValue: double; const ASelf: TPascalUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cPascal];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TPascalUnit./(const AValue: double; const ASelf: TPascalUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cPascal];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TPascalUnit.*(const AValue: TQuantity; const ASelf: TPascalUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cPascal];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TPascalUnit./(const AValue: TQuantity; const ASelf: TPascalUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cPascal];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TNewtonPerSquareMeterUnit.*(const AValue: double; const ASelf: TNewtonPerSquareMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cPascal];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

class operator TNewtonPerSquareMeterUnit./(const AValue: double; const ASelf: TNewtonPerSquareMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cPascal];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

{$IFOPT D+}
class operator TNewtonPerSquareMeterUnit.*(const AValue: TQuantity; const ASelf: TNewtonPerSquareMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cPascal];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

{$IFOPT D+}
class operator TNewtonPerSquareMeterUnit./(const AValue: TQuantity; const ASelf: TNewtonPerSquareMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cPascal];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

class operator TBarUnit.*(const AValue: double; const ASelf: TBarUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cPascal];
  result.FValue := AValue * 1E+05;
{$ELSE}
  result := AValue * 1E+05;
{$ENDIF}
end;

class operator TBarUnit./(const AValue: double; const ASelf: TBarUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cPascal];
  result.FValue := AValue * 1E+05;
{$ELSE}
  result := AValue * 1E+05;
{$ENDIF}
end;

{$IFOPT D+}
class operator TBarUnit.*(const AValue: TQuantity; const ASelf: TBarUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[cScalar, cPascal];
  result.FValue := AValue.FValue * 1E+05;
end;
{$ENDIF}

{$IFOPT D+}
class operator TBarUnit./(const AValue: TQuantity; const ASelf: TBarUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[cScalar, cPascal];
  result.FValue := AValue.FValue * 1E+05;
end;
{$ENDIF}

class operator TPoundPerSquareInchUnit.*(const AValue: double; const ASelf: TPoundPerSquareInchUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cPascal];
  result.FValue := AValue * 6894.75729316836;
{$ELSE}
  result := AValue * 6894.75729316836;
{$ENDIF}
end;

class operator TPoundPerSquareInchUnit./(const AValue: double; const ASelf: TPoundPerSquareInchUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cPascal];
  result.FValue := AValue * 6894.75729316836;
{$ELSE}
  result := AValue * 6894.75729316836;
{$ENDIF}
end;

{$IFOPT D+}
class operator TPoundPerSquareInchUnit.*(const AValue: TQuantity; const ASelf: TPoundPerSquareInchUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[cScalar, cPascal];
  result.FValue := AValue.FValue * 6894.75729316836;
end;
{$ENDIF}

{$IFOPT D+}
class operator TPoundPerSquareInchUnit./(const AValue: TQuantity; const ASelf: TPoundPerSquareInchUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[cScalar, cPascal];
  result.FValue := AValue.FValue * 6894.75729316836;
end;
{$ENDIF}

class operator TJoulePerCubicMeterUnit.*(const AValue: double; const ASelf: TJoulePerCubicMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cPascal];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

class operator TJoulePerCubicMeterUnit./(const AValue: double; const ASelf: TJoulePerCubicMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cPascal];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

{$IFOPT D+}
class operator TJoulePerCubicMeterUnit.*(const AValue: TQuantity; const ASelf: TJoulePerCubicMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cPascal];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

{$IFOPT D+}
class operator TJoulePerCubicMeterUnit./(const AValue: TQuantity; const ASelf: TJoulePerCubicMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cPascal];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

class operator TKilogramPerMeterPerSquareSecondUnit.*(const AValue: double; const ASelf: TKilogramPerMeterPerSquareSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cPascal];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

class operator TKilogramPerMeterPerSquareSecondUnit./(const AValue: double; const ASelf: TKilogramPerMeterPerSquareSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cPascal];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

{$IFOPT D+}
class operator TKilogramPerMeterPerSquareSecondUnit.*(const AValue: TQuantity; const ASelf: TKilogramPerMeterPerSquareSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cPascal];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

{$IFOPT D+}
class operator TKilogramPerMeterPerSquareSecondUnit./(const AValue: TQuantity; const ASelf: TKilogramPerMeterPerSquareSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cPascal];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

class operator TJouleUnit.*(const AValue: double; const ASelf: TJouleUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cJoule];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TJouleUnit./(const AValue: double; const ASelf: TJouleUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cJoule];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TJouleUnit.*(const AValue: TQuantity; const ASelf: TJouleUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cJoule];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TJouleUnit./(const AValue: TQuantity; const ASelf: TJouleUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cJoule];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TWattHourUnit.*(const AValue: double; const ASelf: TWattHourUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cJoule];
  result.FValue := AValue * 3600;
{$ELSE}
  result := AValue * 3600;
{$ENDIF}
end;

class operator TWattHourUnit./(const AValue: double; const ASelf: TWattHourUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cJoule];
  result.FValue := AValue * 3600;
{$ELSE}
  result := AValue * 3600;
{$ENDIF}
end;

{$IFOPT D+}
class operator TWattHourUnit.*(const AValue: TQuantity; const ASelf: TWattHourUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[cScalar, cJoule];
  result.FValue := AValue.FValue * 3600;
end;
{$ENDIF}

{$IFOPT D+}
class operator TWattHourUnit./(const AValue: TQuantity; const ASelf: TWattHourUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[cScalar, cJoule];
  result.FValue := AValue.FValue * 3600;
end;
{$ENDIF}

class operator TWattSecondUnit.*(const AValue: double; const ASelf: TWattSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cJoule];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

class operator TWattSecondUnit./(const AValue: double; const ASelf: TWattSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cJoule];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

{$IFOPT D+}
class operator TWattSecondUnit.*(const AValue: TQuantity; const ASelf: TWattSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cJoule];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

{$IFOPT D+}
class operator TWattSecondUnit./(const AValue: TQuantity; const ASelf: TWattSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cJoule];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

class operator TWattPerHertzUnit.*(const AValue: double; const ASelf: TWattPerHertzUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cJoule];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

class operator TWattPerHertzUnit./(const AValue: double; const ASelf: TWattPerHertzUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cJoule];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

{$IFOPT D+}
class operator TWattPerHertzUnit.*(const AValue: TQuantity; const ASelf: TWattPerHertzUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cJoule];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

{$IFOPT D+}
class operator TWattPerHertzUnit./(const AValue: TQuantity; const ASelf: TWattPerHertzUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cJoule];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

class operator TElectronvoltUnit.*(const AValue: double; const ASelf: TElectronvoltUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cJoule];
  result.FValue := AValue * 1.602176634E-019;
{$ELSE}
  result := AValue * 1.602176634E-019;
{$ENDIF}
end;

class operator TElectronvoltUnit./(const AValue: double; const ASelf: TElectronvoltUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cJoule];
  result.FValue := AValue * 1.602176634E-019;
{$ELSE}
  result := AValue * 1.602176634E-019;
{$ENDIF}
end;

{$IFOPT D+}
class operator TElectronvoltUnit.*(const AValue: TQuantity; const ASelf: TElectronvoltUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[cScalar, cJoule];
  result.FValue := AValue.FValue * 1.602176634E-019;
end;
{$ENDIF}

{$IFOPT D+}
class operator TElectronvoltUnit./(const AValue: TQuantity; const ASelf: TElectronvoltUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[cScalar, cJoule];
  result.FValue := AValue.FValue * 1.602176634E-019;
end;
{$ENDIF}

class operator TNewtonMeterUnit.*(const AValue: double; const ASelf: TNewtonMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cJoule];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

class operator TNewtonMeterUnit./(const AValue: double; const ASelf: TNewtonMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cJoule];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

{$IFOPT D+}
class operator TNewtonMeterUnit.*(const AValue: TQuantity; const ASelf: TNewtonMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cJoule];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

{$IFOPT D+}
class operator TNewtonMeterUnit./(const AValue: TQuantity; const ASelf: TNewtonMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cJoule];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

class operator TPoundForceInchUnit.*(const AValue: double; const ASelf: TPoundForceInchUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cJoule];
  result.FValue := AValue * 0.112984829027617;
{$ELSE}
  result := AValue * 0.112984829027617;
{$ENDIF}
end;

class operator TPoundForceInchUnit./(const AValue: double; const ASelf: TPoundForceInchUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cJoule];
  result.FValue := AValue * 0.112984829027617;
{$ELSE}
  result := AValue * 0.112984829027617;
{$ENDIF}
end;

{$IFOPT D+}
class operator TPoundForceInchUnit.*(const AValue: TQuantity; const ASelf: TPoundForceInchUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[cScalar, cJoule];
  result.FValue := AValue.FValue * 0.112984829027617;
end;
{$ENDIF}

{$IFOPT D+}
class operator TPoundForceInchUnit./(const AValue: TQuantity; const ASelf: TPoundForceInchUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[cScalar, cJoule];
  result.FValue := AValue.FValue * 0.112984829027617;
end;
{$ENDIF}

class operator TRydbergUnit.*(const AValue: double; const ASelf: TRydbergUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cJoule];
  result.FValue := AValue * 2.1798723611035E-18;
{$ELSE}
  result := AValue * 2.1798723611035E-18;
{$ENDIF}
end;

class operator TRydbergUnit./(const AValue: double; const ASelf: TRydbergUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cJoule];
  result.FValue := AValue * 2.1798723611035E-18;
{$ELSE}
  result := AValue * 2.1798723611035E-18;
{$ENDIF}
end;

{$IFOPT D+}
class operator TRydbergUnit.*(const AValue: TQuantity; const ASelf: TRydbergUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[cScalar, cJoule];
  result.FValue := AValue.FValue * 2.1798723611035E-18;
end;
{$ENDIF}

{$IFOPT D+}
class operator TRydbergUnit./(const AValue: TQuantity; const ASelf: TRydbergUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[cScalar, cJoule];
  result.FValue := AValue.FValue * 2.1798723611035E-18;
end;
{$ENDIF}

class operator TCalorieUnit.*(const AValue: double; const ASelf: TCalorieUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cJoule];
  result.FValue := AValue * 4.184;
{$ELSE}
  result := AValue * 4.184;
{$ENDIF}
end;

class operator TCalorieUnit./(const AValue: double; const ASelf: TCalorieUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cJoule];
  result.FValue := AValue * 4.184;
{$ELSE}
  result := AValue * 4.184;
{$ENDIF}
end;

{$IFOPT D+}
class operator TCalorieUnit.*(const AValue: TQuantity; const ASelf: TCalorieUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[cScalar, cJoule];
  result.FValue := AValue.FValue * 4.184;
end;
{$ENDIF}

{$IFOPT D+}
class operator TCalorieUnit./(const AValue: TQuantity; const ASelf: TCalorieUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[cScalar, cJoule];
  result.FValue := AValue.FValue * 4.184;
end;
{$ENDIF}

class operator TKilogramSquareMeterPerSquareSecondUnit.*(const AValue: double; const ASelf: TKilogramSquareMeterPerSquareSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cJoule];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

class operator TKilogramSquareMeterPerSquareSecondUnit./(const AValue: double; const ASelf: TKilogramSquareMeterPerSquareSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cJoule];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

{$IFOPT D+}
class operator TKilogramSquareMeterPerSquareSecondUnit.*(const AValue: TQuantity; const ASelf: TKilogramSquareMeterPerSquareSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cJoule];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

{$IFOPT D+}
class operator TKilogramSquareMeterPerSquareSecondUnit./(const AValue: TQuantity; const ASelf: TKilogramSquareMeterPerSquareSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cJoule];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

class operator TJoulePerRadianUnit.*(const AValue: double; const ASelf: TJoulePerRadianUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cJoulePerRadian];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TJoulePerRadianUnit./(const AValue: double; const ASelf: TJoulePerRadianUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cJoulePerRadian];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TJoulePerRadianUnit.*(const AValue: TQuantity; const ASelf: TJoulePerRadianUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cJoulePerRadian];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TJoulePerRadianUnit./(const AValue: TQuantity; const ASelf: TJoulePerRadianUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cJoulePerRadian];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TJoulePerDegreeUnit.*(const AValue: double; const ASelf: TJoulePerDegreeUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cJoulePerRadian];
  result.FValue := AValue * 180/Pi;
{$ELSE}
  result := AValue * 180/Pi;
{$ENDIF}
end;

class operator TJoulePerDegreeUnit./(const AValue: double; const ASelf: TJoulePerDegreeUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cJoulePerRadian];
  result.FValue := AValue * 180/Pi;
{$ELSE}
  result := AValue * 180/Pi;
{$ENDIF}
end;

{$IFOPT D+}
class operator TJoulePerDegreeUnit.*(const AValue: TQuantity; const ASelf: TJoulePerDegreeUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[cScalar, cJoulePerRadian];
  result.FValue := AValue.FValue * 180/Pi;
end;
{$ENDIF}

{$IFOPT D+}
class operator TJoulePerDegreeUnit./(const AValue: TQuantity; const ASelf: TJoulePerDegreeUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[cScalar, cJoulePerRadian];
  result.FValue := AValue.FValue * 180/Pi;
end;
{$ENDIF}

class operator TNewtonMeterPerRadianUnit.*(const AValue: double; const ASelf: TNewtonMeterPerRadianUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cJoulePerRadian];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

class operator TNewtonMeterPerRadianUnit./(const AValue: double; const ASelf: TNewtonMeterPerRadianUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cJoulePerRadian];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

{$IFOPT D+}
class operator TNewtonMeterPerRadianUnit.*(const AValue: TQuantity; const ASelf: TNewtonMeterPerRadianUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cJoulePerRadian];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

{$IFOPT D+}
class operator TNewtonMeterPerRadianUnit./(const AValue: TQuantity; const ASelf: TNewtonMeterPerRadianUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cJoulePerRadian];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

class operator TNewtonMeterPerDegreeUnit.*(const AValue: double; const ASelf: TNewtonMeterPerDegreeUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cJoulePerRadian];
  result.FValue := AValue * 180/Pi;
{$ELSE}
  result := AValue * 180/Pi;
{$ENDIF}
end;

class operator TNewtonMeterPerDegreeUnit./(const AValue: double; const ASelf: TNewtonMeterPerDegreeUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cJoulePerRadian];
  result.FValue := AValue * 180/Pi;
{$ELSE}
  result := AValue * 180/Pi;
{$ENDIF}
end;

{$IFOPT D+}
class operator TNewtonMeterPerDegreeUnit.*(const AValue: TQuantity; const ASelf: TNewtonMeterPerDegreeUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[cScalar, cJoulePerRadian];
  result.FValue := AValue.FValue * 180/Pi;
end;
{$ENDIF}

{$IFOPT D+}
class operator TNewtonMeterPerDegreeUnit./(const AValue: TQuantity; const ASelf: TNewtonMeterPerDegreeUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[cScalar, cJoulePerRadian];
  result.FValue := AValue.FValue * 180/Pi;
end;
{$ENDIF}

class operator TKilogramSquareMeterPerSquareSecondPerRadianUnit.*(const AValue: double; const ASelf: TKilogramSquareMeterPerSquareSecondPerRadianUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cJoulePerRadian];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

class operator TKilogramSquareMeterPerSquareSecondPerRadianUnit./(const AValue: double; const ASelf: TKilogramSquareMeterPerSquareSecondPerRadianUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cJoulePerRadian];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

{$IFOPT D+}
class operator TKilogramSquareMeterPerSquareSecondPerRadianUnit.*(const AValue: TQuantity; const ASelf: TKilogramSquareMeterPerSquareSecondPerRadianUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cJoulePerRadian];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

{$IFOPT D+}
class operator TKilogramSquareMeterPerSquareSecondPerRadianUnit./(const AValue: TQuantity; const ASelf: TKilogramSquareMeterPerSquareSecondPerRadianUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cJoulePerRadian];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

class operator TWattUnit.*(const AValue: double; const ASelf: TWattUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cWatt];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TWattUnit./(const AValue: double; const ASelf: TWattUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cWatt];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TWattUnit.*(const AValue: TQuantity; const ASelf: TWattUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cWatt];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TWattUnit./(const AValue: TQuantity; const ASelf: TWattUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cWatt];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TKilogramSquareMeterPerCubicSecondUnit.*(const AValue: double; const ASelf: TKilogramSquareMeterPerCubicSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cWatt];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

class operator TKilogramSquareMeterPerCubicSecondUnit./(const AValue: double; const ASelf: TKilogramSquareMeterPerCubicSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cWatt];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

{$IFOPT D+}
class operator TKilogramSquareMeterPerCubicSecondUnit.*(const AValue: TQuantity; const ASelf: TKilogramSquareMeterPerCubicSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cWatt];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

{$IFOPT D+}
class operator TKilogramSquareMeterPerCubicSecondUnit./(const AValue: TQuantity; const ASelf: TKilogramSquareMeterPerCubicSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cWatt];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

class operator TCoulombUnit.*(const AValue: double; const ASelf: TCoulombUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cCoulomb];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TCoulombUnit./(const AValue: double; const ASelf: TCoulombUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cCoulomb];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TCoulombUnit.*(const AValue: TQuantity; const ASelf: TCoulombUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cCoulomb];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TCoulombUnit./(const AValue: TQuantity; const ASelf: TCoulombUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cCoulomb];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TAmpereHourUnit.*(const AValue: double; const ASelf: TAmpereHourUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cCoulomb];
  result.FValue := AValue * 3600;
{$ELSE}
  result := AValue * 3600;
{$ENDIF}
end;

class operator TAmpereHourUnit./(const AValue: double; const ASelf: TAmpereHourUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cCoulomb];
  result.FValue := AValue * 3600;
{$ELSE}
  result := AValue * 3600;
{$ENDIF}
end;

{$IFOPT D+}
class operator TAmpereHourUnit.*(const AValue: TQuantity; const ASelf: TAmpereHourUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[cScalar, cCoulomb];
  result.FValue := AValue.FValue * 3600;
end;
{$ENDIF}

{$IFOPT D+}
class operator TAmpereHourUnit./(const AValue: TQuantity; const ASelf: TAmpereHourUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[cScalar, cCoulomb];
  result.FValue := AValue.FValue * 3600;
end;
{$ENDIF}

class operator TAmpereSecondUnit.*(const AValue: double; const ASelf: TAmpereSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cCoulomb];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

class operator TAmpereSecondUnit./(const AValue: double; const ASelf: TAmpereSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cCoulomb];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

{$IFOPT D+}
class operator TAmpereSecondUnit.*(const AValue: TQuantity; const ASelf: TAmpereSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cCoulomb];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

{$IFOPT D+}
class operator TAmpereSecondUnit./(const AValue: TQuantity; const ASelf: TAmpereSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cCoulomb];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

class operator TSquareCoulombUnit.*(const AValue: double; const ASelf: TSquareCoulombUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cSquareCoulomb];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TSquareCoulombUnit./(const AValue: double; const ASelf: TSquareCoulombUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cSquareCoulomb];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TSquareCoulombUnit.*(const AValue: TQuantity; const ASelf: TSquareCoulombUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cSquareCoulomb];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TSquareCoulombUnit./(const AValue: TQuantity; const ASelf: TSquareCoulombUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cSquareCoulomb];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TSquareAmpereSquareSecondUnit.*(const AValue: double; const ASelf: TSquareAmpereSquareSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cSquareCoulomb];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

class operator TSquareAmpereSquareSecondUnit./(const AValue: double; const ASelf: TSquareAmpereSquareSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cSquareCoulomb];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

{$IFOPT D+}
class operator TSquareAmpereSquareSecondUnit.*(const AValue: TQuantity; const ASelf: TSquareAmpereSquareSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cSquareCoulomb];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

{$IFOPT D+}
class operator TSquareAmpereSquareSecondUnit./(const AValue: TQuantity; const ASelf: TSquareAmpereSquareSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cSquareCoulomb];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

class operator TCoulombMeterUnit.*(const AValue: double; const ASelf: TCoulombMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cCoulombMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TCoulombMeterUnit./(const AValue: double; const ASelf: TCoulombMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cCoulombMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TCoulombMeterUnit.*(const AValue: TQuantity; const ASelf: TCoulombMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cCoulombMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TCoulombMeterUnit./(const AValue: TQuantity; const ASelf: TCoulombMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cCoulombMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TVoltUnit.*(const AValue: double; const ASelf: TVoltUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cVolt];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TVoltUnit./(const AValue: double; const ASelf: TVoltUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cVolt];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TVoltUnit.*(const AValue: TQuantity; const ASelf: TVoltUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cVolt];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TVoltUnit./(const AValue: TQuantity; const ASelf: TVoltUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cVolt];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TJoulePerCoulombUnit.*(const AValue: double; const ASelf: TJoulePerCoulombUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cVolt];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

class operator TJoulePerCoulombUnit./(const AValue: double; const ASelf: TJoulePerCoulombUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cVolt];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

{$IFOPT D+}
class operator TJoulePerCoulombUnit.*(const AValue: TQuantity; const ASelf: TJoulePerCoulombUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cVolt];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

{$IFOPT D+}
class operator TJoulePerCoulombUnit./(const AValue: TQuantity; const ASelf: TJoulePerCoulombUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cVolt];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

class operator TKilogramSquareMeterPerAmperePerCubicSecondUnit.*(const AValue: double; const ASelf: TKilogramSquareMeterPerAmperePerCubicSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cVolt];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

class operator TKilogramSquareMeterPerAmperePerCubicSecondUnit./(const AValue: double; const ASelf: TKilogramSquareMeterPerAmperePerCubicSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cVolt];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

{$IFOPT D+}
class operator TKilogramSquareMeterPerAmperePerCubicSecondUnit.*(const AValue: TQuantity; const ASelf: TKilogramSquareMeterPerAmperePerCubicSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cVolt];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

{$IFOPT D+}
class operator TKilogramSquareMeterPerAmperePerCubicSecondUnit./(const AValue: TQuantity; const ASelf: TKilogramSquareMeterPerAmperePerCubicSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cVolt];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

class operator TSquareVoltUnit.*(const AValue: double; const ASelf: TSquareVoltUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cSquareVolt];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TSquareVoltUnit./(const AValue: double; const ASelf: TSquareVoltUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cSquareVolt];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TSquareVoltUnit.*(const AValue: TQuantity; const ASelf: TSquareVoltUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cSquareVolt];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TSquareVoltUnit./(const AValue: TQuantity; const ASelf: TSquareVoltUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cSquareVolt];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TSquareKilogramQuarticMeterPerSquareAmperePerSexticSecondUnit.*(const AValue: double; const ASelf: TSquareKilogramQuarticMeterPerSquareAmperePerSexticSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cSquareVolt];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

class operator TSquareKilogramQuarticMeterPerSquareAmperePerSexticSecondUnit./(const AValue: double; const ASelf: TSquareKilogramQuarticMeterPerSquareAmperePerSexticSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cSquareVolt];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

{$IFOPT D+}
class operator TSquareKilogramQuarticMeterPerSquareAmperePerSexticSecondUnit.*(const AValue: TQuantity; const ASelf: TSquareKilogramQuarticMeterPerSquareAmperePerSexticSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cSquareVolt];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

{$IFOPT D+}
class operator TSquareKilogramQuarticMeterPerSquareAmperePerSexticSecondUnit./(const AValue: TQuantity; const ASelf: TSquareKilogramQuarticMeterPerSquareAmperePerSexticSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cSquareVolt];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

class operator TFaradUnit.*(const AValue: double; const ASelf: TFaradUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cFarad];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TFaradUnit./(const AValue: double; const ASelf: TFaradUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cFarad];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TFaradUnit.*(const AValue: TQuantity; const ASelf: TFaradUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cFarad];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TFaradUnit./(const AValue: TQuantity; const ASelf: TFaradUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cFarad];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TCoulombPerVoltUnit.*(const AValue: double; const ASelf: TCoulombPerVoltUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cFarad];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

class operator TCoulombPerVoltUnit./(const AValue: double; const ASelf: TCoulombPerVoltUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cFarad];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

{$IFOPT D+}
class operator TCoulombPerVoltUnit.*(const AValue: TQuantity; const ASelf: TCoulombPerVoltUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cFarad];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

{$IFOPT D+}
class operator TCoulombPerVoltUnit./(const AValue: TQuantity; const ASelf: TCoulombPerVoltUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cFarad];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

class operator TSquareAmpereQuarticSecondPerKilogramPerSquareMeterUnit.*(const AValue: double; const ASelf: TSquareAmpereQuarticSecondPerKilogramPerSquareMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cFarad];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

class operator TSquareAmpereQuarticSecondPerKilogramPerSquareMeterUnit./(const AValue: double; const ASelf: TSquareAmpereQuarticSecondPerKilogramPerSquareMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cFarad];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

{$IFOPT D+}
class operator TSquareAmpereQuarticSecondPerKilogramPerSquareMeterUnit.*(const AValue: TQuantity; const ASelf: TSquareAmpereQuarticSecondPerKilogramPerSquareMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cFarad];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

{$IFOPT D+}
class operator TSquareAmpereQuarticSecondPerKilogramPerSquareMeterUnit./(const AValue: TQuantity; const ASelf: TSquareAmpereQuarticSecondPerKilogramPerSquareMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cFarad];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

class operator TOhmUnit.*(const AValue: double; const ASelf: TOhmUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cOhm];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TOhmUnit./(const AValue: double; const ASelf: TOhmUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cOhm];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TOhmUnit.*(const AValue: TQuantity; const ASelf: TOhmUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cOhm];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TOhmUnit./(const AValue: TQuantity; const ASelf: TOhmUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cOhm];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TKilogramSquareMeterPerSquareAmperePerCubicSecondUnit.*(const AValue: double; const ASelf: TKilogramSquareMeterPerSquareAmperePerCubicSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cOhm];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

class operator TKilogramSquareMeterPerSquareAmperePerCubicSecondUnit./(const AValue: double; const ASelf: TKilogramSquareMeterPerSquareAmperePerCubicSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cOhm];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

{$IFOPT D+}
class operator TKilogramSquareMeterPerSquareAmperePerCubicSecondUnit.*(const AValue: TQuantity; const ASelf: TKilogramSquareMeterPerSquareAmperePerCubicSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cOhm];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

{$IFOPT D+}
class operator TKilogramSquareMeterPerSquareAmperePerCubicSecondUnit./(const AValue: TQuantity; const ASelf: TKilogramSquareMeterPerSquareAmperePerCubicSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cOhm];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

class operator TSiemensUnit.*(const AValue: double; const ASelf: TSiemensUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cSiemens];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TSiemensUnit./(const AValue: double; const ASelf: TSiemensUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cSiemens];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TSiemensUnit.*(const AValue: TQuantity; const ASelf: TSiemensUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cSiemens];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TSiemensUnit./(const AValue: TQuantity; const ASelf: TSiemensUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cSiemens];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TSquareAmpereCubicSecondPerKilogramPerSquareMeterUnit.*(const AValue: double; const ASelf: TSquareAmpereCubicSecondPerKilogramPerSquareMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cSiemens];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

class operator TSquareAmpereCubicSecondPerKilogramPerSquareMeterUnit./(const AValue: double; const ASelf: TSquareAmpereCubicSecondPerKilogramPerSquareMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cSiemens];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

{$IFOPT D+}
class operator TSquareAmpereCubicSecondPerKilogramPerSquareMeterUnit.*(const AValue: TQuantity; const ASelf: TSquareAmpereCubicSecondPerKilogramPerSquareMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cSiemens];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

{$IFOPT D+}
class operator TSquareAmpereCubicSecondPerKilogramPerSquareMeterUnit./(const AValue: TQuantity; const ASelf: TSquareAmpereCubicSecondPerKilogramPerSquareMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cSiemens];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

class operator TSiemensPerMeterUnit.*(const AValue: double; const ASelf: TSiemensPerMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cSiemensPerMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TSiemensPerMeterUnit./(const AValue: double; const ASelf: TSiemensPerMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cSiemensPerMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TSiemensPerMeterUnit.*(const AValue: TQuantity; const ASelf: TSiemensPerMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cSiemensPerMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TSiemensPerMeterUnit./(const AValue: TQuantity; const ASelf: TSiemensPerMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cSiemensPerMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TTeslaUnit.*(const AValue: double; const ASelf: TTeslaUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cTesla];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TTeslaUnit./(const AValue: double; const ASelf: TTeslaUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cTesla];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TTeslaUnit.*(const AValue: TQuantity; const ASelf: TTeslaUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cTesla];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TTeslaUnit./(const AValue: TQuantity; const ASelf: TTeslaUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cTesla];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TWeberPerSquareMeterUnit.*(const AValue: double; const ASelf: TWeberPerSquareMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cTesla];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

class operator TWeberPerSquareMeterUnit./(const AValue: double; const ASelf: TWeberPerSquareMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cTesla];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

{$IFOPT D+}
class operator TWeberPerSquareMeterUnit.*(const AValue: TQuantity; const ASelf: TWeberPerSquareMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cTesla];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

{$IFOPT D+}
class operator TWeberPerSquareMeterUnit./(const AValue: TQuantity; const ASelf: TWeberPerSquareMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cTesla];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

class operator TKilogramPerAmperePerSquareSecondUnit.*(const AValue: double; const ASelf: TKilogramPerAmperePerSquareSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cTesla];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

class operator TKilogramPerAmperePerSquareSecondUnit./(const AValue: double; const ASelf: TKilogramPerAmperePerSquareSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cTesla];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

{$IFOPT D+}
class operator TKilogramPerAmperePerSquareSecondUnit.*(const AValue: TQuantity; const ASelf: TKilogramPerAmperePerSquareSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cTesla];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

{$IFOPT D+}
class operator TKilogramPerAmperePerSquareSecondUnit./(const AValue: TQuantity; const ASelf: TKilogramPerAmperePerSquareSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cTesla];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

class operator TWeberUnit.*(const AValue: double; const ASelf: TWeberUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cWeber];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TWeberUnit./(const AValue: double; const ASelf: TWeberUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cWeber];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TWeberUnit.*(const AValue: TQuantity; const ASelf: TWeberUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cWeber];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TWeberUnit./(const AValue: TQuantity; const ASelf: TWeberUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cWeber];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TKilogramSquareMeterPerAmperePerSquareSecondUnit.*(const AValue: double; const ASelf: TKilogramSquareMeterPerAmperePerSquareSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cWeber];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

class operator TKilogramSquareMeterPerAmperePerSquareSecondUnit./(const AValue: double; const ASelf: TKilogramSquareMeterPerAmperePerSquareSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cWeber];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

{$IFOPT D+}
class operator TKilogramSquareMeterPerAmperePerSquareSecondUnit.*(const AValue: TQuantity; const ASelf: TKilogramSquareMeterPerAmperePerSquareSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cWeber];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

{$IFOPT D+}
class operator TKilogramSquareMeterPerAmperePerSquareSecondUnit./(const AValue: TQuantity; const ASelf: TKilogramSquareMeterPerAmperePerSquareSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cWeber];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

class operator THenryUnit.*(const AValue: double; const ASelf: THenryUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cHenry];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator THenryUnit./(const AValue: double; const ASelf: THenryUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cHenry];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator THenryUnit.*(const AValue: TQuantity; const ASelf: THenryUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cHenry];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator THenryUnit./(const AValue: TQuantity; const ASelf: THenryUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cHenry];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TKilogramSquareMeterPerSquareAmperePerSquareSecondUnit.*(const AValue: double; const ASelf: TKilogramSquareMeterPerSquareAmperePerSquareSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cHenry];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

class operator TKilogramSquareMeterPerSquareAmperePerSquareSecondUnit./(const AValue: double; const ASelf: TKilogramSquareMeterPerSquareAmperePerSquareSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cHenry];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

{$IFOPT D+}
class operator TKilogramSquareMeterPerSquareAmperePerSquareSecondUnit.*(const AValue: TQuantity; const ASelf: TKilogramSquareMeterPerSquareAmperePerSquareSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cHenry];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

{$IFOPT D+}
class operator TKilogramSquareMeterPerSquareAmperePerSquareSecondUnit./(const AValue: TQuantity; const ASelf: TKilogramSquareMeterPerSquareAmperePerSquareSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cHenry];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

class operator TReciprocalHenryUnit.*(const AValue: double; const ASelf: TReciprocalHenryUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cReciprocalHenry];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TReciprocalHenryUnit./(const AValue: double; const ASelf: TReciprocalHenryUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cReciprocalHenry];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TReciprocalHenryUnit.*(const AValue: TQuantity; const ASelf: TReciprocalHenryUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cReciprocalHenry];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TReciprocalHenryUnit./(const AValue: TQuantity; const ASelf: TReciprocalHenryUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cReciprocalHenry];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TLumenUnit.*(const AValue: double; const ASelf: TLumenUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cLumen];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TLumenUnit./(const AValue: double; const ASelf: TLumenUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cLumen];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TLumenUnit.*(const AValue: TQuantity; const ASelf: TLumenUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cLumen];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TLumenUnit./(const AValue: TQuantity; const ASelf: TLumenUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cLumen];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TCandelaSteradianUnit.*(const AValue: double; const ASelf: TCandelaSteradianUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cLumen];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

class operator TCandelaSteradianUnit./(const AValue: double; const ASelf: TCandelaSteradianUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cLumen];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

{$IFOPT D+}
class operator TCandelaSteradianUnit.*(const AValue: TQuantity; const ASelf: TCandelaSteradianUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cLumen];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

{$IFOPT D+}
class operator TCandelaSteradianUnit./(const AValue: TQuantity; const ASelf: TCandelaSteradianUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cLumen];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

class operator TLumenSecondUnit.*(const AValue: double; const ASelf: TLumenSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cLumenSecond];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TLumenSecondUnit./(const AValue: double; const ASelf: TLumenSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cLumenSecond];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TLumenSecondUnit.*(const AValue: TQuantity; const ASelf: TLumenSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cLumenSecond];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TLumenSecondUnit./(const AValue: TQuantity; const ASelf: TLumenSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cLumenSecond];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TLumenSecondPerCubicMeterUnit.*(const AValue: double; const ASelf: TLumenSecondPerCubicMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cLumenSecondPerCubicMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TLumenSecondPerCubicMeterUnit./(const AValue: double; const ASelf: TLumenSecondPerCubicMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cLumenSecondPerCubicMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TLumenSecondPerCubicMeterUnit.*(const AValue: TQuantity; const ASelf: TLumenSecondPerCubicMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cLumenSecondPerCubicMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TLumenSecondPerCubicMeterUnit./(const AValue: TQuantity; const ASelf: TLumenSecondPerCubicMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cLumenSecondPerCubicMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TLuxUnit.*(const AValue: double; const ASelf: TLuxUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cLux];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TLuxUnit./(const AValue: double; const ASelf: TLuxUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cLux];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TLuxUnit.*(const AValue: TQuantity; const ASelf: TLuxUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cLux];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TLuxUnit./(const AValue: TQuantity; const ASelf: TLuxUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cLux];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TCandelaSteradianPerSquareMeterUnit.*(const AValue: double; const ASelf: TCandelaSteradianPerSquareMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cLux];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

class operator TCandelaSteradianPerSquareMeterUnit./(const AValue: double; const ASelf: TCandelaSteradianPerSquareMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cLux];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

{$IFOPT D+}
class operator TCandelaSteradianPerSquareMeterUnit.*(const AValue: TQuantity; const ASelf: TCandelaSteradianPerSquareMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cLux];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

{$IFOPT D+}
class operator TCandelaSteradianPerSquareMeterUnit./(const AValue: TQuantity; const ASelf: TCandelaSteradianPerSquareMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cLux];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

class operator TLuxSecondUnit.*(const AValue: double; const ASelf: TLuxSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cLuxSecond];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TLuxSecondUnit./(const AValue: double; const ASelf: TLuxSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cLuxSecond];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TLuxSecondUnit.*(const AValue: TQuantity; const ASelf: TLuxSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cLuxSecond];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TLuxSecondUnit./(const AValue: TQuantity; const ASelf: TLuxSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cLuxSecond];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TBequerelUnit.*(const AValue: double; const ASelf: TBequerelUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cHertz];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

class operator TBequerelUnit./(const AValue: double; const ASelf: TBequerelUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cHertz];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

{$IFOPT D+}
class operator TBequerelUnit.*(const AValue: TQuantity; const ASelf: TBequerelUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cHertz];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

{$IFOPT D+}
class operator TBequerelUnit./(const AValue: TQuantity; const ASelf: TBequerelUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cHertz];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

class operator TKatalUnit.*(const AValue: double; const ASelf: TKatalUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cKatal];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TKatalUnit./(const AValue: double; const ASelf: TKatalUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cKatal];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TKatalUnit.*(const AValue: TQuantity; const ASelf: TKatalUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cKatal];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TKatalUnit./(const AValue: TQuantity; const ASelf: TKatalUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cKatal];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TMolePerSecondUnit.*(const AValue: double; const ASelf: TMolePerSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cKatal];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

class operator TMolePerSecondUnit./(const AValue: double; const ASelf: TMolePerSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cKatal];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

{$IFOPT D+}
class operator TMolePerSecondUnit.*(const AValue: TQuantity; const ASelf: TMolePerSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cKatal];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

{$IFOPT D+}
class operator TMolePerSecondUnit./(const AValue: TQuantity; const ASelf: TMolePerSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cKatal];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

class operator TNewtonPerCubicMeterUnit.*(const AValue: double; const ASelf: TNewtonPerCubicMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cNewtonPerCubicMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TNewtonPerCubicMeterUnit./(const AValue: double; const ASelf: TNewtonPerCubicMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cNewtonPerCubicMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TNewtonPerCubicMeterUnit.*(const AValue: TQuantity; const ASelf: TNewtonPerCubicMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cNewtonPerCubicMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TNewtonPerCubicMeterUnit./(const AValue: TQuantity; const ASelf: TNewtonPerCubicMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cNewtonPerCubicMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TPascalPerMeterUnit.*(const AValue: double; const ASelf: TPascalPerMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cNewtonPerCubicMeter];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

class operator TPascalPerMeterUnit./(const AValue: double; const ASelf: TPascalPerMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cNewtonPerCubicMeter];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

{$IFOPT D+}
class operator TPascalPerMeterUnit.*(const AValue: TQuantity; const ASelf: TPascalPerMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cNewtonPerCubicMeter];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

{$IFOPT D+}
class operator TPascalPerMeterUnit./(const AValue: TQuantity; const ASelf: TPascalPerMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cNewtonPerCubicMeter];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

class operator TKilogramPerSquareMeterPerSquareSecondUnit.*(const AValue: double; const ASelf: TKilogramPerSquareMeterPerSquareSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cNewtonPerCubicMeter];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

class operator TKilogramPerSquareMeterPerSquareSecondUnit./(const AValue: double; const ASelf: TKilogramPerSquareMeterPerSquareSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cNewtonPerCubicMeter];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

{$IFOPT D+}
class operator TKilogramPerSquareMeterPerSquareSecondUnit.*(const AValue: TQuantity; const ASelf: TKilogramPerSquareMeterPerSquareSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cNewtonPerCubicMeter];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

{$IFOPT D+}
class operator TKilogramPerSquareMeterPerSquareSecondUnit./(const AValue: TQuantity; const ASelf: TKilogramPerSquareMeterPerSquareSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cNewtonPerCubicMeter];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

class operator TNewtonPerMeterUnit.*(const AValue: double; const ASelf: TNewtonPerMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cNewtonPerMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TNewtonPerMeterUnit./(const AValue: double; const ASelf: TNewtonPerMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cNewtonPerMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TNewtonPerMeterUnit.*(const AValue: TQuantity; const ASelf: TNewtonPerMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cNewtonPerMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TNewtonPerMeterUnit./(const AValue: TQuantity; const ASelf: TNewtonPerMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cNewtonPerMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TJoulePerSquareMeterUnit.*(const AValue: double; const ASelf: TJoulePerSquareMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cNewtonPerMeter];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

class operator TJoulePerSquareMeterUnit./(const AValue: double; const ASelf: TJoulePerSquareMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cNewtonPerMeter];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

{$IFOPT D+}
class operator TJoulePerSquareMeterUnit.*(const AValue: TQuantity; const ASelf: TJoulePerSquareMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cNewtonPerMeter];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

{$IFOPT D+}
class operator TJoulePerSquareMeterUnit./(const AValue: TQuantity; const ASelf: TJoulePerSquareMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cNewtonPerMeter];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

class operator TWattPerSquareMeterPerHertzUnit.*(const AValue: double; const ASelf: TWattPerSquareMeterPerHertzUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cNewtonPerMeter];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

class operator TWattPerSquareMeterPerHertzUnit./(const AValue: double; const ASelf: TWattPerSquareMeterPerHertzUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cNewtonPerMeter];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

{$IFOPT D+}
class operator TWattPerSquareMeterPerHertzUnit.*(const AValue: TQuantity; const ASelf: TWattPerSquareMeterPerHertzUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cNewtonPerMeter];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

{$IFOPT D+}
class operator TWattPerSquareMeterPerHertzUnit./(const AValue: TQuantity; const ASelf: TWattPerSquareMeterPerHertzUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cNewtonPerMeter];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

class operator TPoundForcePerInchUnit.*(const AValue: double; const ASelf: TPoundForcePerInchUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cNewtonPerMeter];
  result.FValue := AValue * 175.126835246476;
{$ELSE}
  result := AValue * 175.126835246476;
{$ENDIF}
end;

class operator TPoundForcePerInchUnit./(const AValue: double; const ASelf: TPoundForcePerInchUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cNewtonPerMeter];
  result.FValue := AValue * 175.126835246476;
{$ELSE}
  result := AValue * 175.126835246476;
{$ENDIF}
end;

{$IFOPT D+}
class operator TPoundForcePerInchUnit.*(const AValue: TQuantity; const ASelf: TPoundForcePerInchUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[cScalar, cNewtonPerMeter];
  result.FValue := AValue.FValue * 175.126835246476;
end;
{$ENDIF}

{$IFOPT D+}
class operator TPoundForcePerInchUnit./(const AValue: TQuantity; const ASelf: TPoundForcePerInchUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[cScalar, cNewtonPerMeter];
  result.FValue := AValue.FValue * 175.126835246476;
end;
{$ENDIF}

class operator TKilogramPerSquareSecondUnit.*(const AValue: double; const ASelf: TKilogramPerSquareSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cNewtonPerMeter];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

class operator TKilogramPerSquareSecondUnit./(const AValue: double; const ASelf: TKilogramPerSquareSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cNewtonPerMeter];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

{$IFOPT D+}
class operator TKilogramPerSquareSecondUnit.*(const AValue: TQuantity; const ASelf: TKilogramPerSquareSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cNewtonPerMeter];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

{$IFOPT D+}
class operator TKilogramPerSquareSecondUnit./(const AValue: TQuantity; const ASelf: TKilogramPerSquareSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cNewtonPerMeter];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

class operator TCubicMeterPerSecondUnit.*(const AValue: double; const ASelf: TCubicMeterPerSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cCubicMeterPerSecond];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TCubicMeterPerSecondUnit./(const AValue: double; const ASelf: TCubicMeterPerSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cCubicMeterPerSecond];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TCubicMeterPerSecondUnit.*(const AValue: TQuantity; const ASelf: TCubicMeterPerSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cCubicMeterPerSecond];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TCubicMeterPerSecondUnit./(const AValue: TQuantity; const ASelf: TCubicMeterPerSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cCubicMeterPerSecond];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TPoiseuilleUnit.*(const AValue: double; const ASelf: TPoiseuilleUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cPoiseuille];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TPoiseuilleUnit./(const AValue: double; const ASelf: TPoiseuilleUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cPoiseuille];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TPoiseuilleUnit.*(const AValue: TQuantity; const ASelf: TPoiseuilleUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cPoiseuille];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TPoiseuilleUnit./(const AValue: TQuantity; const ASelf: TPoiseuilleUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cPoiseuille];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TPascalSecondUnit.*(const AValue: double; const ASelf: TPascalSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cPoiseuille];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

class operator TPascalSecondUnit./(const AValue: double; const ASelf: TPascalSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cPoiseuille];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

{$IFOPT D+}
class operator TPascalSecondUnit.*(const AValue: TQuantity; const ASelf: TPascalSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cPoiseuille];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

{$IFOPT D+}
class operator TPascalSecondUnit./(const AValue: TQuantity; const ASelf: TPascalSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cPoiseuille];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

class operator TKilogramPerMeterPerSecondUnit.*(const AValue: double; const ASelf: TKilogramPerMeterPerSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cPoiseuille];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

class operator TKilogramPerMeterPerSecondUnit./(const AValue: double; const ASelf: TKilogramPerMeterPerSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cPoiseuille];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

{$IFOPT D+}
class operator TKilogramPerMeterPerSecondUnit.*(const AValue: TQuantity; const ASelf: TKilogramPerMeterPerSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cPoiseuille];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

{$IFOPT D+}
class operator TKilogramPerMeterPerSecondUnit./(const AValue: TQuantity; const ASelf: TKilogramPerMeterPerSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cPoiseuille];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

class operator TSquareMeterPerSecondUnit.*(const AValue: double; const ASelf: TSquareMeterPerSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cSquareMeterPerSecond];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TSquareMeterPerSecondUnit./(const AValue: double; const ASelf: TSquareMeterPerSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cSquareMeterPerSecond];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TSquareMeterPerSecondUnit.*(const AValue: TQuantity; const ASelf: TSquareMeterPerSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cSquareMeterPerSecond];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TSquareMeterPerSecondUnit./(const AValue: TQuantity; const ASelf: TSquareMeterPerSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cSquareMeterPerSecond];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TKilogramPerQuarticMeterUnit.*(const AValue: double; const ASelf: TKilogramPerQuarticMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cKilogramPerQuarticMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TKilogramPerQuarticMeterUnit./(const AValue: double; const ASelf: TKilogramPerQuarticMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cKilogramPerQuarticMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TKilogramPerQuarticMeterUnit.*(const AValue: TQuantity; const ASelf: TKilogramPerQuarticMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cKilogramPerQuarticMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TKilogramPerQuarticMeterUnit./(const AValue: TQuantity; const ASelf: TKilogramPerQuarticMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cKilogramPerQuarticMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TQuarticMeterSecondUnit.*(const AValue: double; const ASelf: TQuarticMeterSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cQuarticMeterSecond];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TQuarticMeterSecondUnit./(const AValue: double; const ASelf: TQuarticMeterSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cQuarticMeterSecond];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TQuarticMeterSecondUnit.*(const AValue: TQuantity; const ASelf: TQuarticMeterSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cQuarticMeterSecond];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TQuarticMeterSecondUnit./(const AValue: TQuantity; const ASelf: TQuarticMeterSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cQuarticMeterSecond];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TKilogramPerQuarticMeterPerSecondUnit.*(const AValue: double; const ASelf: TKilogramPerQuarticMeterPerSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cKilogramPerQuarticMeterPerSecond];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TKilogramPerQuarticMeterPerSecondUnit./(const AValue: double; const ASelf: TKilogramPerQuarticMeterPerSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cKilogramPerQuarticMeterPerSecond];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TKilogramPerQuarticMeterPerSecondUnit.*(const AValue: TQuantity; const ASelf: TKilogramPerQuarticMeterPerSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cKilogramPerQuarticMeterPerSecond];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TKilogramPerQuarticMeterPerSecondUnit./(const AValue: TQuantity; const ASelf: TKilogramPerQuarticMeterPerSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cKilogramPerQuarticMeterPerSecond];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TCubicMeterPerKilogramUnit.*(const AValue: double; const ASelf: TCubicMeterPerKilogramUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cCubicMeterPerKilogram];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TCubicMeterPerKilogramUnit./(const AValue: double; const ASelf: TCubicMeterPerKilogramUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cCubicMeterPerKilogram];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TCubicMeterPerKilogramUnit.*(const AValue: TQuantity; const ASelf: TCubicMeterPerKilogramUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cCubicMeterPerKilogram];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TCubicMeterPerKilogramUnit./(const AValue: TQuantity; const ASelf: TCubicMeterPerKilogramUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cCubicMeterPerKilogram];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TKilogramSquareSecondUnit.*(const AValue: double; const ASelf: TKilogramSquareSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cKilogramSquareSecond];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TKilogramSquareSecondUnit./(const AValue: double; const ASelf: TKilogramSquareSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cKilogramSquareSecond];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TKilogramSquareSecondUnit.*(const AValue: TQuantity; const ASelf: TKilogramSquareSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cKilogramSquareSecond];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TKilogramSquareSecondUnit./(const AValue: TQuantity; const ASelf: TKilogramSquareSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cKilogramSquareSecond];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TCubicMeterPerSquareSecondUnit.*(const AValue: double; const ASelf: TCubicMeterPerSquareSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cCubicMeterPerSquareSecond];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TCubicMeterPerSquareSecondUnit./(const AValue: double; const ASelf: TCubicMeterPerSquareSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cCubicMeterPerSquareSecond];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TCubicMeterPerSquareSecondUnit.*(const AValue: TQuantity; const ASelf: TCubicMeterPerSquareSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cCubicMeterPerSquareSecond];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TCubicMeterPerSquareSecondUnit./(const AValue: TQuantity; const ASelf: TCubicMeterPerSquareSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cCubicMeterPerSquareSecond];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TNewtonSquareMeterUnit.*(const AValue: double; const ASelf: TNewtonSquareMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cNewtonSquareMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TNewtonSquareMeterUnit./(const AValue: double; const ASelf: TNewtonSquareMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cNewtonSquareMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TNewtonSquareMeterUnit.*(const AValue: TQuantity; const ASelf: TNewtonSquareMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cNewtonSquareMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TNewtonSquareMeterUnit./(const AValue: TQuantity; const ASelf: TNewtonSquareMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cNewtonSquareMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TKilogramCubicMeterPerSquareSecondUnit.*(const AValue: double; const ASelf: TKilogramCubicMeterPerSquareSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cNewtonSquareMeter];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

class operator TKilogramCubicMeterPerSquareSecondUnit./(const AValue: double; const ASelf: TKilogramCubicMeterPerSquareSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cNewtonSquareMeter];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

{$IFOPT D+}
class operator TKilogramCubicMeterPerSquareSecondUnit.*(const AValue: TQuantity; const ASelf: TKilogramCubicMeterPerSquareSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cNewtonSquareMeter];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

{$IFOPT D+}
class operator TKilogramCubicMeterPerSquareSecondUnit./(const AValue: TQuantity; const ASelf: TKilogramCubicMeterPerSquareSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cNewtonSquareMeter];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

class operator TNewtonCubicMeterUnit.*(const AValue: double; const ASelf: TNewtonCubicMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cNewtonCubicMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TNewtonCubicMeterUnit./(const AValue: double; const ASelf: TNewtonCubicMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cNewtonCubicMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TNewtonCubicMeterUnit.*(const AValue: TQuantity; const ASelf: TNewtonCubicMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cNewtonCubicMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TNewtonCubicMeterUnit./(const AValue: TQuantity; const ASelf: TNewtonCubicMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cNewtonCubicMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TKilogramQuarticMeterPerSquareSecondUnit.*(const AValue: double; const ASelf: TKilogramQuarticMeterPerSquareSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cNewtonCubicMeter];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

class operator TKilogramQuarticMeterPerSquareSecondUnit./(const AValue: double; const ASelf: TKilogramQuarticMeterPerSquareSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cNewtonCubicMeter];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

{$IFOPT D+}
class operator TKilogramQuarticMeterPerSquareSecondUnit.*(const AValue: TQuantity; const ASelf: TKilogramQuarticMeterPerSquareSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cNewtonCubicMeter];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

{$IFOPT D+}
class operator TKilogramQuarticMeterPerSquareSecondUnit./(const AValue: TQuantity; const ASelf: TKilogramQuarticMeterPerSquareSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cNewtonCubicMeter];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

class operator TNewtonPerSquareKilogramUnit.*(const AValue: double; const ASelf: TNewtonPerSquareKilogramUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cNewtonPerSquareKilogram];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TNewtonPerSquareKilogramUnit./(const AValue: double; const ASelf: TNewtonPerSquareKilogramUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cNewtonPerSquareKilogram];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TNewtonPerSquareKilogramUnit.*(const AValue: TQuantity; const ASelf: TNewtonPerSquareKilogramUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cNewtonPerSquareKilogram];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TNewtonPerSquareKilogramUnit./(const AValue: TQuantity; const ASelf: TNewtonPerSquareKilogramUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cNewtonPerSquareKilogram];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TMeterPerKilogramPerSquareSecondUnit.*(const AValue: double; const ASelf: TMeterPerKilogramPerSquareSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cNewtonPerSquareKilogram];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

class operator TMeterPerKilogramPerSquareSecondUnit./(const AValue: double; const ASelf: TMeterPerKilogramPerSquareSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cNewtonPerSquareKilogram];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

{$IFOPT D+}
class operator TMeterPerKilogramPerSquareSecondUnit.*(const AValue: TQuantity; const ASelf: TMeterPerKilogramPerSquareSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cNewtonPerSquareKilogram];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

{$IFOPT D+}
class operator TMeterPerKilogramPerSquareSecondUnit./(const AValue: TQuantity; const ASelf: TMeterPerKilogramPerSquareSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cNewtonPerSquareKilogram];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

class operator TSquareKilogramPerMeterUnit.*(const AValue: double; const ASelf: TSquareKilogramPerMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cSquareKilogramPerMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TSquareKilogramPerMeterUnit./(const AValue: double; const ASelf: TSquareKilogramPerMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cSquareKilogramPerMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TSquareKilogramPerMeterUnit.*(const AValue: TQuantity; const ASelf: TSquareKilogramPerMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cSquareKilogramPerMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TSquareKilogramPerMeterUnit./(const AValue: TQuantity; const ASelf: TSquareKilogramPerMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cSquareKilogramPerMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TSquareKilogramPerSquareMeterUnit.*(const AValue: double; const ASelf: TSquareKilogramPerSquareMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cSquareKilogramPerSquareMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TSquareKilogramPerSquareMeterUnit./(const AValue: double; const ASelf: TSquareKilogramPerSquareMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cSquareKilogramPerSquareMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TSquareKilogramPerSquareMeterUnit.*(const AValue: TQuantity; const ASelf: TSquareKilogramPerSquareMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cSquareKilogramPerSquareMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TSquareKilogramPerSquareMeterUnit./(const AValue: TQuantity; const ASelf: TSquareKilogramPerSquareMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cSquareKilogramPerSquareMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TSquareMeterPerSquareKilogramUnit.*(const AValue: double; const ASelf: TSquareMeterPerSquareKilogramUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cSquareMeterPerSquareKilogram];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TSquareMeterPerSquareKilogramUnit./(const AValue: double; const ASelf: TSquareMeterPerSquareKilogramUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cSquareMeterPerSquareKilogram];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TSquareMeterPerSquareKilogramUnit.*(const AValue: TQuantity; const ASelf: TSquareMeterPerSquareKilogramUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cSquareMeterPerSquareKilogram];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TSquareMeterPerSquareKilogramUnit./(const AValue: TQuantity; const ASelf: TSquareMeterPerSquareKilogramUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cSquareMeterPerSquareKilogram];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TNewtonSquareMeterPerSquareKilogramUnit.*(const AValue: double; const ASelf: TNewtonSquareMeterPerSquareKilogramUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cNewtonSquareMeterPerSquareKilogram];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TNewtonSquareMeterPerSquareKilogramUnit./(const AValue: double; const ASelf: TNewtonSquareMeterPerSquareKilogramUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cNewtonSquareMeterPerSquareKilogram];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TNewtonSquareMeterPerSquareKilogramUnit.*(const AValue: TQuantity; const ASelf: TNewtonSquareMeterPerSquareKilogramUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cNewtonSquareMeterPerSquareKilogram];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TNewtonSquareMeterPerSquareKilogramUnit./(const AValue: TQuantity; const ASelf: TNewtonSquareMeterPerSquareKilogramUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cNewtonSquareMeterPerSquareKilogram];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TCubicMeterPerKilogramPerSquareSecondUnit.*(const AValue: double; const ASelf: TCubicMeterPerKilogramPerSquareSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cNewtonSquareMeterPerSquareKilogram];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

class operator TCubicMeterPerKilogramPerSquareSecondUnit./(const AValue: double; const ASelf: TCubicMeterPerKilogramPerSquareSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cNewtonSquareMeterPerSquareKilogram];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

{$IFOPT D+}
class operator TCubicMeterPerKilogramPerSquareSecondUnit.*(const AValue: TQuantity; const ASelf: TCubicMeterPerKilogramPerSquareSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cNewtonSquareMeterPerSquareKilogram];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

{$IFOPT D+}
class operator TCubicMeterPerKilogramPerSquareSecondUnit./(const AValue: TQuantity; const ASelf: TCubicMeterPerKilogramPerSquareSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cNewtonSquareMeterPerSquareKilogram];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

class operator TReciprocalKelvinUnit.*(const AValue: double; const ASelf: TReciprocalKelvinUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cReciprocalKelvin];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TReciprocalKelvinUnit./(const AValue: double; const ASelf: TReciprocalKelvinUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cReciprocalKelvin];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TReciprocalKelvinUnit.*(const AValue: TQuantity; const ASelf: TReciprocalKelvinUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cReciprocalKelvin];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TReciprocalKelvinUnit./(const AValue: TQuantity; const ASelf: TReciprocalKelvinUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cReciprocalKelvin];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TKilogramKelvinUnit.*(const AValue: double; const ASelf: TKilogramKelvinUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cKilogramKelvin];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TKilogramKelvinUnit./(const AValue: double; const ASelf: TKilogramKelvinUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cKilogramKelvin];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TKilogramKelvinUnit.*(const AValue: TQuantity; const ASelf: TKilogramKelvinUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cKilogramKelvin];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TKilogramKelvinUnit./(const AValue: TQuantity; const ASelf: TKilogramKelvinUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cKilogramKelvin];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TJoulePerKelvinUnit.*(const AValue: double; const ASelf: TJoulePerKelvinUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cJoulePerKelvin];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TJoulePerKelvinUnit./(const AValue: double; const ASelf: TJoulePerKelvinUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cJoulePerKelvin];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TJoulePerKelvinUnit.*(const AValue: TQuantity; const ASelf: TJoulePerKelvinUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cJoulePerKelvin];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TJoulePerKelvinUnit./(const AValue: TQuantity; const ASelf: TJoulePerKelvinUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cJoulePerKelvin];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TKilogramSquareMeterPerSquareSecondPerKelvinUnit.*(const AValue: double; const ASelf: TKilogramSquareMeterPerSquareSecondPerKelvinUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cJoulePerKelvin];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

class operator TKilogramSquareMeterPerSquareSecondPerKelvinUnit./(const AValue: double; const ASelf: TKilogramSquareMeterPerSquareSecondPerKelvinUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cJoulePerKelvin];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

{$IFOPT D+}
class operator TKilogramSquareMeterPerSquareSecondPerKelvinUnit.*(const AValue: TQuantity; const ASelf: TKilogramSquareMeterPerSquareSecondPerKelvinUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cJoulePerKelvin];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

{$IFOPT D+}
class operator TKilogramSquareMeterPerSquareSecondPerKelvinUnit./(const AValue: TQuantity; const ASelf: TKilogramSquareMeterPerSquareSecondPerKelvinUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cJoulePerKelvin];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

class operator TJoulePerKilogramPerKelvinUnit.*(const AValue: double; const ASelf: TJoulePerKilogramPerKelvinUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cJoulePerKilogramPerKelvin];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TJoulePerKilogramPerKelvinUnit./(const AValue: double; const ASelf: TJoulePerKilogramPerKelvinUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cJoulePerKilogramPerKelvin];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TJoulePerKilogramPerKelvinUnit.*(const AValue: TQuantity; const ASelf: TJoulePerKilogramPerKelvinUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cJoulePerKilogramPerKelvin];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TJoulePerKilogramPerKelvinUnit./(const AValue: TQuantity; const ASelf: TJoulePerKilogramPerKelvinUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cJoulePerKilogramPerKelvin];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TSquareMeterPerSquareSecondPerKelvinUnit.*(const AValue: double; const ASelf: TSquareMeterPerSquareSecondPerKelvinUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cJoulePerKilogramPerKelvin];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

class operator TSquareMeterPerSquareSecondPerKelvinUnit./(const AValue: double; const ASelf: TSquareMeterPerSquareSecondPerKelvinUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cJoulePerKilogramPerKelvin];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

{$IFOPT D+}
class operator TSquareMeterPerSquareSecondPerKelvinUnit.*(const AValue: TQuantity; const ASelf: TSquareMeterPerSquareSecondPerKelvinUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cJoulePerKilogramPerKelvin];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

{$IFOPT D+}
class operator TSquareMeterPerSquareSecondPerKelvinUnit./(const AValue: TQuantity; const ASelf: TSquareMeterPerSquareSecondPerKelvinUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cJoulePerKilogramPerKelvin];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

class operator TMeterKelvinUnit.*(const AValue: double; const ASelf: TMeterKelvinUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cMeterKelvin];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TMeterKelvinUnit./(const AValue: double; const ASelf: TMeterKelvinUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cMeterKelvin];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TMeterKelvinUnit.*(const AValue: TQuantity; const ASelf: TMeterKelvinUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cMeterKelvin];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TMeterKelvinUnit./(const AValue: TQuantity; const ASelf: TMeterKelvinUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cMeterKelvin];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TKelvinPerMeterUnit.*(const AValue: double; const ASelf: TKelvinPerMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cKelvinPerMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TKelvinPerMeterUnit./(const AValue: double; const ASelf: TKelvinPerMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cKelvinPerMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TKelvinPerMeterUnit.*(const AValue: TQuantity; const ASelf: TKelvinPerMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cKelvinPerMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TKelvinPerMeterUnit./(const AValue: TQuantity; const ASelf: TKelvinPerMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cKelvinPerMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TWattPerMeterUnit.*(const AValue: double; const ASelf: TWattPerMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cWattPerMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TWattPerMeterUnit./(const AValue: double; const ASelf: TWattPerMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cWattPerMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TWattPerMeterUnit.*(const AValue: TQuantity; const ASelf: TWattPerMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cWattPerMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TWattPerMeterUnit./(const AValue: TQuantity; const ASelf: TWattPerMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cWattPerMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TKilogramMeterPerCubicSecondUnit.*(const AValue: double; const ASelf: TKilogramMeterPerCubicSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cWattPerMeter];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

class operator TKilogramMeterPerCubicSecondUnit./(const AValue: double; const ASelf: TKilogramMeterPerCubicSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cWattPerMeter];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

{$IFOPT D+}
class operator TKilogramMeterPerCubicSecondUnit.*(const AValue: TQuantity; const ASelf: TKilogramMeterPerCubicSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cWattPerMeter];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

{$IFOPT D+}
class operator TKilogramMeterPerCubicSecondUnit./(const AValue: TQuantity; const ASelf: TKilogramMeterPerCubicSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cWattPerMeter];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

class operator TWattPerSquareMeterUnit.*(const AValue: double; const ASelf: TWattPerSquareMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cWattPerSquareMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TWattPerSquareMeterUnit./(const AValue: double; const ASelf: TWattPerSquareMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cWattPerSquareMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TWattPerSquareMeterUnit.*(const AValue: TQuantity; const ASelf: TWattPerSquareMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cWattPerSquareMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TWattPerSquareMeterUnit./(const AValue: TQuantity; const ASelf: TWattPerSquareMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cWattPerSquareMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TKilogramPerCubicSecondUnit.*(const AValue: double; const ASelf: TKilogramPerCubicSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cWattPerSquareMeter];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

class operator TKilogramPerCubicSecondUnit./(const AValue: double; const ASelf: TKilogramPerCubicSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cWattPerSquareMeter];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

{$IFOPT D+}
class operator TKilogramPerCubicSecondUnit.*(const AValue: TQuantity; const ASelf: TKilogramPerCubicSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cWattPerSquareMeter];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

{$IFOPT D+}
class operator TKilogramPerCubicSecondUnit./(const AValue: TQuantity; const ASelf: TKilogramPerCubicSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cWattPerSquareMeter];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

class operator TWattPerCubicMeterUnit.*(const AValue: double; const ASelf: TWattPerCubicMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cWattPerCubicMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TWattPerCubicMeterUnit./(const AValue: double; const ASelf: TWattPerCubicMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cWattPerCubicMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TWattPerCubicMeterUnit.*(const AValue: TQuantity; const ASelf: TWattPerCubicMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cWattPerCubicMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TWattPerCubicMeterUnit./(const AValue: TQuantity; const ASelf: TWattPerCubicMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cWattPerCubicMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TWattPerKelvinUnit.*(const AValue: double; const ASelf: TWattPerKelvinUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cWattPerKelvin];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TWattPerKelvinUnit./(const AValue: double; const ASelf: TWattPerKelvinUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cWattPerKelvin];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TWattPerKelvinUnit.*(const AValue: TQuantity; const ASelf: TWattPerKelvinUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cWattPerKelvin];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TWattPerKelvinUnit./(const AValue: TQuantity; const ASelf: TWattPerKelvinUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cWattPerKelvin];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TKilogramSquareMeterPerCubicSecondPerKelvinUnit.*(const AValue: double; const ASelf: TKilogramSquareMeterPerCubicSecondPerKelvinUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cWattPerKelvin];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

class operator TKilogramSquareMeterPerCubicSecondPerKelvinUnit./(const AValue: double; const ASelf: TKilogramSquareMeterPerCubicSecondPerKelvinUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cWattPerKelvin];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

{$IFOPT D+}
class operator TKilogramSquareMeterPerCubicSecondPerKelvinUnit.*(const AValue: TQuantity; const ASelf: TKilogramSquareMeterPerCubicSecondPerKelvinUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cWattPerKelvin];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

{$IFOPT D+}
class operator TKilogramSquareMeterPerCubicSecondPerKelvinUnit./(const AValue: TQuantity; const ASelf: TKilogramSquareMeterPerCubicSecondPerKelvinUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cWattPerKelvin];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

class operator TWattPerMeterPerKelvinUnit.*(const AValue: double; const ASelf: TWattPerMeterPerKelvinUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cWattPerMeterPerKelvin];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TWattPerMeterPerKelvinUnit./(const AValue: double; const ASelf: TWattPerMeterPerKelvinUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cWattPerMeterPerKelvin];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TWattPerMeterPerKelvinUnit.*(const AValue: TQuantity; const ASelf: TWattPerMeterPerKelvinUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cWattPerMeterPerKelvin];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TWattPerMeterPerKelvinUnit./(const AValue: TQuantity; const ASelf: TWattPerMeterPerKelvinUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cWattPerMeterPerKelvin];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TKilogramMeterPerCubicSecondPerKelvinUnit.*(const AValue: double; const ASelf: TKilogramMeterPerCubicSecondPerKelvinUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cWattPerMeterPerKelvin];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

class operator TKilogramMeterPerCubicSecondPerKelvinUnit./(const AValue: double; const ASelf: TKilogramMeterPerCubicSecondPerKelvinUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cWattPerMeterPerKelvin];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

{$IFOPT D+}
class operator TKilogramMeterPerCubicSecondPerKelvinUnit.*(const AValue: TQuantity; const ASelf: TKilogramMeterPerCubicSecondPerKelvinUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cWattPerMeterPerKelvin];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

{$IFOPT D+}
class operator TKilogramMeterPerCubicSecondPerKelvinUnit./(const AValue: TQuantity; const ASelf: TKilogramMeterPerCubicSecondPerKelvinUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cWattPerMeterPerKelvin];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

class operator TKelvinPerWattUnit.*(const AValue: double; const ASelf: TKelvinPerWattUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cKelvinPerWatt];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TKelvinPerWattUnit./(const AValue: double; const ASelf: TKelvinPerWattUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cKelvinPerWatt];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TKelvinPerWattUnit.*(const AValue: TQuantity; const ASelf: TKelvinPerWattUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cKelvinPerWatt];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TKelvinPerWattUnit./(const AValue: TQuantity; const ASelf: TKelvinPerWattUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cKelvinPerWatt];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TMeterPerWattUnit.*(const AValue: double; const ASelf: TMeterPerWattUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cMeterPerWatt];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TMeterPerWattUnit./(const AValue: double; const ASelf: TMeterPerWattUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cMeterPerWatt];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TMeterPerWattUnit.*(const AValue: TQuantity; const ASelf: TMeterPerWattUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cMeterPerWatt];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TMeterPerWattUnit./(const AValue: TQuantity; const ASelf: TMeterPerWattUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cMeterPerWatt];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TMeterKelvinPerWattUnit.*(const AValue: double; const ASelf: TMeterKelvinPerWattUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cMeterKelvinPerWatt];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TMeterKelvinPerWattUnit./(const AValue: double; const ASelf: TMeterKelvinPerWattUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cMeterKelvinPerWatt];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TMeterKelvinPerWattUnit.*(const AValue: TQuantity; const ASelf: TMeterKelvinPerWattUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cMeterKelvinPerWatt];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TMeterKelvinPerWattUnit./(const AValue: TQuantity; const ASelf: TMeterKelvinPerWattUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cMeterKelvinPerWatt];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TSquareMeterKelvinUnit.*(const AValue: double; const ASelf: TSquareMeterKelvinUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cSquareMeterKelvin];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TSquareMeterKelvinUnit./(const AValue: double; const ASelf: TSquareMeterKelvinUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cSquareMeterKelvin];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TSquareMeterKelvinUnit.*(const AValue: TQuantity; const ASelf: TSquareMeterKelvinUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cSquareMeterKelvin];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TSquareMeterKelvinUnit./(const AValue: TQuantity; const ASelf: TSquareMeterKelvinUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cSquareMeterKelvin];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TWattPerSquareMeterPerKelvinUnit.*(const AValue: double; const ASelf: TWattPerSquareMeterPerKelvinUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cWattPerSquareMeterPerKelvin];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TWattPerSquareMeterPerKelvinUnit./(const AValue: double; const ASelf: TWattPerSquareMeterPerKelvinUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cWattPerSquareMeterPerKelvin];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TWattPerSquareMeterPerKelvinUnit.*(const AValue: TQuantity; const ASelf: TWattPerSquareMeterPerKelvinUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cWattPerSquareMeterPerKelvin];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TWattPerSquareMeterPerKelvinUnit./(const AValue: TQuantity; const ASelf: TWattPerSquareMeterPerKelvinUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cWattPerSquareMeterPerKelvin];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TKilogramPerCubicSecondPerKelvinUnit.*(const AValue: double; const ASelf: TKilogramPerCubicSecondPerKelvinUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cWattPerSquareMeterPerKelvin];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

class operator TKilogramPerCubicSecondPerKelvinUnit./(const AValue: double; const ASelf: TKilogramPerCubicSecondPerKelvinUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cWattPerSquareMeterPerKelvin];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

{$IFOPT D+}
class operator TKilogramPerCubicSecondPerKelvinUnit.*(const AValue: TQuantity; const ASelf: TKilogramPerCubicSecondPerKelvinUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cWattPerSquareMeterPerKelvin];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

{$IFOPT D+}
class operator TKilogramPerCubicSecondPerKelvinUnit./(const AValue: TQuantity; const ASelf: TKilogramPerCubicSecondPerKelvinUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cWattPerSquareMeterPerKelvin];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

class operator TSquareMeterQuarticKelvinUnit.*(const AValue: double; const ASelf: TSquareMeterQuarticKelvinUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cSquareMeterQuarticKelvin];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TSquareMeterQuarticKelvinUnit./(const AValue: double; const ASelf: TSquareMeterQuarticKelvinUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cSquareMeterQuarticKelvin];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TSquareMeterQuarticKelvinUnit.*(const AValue: TQuantity; const ASelf: TSquareMeterQuarticKelvinUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cSquareMeterQuarticKelvin];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TSquareMeterQuarticKelvinUnit./(const AValue: TQuantity; const ASelf: TSquareMeterQuarticKelvinUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cSquareMeterQuarticKelvin];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TWattPerQuarticKelvinUnit.*(const AValue: double; const ASelf: TWattPerQuarticKelvinUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cWattPerQuarticKelvin];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TWattPerQuarticKelvinUnit./(const AValue: double; const ASelf: TWattPerQuarticKelvinUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cWattPerQuarticKelvin];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TWattPerQuarticKelvinUnit.*(const AValue: TQuantity; const ASelf: TWattPerQuarticKelvinUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cWattPerQuarticKelvin];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TWattPerQuarticKelvinUnit./(const AValue: TQuantity; const ASelf: TWattPerQuarticKelvinUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cWattPerQuarticKelvin];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TWattPerSquareMeterPerQuarticKelvinUnit.*(const AValue: double; const ASelf: TWattPerSquareMeterPerQuarticKelvinUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cWattPerSquareMeterPerQuarticKelvin];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TWattPerSquareMeterPerQuarticKelvinUnit./(const AValue: double; const ASelf: TWattPerSquareMeterPerQuarticKelvinUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cWattPerSquareMeterPerQuarticKelvin];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TWattPerSquareMeterPerQuarticKelvinUnit.*(const AValue: TQuantity; const ASelf: TWattPerSquareMeterPerQuarticKelvinUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cWattPerSquareMeterPerQuarticKelvin];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TWattPerSquareMeterPerQuarticKelvinUnit./(const AValue: TQuantity; const ASelf: TWattPerSquareMeterPerQuarticKelvinUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cWattPerSquareMeterPerQuarticKelvin];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TJoulePerMoleUnit.*(const AValue: double; const ASelf: TJoulePerMoleUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cJoulePerMole];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TJoulePerMoleUnit./(const AValue: double; const ASelf: TJoulePerMoleUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cJoulePerMole];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TJoulePerMoleUnit.*(const AValue: TQuantity; const ASelf: TJoulePerMoleUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cJoulePerMole];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TJoulePerMoleUnit./(const AValue: TQuantity; const ASelf: TJoulePerMoleUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cJoulePerMole];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TMoleKelvinUnit.*(const AValue: double; const ASelf: TMoleKelvinUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cMoleKelvin];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TMoleKelvinUnit./(const AValue: double; const ASelf: TMoleKelvinUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cMoleKelvin];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TMoleKelvinUnit.*(const AValue: TQuantity; const ASelf: TMoleKelvinUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cMoleKelvin];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TMoleKelvinUnit./(const AValue: TQuantity; const ASelf: TMoleKelvinUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cMoleKelvin];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TJoulePerMolePerKelvinUnit.*(const AValue: double; const ASelf: TJoulePerMolePerKelvinUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cJoulePerMolePerKelvin];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TJoulePerMolePerKelvinUnit./(const AValue: double; const ASelf: TJoulePerMolePerKelvinUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cJoulePerMolePerKelvin];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TJoulePerMolePerKelvinUnit.*(const AValue: TQuantity; const ASelf: TJoulePerMolePerKelvinUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cJoulePerMolePerKelvin];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TJoulePerMolePerKelvinUnit./(const AValue: TQuantity; const ASelf: TJoulePerMolePerKelvinUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cJoulePerMolePerKelvin];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TOhmMeterUnit.*(const AValue: double; const ASelf: TOhmMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cOhmMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TOhmMeterUnit./(const AValue: double; const ASelf: TOhmMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cOhmMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TOhmMeterUnit.*(const AValue: TQuantity; const ASelf: TOhmMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cOhmMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TOhmMeterUnit./(const AValue: TQuantity; const ASelf: TOhmMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cOhmMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TVoltPerMeterUnit.*(const AValue: double; const ASelf: TVoltPerMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cVoltPerMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TVoltPerMeterUnit./(const AValue: double; const ASelf: TVoltPerMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cVoltPerMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TVoltPerMeterUnit.*(const AValue: TQuantity; const ASelf: TVoltPerMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cVoltPerMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TVoltPerMeterUnit./(const AValue: TQuantity; const ASelf: TVoltPerMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cVoltPerMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TNewtonPerCoulombUnit.*(const AValue: double; const ASelf: TNewtonPerCoulombUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cVoltPerMeter];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

class operator TNewtonPerCoulombUnit./(const AValue: double; const ASelf: TNewtonPerCoulombUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cVoltPerMeter];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

{$IFOPT D+}
class operator TNewtonPerCoulombUnit.*(const AValue: TQuantity; const ASelf: TNewtonPerCoulombUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cVoltPerMeter];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

{$IFOPT D+}
class operator TNewtonPerCoulombUnit./(const AValue: TQuantity; const ASelf: TNewtonPerCoulombUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cVoltPerMeter];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

class operator TCoulombPerMeterUnit.*(const AValue: double; const ASelf: TCoulombPerMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cCoulombPerMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TCoulombPerMeterUnit./(const AValue: double; const ASelf: TCoulombPerMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cCoulombPerMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TCoulombPerMeterUnit.*(const AValue: TQuantity; const ASelf: TCoulombPerMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cCoulombPerMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TCoulombPerMeterUnit./(const AValue: TQuantity; const ASelf: TCoulombPerMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cCoulombPerMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TSquareCoulombPerMeterUnit.*(const AValue: double; const ASelf: TSquareCoulombPerMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cSquareCoulombPerMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TSquareCoulombPerMeterUnit./(const AValue: double; const ASelf: TSquareCoulombPerMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cSquareCoulombPerMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TSquareCoulombPerMeterUnit.*(const AValue: TQuantity; const ASelf: TSquareCoulombPerMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cSquareCoulombPerMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TSquareCoulombPerMeterUnit./(const AValue: TQuantity; const ASelf: TSquareCoulombPerMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cSquareCoulombPerMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TCoulombPerSquareMeterUnit.*(const AValue: double; const ASelf: TCoulombPerSquareMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cCoulombPerSquareMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TCoulombPerSquareMeterUnit./(const AValue: double; const ASelf: TCoulombPerSquareMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cCoulombPerSquareMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TCoulombPerSquareMeterUnit.*(const AValue: TQuantity; const ASelf: TCoulombPerSquareMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cCoulombPerSquareMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TCoulombPerSquareMeterUnit./(const AValue: TQuantity; const ASelf: TCoulombPerSquareMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cCoulombPerSquareMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TSquareMeterPerSquareCoulombUnit.*(const AValue: double; const ASelf: TSquareMeterPerSquareCoulombUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cSquareMeterPerSquareCoulomb];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TSquareMeterPerSquareCoulombUnit./(const AValue: double; const ASelf: TSquareMeterPerSquareCoulombUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cSquareMeterPerSquareCoulomb];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TSquareMeterPerSquareCoulombUnit.*(const AValue: TQuantity; const ASelf: TSquareMeterPerSquareCoulombUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cSquareMeterPerSquareCoulomb];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TSquareMeterPerSquareCoulombUnit./(const AValue: TQuantity; const ASelf: TSquareMeterPerSquareCoulombUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cSquareMeterPerSquareCoulomb];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TNewtonPerSquareCoulombUnit.*(const AValue: double; const ASelf: TNewtonPerSquareCoulombUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cNewtonPerSquareCoulomb];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TNewtonPerSquareCoulombUnit./(const AValue: double; const ASelf: TNewtonPerSquareCoulombUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cNewtonPerSquareCoulomb];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TNewtonPerSquareCoulombUnit.*(const AValue: TQuantity; const ASelf: TNewtonPerSquareCoulombUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cNewtonPerSquareCoulomb];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TNewtonPerSquareCoulombUnit./(const AValue: TQuantity; const ASelf: TNewtonPerSquareCoulombUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cNewtonPerSquareCoulomb];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TNewtonSquareMeterPerSquareCoulombUnit.*(const AValue: double; const ASelf: TNewtonSquareMeterPerSquareCoulombUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cNewtonSquareMeterPerSquareCoulomb];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TNewtonSquareMeterPerSquareCoulombUnit./(const AValue: double; const ASelf: TNewtonSquareMeterPerSquareCoulombUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cNewtonSquareMeterPerSquareCoulomb];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TNewtonSquareMeterPerSquareCoulombUnit.*(const AValue: TQuantity; const ASelf: TNewtonSquareMeterPerSquareCoulombUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cNewtonSquareMeterPerSquareCoulomb];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TNewtonSquareMeterPerSquareCoulombUnit./(const AValue: TQuantity; const ASelf: TNewtonSquareMeterPerSquareCoulombUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cNewtonSquareMeterPerSquareCoulomb];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TVoltMeterUnit.*(const AValue: double; const ASelf: TVoltMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cVoltMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TVoltMeterUnit./(const AValue: double; const ASelf: TVoltMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cVoltMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TVoltMeterUnit.*(const AValue: TQuantity; const ASelf: TVoltMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cVoltMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TVoltMeterUnit./(const AValue: TQuantity; const ASelf: TVoltMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cVoltMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TNewtonSquareMeterPerCoulombUnit.*(const AValue: double; const ASelf: TNewtonSquareMeterPerCoulombUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cVoltMeter];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

class operator TNewtonSquareMeterPerCoulombUnit./(const AValue: double; const ASelf: TNewtonSquareMeterPerCoulombUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cVoltMeter];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

{$IFOPT D+}
class operator TNewtonSquareMeterPerCoulombUnit.*(const AValue: TQuantity; const ASelf: TNewtonSquareMeterPerCoulombUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cVoltMeter];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

{$IFOPT D+}
class operator TNewtonSquareMeterPerCoulombUnit./(const AValue: TQuantity; const ASelf: TNewtonSquareMeterPerCoulombUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cVoltMeter];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

class operator TVoltMeterPerSecondUnit.*(const AValue: double; const ASelf: TVoltMeterPerSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cVoltMeterPerSecond];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TVoltMeterPerSecondUnit./(const AValue: double; const ASelf: TVoltMeterPerSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cVoltMeterPerSecond];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TVoltMeterPerSecondUnit.*(const AValue: TQuantity; const ASelf: TVoltMeterPerSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cVoltMeterPerSecond];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TVoltMeterPerSecondUnit./(const AValue: TQuantity; const ASelf: TVoltMeterPerSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cVoltMeterPerSecond];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TFaradPerMeterUnit.*(const AValue: double; const ASelf: TFaradPerMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cFaradPerMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TFaradPerMeterUnit./(const AValue: double; const ASelf: TFaradPerMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cFaradPerMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TFaradPerMeterUnit.*(const AValue: TQuantity; const ASelf: TFaradPerMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cFaradPerMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TFaradPerMeterUnit./(const AValue: TQuantity; const ASelf: TFaradPerMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cFaradPerMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TAmperePerMeterUnit.*(const AValue: double; const ASelf: TAmperePerMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cAmperePerMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TAmperePerMeterUnit./(const AValue: double; const ASelf: TAmperePerMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cAmperePerMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TAmperePerMeterUnit.*(const AValue: TQuantity; const ASelf: TAmperePerMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cAmperePerMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TAmperePerMeterUnit./(const AValue: TQuantity; const ASelf: TAmperePerMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cAmperePerMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TMeterPerAmpereUnit.*(const AValue: double; const ASelf: TMeterPerAmpereUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cMeterPerAmpere];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TMeterPerAmpereUnit./(const AValue: double; const ASelf: TMeterPerAmpereUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cMeterPerAmpere];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TMeterPerAmpereUnit.*(const AValue: TQuantity; const ASelf: TMeterPerAmpereUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cMeterPerAmpere];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TMeterPerAmpereUnit./(const AValue: TQuantity; const ASelf: TMeterPerAmpereUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cMeterPerAmpere];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TTeslaMeterUnit.*(const AValue: double; const ASelf: TTeslaMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cTeslaMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TTeslaMeterUnit./(const AValue: double; const ASelf: TTeslaMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cTeslaMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TTeslaMeterUnit.*(const AValue: TQuantity; const ASelf: TTeslaMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cTeslaMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TTeslaMeterUnit./(const AValue: TQuantity; const ASelf: TTeslaMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cTeslaMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TNewtonPerAmpereUnit.*(const AValue: double; const ASelf: TNewtonPerAmpereUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cTeslaMeter];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

class operator TNewtonPerAmpereUnit./(const AValue: double; const ASelf: TNewtonPerAmpereUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cTeslaMeter];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

{$IFOPT D+}
class operator TNewtonPerAmpereUnit.*(const AValue: TQuantity; const ASelf: TNewtonPerAmpereUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cTeslaMeter];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

{$IFOPT D+}
class operator TNewtonPerAmpereUnit./(const AValue: TQuantity; const ASelf: TNewtonPerAmpereUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cTeslaMeter];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

class operator TTeslaPerAmpereUnit.*(const AValue: double; const ASelf: TTeslaPerAmpereUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cTeslaPerAmpere];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TTeslaPerAmpereUnit./(const AValue: double; const ASelf: TTeslaPerAmpereUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cTeslaPerAmpere];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TTeslaPerAmpereUnit.*(const AValue: TQuantity; const ASelf: TTeslaPerAmpereUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cTeslaPerAmpere];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TTeslaPerAmpereUnit./(const AValue: TQuantity; const ASelf: TTeslaPerAmpereUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cTeslaPerAmpere];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator THenryPerMeterUnit.*(const AValue: double; const ASelf: THenryPerMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cHenryPerMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator THenryPerMeterUnit./(const AValue: double; const ASelf: THenryPerMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cHenryPerMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator THenryPerMeterUnit.*(const AValue: TQuantity; const ASelf: THenryPerMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cHenryPerMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator THenryPerMeterUnit./(const AValue: TQuantity; const ASelf: THenryPerMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cHenryPerMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TTeslaMeterPerAmpereUnit.*(const AValue: double; const ASelf: TTeslaMeterPerAmpereUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cHenryPerMeter];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

class operator TTeslaMeterPerAmpereUnit./(const AValue: double; const ASelf: TTeslaMeterPerAmpereUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cHenryPerMeter];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

{$IFOPT D+}
class operator TTeslaMeterPerAmpereUnit.*(const AValue: TQuantity; const ASelf: TTeslaMeterPerAmpereUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cHenryPerMeter];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

{$IFOPT D+}
class operator TTeslaMeterPerAmpereUnit./(const AValue: TQuantity; const ASelf: TTeslaMeterPerAmpereUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cHenryPerMeter];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

class operator TNewtonPerSquareAmpereUnit.*(const AValue: double; const ASelf: TNewtonPerSquareAmpereUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cHenryPerMeter];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

class operator TNewtonPerSquareAmpereUnit./(const AValue: double; const ASelf: TNewtonPerSquareAmpereUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cHenryPerMeter];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

{$IFOPT D+}
class operator TNewtonPerSquareAmpereUnit.*(const AValue: TQuantity; const ASelf: TNewtonPerSquareAmpereUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cHenryPerMeter];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

{$IFOPT D+}
class operator TNewtonPerSquareAmpereUnit./(const AValue: TQuantity; const ASelf: TNewtonPerSquareAmpereUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cHenryPerMeter];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

class operator TRadianPerMeterUnit.*(const AValue: double; const ASelf: TRadianPerMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cRadianPerMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TRadianPerMeterUnit./(const AValue: double; const ASelf: TRadianPerMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cRadianPerMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TRadianPerMeterUnit.*(const AValue: TQuantity; const ASelf: TRadianPerMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cRadianPerMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TRadianPerMeterUnit./(const AValue: TQuantity; const ASelf: TRadianPerMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cRadianPerMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TSquareKilogramPerSquareSecondUnit.*(const AValue: double; const ASelf: TSquareKilogramPerSquareSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cSquareKilogramPerSquareSecond];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TSquareKilogramPerSquareSecondUnit./(const AValue: double; const ASelf: TSquareKilogramPerSquareSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cSquareKilogramPerSquareSecond];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TSquareKilogramPerSquareSecondUnit.*(const AValue: TQuantity; const ASelf: TSquareKilogramPerSquareSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cSquareKilogramPerSquareSecond];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TSquareKilogramPerSquareSecondUnit./(const AValue: TQuantity; const ASelf: TSquareKilogramPerSquareSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cSquareKilogramPerSquareSecond];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TSquareSecondPerSquareMeterUnit.*(const AValue: double; const ASelf: TSquareSecondPerSquareMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cSquareSecondPerSquareMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TSquareSecondPerSquareMeterUnit./(const AValue: double; const ASelf: TSquareSecondPerSquareMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cSquareSecondPerSquareMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TSquareSecondPerSquareMeterUnit.*(const AValue: TQuantity; const ASelf: TSquareSecondPerSquareMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cSquareSecondPerSquareMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TSquareSecondPerSquareMeterUnit./(const AValue: TQuantity; const ASelf: TSquareSecondPerSquareMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cSquareSecondPerSquareMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TSquareJouleUnit.*(const AValue: double; const ASelf: TSquareJouleUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cSquareJoule];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TSquareJouleUnit./(const AValue: double; const ASelf: TSquareJouleUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cSquareJoule];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TSquareJouleUnit.*(const AValue: TQuantity; const ASelf: TSquareJouleUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cSquareJoule];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TSquareJouleUnit./(const AValue: TQuantity; const ASelf: TSquareJouleUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cSquareJoule];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TJouleSecondUnit.*(const AValue: double; const ASelf: TJouleSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cKilogramSquareMeterPerSecond];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

class operator TJouleSecondUnit./(const AValue: double; const ASelf: TJouleSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cKilogramSquareMeterPerSecond];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

{$IFOPT D+}
class operator TJouleSecondUnit.*(const AValue: TQuantity; const ASelf: TJouleSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cKilogramSquareMeterPerSecond];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

{$IFOPT D+}
class operator TJouleSecondUnit./(const AValue: TQuantity; const ASelf: TJouleSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cKilogramSquareMeterPerSecond];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

class operator TJoulePerHertzUnit.*(const AValue: double; const ASelf: TJoulePerHertzUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cKilogramSquareMeterPerSecond];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

class operator TJoulePerHertzUnit./(const AValue: double; const ASelf: TJoulePerHertzUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cKilogramSquareMeterPerSecond];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

{$IFOPT D+}
class operator TJoulePerHertzUnit.*(const AValue: TQuantity; const ASelf: TJoulePerHertzUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cKilogramSquareMeterPerSecond];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

{$IFOPT D+}
class operator TJoulePerHertzUnit./(const AValue: TQuantity; const ASelf: TJoulePerHertzUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cKilogramSquareMeterPerSecond];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

class operator TElectronvoltSecondUnit.*(const AValue: double; const ASelf: TElectronvoltSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cKilogramSquareMeterPerSecond];
  result.FValue := AValue * 1.60217742320523E-019;
{$ELSE}
  result := AValue * 1.60217742320523E-019;
{$ENDIF}
end;

class operator TElectronvoltSecondUnit./(const AValue: double; const ASelf: TElectronvoltSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cKilogramSquareMeterPerSecond];
  result.FValue := AValue * 1.60217742320523E-019;
{$ELSE}
  result := AValue * 1.60217742320523E-019;
{$ENDIF}
end;

{$IFOPT D+}
class operator TElectronvoltSecondUnit.*(const AValue: TQuantity; const ASelf: TElectronvoltSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[cScalar, cKilogramSquareMeterPerSecond];
  result.FValue := AValue.FValue * 1.60217742320523E-019;
end;
{$ENDIF}

{$IFOPT D+}
class operator TElectronvoltSecondUnit./(const AValue: TQuantity; const ASelf: TElectronvoltSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[cScalar, cKilogramSquareMeterPerSecond];
  result.FValue := AValue.FValue * 1.60217742320523E-019;
end;
{$ENDIF}

class operator TElectronvoltMeterPerSpeedOfLightUnit.*(const AValue: double; const ASelf: TElectronvoltMeterPerSpeedOfLightUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cKilogramSquareMeterPerSecond];
  result.FValue := AValue * 1.7826619216279E-36;
{$ELSE}
  result := AValue * 1.7826619216279E-36;
{$ENDIF}
end;

class operator TElectronvoltMeterPerSpeedOfLightUnit./(const AValue: double; const ASelf: TElectronvoltMeterPerSpeedOfLightUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cKilogramSquareMeterPerSecond];
  result.FValue := AValue * 1.7826619216279E-36;
{$ELSE}
  result := AValue * 1.7826619216279E-36;
{$ENDIF}
end;

{$IFOPT D+}
class operator TElectronvoltMeterPerSpeedOfLightUnit.*(const AValue: TQuantity; const ASelf: TElectronvoltMeterPerSpeedOfLightUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[cScalar, cKilogramSquareMeterPerSecond];
  result.FValue := AValue.FValue * 1.7826619216279E-36;
end;
{$ENDIF}

{$IFOPT D+}
class operator TElectronvoltMeterPerSpeedOfLightUnit./(const AValue: TQuantity; const ASelf: TElectronvoltMeterPerSpeedOfLightUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[cScalar, cKilogramSquareMeterPerSecond];
  result.FValue := AValue.FValue * 1.7826619216279E-36;
end;
{$ENDIF}

class operator TSquareJouleSquareSecondUnit.*(const AValue: double; const ASelf: TSquareJouleSquareSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cSquareJouleSquareSecond];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TSquareJouleSquareSecondUnit./(const AValue: double; const ASelf: TSquareJouleSquareSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cSquareJouleSquareSecond];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TSquareJouleSquareSecondUnit.*(const AValue: TQuantity; const ASelf: TSquareJouleSquareSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cSquareJouleSquareSecond];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TSquareJouleSquareSecondUnit./(const AValue: TQuantity; const ASelf: TSquareJouleSquareSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cSquareJouleSquareSecond];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TCoulombPerKilogramUnit.*(const AValue: double; const ASelf: TCoulombPerKilogramUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cCoulombPerKilogram];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TCoulombPerKilogramUnit./(const AValue: double; const ASelf: TCoulombPerKilogramUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cCoulombPerKilogram];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TCoulombPerKilogramUnit.*(const AValue: TQuantity; const ASelf: TCoulombPerKilogramUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cCoulombPerKilogram];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TCoulombPerKilogramUnit./(const AValue: TQuantity; const ASelf: TCoulombPerKilogramUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cCoulombPerKilogram];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TSquareMeterAmpereUnit.*(const AValue: double; const ASelf: TSquareMeterAmpereUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cSquareMeterAmpere];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TSquareMeterAmpereUnit./(const AValue: double; const ASelf: TSquareMeterAmpereUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cSquareMeterAmpere];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TSquareMeterAmpereUnit.*(const AValue: TQuantity; const ASelf: TSquareMeterAmpereUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cSquareMeterAmpere];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TSquareMeterAmpereUnit./(const AValue: TQuantity; const ASelf: TSquareMeterAmpereUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cSquareMeterAmpere];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TJoulePerTeslaUnit.*(const AValue: double; const ASelf: TJoulePerTeslaUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cSquareMeterAmpere];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

class operator TJoulePerTeslaUnit./(const AValue: double; const ASelf: TJoulePerTeslaUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cSquareMeterAmpere];
  result.FValue := AValue;
{$ELSE}
  result := AValue;
{$ENDIF}
end;

{$IFOPT D+}
class operator TJoulePerTeslaUnit.*(const AValue: TQuantity; const ASelf: TJoulePerTeslaUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cSquareMeterAmpere];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

{$IFOPT D+}
class operator TJoulePerTeslaUnit./(const AValue: TQuantity; const ASelf: TJoulePerTeslaUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cSquareMeterAmpere];
  result.FValue := AValue.FValue;
end;
{$ENDIF}

class operator TLumenPerWattUnit.*(const AValue: double; const ASelf: TLumenPerWattUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cLumenPerWatt];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TLumenPerWattUnit./(const AValue: double; const ASelf: TLumenPerWattUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cLumenPerWatt];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TLumenPerWattUnit.*(const AValue: TQuantity; const ASelf: TLumenPerWattUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cLumenPerWatt];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TLumenPerWattUnit./(const AValue: TQuantity; const ASelf: TLumenPerWattUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cLumenPerWatt];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TReciprocalMoleUnit.*(const AValue: double; const ASelf: TReciprocalMoleUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cReciprocalMole];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TReciprocalMoleUnit./(const AValue: double; const ASelf: TReciprocalMoleUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cReciprocalMole];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TReciprocalMoleUnit.*(const AValue: TQuantity; const ASelf: TReciprocalMoleUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cReciprocalMole];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TReciprocalMoleUnit./(const AValue: TQuantity; const ASelf: TReciprocalMoleUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cReciprocalMole];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TAmperePerSquareMeterUnit.*(const AValue: double; const ASelf: TAmperePerSquareMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cAmperePerSquareMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TAmperePerSquareMeterUnit./(const AValue: double; const ASelf: TAmperePerSquareMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cAmperePerSquareMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TAmperePerSquareMeterUnit.*(const AValue: TQuantity; const ASelf: TAmperePerSquareMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cAmperePerSquareMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TAmperePerSquareMeterUnit./(const AValue: TQuantity; const ASelf: TAmperePerSquareMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cAmperePerSquareMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TMolePerCubicMeterUnit.*(const AValue: double; const ASelf: TMolePerCubicMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cMolePerCubicMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TMolePerCubicMeterUnit./(const AValue: double; const ASelf: TMolePerCubicMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cMolePerCubicMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TMolePerCubicMeterUnit.*(const AValue: TQuantity; const ASelf: TMolePerCubicMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cMolePerCubicMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TMolePerCubicMeterUnit./(const AValue: TQuantity; const ASelf: TMolePerCubicMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cMolePerCubicMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TCandelaPerSquareMeterUnit.*(const AValue: double; const ASelf: TCandelaPerSquareMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cCandelaPerSquareMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TCandelaPerSquareMeterUnit./(const AValue: double; const ASelf: TCandelaPerSquareMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cCandelaPerSquareMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TCandelaPerSquareMeterUnit.*(const AValue: TQuantity; const ASelf: TCandelaPerSquareMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cCandelaPerSquareMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TCandelaPerSquareMeterUnit./(const AValue: TQuantity; const ASelf: TCandelaPerSquareMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cCandelaPerSquareMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TCoulombPerCubicMeterUnit.*(const AValue: double; const ASelf: TCoulombPerCubicMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cCoulombPerCubicMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TCoulombPerCubicMeterUnit./(const AValue: double; const ASelf: TCoulombPerCubicMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cCoulombPerCubicMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TCoulombPerCubicMeterUnit.*(const AValue: TQuantity; const ASelf: TCoulombPerCubicMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cCoulombPerCubicMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TCoulombPerCubicMeterUnit./(const AValue: TQuantity; const ASelf: TCoulombPerCubicMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cCoulombPerCubicMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TGrayPerSecondUnit.*(const AValue: double; const ASelf: TGrayPerSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cGrayPerSecond];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TGrayPerSecondUnit./(const AValue: double; const ASelf: TGrayPerSecondUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cGrayPerSecond];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TGrayPerSecondUnit.*(const AValue: TQuantity; const ASelf: TGrayPerSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cGrayPerSecond];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TGrayPerSecondUnit./(const AValue: TQuantity; const ASelf: TGrayPerSecondUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cGrayPerSecond];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TSteradianHertzUnit.*(const AValue: double; const ASelf: TSteradianHertzUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cSteradianHertz];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TSteradianHertzUnit./(const AValue: double; const ASelf: TSteradianHertzUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cSteradianHertz];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TSteradianHertzUnit.*(const AValue: TQuantity; const ASelf: TSteradianHertzUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cSteradianHertz];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TSteradianHertzUnit./(const AValue: TQuantity; const ASelf: TSteradianHertzUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cSteradianHertz];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TMeterSteradianUnit.*(const AValue: double; const ASelf: TMeterSteradianUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cMeterSteradian];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TMeterSteradianUnit./(const AValue: double; const ASelf: TMeterSteradianUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cMeterSteradian];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TMeterSteradianUnit.*(const AValue: TQuantity; const ASelf: TMeterSteradianUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cMeterSteradian];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TMeterSteradianUnit./(const AValue: TQuantity; const ASelf: TMeterSteradianUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cMeterSteradian];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TSquareMeterSteradianUnit.*(const AValue: double; const ASelf: TSquareMeterSteradianUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cSquareMeterSteradian];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TSquareMeterSteradianUnit./(const AValue: double; const ASelf: TSquareMeterSteradianUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cSquareMeterSteradian];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TSquareMeterSteradianUnit.*(const AValue: TQuantity; const ASelf: TSquareMeterSteradianUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cSquareMeterSteradian];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TSquareMeterSteradianUnit./(const AValue: TQuantity; const ASelf: TSquareMeterSteradianUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cSquareMeterSteradian];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TCubicMeterSteradianUnit.*(const AValue: double; const ASelf: TCubicMeterSteradianUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cCubicMeterSteradian];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TCubicMeterSteradianUnit./(const AValue: double; const ASelf: TCubicMeterSteradianUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cCubicMeterSteradian];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TCubicMeterSteradianUnit.*(const AValue: TQuantity; const ASelf: TCubicMeterSteradianUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cCubicMeterSteradian];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TCubicMeterSteradianUnit./(const AValue: TQuantity; const ASelf: TCubicMeterSteradianUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cCubicMeterSteradian];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TSquareMeterSteradianHertzUnit.*(const AValue: double; const ASelf: TSquareMeterSteradianHertzUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cSquareMeterSteradianHertz];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TSquareMeterSteradianHertzUnit./(const AValue: double; const ASelf: TSquareMeterSteradianHertzUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cSquareMeterSteradianHertz];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TSquareMeterSteradianHertzUnit.*(const AValue: TQuantity; const ASelf: TSquareMeterSteradianHertzUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cSquareMeterSteradianHertz];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TSquareMeterSteradianHertzUnit./(const AValue: TQuantity; const ASelf: TSquareMeterSteradianHertzUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cSquareMeterSteradianHertz];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TWattPerSteradianUnit.*(const AValue: double; const ASelf: TWattPerSteradianUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cWattPerSteradian];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TWattPerSteradianUnit./(const AValue: double; const ASelf: TWattPerSteradianUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cWattPerSteradian];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TWattPerSteradianUnit.*(const AValue: TQuantity; const ASelf: TWattPerSteradianUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cWattPerSteradian];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TWattPerSteradianUnit./(const AValue: TQuantity; const ASelf: TWattPerSteradianUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cWattPerSteradian];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TWattPerSteradianPerHertzUnit.*(const AValue: double; const ASelf: TWattPerSteradianPerHertzUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cWattPerSteradianPerHertz];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TWattPerSteradianPerHertzUnit./(const AValue: double; const ASelf: TWattPerSteradianPerHertzUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cWattPerSteradianPerHertz];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TWattPerSteradianPerHertzUnit.*(const AValue: TQuantity; const ASelf: TWattPerSteradianPerHertzUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cWattPerSteradianPerHertz];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TWattPerSteradianPerHertzUnit./(const AValue: TQuantity; const ASelf: TWattPerSteradianPerHertzUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cWattPerSteradianPerHertz];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TWattPerMeterPerSteradianUnit.*(const AValue: double; const ASelf: TWattPerMeterPerSteradianUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cWattPerMeterPerSteradian];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TWattPerMeterPerSteradianUnit./(const AValue: double; const ASelf: TWattPerMeterPerSteradianUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cWattPerMeterPerSteradian];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TWattPerMeterPerSteradianUnit.*(const AValue: TQuantity; const ASelf: TWattPerMeterPerSteradianUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cWattPerMeterPerSteradian];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TWattPerMeterPerSteradianUnit./(const AValue: TQuantity; const ASelf: TWattPerMeterPerSteradianUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cWattPerMeterPerSteradian];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TWattPerSquareMeterPerSteradianUnit.*(const AValue: double; const ASelf: TWattPerSquareMeterPerSteradianUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cWattPerSquareMeterPerSteradian];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TWattPerSquareMeterPerSteradianUnit./(const AValue: double; const ASelf: TWattPerSquareMeterPerSteradianUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cWattPerSquareMeterPerSteradian];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TWattPerSquareMeterPerSteradianUnit.*(const AValue: TQuantity; const ASelf: TWattPerSquareMeterPerSteradianUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cWattPerSquareMeterPerSteradian];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TWattPerSquareMeterPerSteradianUnit./(const AValue: TQuantity; const ASelf: TWattPerSquareMeterPerSteradianUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cWattPerSquareMeterPerSteradian];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TWattPerCubicMeterPerSteradianUnit.*(const AValue: double; const ASelf: TWattPerCubicMeterPerSteradianUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cWattPerCubicMeterPerSteradian];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TWattPerCubicMeterPerSteradianUnit./(const AValue: double; const ASelf: TWattPerCubicMeterPerSteradianUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cWattPerCubicMeterPerSteradian];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TWattPerCubicMeterPerSteradianUnit.*(const AValue: TQuantity; const ASelf: TWattPerCubicMeterPerSteradianUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cWattPerCubicMeterPerSteradian];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TWattPerCubicMeterPerSteradianUnit./(const AValue: TQuantity; const ASelf: TWattPerCubicMeterPerSteradianUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cWattPerCubicMeterPerSteradian];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TWattPerSquareMeterPerSteradianPerHertzUnit.*(const AValue: double; const ASelf: TWattPerSquareMeterPerSteradianPerHertzUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cWattPerSquareMeterPerSteradianPerHertz];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TWattPerSquareMeterPerSteradianPerHertzUnit./(const AValue: double; const ASelf: TWattPerSquareMeterPerSteradianPerHertzUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cWattPerSquareMeterPerSteradianPerHertz];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TWattPerSquareMeterPerSteradianPerHertzUnit.*(const AValue: TQuantity; const ASelf: TWattPerSquareMeterPerSteradianPerHertzUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cWattPerSquareMeterPerSteradianPerHertz];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TWattPerSquareMeterPerSteradianPerHertzUnit./(const AValue: TQuantity; const ASelf: TWattPerSquareMeterPerSteradianPerHertzUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cWattPerSquareMeterPerSteradianPerHertz];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TKatalPerCubicMeterUnit.*(const AValue: double; const ASelf: TKatalPerCubicMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cKatalPerCubicMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TKatalPerCubicMeterUnit./(const AValue: double; const ASelf: TKatalPerCubicMeterUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cKatalPerCubicMeter];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TKatalPerCubicMeterUnit.*(const AValue: TQuantity; const ASelf: TKatalPerCubicMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cKatalPerCubicMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TKatalPerCubicMeterUnit./(const AValue: TQuantity; const ASelf: TKatalPerCubicMeterUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cKatalPerCubicMeter];
  result.FValue := AValue.FValue
end;
{$ENDIF}

class operator TCoulombPerMoleUnit.*(const AValue: double; const ASelf: TCoulombPerMoleUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := MulTable[cScalar, cCoulombPerMole];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

class operator TCoulombPerMoleUnit./(const AValue: double; const ASelf: TCoulombPerMoleUnit): TQuantity; inline;
begin
{$IFOPT D+}
  result.FUnitOfMeasurement := DivTable[cScalar, cCoulombPerMole];
  result.FValue := AValue
{$ELSE}
  result := AValue
{$ENDIF}
end;

{$IFOPT D+}
class operator TCoulombPerMoleUnit.*(const AValue: TQuantity; const ASelf: TCoulombPerMoleUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := MulTable[AValue.FUnitOfMeasurement, cCoulombPerMole];
  result.FValue := AValue.FValue
end;
{$ENDIF}

{$IFOPT D+}
class operator TCoulombPerMoleUnit./(const AValue: TQuantity; const ASelf: TCoulombPerMoleUnit): TQuantity; inline;
begin
  result.FUnitOfMeasurement := DivTable[AValue.FUnitOfMeasurement, cCoulombPerMole];
  result.FValue := AValue.FValue
end;
{$ENDIF}

function ScalarToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cScalar then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsScalarSymbol, cScalarPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsScalarSymbol, cScalarPrefixes);
{$ENDIF}
end;

function ScalarToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cScalar then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cScalarPrefixes, cScalarExponents, cScalarExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cScalarPrefixes, cScalarExponents, cScalarExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsScalarSymbol, cScalarPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsScalarSymbol, APrefixes);
end;

function ScalarToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cScalar then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function ScalarToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cScalar then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function ScalarToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cScalar then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function RadianToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cScalar then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function RadianToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cScalar then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cRadianPrefixes, cRadianExponents, cRadianExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cRadianPrefixes, cRadianExponents, cRadianExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsRadianSymbol, cRadianPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsRadianSymbol, APrefixes);
end;

function RadianToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cScalar then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function RadianToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cScalar then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function RadianToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cScalar then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function DegreeToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cScalar then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function DegreeToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cScalar then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cDegreePrefixes, cDegreeExponents, cDegreeExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cDegreePrefixes, cDegreeExponents, cDegreeExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsDegreeSymbol, cDegreePrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsDegreeSymbol, APrefixes);
end;

function DegreeToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cScalar then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function DegreeToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cScalar then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function DegreeToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cScalar then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function SteradianToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cScalar then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SteradianToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cScalar then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSteradianPrefixes, cSteradianExponents, cSteradianExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSteradianPrefixes, cSteradianExponents, cSteradianExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSteradianSymbol, cSteradianPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSteradianSymbol, APrefixes);
end;

function SteradianToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cScalar then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SteradianToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cScalar then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SteradianToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cScalar then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function SquareDegreeToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cScalar then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareDegreeToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cScalar then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSquareDegreePrefixes, cSquareDegreeExponents, cSquareDegreeExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSquareDegreePrefixes, cSquareDegreeExponents, cSquareDegreeExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareDegreeSymbol, cSquareDegreePrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareDegreeSymbol, APrefixes);
end;

function SquareDegreeToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cScalar then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareDegreeToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cScalar then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareDegreeToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cScalar then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function SecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSecond then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsSecondSymbol, cSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsSecondSymbol, cSecondPrefixes);
{$ENDIF}
end;

function SecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSecond then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSecondPrefixes, cSecondExponents, cSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSecondPrefixes, cSecondExponents, cSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSecondSymbol, cSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSecondSymbol, APrefixes);
end;

function SecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function DayToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function DayToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSecond then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cDayPrefixes, cDayExponents, cDayExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cDayPrefixes, cDayExponents, cDayExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsDaySymbol, cDayPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsDaySymbol, APrefixes);
end;

function DayToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function DayToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function DayToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function HourToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function HourToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSecond then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cHourPrefixes, cHourExponents, cHourExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cHourPrefixes, cHourExponents, cHourExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsHourSymbol, cHourPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsHourSymbol, APrefixes);
end;

function HourToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function HourToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function HourToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function MinuteToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function MinuteToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSecond then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cMinutePrefixes, cMinuteExponents, cMinuteExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cMinutePrefixes, cMinuteExponents, cMinuteExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMinuteSymbol, cMinutePrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMinuteSymbol, APrefixes);
end;

function MinuteToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function MinuteToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function MinuteToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function SquareSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsSquareSecondSymbol, cSquareSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsSquareSecondSymbol, cSquareSecondPrefixes);
{$ENDIF}
end;

function SquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSquareSecondPrefixes, cSquareSecondExponents, cSquareSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSquareSecondPrefixes, cSquareSecondExponents, cSquareSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareSecondSymbol, cSquareSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareSecondSymbol, APrefixes);
end;

function SquareSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function SquareDayToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareDayToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSquareDayPrefixes, cSquareDayExponents, cSquareDayExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSquareDayPrefixes, cSquareDayExponents, cSquareDayExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareDaySymbol, cSquareDayPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareDaySymbol, APrefixes);
end;

function SquareDayToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareDayToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareDayToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function SquareHourToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareHourToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSquareHourPrefixes, cSquareHourExponents, cSquareHourExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSquareHourPrefixes, cSquareHourExponents, cSquareHourExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareHourSymbol, cSquareHourPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareHourSymbol, APrefixes);
end;

function SquareHourToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareHourToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareHourToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function SquareMinuteToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareMinuteToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSquareMinutePrefixes, cSquareMinuteExponents, cSquareMinuteExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSquareMinutePrefixes, cSquareMinuteExponents, cSquareMinuteExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareMinuteSymbol, cSquareMinutePrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareMinuteSymbol, APrefixes);
end;

function SquareMinuteToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareMinuteToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareMinuteToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function CubicSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicSecond then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsCubicSecondSymbol, cCubicSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsCubicSecondSymbol, cCubicSecondPrefixes);
{$ENDIF}
end;

function CubicSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicSecond then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cCubicSecondPrefixes, cCubicSecondExponents, cCubicSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cCubicSecondPrefixes, cCubicSecondExponents, cCubicSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCubicSecondSymbol, cCubicSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCubicSecondSymbol, APrefixes);
end;

function CubicSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function CubicSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function CubicSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function QuarticSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cQuarticSecond then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsQuarticSecondSymbol, cQuarticSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsQuarticSecondSymbol, cQuarticSecondPrefixes);
{$ENDIF}
end;

function QuarticSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cQuarticSecond then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cQuarticSecondPrefixes, cQuarticSecondExponents, cQuarticSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cQuarticSecondPrefixes, cQuarticSecondExponents, cQuarticSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsQuarticSecondSymbol, cQuarticSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsQuarticSecondSymbol, APrefixes);
end;

function QuarticSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cQuarticSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function QuarticSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cQuarticSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function QuarticSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cQuarticSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function QuinticSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cQuinticSecond then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsQuinticSecondSymbol, cQuinticSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsQuinticSecondSymbol, cQuinticSecondPrefixes);
{$ENDIF}
end;

function QuinticSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cQuinticSecond then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cQuinticSecondPrefixes, cQuinticSecondExponents, cQuinticSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cQuinticSecondPrefixes, cQuinticSecondExponents, cQuinticSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsQuinticSecondSymbol, cQuinticSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsQuinticSecondSymbol, APrefixes);
end;

function QuinticSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cQuinticSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function QuinticSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cQuinticSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function QuinticSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cQuinticSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function SexticSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSexticSecond then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsSexticSecondSymbol, cSexticSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsSexticSecondSymbol, cSexticSecondPrefixes);
{$ENDIF}
end;

function SexticSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSexticSecond then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSexticSecondPrefixes, cSexticSecondExponents, cSexticSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSexticSecondPrefixes, cSexticSecondExponents, cSexticSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSexticSecondSymbol, cSexticSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSexticSecondSymbol, APrefixes);
end;

function SexticSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSexticSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SexticSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSexticSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SexticSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSexticSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function MeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsMeterSymbol, cMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsMeterSymbol, cMeterPrefixes);
{$ENDIF}
end;

function MeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cMeterPrefixes, cMeterExponents, cMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cMeterPrefixes, cMeterExponents, cMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterSymbol, cMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterSymbol, APrefixes);
end;

function MeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function MeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function MeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function AstronomicalToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function AstronomicalToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cAstronomicalPrefixes, cAstronomicalExponents, cAstronomicalExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cAstronomicalPrefixes, cAstronomicalExponents, cAstronomicalExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsAstronomicalSymbol, cAstronomicalPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsAstronomicalSymbol, APrefixes);
end;

function AstronomicalToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function AstronomicalToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function AstronomicalToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function InchToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function InchToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cInchPrefixes, cInchExponents, cInchExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cInchPrefixes, cInchExponents, cInchExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsInchSymbol, cInchPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsInchSymbol, APrefixes);
end;

function InchToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function InchToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function InchToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function FootToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function FootToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cFootPrefixes, cFootExponents, cFootExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cFootPrefixes, cFootExponents, cFootExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsFootSymbol, cFootPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsFootSymbol, APrefixes);
end;

function FootToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function FootToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function FootToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function YardToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function YardToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cYardPrefixes, cYardExponents, cYardExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cYardPrefixes, cYardExponents, cYardExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsYardSymbol, cYardPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsYardSymbol, APrefixes);
end;

function YardToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function YardToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function YardToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function MileToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function MileToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cMilePrefixes, cMileExponents, cMileExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cMilePrefixes, cMileExponents, cMileExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMileSymbol, cMilePrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMileSymbol, APrefixes);
end;

function MileToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function MileToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function MileToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function NauticalMileToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function NauticalMileToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cNauticalMilePrefixes, cNauticalMileExponents, cNauticalMileExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cNauticalMilePrefixes, cNauticalMileExponents, cNauticalMileExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNauticalMileSymbol, cNauticalMilePrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNauticalMileSymbol, APrefixes);
end;

function NauticalMileToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function NauticalMileToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function NauticalMileToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function AngstromToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function AngstromToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cAngstromPrefixes, cAngstromExponents, cAngstromExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cAngstromPrefixes, cAngstromExponents, cAngstromExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsAngstromSymbol, cAngstromPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsAngstromSymbol, APrefixes);
end;

function AngstromToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function AngstromToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function AngstromToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function SquareRootMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareRootMeter then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsSquareRootMeterSymbol, cSquareRootMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsSquareRootMeterSymbol, cSquareRootMeterPrefixes);
{$ENDIF}
end;

function SquareRootMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareRootMeter then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSquareRootMeterPrefixes, cSquareRootMeterExponents, cSquareRootMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSquareRootMeterPrefixes, cSquareRootMeterExponents, cSquareRootMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareRootMeterSymbol, cSquareRootMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareRootMeterSymbol, APrefixes);
end;

function SquareRootMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareRootMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareRootMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareRootMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareRootMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareRootMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function SquareMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsSquareMeterSymbol, cSquareMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsSquareMeterSymbol, cSquareMeterPrefixes);
{$ENDIF}
end;

function SquareMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSquareMeterPrefixes, cSquareMeterExponents, cSquareMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSquareMeterPrefixes, cSquareMeterExponents, cSquareMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareMeterSymbol, cSquareMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareMeterSymbol, APrefixes);
end;

function SquareMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function SquareInchToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareInchToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSquareInchPrefixes, cSquareInchExponents, cSquareInchExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSquareInchPrefixes, cSquareInchExponents, cSquareInchExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareInchSymbol, cSquareInchPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareInchSymbol, APrefixes);
end;

function SquareInchToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareInchToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareInchToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function SquareFootToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareFootToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSquareFootPrefixes, cSquareFootExponents, cSquareFootExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSquareFootPrefixes, cSquareFootExponents, cSquareFootExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareFootSymbol, cSquareFootPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareFootSymbol, APrefixes);
end;

function SquareFootToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareFootToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareFootToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function SquareYardToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareYardToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSquareYardPrefixes, cSquareYardExponents, cSquareYardExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSquareYardPrefixes, cSquareYardExponents, cSquareYardExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareYardSymbol, cSquareYardPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareYardSymbol, APrefixes);
end;

function SquareYardToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareYardToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareYardToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function SquareMileToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareMileToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSquareMilePrefixes, cSquareMileExponents, cSquareMileExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSquareMilePrefixes, cSquareMileExponents, cSquareMileExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareMileSymbol, cSquareMilePrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareMileSymbol, APrefixes);
end;

function SquareMileToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareMileToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareMileToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function CubicMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsCubicMeterSymbol, cCubicMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsCubicMeterSymbol, cCubicMeterPrefixes);
{$ENDIF}
end;

function CubicMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cCubicMeterPrefixes, cCubicMeterExponents, cCubicMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cCubicMeterPrefixes, cCubicMeterExponents, cCubicMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCubicMeterSymbol, cCubicMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCubicMeterSymbol, APrefixes);
end;

function CubicMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function CubicMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function CubicMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function CubicInchToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function CubicInchToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cCubicInchPrefixes, cCubicInchExponents, cCubicInchExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cCubicInchPrefixes, cCubicInchExponents, cCubicInchExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCubicInchSymbol, cCubicInchPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCubicInchSymbol, APrefixes);
end;

function CubicInchToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function CubicInchToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function CubicInchToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function CubicFootToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function CubicFootToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cCubicFootPrefixes, cCubicFootExponents, cCubicFootExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cCubicFootPrefixes, cCubicFootExponents, cCubicFootExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCubicFootSymbol, cCubicFootPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCubicFootSymbol, APrefixes);
end;

function CubicFootToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function CubicFootToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function CubicFootToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function CubicYardToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function CubicYardToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cCubicYardPrefixes, cCubicYardExponents, cCubicYardExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cCubicYardPrefixes, cCubicYardExponents, cCubicYardExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCubicYardSymbol, cCubicYardPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCubicYardSymbol, APrefixes);
end;

function CubicYardToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function CubicYardToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function CubicYardToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function LitreToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function LitreToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cLitrePrefixes, cLitreExponents, cLitreExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cLitrePrefixes, cLitreExponents, cLitreExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsLitreSymbol, cLitrePrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsLitreSymbol, APrefixes);
end;

function LitreToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function LitreToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function LitreToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function GallonToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function GallonToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cGallonPrefixes, cGallonExponents, cGallonExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cGallonPrefixes, cGallonExponents, cGallonExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsGallonSymbol, cGallonPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsGallonSymbol, APrefixes);
end;

function GallonToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function GallonToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function GallonToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function QuarticMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cQuarticMeter then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsQuarticMeterSymbol, cQuarticMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsQuarticMeterSymbol, cQuarticMeterPrefixes);
{$ENDIF}
end;

function QuarticMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cQuarticMeter then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cQuarticMeterPrefixes, cQuarticMeterExponents, cQuarticMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cQuarticMeterPrefixes, cQuarticMeterExponents, cQuarticMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsQuarticMeterSymbol, cQuarticMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsQuarticMeterSymbol, APrefixes);
end;

function QuarticMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cQuarticMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function QuarticMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cQuarticMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function QuarticMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cQuarticMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function QuinticMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cQuinticMeter then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsQuinticMeterSymbol, cQuinticMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsQuinticMeterSymbol, cQuinticMeterPrefixes);
{$ENDIF}
end;

function QuinticMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cQuinticMeter then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cQuinticMeterPrefixes, cQuinticMeterExponents, cQuinticMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cQuinticMeterPrefixes, cQuinticMeterExponents, cQuinticMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsQuinticMeterSymbol, cQuinticMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsQuinticMeterSymbol, APrefixes);
end;

function QuinticMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cQuinticMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function QuinticMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cQuinticMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function QuinticMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cQuinticMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function SexticMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSexticMeter then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsSexticMeterSymbol, cSexticMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsSexticMeterSymbol, cSexticMeterPrefixes);
{$ENDIF}
end;

function SexticMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSexticMeter then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSexticMeterPrefixes, cSexticMeterExponents, cSexticMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSexticMeterPrefixes, cSexticMeterExponents, cSexticMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSexticMeterSymbol, cSexticMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSexticMeterSymbol, APrefixes);
end;

function SexticMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSexticMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SexticMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSexticMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SexticMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSexticMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function KilogramToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogram then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsKilogramSymbol, cKilogramPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsKilogramSymbol, cKilogramPrefixes);
{$ENDIF}
end;

function KilogramToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogram then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cKilogramPrefixes, cKilogramExponents, cKilogramExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cKilogramPrefixes, cKilogramExponents, cKilogramExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramSymbol, cKilogramPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramSymbol, APrefixes);
end;

function KilogramToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogram then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogram then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogram then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function TonneToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogram then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function TonneToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogram then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cTonnePrefixes, cTonneExponents, cTonneExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cTonnePrefixes, cTonneExponents, cTonneExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsTonneSymbol, cTonnePrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsTonneSymbol, APrefixes);
end;

function TonneToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogram then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function TonneToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogram then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function TonneToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogram then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function PoundToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogram then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function PoundToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogram then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cPoundPrefixes, cPoundExponents, cPoundExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cPoundPrefixes, cPoundExponents, cPoundExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsPoundSymbol, cPoundPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsPoundSymbol, APrefixes);
end;

function PoundToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogram then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function PoundToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogram then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function PoundToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogram then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function OunceToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogram then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function OunceToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogram then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cOuncePrefixes, cOunceExponents, cOunceExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cOuncePrefixes, cOunceExponents, cOunceExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsOunceSymbol, cOuncePrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsOunceSymbol, APrefixes);
end;

function OunceToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogram then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function OunceToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogram then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function OunceToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogram then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function StoneToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogram then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function StoneToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogram then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cStonePrefixes, cStoneExponents, cStoneExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cStonePrefixes, cStoneExponents, cStoneExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsStoneSymbol, cStonePrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsStoneSymbol, APrefixes);
end;

function StoneToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogram then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function StoneToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogram then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function StoneToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogram then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function TonToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogram then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function TonToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogram then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cTonPrefixes, cTonExponents, cTonExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cTonPrefixes, cTonExponents, cTonExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsTonSymbol, cTonPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsTonSymbol, APrefixes);
end;

function TonToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogram then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function TonToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogram then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function TonToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogram then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function ElectronvoltPerSquareSpeedOfLightToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogram then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function ElectronvoltPerSquareSpeedOfLightToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogram then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cElectronvoltPerSquareSpeedOfLightPrefixes, cElectronvoltPerSquareSpeedOfLightExponents, cElectronvoltPerSquareSpeedOfLightExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cElectronvoltPerSquareSpeedOfLightPrefixes, cElectronvoltPerSquareSpeedOfLightExponents, cElectronvoltPerSquareSpeedOfLightExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsElectronvoltPerSquareSpeedOfLightSymbol, cElectronvoltPerSquareSpeedOfLightPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsElectronvoltPerSquareSpeedOfLightSymbol, APrefixes);
end;

function ElectronvoltPerSquareSpeedOfLightToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogram then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function ElectronvoltPerSquareSpeedOfLightToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogram then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function ElectronvoltPerSquareSpeedOfLightToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogram then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function SquareKilogramToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareKilogram then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsSquareKilogramSymbol, cSquareKilogramPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsSquareKilogramSymbol, cSquareKilogramPrefixes);
{$ENDIF}
end;

function SquareKilogramToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareKilogram then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSquareKilogramPrefixes, cSquareKilogramExponents, cSquareKilogramExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSquareKilogramPrefixes, cSquareKilogramExponents, cSquareKilogramExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareKilogramSymbol, cSquareKilogramPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareKilogramSymbol, APrefixes);
end;

function SquareKilogramToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareKilogram then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareKilogramToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareKilogram then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareKilogramToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareKilogram then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function AmpereToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cAmpere then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsAmpereSymbol, cAmperePrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsAmpereSymbol, cAmperePrefixes);
{$ENDIF}
end;

function AmpereToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cAmpere then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cAmperePrefixes, cAmpereExponents, cAmpereExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cAmperePrefixes, cAmpereExponents, cAmpereExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsAmpereSymbol, cAmperePrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsAmpereSymbol, APrefixes);
end;

function AmpereToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cAmpere then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function AmpereToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cAmpere then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function AmpereToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cAmpere then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function SquareAmpereToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareAmpere then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsSquareAmpereSymbol, cSquareAmperePrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsSquareAmpereSymbol, cSquareAmperePrefixes);
{$ENDIF}
end;

function SquareAmpereToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareAmpere then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSquareAmperePrefixes, cSquareAmpereExponents, cSquareAmpereExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSquareAmperePrefixes, cSquareAmpereExponents, cSquareAmpereExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareAmpereSymbol, cSquareAmperePrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareAmpereSymbol, APrefixes);
end;

function SquareAmpereToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareAmpere then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareAmpereToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareAmpere then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareAmpereToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareAmpere then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function KelvinToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKelvin then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsKelvinSymbol, cKelvinPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsKelvinSymbol, cKelvinPrefixes);
{$ENDIF}
end;

function KelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKelvin then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cKelvinPrefixes, cKelvinExponents, cKelvinExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cKelvinPrefixes, cKelvinExponents, cKelvinExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKelvinSymbol, cKelvinPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKelvinSymbol, APrefixes);
end;

function KelvinToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKelvin then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKelvin then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KelvinToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKelvin then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function DegreeCelsiusToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKelvin then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function DegreeCelsiusToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKelvin then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cDegreeCelsiusPrefixes, cDegreeCelsiusExponents, cDegreeCelsiusExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cDegreeCelsiusPrefixes, cDegreeCelsiusExponents, cDegreeCelsiusExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsDegreeCelsiusSymbol, cDegreeCelsiusPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsDegreeCelsiusSymbol, APrefixes);
end;

function DegreeCelsiusToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKelvin then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function DegreeCelsiusToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKelvin then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function DegreeCelsiusToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKelvin then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function DegreeFahrenheitToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKelvin then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function DegreeFahrenheitToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKelvin then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cDegreeFahrenheitPrefixes, cDegreeFahrenheitExponents, cDegreeFahrenheitExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cDegreeFahrenheitPrefixes, cDegreeFahrenheitExponents, cDegreeFahrenheitExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsDegreeFahrenheitSymbol, cDegreeFahrenheitPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsDegreeFahrenheitSymbol, APrefixes);
end;

function DegreeFahrenheitToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKelvin then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function DegreeFahrenheitToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKelvin then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function DegreeFahrenheitToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKelvin then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function SquareKelvinToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareKelvin then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsSquareKelvinSymbol, cSquareKelvinPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsSquareKelvinSymbol, cSquareKelvinPrefixes);
{$ENDIF}
end;

function SquareKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareKelvin then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSquareKelvinPrefixes, cSquareKelvinExponents, cSquareKelvinExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSquareKelvinPrefixes, cSquareKelvinExponents, cSquareKelvinExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareKelvinSymbol, cSquareKelvinPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareKelvinSymbol, APrefixes);
end;

function SquareKelvinToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareKelvin then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareKelvin then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareKelvinToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareKelvin then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function CubicKelvinToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicKelvin then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsCubicKelvinSymbol, cCubicKelvinPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsCubicKelvinSymbol, cCubicKelvinPrefixes);
{$ENDIF}
end;

function CubicKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicKelvin then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cCubicKelvinPrefixes, cCubicKelvinExponents, cCubicKelvinExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cCubicKelvinPrefixes, cCubicKelvinExponents, cCubicKelvinExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCubicKelvinSymbol, cCubicKelvinPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCubicKelvinSymbol, APrefixes);
end;

function CubicKelvinToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicKelvin then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function CubicKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicKelvin then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function CubicKelvinToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicKelvin then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function QuarticKelvinToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cQuarticKelvin then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsQuarticKelvinSymbol, cQuarticKelvinPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsQuarticKelvinSymbol, cQuarticKelvinPrefixes);
{$ENDIF}
end;

function QuarticKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cQuarticKelvin then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cQuarticKelvinPrefixes, cQuarticKelvinExponents, cQuarticKelvinExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cQuarticKelvinPrefixes, cQuarticKelvinExponents, cQuarticKelvinExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsQuarticKelvinSymbol, cQuarticKelvinPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsQuarticKelvinSymbol, APrefixes);
end;

function QuarticKelvinToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cQuarticKelvin then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function QuarticKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cQuarticKelvin then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function QuarticKelvinToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cQuarticKelvin then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function MoleToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMole then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsMoleSymbol, cMolePrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsMoleSymbol, cMolePrefixes);
{$ENDIF}
end;

function MoleToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMole then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cMolePrefixes, cMoleExponents, cMoleExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cMolePrefixes, cMoleExponents, cMoleExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMoleSymbol, cMolePrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMoleSymbol, APrefixes);
end;

function MoleToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMole then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function MoleToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMole then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function MoleToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMole then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function CandelaToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCandela then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsCandelaSymbol, cCandelaPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsCandelaSymbol, cCandelaPrefixes);
{$ENDIF}
end;

function CandelaToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCandela then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cCandelaPrefixes, cCandelaExponents, cCandelaExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cCandelaPrefixes, cCandelaExponents, cCandelaExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCandelaSymbol, cCandelaPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCandelaSymbol, APrefixes);
end;

function CandelaToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCandela then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function CandelaToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCandela then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function CandelaToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCandela then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function HertzToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHertz then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsHertzSymbol, cHertzPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsHertzSymbol, cHertzPrefixes);
{$ENDIF}
end;

function HertzToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHertz then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cHertzPrefixes, cHertzExponents, cHertzExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cHertzPrefixes, cHertzExponents, cHertzExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsHertzSymbol, cHertzPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsHertzSymbol, APrefixes);
end;

function HertzToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHertz then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function HertzToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHertz then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function HertzToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHertz then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function ReciprocalSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHertz then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function ReciprocalSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHertz then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cReciprocalSecondPrefixes, cReciprocalSecondExponents, cReciprocalSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cReciprocalSecondPrefixes, cReciprocalSecondExponents, cReciprocalSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsReciprocalSecondSymbol, cReciprocalSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsReciprocalSecondSymbol, APrefixes);
end;

function ReciprocalSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHertz then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function ReciprocalSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHertz then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function ReciprocalSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHertz then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function RadianPerSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHertz then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function RadianPerSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHertz then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cRadianPerSecondPrefixes, cRadianPerSecondExponents, cRadianPerSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cRadianPerSecondPrefixes, cRadianPerSecondExponents, cRadianPerSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsRadianPerSecondSymbol, cRadianPerSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsRadianPerSecondSymbol, APrefixes);
end;

function RadianPerSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHertz then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function RadianPerSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHertz then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function RadianPerSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHertz then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function SquareHertzToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareHertz then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsSquareHertzSymbol, cSquareHertzPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsSquareHertzSymbol, cSquareHertzPrefixes);
{$ENDIF}
end;

function SquareHertzToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareHertz then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSquareHertzPrefixes, cSquareHertzExponents, cSquareHertzExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSquareHertzPrefixes, cSquareHertzExponents, cSquareHertzExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareHertzSymbol, cSquareHertzPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareHertzSymbol, APrefixes);
end;

function SquareHertzToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareHertz then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareHertzToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareHertz then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareHertzToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareHertz then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function ReciprocalSquareSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareHertz then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function ReciprocalSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareHertz then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cReciprocalSquareSecondPrefixes, cReciprocalSquareSecondExponents, cReciprocalSquareSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cReciprocalSquareSecondPrefixes, cReciprocalSquareSecondExponents, cReciprocalSquareSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsReciprocalSquareSecondSymbol, cReciprocalSquareSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsReciprocalSquareSecondSymbol, APrefixes);
end;

function ReciprocalSquareSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareHertz then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function ReciprocalSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareHertz then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function ReciprocalSquareSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareHertz then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function RadianPerSquareSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareHertz then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function RadianPerSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareHertz then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cRadianPerSquareSecondPrefixes, cRadianPerSquareSecondExponents, cRadianPerSquareSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cRadianPerSquareSecondPrefixes, cRadianPerSquareSecondExponents, cRadianPerSquareSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsRadianPerSquareSecondSymbol, cRadianPerSquareSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsRadianPerSquareSecondSymbol, APrefixes);
end;

function RadianPerSquareSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareHertz then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function RadianPerSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareHertz then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function RadianPerSquareSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareHertz then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function SteradianPerSquareSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSteradianPerSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsSteradianPerSquareSecondSymbol, cSteradianPerSquareSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsSteradianPerSquareSecondSymbol, cSteradianPerSquareSecondPrefixes);
{$ENDIF}
end;

function SteradianPerSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSteradianPerSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSteradianPerSquareSecondPrefixes, cSteradianPerSquareSecondExponents, cSteradianPerSquareSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSteradianPerSquareSecondPrefixes, cSteradianPerSquareSecondExponents, cSteradianPerSquareSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSteradianPerSquareSecondSymbol, cSteradianPerSquareSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSteradianPerSquareSecondSymbol, APrefixes);
end;

function SteradianPerSquareSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSteradianPerSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SteradianPerSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSteradianPerSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SteradianPerSquareSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSteradianPerSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function MeterPerSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSecond then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsMeterPerSecondSymbol, cMeterPerSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsMeterPerSecondSymbol, cMeterPerSecondPrefixes);
{$ENDIF}
end;

function MeterPerSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSecond then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cMeterPerSecondPrefixes, cMeterPerSecondExponents, cMeterPerSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cMeterPerSecondPrefixes, cMeterPerSecondExponents, cMeterPerSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterPerSecondSymbol, cMeterPerSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterPerSecondSymbol, APrefixes);
end;

function MeterPerSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function MeterPerSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function MeterPerSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function MeterPerHourToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function MeterPerHourToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSecond then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cMeterPerHourPrefixes, cMeterPerHourExponents, cMeterPerHourExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cMeterPerHourPrefixes, cMeterPerHourExponents, cMeterPerHourExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterPerHourSymbol, cMeterPerHourPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterPerHourSymbol, APrefixes);
end;

function MeterPerHourToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function MeterPerHourToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function MeterPerHourToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function MilePerHourToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function MilePerHourToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSecond then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cMilePerHourPrefixes, cMilePerHourExponents, cMilePerHourExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cMilePerHourPrefixes, cMilePerHourExponents, cMilePerHourExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMilePerHourSymbol, cMilePerHourPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMilePerHourSymbol, APrefixes);
end;

function MilePerHourToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function MilePerHourToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function MilePerHourToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function NauticalMilePerHourToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function NauticalMilePerHourToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSecond then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cNauticalMilePerHourPrefixes, cNauticalMilePerHourExponents, cNauticalMilePerHourExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cNauticalMilePerHourPrefixes, cNauticalMilePerHourExponents, cNauticalMilePerHourExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNauticalMilePerHourSymbol, cNauticalMilePerHourPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNauticalMilePerHourSymbol, APrefixes);
end;

function NauticalMilePerHourToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function NauticalMilePerHourToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function NauticalMilePerHourToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function MeterPerSquareSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsMeterPerSquareSecondSymbol, cMeterPerSquareSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsMeterPerSquareSecondSymbol, cMeterPerSquareSecondPrefixes);
{$ENDIF}
end;

function MeterPerSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cMeterPerSquareSecondPrefixes, cMeterPerSquareSecondExponents, cMeterPerSquareSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cMeterPerSquareSecondPrefixes, cMeterPerSquareSecondExponents, cMeterPerSquareSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterPerSquareSecondSymbol, cMeterPerSquareSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterPerSquareSecondSymbol, APrefixes);
end;

function MeterPerSquareSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function MeterPerSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function MeterPerSquareSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function MeterPerSecondPerSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function MeterPerSecondPerSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cMeterPerSecondPerSecondPrefixes, cMeterPerSecondPerSecondExponents, cMeterPerSecondPerSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cMeterPerSecondPerSecondPrefixes, cMeterPerSecondPerSecondExponents, cMeterPerSecondPerSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterPerSecondPerSecondSymbol, cMeterPerSecondPerSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterPerSecondPerSecondSymbol, APrefixes);
end;

function MeterPerSecondPerSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function MeterPerSecondPerSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function MeterPerSecondPerSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function MeterPerHourPerSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function MeterPerHourPerSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cMeterPerHourPerSecondPrefixes, cMeterPerHourPerSecondExponents, cMeterPerHourPerSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cMeterPerHourPerSecondPrefixes, cMeterPerHourPerSecondExponents, cMeterPerHourPerSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterPerHourPerSecondSymbol, cMeterPerHourPerSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterPerHourPerSecondSymbol, APrefixes);
end;

function MeterPerHourPerSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function MeterPerHourPerSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function MeterPerHourPerSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function MeterPerCubicSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerCubicSecond then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsMeterPerCubicSecondSymbol, cMeterPerCubicSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsMeterPerCubicSecondSymbol, cMeterPerCubicSecondPrefixes);
{$ENDIF}
end;

function MeterPerCubicSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerCubicSecond then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cMeterPerCubicSecondPrefixes, cMeterPerCubicSecondExponents, cMeterPerCubicSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cMeterPerCubicSecondPrefixes, cMeterPerCubicSecondExponents, cMeterPerCubicSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterPerCubicSecondSymbol, cMeterPerCubicSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterPerCubicSecondSymbol, APrefixes);
end;

function MeterPerCubicSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerCubicSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function MeterPerCubicSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerCubicSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function MeterPerCubicSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerCubicSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function MeterPerQuarticSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerQuarticSecond then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsMeterPerQuarticSecondSymbol, cMeterPerQuarticSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsMeterPerQuarticSecondSymbol, cMeterPerQuarticSecondPrefixes);
{$ENDIF}
end;

function MeterPerQuarticSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerQuarticSecond then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cMeterPerQuarticSecondPrefixes, cMeterPerQuarticSecondExponents, cMeterPerQuarticSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cMeterPerQuarticSecondPrefixes, cMeterPerQuarticSecondExponents, cMeterPerQuarticSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterPerQuarticSecondSymbol, cMeterPerQuarticSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterPerQuarticSecondSymbol, APrefixes);
end;

function MeterPerQuarticSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerQuarticSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function MeterPerQuarticSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerQuarticSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function MeterPerQuarticSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerQuarticSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function MeterPerQuinticSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerQuinticSecond then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsMeterPerQuinticSecondSymbol, cMeterPerQuinticSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsMeterPerQuinticSecondSymbol, cMeterPerQuinticSecondPrefixes);
{$ENDIF}
end;

function MeterPerQuinticSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerQuinticSecond then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cMeterPerQuinticSecondPrefixes, cMeterPerQuinticSecondExponents, cMeterPerQuinticSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cMeterPerQuinticSecondPrefixes, cMeterPerQuinticSecondExponents, cMeterPerQuinticSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterPerQuinticSecondSymbol, cMeterPerQuinticSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterPerQuinticSecondSymbol, APrefixes);
end;

function MeterPerQuinticSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerQuinticSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function MeterPerQuinticSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerQuinticSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function MeterPerQuinticSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerQuinticSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function MeterPerSexticSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSexticSecond then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsMeterPerSexticSecondSymbol, cMeterPerSexticSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsMeterPerSexticSecondSymbol, cMeterPerSexticSecondPrefixes);
{$ENDIF}
end;

function MeterPerSexticSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSexticSecond then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cMeterPerSexticSecondPrefixes, cMeterPerSexticSecondExponents, cMeterPerSexticSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cMeterPerSexticSecondPrefixes, cMeterPerSexticSecondExponents, cMeterPerSexticSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterPerSexticSecondSymbol, cMeterPerSexticSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterPerSexticSecondSymbol, APrefixes);
end;

function MeterPerSexticSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSexticSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function MeterPerSexticSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSexticSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function MeterPerSexticSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerSexticSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function SquareMeterPerSquareSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterPerSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsSquareMeterPerSquareSecondSymbol, cSquareMeterPerSquareSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsSquareMeterPerSquareSecondSymbol, cSquareMeterPerSquareSecondPrefixes);
{$ENDIF}
end;

function SquareMeterPerSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterPerSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSquareMeterPerSquareSecondPrefixes, cSquareMeterPerSquareSecondExponents, cSquareMeterPerSquareSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSquareMeterPerSquareSecondPrefixes, cSquareMeterPerSquareSecondExponents, cSquareMeterPerSquareSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareMeterPerSquareSecondSymbol, cSquareMeterPerSquareSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareMeterPerSquareSecondSymbol, APrefixes);
end;

function SquareMeterPerSquareSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterPerSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareMeterPerSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterPerSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareMeterPerSquareSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterPerSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function JoulePerKilogramToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterPerSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function JoulePerKilogramToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterPerSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cJoulePerKilogramPrefixes, cJoulePerKilogramExponents, cJoulePerKilogramExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cJoulePerKilogramPrefixes, cJoulePerKilogramExponents, cJoulePerKilogramExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsJoulePerKilogramSymbol, cJoulePerKilogramPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsJoulePerKilogramSymbol, APrefixes);
end;

function JoulePerKilogramToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterPerSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function JoulePerKilogramToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterPerSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function JoulePerKilogramToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterPerSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function GrayToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterPerSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function GrayToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterPerSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cGrayPrefixes, cGrayExponents, cGrayExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cGrayPrefixes, cGrayExponents, cGrayExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsGraySymbol, cGrayPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsGraySymbol, APrefixes);
end;

function GrayToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterPerSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function GrayToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterPerSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function GrayToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterPerSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function SievertToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterPerSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SievertToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterPerSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSievertPrefixes, cSievertExponents, cSievertExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSievertPrefixes, cSievertExponents, cSievertExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSievertSymbol, cSievertPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSievertSymbol, APrefixes);
end;

function SievertToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterPerSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SievertToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterPerSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SievertToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterPerSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function MeterSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterSecond then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsMeterSecondSymbol, cMeterSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsMeterSecondSymbol, cMeterSecondPrefixes);
{$ENDIF}
end;

function MeterSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterSecond then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cMeterSecondPrefixes, cMeterSecondExponents, cMeterSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cMeterSecondPrefixes, cMeterSecondExponents, cMeterSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterSecondSymbol, cMeterSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterSecondSymbol, APrefixes);
end;

function MeterSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function MeterSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function MeterSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function KilogramMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramMeter then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsKilogramMeterSymbol, cKilogramMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsKilogramMeterSymbol, cKilogramMeterPrefixes);
{$ENDIF}
end;

function KilogramMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramMeter then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cKilogramMeterPrefixes, cKilogramMeterExponents, cKilogramMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cKilogramMeterPrefixes, cKilogramMeterExponents, cKilogramMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramMeterSymbol, cKilogramMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramMeterSymbol, APrefixes);
end;

function KilogramMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function KilogramPerSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerSecond then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsKilogramPerSecondSymbol, cKilogramPerSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsKilogramPerSecondSymbol, cKilogramPerSecondPrefixes);
{$ENDIF}
end;

function KilogramPerSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerSecond then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cKilogramPerSecondPrefixes, cKilogramPerSecondExponents, cKilogramPerSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cKilogramPerSecondPrefixes, cKilogramPerSecondExponents, cKilogramPerSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramPerSecondSymbol, cKilogramPerSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramPerSecondSymbol, APrefixes);
end;

function KilogramPerSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramPerSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramPerSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function JoulePerSquareMeterPerHertzToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function JoulePerSquareMeterPerHertzToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerSecond then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cJoulePerSquareMeterPerHertzPrefixes, cJoulePerSquareMeterPerHertzExponents, cJoulePerSquareMeterPerHertzExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cJoulePerSquareMeterPerHertzPrefixes, cJoulePerSquareMeterPerHertzExponents, cJoulePerSquareMeterPerHertzExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsJoulePerSquareMeterPerHertzSymbol, cJoulePerSquareMeterPerHertzPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsJoulePerSquareMeterPerHertzSymbol, APrefixes);
end;

function JoulePerSquareMeterPerHertzToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function JoulePerSquareMeterPerHertzToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function JoulePerSquareMeterPerHertzToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function KilogramMeterPerSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramMeterPerSecond then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsKilogramMeterPerSecondSymbol, cKilogramMeterPerSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsKilogramMeterPerSecondSymbol, cKilogramMeterPerSecondPrefixes);
{$ENDIF}
end;

function KilogramMeterPerSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramMeterPerSecond then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cKilogramMeterPerSecondPrefixes, cKilogramMeterPerSecondExponents, cKilogramMeterPerSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cKilogramMeterPerSecondPrefixes, cKilogramMeterPerSecondExponents, cKilogramMeterPerSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramMeterPerSecondSymbol, cKilogramMeterPerSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramMeterPerSecondSymbol, APrefixes);
end;

function KilogramMeterPerSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramMeterPerSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramMeterPerSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramMeterPerSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramMeterPerSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramMeterPerSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function NewtonSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramMeterPerSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function NewtonSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramMeterPerSecond then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cNewtonSecondPrefixes, cNewtonSecondExponents, cNewtonSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cNewtonSecondPrefixes, cNewtonSecondExponents, cNewtonSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonSecondSymbol, cNewtonSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonSecondSymbol, APrefixes);
end;

function NewtonSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramMeterPerSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function NewtonSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramMeterPerSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function NewtonSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramMeterPerSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function SquareKilogramSquareMeterPerSquareSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareKilogramSquareMeterPerSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsSquareKilogramSquareMeterPerSquareSecondSymbol, cSquareKilogramSquareMeterPerSquareSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsSquareKilogramSquareMeterPerSquareSecondSymbol, cSquareKilogramSquareMeterPerSquareSecondPrefixes);
{$ENDIF}
end;

function SquareKilogramSquareMeterPerSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareKilogramSquareMeterPerSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSquareKilogramSquareMeterPerSquareSecondPrefixes, cSquareKilogramSquareMeterPerSquareSecondExponents, cSquareKilogramSquareMeterPerSquareSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSquareKilogramSquareMeterPerSquareSecondPrefixes, cSquareKilogramSquareMeterPerSquareSecondExponents, cSquareKilogramSquareMeterPerSquareSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareKilogramSquareMeterPerSquareSecondSymbol, cSquareKilogramSquareMeterPerSquareSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareKilogramSquareMeterPerSquareSecondSymbol, APrefixes);
end;

function SquareKilogramSquareMeterPerSquareSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareKilogramSquareMeterPerSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareKilogramSquareMeterPerSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareKilogramSquareMeterPerSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareKilogramSquareMeterPerSquareSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareKilogramSquareMeterPerSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function ReciprocalSquareRootMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalSquareRootMeter then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsReciprocalSquareRootMeterSymbol, cReciprocalSquareRootMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsReciprocalSquareRootMeterSymbol, cReciprocalSquareRootMeterPrefixes);
{$ENDIF}
end;

function ReciprocalSquareRootMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalSquareRootMeter then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cReciprocalSquareRootMeterPrefixes, cReciprocalSquareRootMeterExponents, cReciprocalSquareRootMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cReciprocalSquareRootMeterPrefixes, cReciprocalSquareRootMeterExponents, cReciprocalSquareRootMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsReciprocalSquareRootMeterSymbol, cReciprocalSquareRootMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsReciprocalSquareRootMeterSymbol, APrefixes);
end;

function ReciprocalSquareRootMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalSquareRootMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function ReciprocalSquareRootMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalSquareRootMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function ReciprocalSquareRootMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalSquareRootMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function ReciprocalMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalMeter then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsReciprocalMeterSymbol, cReciprocalMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsReciprocalMeterSymbol, cReciprocalMeterPrefixes);
{$ENDIF}
end;

function ReciprocalMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalMeter then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cReciprocalMeterPrefixes, cReciprocalMeterExponents, cReciprocalMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cReciprocalMeterPrefixes, cReciprocalMeterExponents, cReciprocalMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsReciprocalMeterSymbol, cReciprocalMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsReciprocalMeterSymbol, APrefixes);
end;

function ReciprocalMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function ReciprocalMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function ReciprocalMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function DioptreToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function DioptreToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalMeter then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cDioptrePrefixes, cDioptreExponents, cDioptreExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cDioptrePrefixes, cDioptreExponents, cDioptreExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsDioptreSymbol, cDioptrePrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsDioptreSymbol, APrefixes);
end;

function DioptreToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function DioptreToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function DioptreToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function ReciprocalSquareRootCubicMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalSquareRootCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsReciprocalSquareRootCubicMeterSymbol, cReciprocalSquareRootCubicMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsReciprocalSquareRootCubicMeterSymbol, cReciprocalSquareRootCubicMeterPrefixes);
{$ENDIF}
end;

function ReciprocalSquareRootCubicMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalSquareRootCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cReciprocalSquareRootCubicMeterPrefixes, cReciprocalSquareRootCubicMeterExponents, cReciprocalSquareRootCubicMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cReciprocalSquareRootCubicMeterPrefixes, cReciprocalSquareRootCubicMeterExponents, cReciprocalSquareRootCubicMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsReciprocalSquareRootCubicMeterSymbol, cReciprocalSquareRootCubicMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsReciprocalSquareRootCubicMeterSymbol, APrefixes);
end;

function ReciprocalSquareRootCubicMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalSquareRootCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function ReciprocalSquareRootCubicMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalSquareRootCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function ReciprocalSquareRootCubicMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalSquareRootCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function ReciprocalSquareMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsReciprocalSquareMeterSymbol, cReciprocalSquareMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsReciprocalSquareMeterSymbol, cReciprocalSquareMeterPrefixes);
{$ENDIF}
end;

function ReciprocalSquareMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cReciprocalSquareMeterPrefixes, cReciprocalSquareMeterExponents, cReciprocalSquareMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cReciprocalSquareMeterPrefixes, cReciprocalSquareMeterExponents, cReciprocalSquareMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsReciprocalSquareMeterSymbol, cReciprocalSquareMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsReciprocalSquareMeterSymbol, APrefixes);
end;

function ReciprocalSquareMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function ReciprocalSquareMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function ReciprocalSquareMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function ReciprocalCubicMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsReciprocalCubicMeterSymbol, cReciprocalCubicMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsReciprocalCubicMeterSymbol, cReciprocalCubicMeterPrefixes);
{$ENDIF}
end;

function ReciprocalCubicMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cReciprocalCubicMeterPrefixes, cReciprocalCubicMeterExponents, cReciprocalCubicMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cReciprocalCubicMeterPrefixes, cReciprocalCubicMeterExponents, cReciprocalCubicMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsReciprocalCubicMeterSymbol, cReciprocalCubicMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsReciprocalCubicMeterSymbol, APrefixes);
end;

function ReciprocalCubicMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function ReciprocalCubicMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function ReciprocalCubicMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function ReciprocalQuarticMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalQuarticMeter then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsReciprocalQuarticMeterSymbol, cReciprocalQuarticMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsReciprocalQuarticMeterSymbol, cReciprocalQuarticMeterPrefixes);
{$ENDIF}
end;

function ReciprocalQuarticMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalQuarticMeter then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cReciprocalQuarticMeterPrefixes, cReciprocalQuarticMeterExponents, cReciprocalQuarticMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cReciprocalQuarticMeterPrefixes, cReciprocalQuarticMeterExponents, cReciprocalQuarticMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsReciprocalQuarticMeterSymbol, cReciprocalQuarticMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsReciprocalQuarticMeterSymbol, APrefixes);
end;

function ReciprocalQuarticMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalQuarticMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function ReciprocalQuarticMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalQuarticMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function ReciprocalQuarticMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalQuarticMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function KilogramSquareMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsKilogramSquareMeterSymbol, cKilogramSquareMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsKilogramSquareMeterSymbol, cKilogramSquareMeterPrefixes);
{$ENDIF}
end;

function KilogramSquareMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cKilogramSquareMeterPrefixes, cKilogramSquareMeterExponents, cKilogramSquareMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cKilogramSquareMeterPrefixes, cKilogramSquareMeterExponents, cKilogramSquareMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramSquareMeterSymbol, cKilogramSquareMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramSquareMeterSymbol, APrefixes);
end;

function KilogramSquareMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramSquareMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramSquareMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function KilogramSquareMeterPerSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareMeterPerSecond then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsKilogramSquareMeterPerSecondSymbol, cKilogramSquareMeterPerSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsKilogramSquareMeterPerSecondSymbol, cKilogramSquareMeterPerSecondPrefixes);
{$ENDIF}
end;

function KilogramSquareMeterPerSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareMeterPerSecond then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cKilogramSquareMeterPerSecondPrefixes, cKilogramSquareMeterPerSecondExponents, cKilogramSquareMeterPerSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cKilogramSquareMeterPerSecondPrefixes, cKilogramSquareMeterPerSecondExponents, cKilogramSquareMeterPerSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramSquareMeterPerSecondSymbol, cKilogramSquareMeterPerSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramSquareMeterPerSecondSymbol, APrefixes);
end;

function KilogramSquareMeterPerSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareMeterPerSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramSquareMeterPerSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareMeterPerSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramSquareMeterPerSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareMeterPerSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function NewtonMeterSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareMeterPerSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function NewtonMeterSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareMeterPerSecond then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cNewtonMeterSecondPrefixes, cNewtonMeterSecondExponents, cNewtonMeterSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cNewtonMeterSecondPrefixes, cNewtonMeterSecondExponents, cNewtonMeterSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonMeterSecondSymbol, cNewtonMeterSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonMeterSecondSymbol, APrefixes);
end;

function NewtonMeterSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareMeterPerSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function NewtonMeterSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareMeterPerSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function NewtonMeterSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareMeterPerSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function SecondPerMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSecondPerMeter then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsSecondPerMeterSymbol, cSecondPerMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsSecondPerMeterSymbol, cSecondPerMeterPrefixes);
{$ENDIF}
end;

function SecondPerMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSecondPerMeter then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSecondPerMeterPrefixes, cSecondPerMeterExponents, cSecondPerMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSecondPerMeterPrefixes, cSecondPerMeterExponents, cSecondPerMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSecondPerMeterSymbol, cSecondPerMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSecondPerMeterSymbol, APrefixes);
end;

function SecondPerMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSecondPerMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SecondPerMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSecondPerMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SecondPerMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSecondPerMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function KilogramPerMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerMeter then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsKilogramPerMeterSymbol, cKilogramPerMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsKilogramPerMeterSymbol, cKilogramPerMeterPrefixes);
{$ENDIF}
end;

function KilogramPerMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerMeter then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cKilogramPerMeterPrefixes, cKilogramPerMeterExponents, cKilogramPerMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cKilogramPerMeterPrefixes, cKilogramPerMeterExponents, cKilogramPerMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramPerMeterSymbol, cKilogramPerMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramPerMeterSymbol, APrefixes);
end;

function KilogramPerMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramPerMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramPerMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function KilogramPerSquareMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsKilogramPerSquareMeterSymbol, cKilogramPerSquareMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsKilogramPerSquareMeterSymbol, cKilogramPerSquareMeterPrefixes);
{$ENDIF}
end;

function KilogramPerSquareMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cKilogramPerSquareMeterPrefixes, cKilogramPerSquareMeterExponents, cKilogramPerSquareMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cKilogramPerSquareMeterPrefixes, cKilogramPerSquareMeterExponents, cKilogramPerSquareMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramPerSquareMeterSymbol, cKilogramPerSquareMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramPerSquareMeterSymbol, APrefixes);
end;

function KilogramPerSquareMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramPerSquareMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramPerSquareMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function KilogramPerCubicMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsKilogramPerCubicMeterSymbol, cKilogramPerCubicMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsKilogramPerCubicMeterSymbol, cKilogramPerCubicMeterPrefixes);
{$ENDIF}
end;

function KilogramPerCubicMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cKilogramPerCubicMeterPrefixes, cKilogramPerCubicMeterExponents, cKilogramPerCubicMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cKilogramPerCubicMeterPrefixes, cKilogramPerCubicMeterExponents, cKilogramPerCubicMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramPerCubicMeterSymbol, cKilogramPerCubicMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramPerCubicMeterSymbol, APrefixes);
end;

function KilogramPerCubicMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramPerCubicMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramPerCubicMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function PoundPerCubicInchToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function PoundPerCubicInchToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cPoundPerCubicInchPrefixes, cPoundPerCubicInchExponents, cPoundPerCubicInchExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cPoundPerCubicInchPrefixes, cPoundPerCubicInchExponents, cPoundPerCubicInchExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsPoundPerCubicInchSymbol, cPoundPerCubicInchPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsPoundPerCubicInchSymbol, APrefixes);
end;

function PoundPerCubicInchToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function PoundPerCubicInchToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function PoundPerCubicInchToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function NewtonToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewton then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsNewtonSymbol, cNewtonPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsNewtonSymbol, cNewtonPrefixes);
{$ENDIF}
end;

function NewtonToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewton then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cNewtonPrefixes, cNewtonExponents, cNewtonExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cNewtonPrefixes, cNewtonExponents, cNewtonExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonSymbol, cNewtonPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonSymbol, APrefixes);
end;

function NewtonToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewton then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function NewtonToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewton then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function NewtonToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewton then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function PoundForceToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewton then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function PoundForceToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewton then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cPoundForcePrefixes, cPoundForceExponents, cPoundForceExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cPoundForcePrefixes, cPoundForceExponents, cPoundForceExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsPoundForceSymbol, cPoundForcePrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsPoundForceSymbol, APrefixes);
end;

function PoundForceToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewton then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function PoundForceToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewton then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function PoundForceToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewton then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function KilogramMeterPerSquareSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewton then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramMeterPerSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewton then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cKilogramMeterPerSquareSecondPrefixes, cKilogramMeterPerSquareSecondExponents, cKilogramMeterPerSquareSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cKilogramMeterPerSquareSecondPrefixes, cKilogramMeterPerSquareSecondExponents, cKilogramMeterPerSquareSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramMeterPerSquareSecondSymbol, cKilogramMeterPerSquareSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramMeterPerSquareSecondSymbol, APrefixes);
end;

function KilogramMeterPerSquareSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewton then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramMeterPerSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewton then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramMeterPerSquareSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewton then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function NewtonRadianToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonRadian then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsNewtonRadianSymbol, cNewtonRadianPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsNewtonRadianSymbol, cNewtonRadianPrefixes);
{$ENDIF}
end;

function NewtonRadianToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonRadian then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cNewtonRadianPrefixes, cNewtonRadianExponents, cNewtonRadianExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cNewtonRadianPrefixes, cNewtonRadianExponents, cNewtonRadianExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonRadianSymbol, cNewtonRadianPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonRadianSymbol, APrefixes);
end;

function NewtonRadianToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonRadian then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function NewtonRadianToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonRadian then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function NewtonRadianToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonRadian then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function SquareNewtonToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareNewton then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsSquareNewtonSymbol, cSquareNewtonPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsSquareNewtonSymbol, cSquareNewtonPrefixes);
{$ENDIF}
end;

function SquareNewtonToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareNewton then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSquareNewtonPrefixes, cSquareNewtonExponents, cSquareNewtonExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSquareNewtonPrefixes, cSquareNewtonExponents, cSquareNewtonExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareNewtonSymbol, cSquareNewtonPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareNewtonSymbol, APrefixes);
end;

function SquareNewtonToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareNewton then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareNewtonToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareNewton then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareNewtonToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareNewton then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function SquareKilogramSquareMeterPerQuarticSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareNewton then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareKilogramSquareMeterPerQuarticSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareNewton then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSquareKilogramSquareMeterPerQuarticSecondPrefixes, cSquareKilogramSquareMeterPerQuarticSecondExponents, cSquareKilogramSquareMeterPerQuarticSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSquareKilogramSquareMeterPerQuarticSecondPrefixes, cSquareKilogramSquareMeterPerQuarticSecondExponents, cSquareKilogramSquareMeterPerQuarticSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareKilogramSquareMeterPerQuarticSecondSymbol, cSquareKilogramSquareMeterPerQuarticSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareKilogramSquareMeterPerQuarticSecondSymbol, APrefixes);
end;

function SquareKilogramSquareMeterPerQuarticSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareNewton then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareKilogramSquareMeterPerQuarticSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareNewton then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareKilogramSquareMeterPerQuarticSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareNewton then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function PascalToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPascal then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsPascalSymbol, cPascalPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsPascalSymbol, cPascalPrefixes);
{$ENDIF}
end;

function PascalToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPascal then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cPascalPrefixes, cPascalExponents, cPascalExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cPascalPrefixes, cPascalExponents, cPascalExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsPascalSymbol, cPascalPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsPascalSymbol, APrefixes);
end;

function PascalToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPascal then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function PascalToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPascal then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function PascalToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPascal then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function NewtonPerSquareMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPascal then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function NewtonPerSquareMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPascal then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cNewtonPerSquareMeterPrefixes, cNewtonPerSquareMeterExponents, cNewtonPerSquareMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cNewtonPerSquareMeterPrefixes, cNewtonPerSquareMeterExponents, cNewtonPerSquareMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonPerSquareMeterSymbol, cNewtonPerSquareMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonPerSquareMeterSymbol, APrefixes);
end;

function NewtonPerSquareMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPascal then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function NewtonPerSquareMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPascal then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function NewtonPerSquareMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPascal then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function BarToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPascal then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function BarToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPascal then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cBarPrefixes, cBarExponents, cBarExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cBarPrefixes, cBarExponents, cBarExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsBarSymbol, cBarPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsBarSymbol, APrefixes);
end;

function BarToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPascal then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function BarToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPascal then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function BarToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPascal then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function PoundPerSquareInchToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPascal then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function PoundPerSquareInchToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPascal then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cPoundPerSquareInchPrefixes, cPoundPerSquareInchExponents, cPoundPerSquareInchExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cPoundPerSquareInchPrefixes, cPoundPerSquareInchExponents, cPoundPerSquareInchExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsPoundPerSquareInchSymbol, cPoundPerSquareInchPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsPoundPerSquareInchSymbol, APrefixes);
end;

function PoundPerSquareInchToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPascal then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function PoundPerSquareInchToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPascal then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function PoundPerSquareInchToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPascal then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function JoulePerCubicMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPascal then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function JoulePerCubicMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPascal then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cJoulePerCubicMeterPrefixes, cJoulePerCubicMeterExponents, cJoulePerCubicMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cJoulePerCubicMeterPrefixes, cJoulePerCubicMeterExponents, cJoulePerCubicMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsJoulePerCubicMeterSymbol, cJoulePerCubicMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsJoulePerCubicMeterSymbol, APrefixes);
end;

function JoulePerCubicMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPascal then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function JoulePerCubicMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPascal then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function JoulePerCubicMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPascal then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function KilogramPerMeterPerSquareSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPascal then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramPerMeterPerSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPascal then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cKilogramPerMeterPerSquareSecondPrefixes, cKilogramPerMeterPerSquareSecondExponents, cKilogramPerMeterPerSquareSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cKilogramPerMeterPerSquareSecondPrefixes, cKilogramPerMeterPerSquareSecondExponents, cKilogramPerMeterPerSquareSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramPerMeterPerSquareSecondSymbol, cKilogramPerMeterPerSquareSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramPerMeterPerSquareSecondSymbol, APrefixes);
end;

function KilogramPerMeterPerSquareSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPascal then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramPerMeterPerSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPascal then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramPerMeterPerSquareSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPascal then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function JouleToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsJouleSymbol, cJoulePrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsJouleSymbol, cJoulePrefixes);
{$ENDIF}
end;

function JouleToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cJoulePrefixes, cJouleExponents, cJouleExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cJoulePrefixes, cJouleExponents, cJouleExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsJouleSymbol, cJoulePrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsJouleSymbol, APrefixes);
end;

function JouleToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function JouleToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function JouleToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function WattHourToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function WattHourToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cWattHourPrefixes, cWattHourExponents, cWattHourExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cWattHourPrefixes, cWattHourExponents, cWattHourExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattHourSymbol, cWattHourPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattHourSymbol, APrefixes);
end;

function WattHourToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function WattHourToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function WattHourToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function WattSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function WattSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cWattSecondPrefixes, cWattSecondExponents, cWattSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cWattSecondPrefixes, cWattSecondExponents, cWattSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattSecondSymbol, cWattSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattSecondSymbol, APrefixes);
end;

function WattSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function WattSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function WattSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function WattPerHertzToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function WattPerHertzToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cWattPerHertzPrefixes, cWattPerHertzExponents, cWattPerHertzExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cWattPerHertzPrefixes, cWattPerHertzExponents, cWattPerHertzExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattPerHertzSymbol, cWattPerHertzPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattPerHertzSymbol, APrefixes);
end;

function WattPerHertzToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function WattPerHertzToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function WattPerHertzToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function ElectronvoltToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function ElectronvoltToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cElectronvoltPrefixes, cElectronvoltExponents, cElectronvoltExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cElectronvoltPrefixes, cElectronvoltExponents, cElectronvoltExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsElectronvoltSymbol, cElectronvoltPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsElectronvoltSymbol, APrefixes);
end;

function ElectronvoltToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function ElectronvoltToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function ElectronvoltToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function NewtonMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function NewtonMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cNewtonMeterPrefixes, cNewtonMeterExponents, cNewtonMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cNewtonMeterPrefixes, cNewtonMeterExponents, cNewtonMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonMeterSymbol, cNewtonMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonMeterSymbol, APrefixes);
end;

function NewtonMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function NewtonMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function NewtonMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function PoundForceInchToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function PoundForceInchToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cPoundForceInchPrefixes, cPoundForceInchExponents, cPoundForceInchExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cPoundForceInchPrefixes, cPoundForceInchExponents, cPoundForceInchExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsPoundForceInchSymbol, cPoundForceInchPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsPoundForceInchSymbol, APrefixes);
end;

function PoundForceInchToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function PoundForceInchToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function PoundForceInchToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function RydbergToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function RydbergToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cRydbergPrefixes, cRydbergExponents, cRydbergExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cRydbergPrefixes, cRydbergExponents, cRydbergExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsRydbergSymbol, cRydbergPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsRydbergSymbol, APrefixes);
end;

function RydbergToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function RydbergToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function RydbergToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function CalorieToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function CalorieToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cCaloriePrefixes, cCalorieExponents, cCalorieExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cCaloriePrefixes, cCalorieExponents, cCalorieExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCalorieSymbol, cCaloriePrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCalorieSymbol, APrefixes);
end;

function CalorieToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function CalorieToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function CalorieToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function KilogramSquareMeterPerSquareSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramSquareMeterPerSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cKilogramSquareMeterPerSquareSecondPrefixes, cKilogramSquareMeterPerSquareSecondExponents, cKilogramSquareMeterPerSquareSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cKilogramSquareMeterPerSquareSecondPrefixes, cKilogramSquareMeterPerSquareSecondExponents, cKilogramSquareMeterPerSquareSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramSquareMeterPerSquareSecondSymbol, cKilogramSquareMeterPerSquareSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramSquareMeterPerSquareSecondSymbol, APrefixes);
end;

function KilogramSquareMeterPerSquareSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramSquareMeterPerSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramSquareMeterPerSquareSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoule then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function JoulePerRadianToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerRadian then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsJoulePerRadianSymbol, cJoulePerRadianPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsJoulePerRadianSymbol, cJoulePerRadianPrefixes);
{$ENDIF}
end;

function JoulePerRadianToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerRadian then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cJoulePerRadianPrefixes, cJoulePerRadianExponents, cJoulePerRadianExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cJoulePerRadianPrefixes, cJoulePerRadianExponents, cJoulePerRadianExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsJoulePerRadianSymbol, cJoulePerRadianPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsJoulePerRadianSymbol, APrefixes);
end;

function JoulePerRadianToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerRadian then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function JoulePerRadianToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerRadian then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function JoulePerRadianToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerRadian then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function JoulePerDegreeToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerRadian then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function JoulePerDegreeToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerRadian then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cJoulePerDegreePrefixes, cJoulePerDegreeExponents, cJoulePerDegreeExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cJoulePerDegreePrefixes, cJoulePerDegreeExponents, cJoulePerDegreeExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsJoulePerDegreeSymbol, cJoulePerDegreePrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsJoulePerDegreeSymbol, APrefixes);
end;

function JoulePerDegreeToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerRadian then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function JoulePerDegreeToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerRadian then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function JoulePerDegreeToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerRadian then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function NewtonMeterPerRadianToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerRadian then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function NewtonMeterPerRadianToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerRadian then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cNewtonMeterPerRadianPrefixes, cNewtonMeterPerRadianExponents, cNewtonMeterPerRadianExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cNewtonMeterPerRadianPrefixes, cNewtonMeterPerRadianExponents, cNewtonMeterPerRadianExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonMeterPerRadianSymbol, cNewtonMeterPerRadianPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonMeterPerRadianSymbol, APrefixes);
end;

function NewtonMeterPerRadianToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerRadian then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function NewtonMeterPerRadianToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerRadian then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function NewtonMeterPerRadianToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerRadian then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function NewtonMeterPerDegreeToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerRadian then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function NewtonMeterPerDegreeToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerRadian then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cNewtonMeterPerDegreePrefixes, cNewtonMeterPerDegreeExponents, cNewtonMeterPerDegreeExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cNewtonMeterPerDegreePrefixes, cNewtonMeterPerDegreeExponents, cNewtonMeterPerDegreeExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonMeterPerDegreeSymbol, cNewtonMeterPerDegreePrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonMeterPerDegreeSymbol, APrefixes);
end;

function NewtonMeterPerDegreeToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerRadian then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function NewtonMeterPerDegreeToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerRadian then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function NewtonMeterPerDegreeToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerRadian then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function KilogramSquareMeterPerSquareSecondPerRadianToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerRadian then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramSquareMeterPerSquareSecondPerRadianToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerRadian then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cKilogramSquareMeterPerSquareSecondPerRadianPrefixes, cKilogramSquareMeterPerSquareSecondPerRadianExponents, cKilogramSquareMeterPerSquareSecondPerRadianExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cKilogramSquareMeterPerSquareSecondPerRadianPrefixes, cKilogramSquareMeterPerSquareSecondPerRadianExponents, cKilogramSquareMeterPerSquareSecondPerRadianExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramSquareMeterPerSquareSecondPerRadianSymbol, cKilogramSquareMeterPerSquareSecondPerRadianPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramSquareMeterPerSquareSecondPerRadianSymbol, APrefixes);
end;

function KilogramSquareMeterPerSquareSecondPerRadianToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerRadian then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramSquareMeterPerSquareSecondPerRadianToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerRadian then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramSquareMeterPerSquareSecondPerRadianToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerRadian then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function WattToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWatt then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsWattSymbol, cWattPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsWattSymbol, cWattPrefixes);
{$ENDIF}
end;

function WattToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWatt then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cWattPrefixes, cWattExponents, cWattExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cWattPrefixes, cWattExponents, cWattExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattSymbol, cWattPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattSymbol, APrefixes);
end;

function WattToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWatt then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function WattToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWatt then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function WattToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWatt then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function KilogramSquareMeterPerCubicSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWatt then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramSquareMeterPerCubicSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWatt then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cKilogramSquareMeterPerCubicSecondPrefixes, cKilogramSquareMeterPerCubicSecondExponents, cKilogramSquareMeterPerCubicSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cKilogramSquareMeterPerCubicSecondPrefixes, cKilogramSquareMeterPerCubicSecondExponents, cKilogramSquareMeterPerCubicSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramSquareMeterPerCubicSecondSymbol, cKilogramSquareMeterPerCubicSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramSquareMeterPerCubicSecondSymbol, APrefixes);
end;

function KilogramSquareMeterPerCubicSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWatt then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramSquareMeterPerCubicSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWatt then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramSquareMeterPerCubicSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWatt then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function CoulombToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulomb then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsCoulombSymbol, cCoulombPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsCoulombSymbol, cCoulombPrefixes);
{$ENDIF}
end;

function CoulombToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulomb then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cCoulombPrefixes, cCoulombExponents, cCoulombExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cCoulombPrefixes, cCoulombExponents, cCoulombExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCoulombSymbol, cCoulombPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCoulombSymbol, APrefixes);
end;

function CoulombToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulomb then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function CoulombToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulomb then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function CoulombToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulomb then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function AmpereHourToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulomb then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function AmpereHourToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulomb then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cAmpereHourPrefixes, cAmpereHourExponents, cAmpereHourExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cAmpereHourPrefixes, cAmpereHourExponents, cAmpereHourExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsAmpereHourSymbol, cAmpereHourPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsAmpereHourSymbol, APrefixes);
end;

function AmpereHourToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulomb then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function AmpereHourToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulomb then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function AmpereHourToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulomb then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function AmpereSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulomb then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function AmpereSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulomb then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cAmpereSecondPrefixes, cAmpereSecondExponents, cAmpereSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cAmpereSecondPrefixes, cAmpereSecondExponents, cAmpereSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsAmpereSecondSymbol, cAmpereSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsAmpereSecondSymbol, APrefixes);
end;

function AmpereSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulomb then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function AmpereSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulomb then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function AmpereSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulomb then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function SquareCoulombToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareCoulomb then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsSquareCoulombSymbol, cSquareCoulombPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsSquareCoulombSymbol, cSquareCoulombPrefixes);
{$ENDIF}
end;

function SquareCoulombToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareCoulomb then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSquareCoulombPrefixes, cSquareCoulombExponents, cSquareCoulombExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSquareCoulombPrefixes, cSquareCoulombExponents, cSquareCoulombExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareCoulombSymbol, cSquareCoulombPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareCoulombSymbol, APrefixes);
end;

function SquareCoulombToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareCoulomb then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareCoulombToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareCoulomb then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareCoulombToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareCoulomb then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function SquareAmpereSquareSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareCoulomb then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareAmpereSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareCoulomb then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSquareAmpereSquareSecondPrefixes, cSquareAmpereSquareSecondExponents, cSquareAmpereSquareSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSquareAmpereSquareSecondPrefixes, cSquareAmpereSquareSecondExponents, cSquareAmpereSquareSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareAmpereSquareSecondSymbol, cSquareAmpereSquareSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareAmpereSquareSecondSymbol, APrefixes);
end;

function SquareAmpereSquareSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareCoulomb then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareAmpereSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareCoulomb then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareAmpereSquareSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareCoulomb then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function CoulombMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulombMeter then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsCoulombMeterSymbol, cCoulombMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsCoulombMeterSymbol, cCoulombMeterPrefixes);
{$ENDIF}
end;

function CoulombMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulombMeter then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cCoulombMeterPrefixes, cCoulombMeterExponents, cCoulombMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cCoulombMeterPrefixes, cCoulombMeterExponents, cCoulombMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCoulombMeterSymbol, cCoulombMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCoulombMeterSymbol, APrefixes);
end;

function CoulombMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulombMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function CoulombMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulombMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function CoulombMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulombMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function VoltToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVolt then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsVoltSymbol, cVoltPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsVoltSymbol, cVoltPrefixes);
{$ENDIF}
end;

function VoltToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVolt then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cVoltPrefixes, cVoltExponents, cVoltExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cVoltPrefixes, cVoltExponents, cVoltExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsVoltSymbol, cVoltPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsVoltSymbol, APrefixes);
end;

function VoltToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVolt then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function VoltToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVolt then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function VoltToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVolt then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function JoulePerCoulombToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVolt then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function JoulePerCoulombToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVolt then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cJoulePerCoulombPrefixes, cJoulePerCoulombExponents, cJoulePerCoulombExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cJoulePerCoulombPrefixes, cJoulePerCoulombExponents, cJoulePerCoulombExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsJoulePerCoulombSymbol, cJoulePerCoulombPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsJoulePerCoulombSymbol, APrefixes);
end;

function JoulePerCoulombToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVolt then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function JoulePerCoulombToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVolt then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function JoulePerCoulombToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVolt then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function KilogramSquareMeterPerAmperePerCubicSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVolt then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramSquareMeterPerAmperePerCubicSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVolt then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cKilogramSquareMeterPerAmperePerCubicSecondPrefixes, cKilogramSquareMeterPerAmperePerCubicSecondExponents, cKilogramSquareMeterPerAmperePerCubicSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cKilogramSquareMeterPerAmperePerCubicSecondPrefixes, cKilogramSquareMeterPerAmperePerCubicSecondExponents, cKilogramSquareMeterPerAmperePerCubicSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramSquareMeterPerAmperePerCubicSecondSymbol, cKilogramSquareMeterPerAmperePerCubicSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramSquareMeterPerAmperePerCubicSecondSymbol, APrefixes);
end;

function KilogramSquareMeterPerAmperePerCubicSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVolt then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramSquareMeterPerAmperePerCubicSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVolt then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramSquareMeterPerAmperePerCubicSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVolt then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function SquareVoltToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareVolt then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsSquareVoltSymbol, cSquareVoltPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsSquareVoltSymbol, cSquareVoltPrefixes);
{$ENDIF}
end;

function SquareVoltToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareVolt then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSquareVoltPrefixes, cSquareVoltExponents, cSquareVoltExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSquareVoltPrefixes, cSquareVoltExponents, cSquareVoltExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareVoltSymbol, cSquareVoltPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareVoltSymbol, APrefixes);
end;

function SquareVoltToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareVolt then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareVoltToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareVolt then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareVoltToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareVolt then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function SquareKilogramQuarticMeterPerSquareAmperePerSexticSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareVolt then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareKilogramQuarticMeterPerSquareAmperePerSexticSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareVolt then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSquareKilogramQuarticMeterPerSquareAmperePerSexticSecondPrefixes, cSquareKilogramQuarticMeterPerSquareAmperePerSexticSecondExponents, cSquareKilogramQuarticMeterPerSquareAmperePerSexticSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSquareKilogramQuarticMeterPerSquareAmperePerSexticSecondPrefixes, cSquareKilogramQuarticMeterPerSquareAmperePerSexticSecondExponents, cSquareKilogramQuarticMeterPerSquareAmperePerSexticSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareKilogramQuarticMeterPerSquareAmperePerSexticSecondSymbol, cSquareKilogramQuarticMeterPerSquareAmperePerSexticSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareKilogramQuarticMeterPerSquareAmperePerSexticSecondSymbol, APrefixes);
end;

function SquareKilogramQuarticMeterPerSquareAmperePerSexticSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareVolt then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareKilogramQuarticMeterPerSquareAmperePerSexticSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareVolt then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareKilogramQuarticMeterPerSquareAmperePerSexticSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareVolt then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function FaradToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cFarad then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsFaradSymbol, cFaradPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsFaradSymbol, cFaradPrefixes);
{$ENDIF}
end;

function FaradToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cFarad then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cFaradPrefixes, cFaradExponents, cFaradExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cFaradPrefixes, cFaradExponents, cFaradExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsFaradSymbol, cFaradPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsFaradSymbol, APrefixes);
end;

function FaradToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cFarad then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function FaradToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cFarad then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function FaradToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cFarad then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function CoulombPerVoltToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cFarad then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function CoulombPerVoltToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cFarad then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cCoulombPerVoltPrefixes, cCoulombPerVoltExponents, cCoulombPerVoltExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cCoulombPerVoltPrefixes, cCoulombPerVoltExponents, cCoulombPerVoltExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCoulombPerVoltSymbol, cCoulombPerVoltPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCoulombPerVoltSymbol, APrefixes);
end;

function CoulombPerVoltToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cFarad then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function CoulombPerVoltToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cFarad then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function CoulombPerVoltToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cFarad then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function SquareAmpereQuarticSecondPerKilogramPerSquareMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cFarad then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareAmpereQuarticSecondPerKilogramPerSquareMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cFarad then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSquareAmpereQuarticSecondPerKilogramPerSquareMeterPrefixes, cSquareAmpereQuarticSecondPerKilogramPerSquareMeterExponents, cSquareAmpereQuarticSecondPerKilogramPerSquareMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSquareAmpereQuarticSecondPerKilogramPerSquareMeterPrefixes, cSquareAmpereQuarticSecondPerKilogramPerSquareMeterExponents, cSquareAmpereQuarticSecondPerKilogramPerSquareMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareAmpereQuarticSecondPerKilogramPerSquareMeterSymbol, cSquareAmpereQuarticSecondPerKilogramPerSquareMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareAmpereQuarticSecondPerKilogramPerSquareMeterSymbol, APrefixes);
end;

function SquareAmpereQuarticSecondPerKilogramPerSquareMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cFarad then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareAmpereQuarticSecondPerKilogramPerSquareMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cFarad then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareAmpereQuarticSecondPerKilogramPerSquareMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cFarad then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function OhmToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cOhm then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsOhmSymbol, cOhmPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsOhmSymbol, cOhmPrefixes);
{$ENDIF}
end;

function OhmToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cOhm then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cOhmPrefixes, cOhmExponents, cOhmExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cOhmPrefixes, cOhmExponents, cOhmExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsOhmSymbol, cOhmPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsOhmSymbol, APrefixes);
end;

function OhmToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cOhm then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function OhmToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cOhm then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function OhmToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cOhm then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function KilogramSquareMeterPerSquareAmperePerCubicSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cOhm then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramSquareMeterPerSquareAmperePerCubicSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cOhm then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cKilogramSquareMeterPerSquareAmperePerCubicSecondPrefixes, cKilogramSquareMeterPerSquareAmperePerCubicSecondExponents, cKilogramSquareMeterPerSquareAmperePerCubicSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cKilogramSquareMeterPerSquareAmperePerCubicSecondPrefixes, cKilogramSquareMeterPerSquareAmperePerCubicSecondExponents, cKilogramSquareMeterPerSquareAmperePerCubicSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramSquareMeterPerSquareAmperePerCubicSecondSymbol, cKilogramSquareMeterPerSquareAmperePerCubicSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramSquareMeterPerSquareAmperePerCubicSecondSymbol, APrefixes);
end;

function KilogramSquareMeterPerSquareAmperePerCubicSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cOhm then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramSquareMeterPerSquareAmperePerCubicSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cOhm then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramSquareMeterPerSquareAmperePerCubicSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cOhm then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function SiemensToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSiemens then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsSiemensSymbol, cSiemensPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsSiemensSymbol, cSiemensPrefixes);
{$ENDIF}
end;

function SiemensToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSiemens then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSiemensPrefixes, cSiemensExponents, cSiemensExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSiemensPrefixes, cSiemensExponents, cSiemensExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSiemensSymbol, cSiemensPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSiemensSymbol, APrefixes);
end;

function SiemensToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSiemens then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SiemensToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSiemens then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SiemensToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSiemens then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function SquareAmpereCubicSecondPerKilogramPerSquareMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSiemens then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareAmpereCubicSecondPerKilogramPerSquareMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSiemens then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSquareAmpereCubicSecondPerKilogramPerSquareMeterPrefixes, cSquareAmpereCubicSecondPerKilogramPerSquareMeterExponents, cSquareAmpereCubicSecondPerKilogramPerSquareMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSquareAmpereCubicSecondPerKilogramPerSquareMeterPrefixes, cSquareAmpereCubicSecondPerKilogramPerSquareMeterExponents, cSquareAmpereCubicSecondPerKilogramPerSquareMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareAmpereCubicSecondPerKilogramPerSquareMeterSymbol, cSquareAmpereCubicSecondPerKilogramPerSquareMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareAmpereCubicSecondPerKilogramPerSquareMeterSymbol, APrefixes);
end;

function SquareAmpereCubicSecondPerKilogramPerSquareMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSiemens then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareAmpereCubicSecondPerKilogramPerSquareMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSiemens then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareAmpereCubicSecondPerKilogramPerSquareMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSiemens then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function SiemensPerMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSiemensPerMeter then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsSiemensPerMeterSymbol, cSiemensPerMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsSiemensPerMeterSymbol, cSiemensPerMeterPrefixes);
{$ENDIF}
end;

function SiemensPerMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSiemensPerMeter then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSiemensPerMeterPrefixes, cSiemensPerMeterExponents, cSiemensPerMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSiemensPerMeterPrefixes, cSiemensPerMeterExponents, cSiemensPerMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSiemensPerMeterSymbol, cSiemensPerMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSiemensPerMeterSymbol, APrefixes);
end;

function SiemensPerMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSiemensPerMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SiemensPerMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSiemensPerMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SiemensPerMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSiemensPerMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function TeslaToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cTesla then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsTeslaSymbol, cTeslaPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsTeslaSymbol, cTeslaPrefixes);
{$ENDIF}
end;

function TeslaToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cTesla then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cTeslaPrefixes, cTeslaExponents, cTeslaExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cTeslaPrefixes, cTeslaExponents, cTeslaExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsTeslaSymbol, cTeslaPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsTeslaSymbol, APrefixes);
end;

function TeslaToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cTesla then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function TeslaToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cTesla then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function TeslaToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cTesla then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function WeberPerSquareMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cTesla then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function WeberPerSquareMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cTesla then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cWeberPerSquareMeterPrefixes, cWeberPerSquareMeterExponents, cWeberPerSquareMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cWeberPerSquareMeterPrefixes, cWeberPerSquareMeterExponents, cWeberPerSquareMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWeberPerSquareMeterSymbol, cWeberPerSquareMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWeberPerSquareMeterSymbol, APrefixes);
end;

function WeberPerSquareMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cTesla then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function WeberPerSquareMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cTesla then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function WeberPerSquareMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cTesla then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function KilogramPerAmperePerSquareSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cTesla then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramPerAmperePerSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cTesla then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cKilogramPerAmperePerSquareSecondPrefixes, cKilogramPerAmperePerSquareSecondExponents, cKilogramPerAmperePerSquareSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cKilogramPerAmperePerSquareSecondPrefixes, cKilogramPerAmperePerSquareSecondExponents, cKilogramPerAmperePerSquareSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramPerAmperePerSquareSecondSymbol, cKilogramPerAmperePerSquareSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramPerAmperePerSquareSecondSymbol, APrefixes);
end;

function KilogramPerAmperePerSquareSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cTesla then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramPerAmperePerSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cTesla then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramPerAmperePerSquareSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cTesla then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function WeberToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWeber then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsWeberSymbol, cWeberPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsWeberSymbol, cWeberPrefixes);
{$ENDIF}
end;

function WeberToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWeber then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cWeberPrefixes, cWeberExponents, cWeberExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cWeberPrefixes, cWeberExponents, cWeberExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWeberSymbol, cWeberPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWeberSymbol, APrefixes);
end;

function WeberToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWeber then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function WeberToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWeber then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function WeberToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWeber then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function KilogramSquareMeterPerAmperePerSquareSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWeber then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramSquareMeterPerAmperePerSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWeber then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cKilogramSquareMeterPerAmperePerSquareSecondPrefixes, cKilogramSquareMeterPerAmperePerSquareSecondExponents, cKilogramSquareMeterPerAmperePerSquareSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cKilogramSquareMeterPerAmperePerSquareSecondPrefixes, cKilogramSquareMeterPerAmperePerSquareSecondExponents, cKilogramSquareMeterPerAmperePerSquareSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramSquareMeterPerAmperePerSquareSecondSymbol, cKilogramSquareMeterPerAmperePerSquareSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramSquareMeterPerAmperePerSquareSecondSymbol, APrefixes);
end;

function KilogramSquareMeterPerAmperePerSquareSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWeber then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramSquareMeterPerAmperePerSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWeber then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramSquareMeterPerAmperePerSquareSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWeber then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function HenryToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHenry then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsHenrySymbol, cHenryPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsHenrySymbol, cHenryPrefixes);
{$ENDIF}
end;

function HenryToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHenry then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cHenryPrefixes, cHenryExponents, cHenryExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cHenryPrefixes, cHenryExponents, cHenryExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsHenrySymbol, cHenryPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsHenrySymbol, APrefixes);
end;

function HenryToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHenry then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function HenryToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHenry then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function HenryToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHenry then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function KilogramSquareMeterPerSquareAmperePerSquareSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHenry then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramSquareMeterPerSquareAmperePerSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHenry then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cKilogramSquareMeterPerSquareAmperePerSquareSecondPrefixes, cKilogramSquareMeterPerSquareAmperePerSquareSecondExponents, cKilogramSquareMeterPerSquareAmperePerSquareSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cKilogramSquareMeterPerSquareAmperePerSquareSecondPrefixes, cKilogramSquareMeterPerSquareAmperePerSquareSecondExponents, cKilogramSquareMeterPerSquareAmperePerSquareSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramSquareMeterPerSquareAmperePerSquareSecondSymbol, cKilogramSquareMeterPerSquareAmperePerSquareSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramSquareMeterPerSquareAmperePerSquareSecondSymbol, APrefixes);
end;

function KilogramSquareMeterPerSquareAmperePerSquareSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHenry then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramSquareMeterPerSquareAmperePerSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHenry then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramSquareMeterPerSquareAmperePerSquareSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHenry then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function ReciprocalHenryToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalHenry then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsReciprocalHenrySymbol, cReciprocalHenryPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsReciprocalHenrySymbol, cReciprocalHenryPrefixes);
{$ENDIF}
end;

function ReciprocalHenryToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalHenry then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cReciprocalHenryPrefixes, cReciprocalHenryExponents, cReciprocalHenryExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cReciprocalHenryPrefixes, cReciprocalHenryExponents, cReciprocalHenryExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsReciprocalHenrySymbol, cReciprocalHenryPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsReciprocalHenrySymbol, APrefixes);
end;

function ReciprocalHenryToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalHenry then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function ReciprocalHenryToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalHenry then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function ReciprocalHenryToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalHenry then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function LumenToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLumen then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsLumenSymbol, cLumenPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsLumenSymbol, cLumenPrefixes);
{$ENDIF}
end;

function LumenToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLumen then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cLumenPrefixes, cLumenExponents, cLumenExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cLumenPrefixes, cLumenExponents, cLumenExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsLumenSymbol, cLumenPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsLumenSymbol, APrefixes);
end;

function LumenToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLumen then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function LumenToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLumen then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function LumenToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLumen then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function CandelaSteradianToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLumen then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function CandelaSteradianToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLumen then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cCandelaSteradianPrefixes, cCandelaSteradianExponents, cCandelaSteradianExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cCandelaSteradianPrefixes, cCandelaSteradianExponents, cCandelaSteradianExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCandelaSteradianSymbol, cCandelaSteradianPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCandelaSteradianSymbol, APrefixes);
end;

function CandelaSteradianToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLumen then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function CandelaSteradianToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLumen then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function CandelaSteradianToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLumen then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function LumenSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLumenSecond then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsLumenSecondSymbol, cLumenSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsLumenSecondSymbol, cLumenSecondPrefixes);
{$ENDIF}
end;

function LumenSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLumenSecond then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cLumenSecondPrefixes, cLumenSecondExponents, cLumenSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cLumenSecondPrefixes, cLumenSecondExponents, cLumenSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsLumenSecondSymbol, cLumenSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsLumenSecondSymbol, APrefixes);
end;

function LumenSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLumenSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function LumenSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLumenSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function LumenSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLumenSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function LumenSecondPerCubicMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLumenSecondPerCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsLumenSecondPerCubicMeterSymbol, cLumenSecondPerCubicMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsLumenSecondPerCubicMeterSymbol, cLumenSecondPerCubicMeterPrefixes);
{$ENDIF}
end;

function LumenSecondPerCubicMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLumenSecondPerCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cLumenSecondPerCubicMeterPrefixes, cLumenSecondPerCubicMeterExponents, cLumenSecondPerCubicMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cLumenSecondPerCubicMeterPrefixes, cLumenSecondPerCubicMeterExponents, cLumenSecondPerCubicMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsLumenSecondPerCubicMeterSymbol, cLumenSecondPerCubicMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsLumenSecondPerCubicMeterSymbol, APrefixes);
end;

function LumenSecondPerCubicMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLumenSecondPerCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function LumenSecondPerCubicMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLumenSecondPerCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function LumenSecondPerCubicMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLumenSecondPerCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function LuxToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLux then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsLuxSymbol, cLuxPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsLuxSymbol, cLuxPrefixes);
{$ENDIF}
end;

function LuxToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLux then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cLuxPrefixes, cLuxExponents, cLuxExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cLuxPrefixes, cLuxExponents, cLuxExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsLuxSymbol, cLuxPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsLuxSymbol, APrefixes);
end;

function LuxToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLux then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function LuxToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLux then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function LuxToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLux then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function CandelaSteradianPerSquareMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLux then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function CandelaSteradianPerSquareMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLux then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cCandelaSteradianPerSquareMeterPrefixes, cCandelaSteradianPerSquareMeterExponents, cCandelaSteradianPerSquareMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cCandelaSteradianPerSquareMeterPrefixes, cCandelaSteradianPerSquareMeterExponents, cCandelaSteradianPerSquareMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCandelaSteradianPerSquareMeterSymbol, cCandelaSteradianPerSquareMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCandelaSteradianPerSquareMeterSymbol, APrefixes);
end;

function CandelaSteradianPerSquareMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLux then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function CandelaSteradianPerSquareMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLux then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function CandelaSteradianPerSquareMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLux then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function LuxSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLuxSecond then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsLuxSecondSymbol, cLuxSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsLuxSecondSymbol, cLuxSecondPrefixes);
{$ENDIF}
end;

function LuxSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLuxSecond then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cLuxSecondPrefixes, cLuxSecondExponents, cLuxSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cLuxSecondPrefixes, cLuxSecondExponents, cLuxSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsLuxSecondSymbol, cLuxSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsLuxSecondSymbol, APrefixes);
end;

function LuxSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLuxSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function LuxSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLuxSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function LuxSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLuxSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function BequerelToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHertz then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function BequerelToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHertz then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cBequerelPrefixes, cBequerelExponents, cBequerelExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cBequerelPrefixes, cBequerelExponents, cBequerelExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsBequerelSymbol, cBequerelPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsBequerelSymbol, APrefixes);
end;

function BequerelToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHertz then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function BequerelToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHertz then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function BequerelToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHertz then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function KatalToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKatal then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsKatalSymbol, cKatalPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsKatalSymbol, cKatalPrefixes);
{$ENDIF}
end;

function KatalToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKatal then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cKatalPrefixes, cKatalExponents, cKatalExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cKatalPrefixes, cKatalExponents, cKatalExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKatalSymbol, cKatalPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKatalSymbol, APrefixes);
end;

function KatalToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKatal then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KatalToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKatal then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KatalToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKatal then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function MolePerSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKatal then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function MolePerSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKatal then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cMolePerSecondPrefixes, cMolePerSecondExponents, cMolePerSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cMolePerSecondPrefixes, cMolePerSecondExponents, cMolePerSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMolePerSecondSymbol, cMolePerSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMolePerSecondSymbol, APrefixes);
end;

function MolePerSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKatal then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function MolePerSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKatal then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function MolePerSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKatal then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function NewtonPerCubicMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsNewtonPerCubicMeterSymbol, cNewtonPerCubicMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsNewtonPerCubicMeterSymbol, cNewtonPerCubicMeterPrefixes);
{$ENDIF}
end;

function NewtonPerCubicMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cNewtonPerCubicMeterPrefixes, cNewtonPerCubicMeterExponents, cNewtonPerCubicMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cNewtonPerCubicMeterPrefixes, cNewtonPerCubicMeterExponents, cNewtonPerCubicMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonPerCubicMeterSymbol, cNewtonPerCubicMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonPerCubicMeterSymbol, APrefixes);
end;

function NewtonPerCubicMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function NewtonPerCubicMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function NewtonPerCubicMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function PascalPerMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function PascalPerMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cPascalPerMeterPrefixes, cPascalPerMeterExponents, cPascalPerMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cPascalPerMeterPrefixes, cPascalPerMeterExponents, cPascalPerMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsPascalPerMeterSymbol, cPascalPerMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsPascalPerMeterSymbol, APrefixes);
end;

function PascalPerMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function PascalPerMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function PascalPerMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function KilogramPerSquareMeterPerSquareSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramPerSquareMeterPerSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cKilogramPerSquareMeterPerSquareSecondPrefixes, cKilogramPerSquareMeterPerSquareSecondExponents, cKilogramPerSquareMeterPerSquareSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cKilogramPerSquareMeterPerSquareSecondPrefixes, cKilogramPerSquareMeterPerSquareSecondExponents, cKilogramPerSquareMeterPerSquareSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramPerSquareMeterPerSquareSecondSymbol, cKilogramPerSquareMeterPerSquareSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramPerSquareMeterPerSquareSecondSymbol, APrefixes);
end;

function KilogramPerSquareMeterPerSquareSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramPerSquareMeterPerSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramPerSquareMeterPerSquareSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function NewtonPerMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerMeter then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsNewtonPerMeterSymbol, cNewtonPerMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsNewtonPerMeterSymbol, cNewtonPerMeterPrefixes);
{$ENDIF}
end;

function NewtonPerMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerMeter then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cNewtonPerMeterPrefixes, cNewtonPerMeterExponents, cNewtonPerMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cNewtonPerMeterPrefixes, cNewtonPerMeterExponents, cNewtonPerMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonPerMeterSymbol, cNewtonPerMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonPerMeterSymbol, APrefixes);
end;

function NewtonPerMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function NewtonPerMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function NewtonPerMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function JoulePerSquareMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function JoulePerSquareMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerMeter then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cJoulePerSquareMeterPrefixes, cJoulePerSquareMeterExponents, cJoulePerSquareMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cJoulePerSquareMeterPrefixes, cJoulePerSquareMeterExponents, cJoulePerSquareMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsJoulePerSquareMeterSymbol, cJoulePerSquareMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsJoulePerSquareMeterSymbol, APrefixes);
end;

function JoulePerSquareMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function JoulePerSquareMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function JoulePerSquareMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function WattPerSquareMeterPerHertzToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function WattPerSquareMeterPerHertzToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerMeter then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cWattPerSquareMeterPerHertzPrefixes, cWattPerSquareMeterPerHertzExponents, cWattPerSquareMeterPerHertzExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cWattPerSquareMeterPerHertzPrefixes, cWattPerSquareMeterPerHertzExponents, cWattPerSquareMeterPerHertzExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattPerSquareMeterPerHertzSymbol, cWattPerSquareMeterPerHertzPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattPerSquareMeterPerHertzSymbol, APrefixes);
end;

function WattPerSquareMeterPerHertzToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function WattPerSquareMeterPerHertzToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function WattPerSquareMeterPerHertzToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function PoundForcePerInchToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function PoundForcePerInchToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerMeter then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cPoundForcePerInchPrefixes, cPoundForcePerInchExponents, cPoundForcePerInchExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cPoundForcePerInchPrefixes, cPoundForcePerInchExponents, cPoundForcePerInchExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsPoundForcePerInchSymbol, cPoundForcePerInchPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsPoundForcePerInchSymbol, APrefixes);
end;

function PoundForcePerInchToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function PoundForcePerInchToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function PoundForcePerInchToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function KilogramPerSquareSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramPerSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerMeter then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cKilogramPerSquareSecondPrefixes, cKilogramPerSquareSecondExponents, cKilogramPerSquareSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cKilogramPerSquareSecondPrefixes, cKilogramPerSquareSecondExponents, cKilogramPerSquareSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramPerSquareSecondSymbol, cKilogramPerSquareSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramPerSquareSecondSymbol, APrefixes);
end;

function KilogramPerSquareSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramPerSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramPerSquareSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function CubicMeterPerSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeterPerSecond then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsCubicMeterPerSecondSymbol, cCubicMeterPerSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsCubicMeterPerSecondSymbol, cCubicMeterPerSecondPrefixes);
{$ENDIF}
end;

function CubicMeterPerSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeterPerSecond then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cCubicMeterPerSecondPrefixes, cCubicMeterPerSecondExponents, cCubicMeterPerSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cCubicMeterPerSecondPrefixes, cCubicMeterPerSecondExponents, cCubicMeterPerSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCubicMeterPerSecondSymbol, cCubicMeterPerSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCubicMeterPerSecondSymbol, APrefixes);
end;

function CubicMeterPerSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeterPerSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function CubicMeterPerSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeterPerSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function CubicMeterPerSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeterPerSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function PoiseuilleToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPoiseuille then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsPoiseuilleSymbol, cPoiseuillePrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsPoiseuilleSymbol, cPoiseuillePrefixes);
{$ENDIF}
end;

function PoiseuilleToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPoiseuille then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cPoiseuillePrefixes, cPoiseuilleExponents, cPoiseuilleExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cPoiseuillePrefixes, cPoiseuilleExponents, cPoiseuilleExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsPoiseuilleSymbol, cPoiseuillePrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsPoiseuilleSymbol, APrefixes);
end;

function PoiseuilleToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPoiseuille then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function PoiseuilleToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPoiseuille then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function PoiseuilleToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPoiseuille then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function PascalSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPoiseuille then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function PascalSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPoiseuille then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cPascalSecondPrefixes, cPascalSecondExponents, cPascalSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cPascalSecondPrefixes, cPascalSecondExponents, cPascalSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsPascalSecondSymbol, cPascalSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsPascalSecondSymbol, APrefixes);
end;

function PascalSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPoiseuille then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function PascalSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPoiseuille then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function PascalSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPoiseuille then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function KilogramPerMeterPerSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPoiseuille then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramPerMeterPerSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPoiseuille then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cKilogramPerMeterPerSecondPrefixes, cKilogramPerMeterPerSecondExponents, cKilogramPerMeterPerSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cKilogramPerMeterPerSecondPrefixes, cKilogramPerMeterPerSecondExponents, cKilogramPerMeterPerSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramPerMeterPerSecondSymbol, cKilogramPerMeterPerSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramPerMeterPerSecondSymbol, APrefixes);
end;

function KilogramPerMeterPerSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPoiseuille then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramPerMeterPerSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPoiseuille then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramPerMeterPerSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cPoiseuille then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function SquareMeterPerSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterPerSecond then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsSquareMeterPerSecondSymbol, cSquareMeterPerSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsSquareMeterPerSecondSymbol, cSquareMeterPerSecondPrefixes);
{$ENDIF}
end;

function SquareMeterPerSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterPerSecond then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSquareMeterPerSecondPrefixes, cSquareMeterPerSecondExponents, cSquareMeterPerSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSquareMeterPerSecondPrefixes, cSquareMeterPerSecondExponents, cSquareMeterPerSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareMeterPerSecondSymbol, cSquareMeterPerSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareMeterPerSecondSymbol, APrefixes);
end;

function SquareMeterPerSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterPerSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareMeterPerSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterPerSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareMeterPerSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterPerSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function KilogramPerQuarticMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerQuarticMeter then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsKilogramPerQuarticMeterSymbol, cKilogramPerQuarticMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsKilogramPerQuarticMeterSymbol, cKilogramPerQuarticMeterPrefixes);
{$ENDIF}
end;

function KilogramPerQuarticMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerQuarticMeter then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cKilogramPerQuarticMeterPrefixes, cKilogramPerQuarticMeterExponents, cKilogramPerQuarticMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cKilogramPerQuarticMeterPrefixes, cKilogramPerQuarticMeterExponents, cKilogramPerQuarticMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramPerQuarticMeterSymbol, cKilogramPerQuarticMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramPerQuarticMeterSymbol, APrefixes);
end;

function KilogramPerQuarticMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerQuarticMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramPerQuarticMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerQuarticMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramPerQuarticMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerQuarticMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function QuarticMeterSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cQuarticMeterSecond then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsQuarticMeterSecondSymbol, cQuarticMeterSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsQuarticMeterSecondSymbol, cQuarticMeterSecondPrefixes);
{$ENDIF}
end;

function QuarticMeterSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cQuarticMeterSecond then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cQuarticMeterSecondPrefixes, cQuarticMeterSecondExponents, cQuarticMeterSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cQuarticMeterSecondPrefixes, cQuarticMeterSecondExponents, cQuarticMeterSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsQuarticMeterSecondSymbol, cQuarticMeterSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsQuarticMeterSecondSymbol, APrefixes);
end;

function QuarticMeterSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cQuarticMeterSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function QuarticMeterSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cQuarticMeterSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function QuarticMeterSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cQuarticMeterSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function KilogramPerQuarticMeterPerSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerQuarticMeterPerSecond then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsKilogramPerQuarticMeterPerSecondSymbol, cKilogramPerQuarticMeterPerSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsKilogramPerQuarticMeterPerSecondSymbol, cKilogramPerQuarticMeterPerSecondPrefixes);
{$ENDIF}
end;

function KilogramPerQuarticMeterPerSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerQuarticMeterPerSecond then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cKilogramPerQuarticMeterPerSecondPrefixes, cKilogramPerQuarticMeterPerSecondExponents, cKilogramPerQuarticMeterPerSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cKilogramPerQuarticMeterPerSecondPrefixes, cKilogramPerQuarticMeterPerSecondExponents, cKilogramPerQuarticMeterPerSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramPerQuarticMeterPerSecondSymbol, cKilogramPerQuarticMeterPerSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramPerQuarticMeterPerSecondSymbol, APrefixes);
end;

function KilogramPerQuarticMeterPerSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerQuarticMeterPerSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramPerQuarticMeterPerSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerQuarticMeterPerSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramPerQuarticMeterPerSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramPerQuarticMeterPerSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function CubicMeterPerKilogramToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeterPerKilogram then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsCubicMeterPerKilogramSymbol, cCubicMeterPerKilogramPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsCubicMeterPerKilogramSymbol, cCubicMeterPerKilogramPrefixes);
{$ENDIF}
end;

function CubicMeterPerKilogramToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeterPerKilogram then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cCubicMeterPerKilogramPrefixes, cCubicMeterPerKilogramExponents, cCubicMeterPerKilogramExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cCubicMeterPerKilogramPrefixes, cCubicMeterPerKilogramExponents, cCubicMeterPerKilogramExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCubicMeterPerKilogramSymbol, cCubicMeterPerKilogramPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCubicMeterPerKilogramSymbol, APrefixes);
end;

function CubicMeterPerKilogramToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeterPerKilogram then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function CubicMeterPerKilogramToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeterPerKilogram then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function CubicMeterPerKilogramToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeterPerKilogram then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function KilogramSquareSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsKilogramSquareSecondSymbol, cKilogramSquareSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsKilogramSquareSecondSymbol, cKilogramSquareSecondPrefixes);
{$ENDIF}
end;

function KilogramSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cKilogramSquareSecondPrefixes, cKilogramSquareSecondExponents, cKilogramSquareSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cKilogramSquareSecondPrefixes, cKilogramSquareSecondExponents, cKilogramSquareSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramSquareSecondSymbol, cKilogramSquareSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramSquareSecondSymbol, APrefixes);
end;

function KilogramSquareSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramSquareSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function CubicMeterPerSquareSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeterPerSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsCubicMeterPerSquareSecondSymbol, cCubicMeterPerSquareSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsCubicMeterPerSquareSecondSymbol, cCubicMeterPerSquareSecondPrefixes);
{$ENDIF}
end;

function CubicMeterPerSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeterPerSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cCubicMeterPerSquareSecondPrefixes, cCubicMeterPerSquareSecondExponents, cCubicMeterPerSquareSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cCubicMeterPerSquareSecondPrefixes, cCubicMeterPerSquareSecondExponents, cCubicMeterPerSquareSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCubicMeterPerSquareSecondSymbol, cCubicMeterPerSquareSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCubicMeterPerSquareSecondSymbol, APrefixes);
end;

function CubicMeterPerSquareSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeterPerSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function CubicMeterPerSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeterPerSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function CubicMeterPerSquareSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeterPerSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function NewtonSquareMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsNewtonSquareMeterSymbol, cNewtonSquareMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsNewtonSquareMeterSymbol, cNewtonSquareMeterPrefixes);
{$ENDIF}
end;

function NewtonSquareMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cNewtonSquareMeterPrefixes, cNewtonSquareMeterExponents, cNewtonSquareMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cNewtonSquareMeterPrefixes, cNewtonSquareMeterExponents, cNewtonSquareMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonSquareMeterSymbol, cNewtonSquareMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonSquareMeterSymbol, APrefixes);
end;

function NewtonSquareMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function NewtonSquareMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function NewtonSquareMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function KilogramCubicMeterPerSquareSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramCubicMeterPerSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cKilogramCubicMeterPerSquareSecondPrefixes, cKilogramCubicMeterPerSquareSecondExponents, cKilogramCubicMeterPerSquareSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cKilogramCubicMeterPerSquareSecondPrefixes, cKilogramCubicMeterPerSquareSecondExponents, cKilogramCubicMeterPerSquareSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramCubicMeterPerSquareSecondSymbol, cKilogramCubicMeterPerSquareSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramCubicMeterPerSquareSecondSymbol, APrefixes);
end;

function KilogramCubicMeterPerSquareSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramCubicMeterPerSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramCubicMeterPerSquareSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function NewtonCubicMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsNewtonCubicMeterSymbol, cNewtonCubicMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsNewtonCubicMeterSymbol, cNewtonCubicMeterPrefixes);
{$ENDIF}
end;

function NewtonCubicMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cNewtonCubicMeterPrefixes, cNewtonCubicMeterExponents, cNewtonCubicMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cNewtonCubicMeterPrefixes, cNewtonCubicMeterExponents, cNewtonCubicMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonCubicMeterSymbol, cNewtonCubicMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonCubicMeterSymbol, APrefixes);
end;

function NewtonCubicMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function NewtonCubicMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function NewtonCubicMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function KilogramQuarticMeterPerSquareSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramQuarticMeterPerSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cKilogramQuarticMeterPerSquareSecondPrefixes, cKilogramQuarticMeterPerSquareSecondExponents, cKilogramQuarticMeterPerSquareSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cKilogramQuarticMeterPerSquareSecondPrefixes, cKilogramQuarticMeterPerSquareSecondExponents, cKilogramQuarticMeterPerSquareSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramQuarticMeterPerSquareSecondSymbol, cKilogramQuarticMeterPerSquareSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramQuarticMeterPerSquareSecondSymbol, APrefixes);
end;

function KilogramQuarticMeterPerSquareSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramQuarticMeterPerSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramQuarticMeterPerSquareSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function NewtonPerSquareKilogramToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerSquareKilogram then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsNewtonPerSquareKilogramSymbol, cNewtonPerSquareKilogramPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsNewtonPerSquareKilogramSymbol, cNewtonPerSquareKilogramPrefixes);
{$ENDIF}
end;

function NewtonPerSquareKilogramToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerSquareKilogram then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cNewtonPerSquareKilogramPrefixes, cNewtonPerSquareKilogramExponents, cNewtonPerSquareKilogramExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cNewtonPerSquareKilogramPrefixes, cNewtonPerSquareKilogramExponents, cNewtonPerSquareKilogramExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonPerSquareKilogramSymbol, cNewtonPerSquareKilogramPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonPerSquareKilogramSymbol, APrefixes);
end;

function NewtonPerSquareKilogramToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerSquareKilogram then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function NewtonPerSquareKilogramToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerSquareKilogram then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function NewtonPerSquareKilogramToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerSquareKilogram then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function MeterPerKilogramPerSquareSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerSquareKilogram then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function MeterPerKilogramPerSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerSquareKilogram then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cMeterPerKilogramPerSquareSecondPrefixes, cMeterPerKilogramPerSquareSecondExponents, cMeterPerKilogramPerSquareSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cMeterPerKilogramPerSquareSecondPrefixes, cMeterPerKilogramPerSquareSecondExponents, cMeterPerKilogramPerSquareSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterPerKilogramPerSquareSecondSymbol, cMeterPerKilogramPerSquareSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterPerKilogramPerSquareSecondSymbol, APrefixes);
end;

function MeterPerKilogramPerSquareSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerSquareKilogram then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function MeterPerKilogramPerSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerSquareKilogram then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function MeterPerKilogramPerSquareSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerSquareKilogram then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function SquareKilogramPerMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareKilogramPerMeter then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsSquareKilogramPerMeterSymbol, cSquareKilogramPerMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsSquareKilogramPerMeterSymbol, cSquareKilogramPerMeterPrefixes);
{$ENDIF}
end;

function SquareKilogramPerMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareKilogramPerMeter then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSquareKilogramPerMeterPrefixes, cSquareKilogramPerMeterExponents, cSquareKilogramPerMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSquareKilogramPerMeterPrefixes, cSquareKilogramPerMeterExponents, cSquareKilogramPerMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareKilogramPerMeterSymbol, cSquareKilogramPerMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareKilogramPerMeterSymbol, APrefixes);
end;

function SquareKilogramPerMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareKilogramPerMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareKilogramPerMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareKilogramPerMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareKilogramPerMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareKilogramPerMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function SquareKilogramPerSquareMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareKilogramPerSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsSquareKilogramPerSquareMeterSymbol, cSquareKilogramPerSquareMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsSquareKilogramPerSquareMeterSymbol, cSquareKilogramPerSquareMeterPrefixes);
{$ENDIF}
end;

function SquareKilogramPerSquareMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareKilogramPerSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSquareKilogramPerSquareMeterPrefixes, cSquareKilogramPerSquareMeterExponents, cSquareKilogramPerSquareMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSquareKilogramPerSquareMeterPrefixes, cSquareKilogramPerSquareMeterExponents, cSquareKilogramPerSquareMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareKilogramPerSquareMeterSymbol, cSquareKilogramPerSquareMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareKilogramPerSquareMeterSymbol, APrefixes);
end;

function SquareKilogramPerSquareMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareKilogramPerSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareKilogramPerSquareMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareKilogramPerSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareKilogramPerSquareMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareKilogramPerSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function SquareMeterPerSquareKilogramToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterPerSquareKilogram then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsSquareMeterPerSquareKilogramSymbol, cSquareMeterPerSquareKilogramPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsSquareMeterPerSquareKilogramSymbol, cSquareMeterPerSquareKilogramPrefixes);
{$ENDIF}
end;

function SquareMeterPerSquareKilogramToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterPerSquareKilogram then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSquareMeterPerSquareKilogramPrefixes, cSquareMeterPerSquareKilogramExponents, cSquareMeterPerSquareKilogramExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSquareMeterPerSquareKilogramPrefixes, cSquareMeterPerSquareKilogramExponents, cSquareMeterPerSquareKilogramExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareMeterPerSquareKilogramSymbol, cSquareMeterPerSquareKilogramPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareMeterPerSquareKilogramSymbol, APrefixes);
end;

function SquareMeterPerSquareKilogramToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterPerSquareKilogram then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareMeterPerSquareKilogramToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterPerSquareKilogram then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareMeterPerSquareKilogramToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterPerSquareKilogram then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function NewtonSquareMeterPerSquareKilogramToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonSquareMeterPerSquareKilogram then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsNewtonSquareMeterPerSquareKilogramSymbol, cNewtonSquareMeterPerSquareKilogramPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsNewtonSquareMeterPerSquareKilogramSymbol, cNewtonSquareMeterPerSquareKilogramPrefixes);
{$ENDIF}
end;

function NewtonSquareMeterPerSquareKilogramToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonSquareMeterPerSquareKilogram then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cNewtonSquareMeterPerSquareKilogramPrefixes, cNewtonSquareMeterPerSquareKilogramExponents, cNewtonSquareMeterPerSquareKilogramExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cNewtonSquareMeterPerSquareKilogramPrefixes, cNewtonSquareMeterPerSquareKilogramExponents, cNewtonSquareMeterPerSquareKilogramExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonSquareMeterPerSquareKilogramSymbol, cNewtonSquareMeterPerSquareKilogramPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonSquareMeterPerSquareKilogramSymbol, APrefixes);
end;

function NewtonSquareMeterPerSquareKilogramToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonSquareMeterPerSquareKilogram then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function NewtonSquareMeterPerSquareKilogramToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonSquareMeterPerSquareKilogram then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function NewtonSquareMeterPerSquareKilogramToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonSquareMeterPerSquareKilogram then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function CubicMeterPerKilogramPerSquareSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonSquareMeterPerSquareKilogram then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function CubicMeterPerKilogramPerSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonSquareMeterPerSquareKilogram then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cCubicMeterPerKilogramPerSquareSecondPrefixes, cCubicMeterPerKilogramPerSquareSecondExponents, cCubicMeterPerKilogramPerSquareSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cCubicMeterPerKilogramPerSquareSecondPrefixes, cCubicMeterPerKilogramPerSquareSecondExponents, cCubicMeterPerKilogramPerSquareSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCubicMeterPerKilogramPerSquareSecondSymbol, cCubicMeterPerKilogramPerSquareSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCubicMeterPerKilogramPerSquareSecondSymbol, APrefixes);
end;

function CubicMeterPerKilogramPerSquareSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonSquareMeterPerSquareKilogram then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function CubicMeterPerKilogramPerSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonSquareMeterPerSquareKilogram then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function CubicMeterPerKilogramPerSquareSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonSquareMeterPerSquareKilogram then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function ReciprocalKelvinToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalKelvin then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsReciprocalKelvinSymbol, cReciprocalKelvinPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsReciprocalKelvinSymbol, cReciprocalKelvinPrefixes);
{$ENDIF}
end;

function ReciprocalKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalKelvin then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cReciprocalKelvinPrefixes, cReciprocalKelvinExponents, cReciprocalKelvinExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cReciprocalKelvinPrefixes, cReciprocalKelvinExponents, cReciprocalKelvinExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsReciprocalKelvinSymbol, cReciprocalKelvinPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsReciprocalKelvinSymbol, APrefixes);
end;

function ReciprocalKelvinToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalKelvin then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function ReciprocalKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalKelvin then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function ReciprocalKelvinToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalKelvin then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function KilogramKelvinToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramKelvin then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsKilogramKelvinSymbol, cKilogramKelvinPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsKilogramKelvinSymbol, cKilogramKelvinPrefixes);
{$ENDIF}
end;

function KilogramKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramKelvin then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cKilogramKelvinPrefixes, cKilogramKelvinExponents, cKilogramKelvinExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cKilogramKelvinPrefixes, cKilogramKelvinExponents, cKilogramKelvinExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramKelvinSymbol, cKilogramKelvinPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramKelvinSymbol, APrefixes);
end;

function KilogramKelvinToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramKelvin then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramKelvin then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramKelvinToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramKelvin then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function JoulePerKelvinToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerKelvin then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsJoulePerKelvinSymbol, cJoulePerKelvinPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsJoulePerKelvinSymbol, cJoulePerKelvinPrefixes);
{$ENDIF}
end;

function JoulePerKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerKelvin then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cJoulePerKelvinPrefixes, cJoulePerKelvinExponents, cJoulePerKelvinExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cJoulePerKelvinPrefixes, cJoulePerKelvinExponents, cJoulePerKelvinExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsJoulePerKelvinSymbol, cJoulePerKelvinPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsJoulePerKelvinSymbol, APrefixes);
end;

function JoulePerKelvinToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerKelvin then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function JoulePerKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerKelvin then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function JoulePerKelvinToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerKelvin then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function KilogramSquareMeterPerSquareSecondPerKelvinToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerKelvin then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramSquareMeterPerSquareSecondPerKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerKelvin then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cKilogramSquareMeterPerSquareSecondPerKelvinPrefixes, cKilogramSquareMeterPerSquareSecondPerKelvinExponents, cKilogramSquareMeterPerSquareSecondPerKelvinExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cKilogramSquareMeterPerSquareSecondPerKelvinPrefixes, cKilogramSquareMeterPerSquareSecondPerKelvinExponents, cKilogramSquareMeterPerSquareSecondPerKelvinExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramSquareMeterPerSquareSecondPerKelvinSymbol, cKilogramSquareMeterPerSquareSecondPerKelvinPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramSquareMeterPerSquareSecondPerKelvinSymbol, APrefixes);
end;

function KilogramSquareMeterPerSquareSecondPerKelvinToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerKelvin then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramSquareMeterPerSquareSecondPerKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerKelvin then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramSquareMeterPerSquareSecondPerKelvinToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerKelvin then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function JoulePerKilogramPerKelvinToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerKilogramPerKelvin then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsJoulePerKilogramPerKelvinSymbol, cJoulePerKilogramPerKelvinPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsJoulePerKilogramPerKelvinSymbol, cJoulePerKilogramPerKelvinPrefixes);
{$ENDIF}
end;

function JoulePerKilogramPerKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerKilogramPerKelvin then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cJoulePerKilogramPerKelvinPrefixes, cJoulePerKilogramPerKelvinExponents, cJoulePerKilogramPerKelvinExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cJoulePerKilogramPerKelvinPrefixes, cJoulePerKilogramPerKelvinExponents, cJoulePerKilogramPerKelvinExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsJoulePerKilogramPerKelvinSymbol, cJoulePerKilogramPerKelvinPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsJoulePerKilogramPerKelvinSymbol, APrefixes);
end;

function JoulePerKilogramPerKelvinToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerKilogramPerKelvin then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function JoulePerKilogramPerKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerKilogramPerKelvin then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function JoulePerKilogramPerKelvinToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerKilogramPerKelvin then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function SquareMeterPerSquareSecondPerKelvinToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerKilogramPerKelvin then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareMeterPerSquareSecondPerKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerKilogramPerKelvin then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSquareMeterPerSquareSecondPerKelvinPrefixes, cSquareMeterPerSquareSecondPerKelvinExponents, cSquareMeterPerSquareSecondPerKelvinExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSquareMeterPerSquareSecondPerKelvinPrefixes, cSquareMeterPerSquareSecondPerKelvinExponents, cSquareMeterPerSquareSecondPerKelvinExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareMeterPerSquareSecondPerKelvinSymbol, cSquareMeterPerSquareSecondPerKelvinPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareMeterPerSquareSecondPerKelvinSymbol, APrefixes);
end;

function SquareMeterPerSquareSecondPerKelvinToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerKilogramPerKelvin then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareMeterPerSquareSecondPerKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerKilogramPerKelvin then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareMeterPerSquareSecondPerKelvinToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerKilogramPerKelvin then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function MeterKelvinToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterKelvin then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsMeterKelvinSymbol, cMeterKelvinPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsMeterKelvinSymbol, cMeterKelvinPrefixes);
{$ENDIF}
end;

function MeterKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterKelvin then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cMeterKelvinPrefixes, cMeterKelvinExponents, cMeterKelvinExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cMeterKelvinPrefixes, cMeterKelvinExponents, cMeterKelvinExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterKelvinSymbol, cMeterKelvinPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterKelvinSymbol, APrefixes);
end;

function MeterKelvinToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterKelvin then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function MeterKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterKelvin then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function MeterKelvinToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterKelvin then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function KelvinPerMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKelvinPerMeter then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsKelvinPerMeterSymbol, cKelvinPerMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsKelvinPerMeterSymbol, cKelvinPerMeterPrefixes);
{$ENDIF}
end;

function KelvinPerMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKelvinPerMeter then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cKelvinPerMeterPrefixes, cKelvinPerMeterExponents, cKelvinPerMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cKelvinPerMeterPrefixes, cKelvinPerMeterExponents, cKelvinPerMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKelvinPerMeterSymbol, cKelvinPerMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKelvinPerMeterSymbol, APrefixes);
end;

function KelvinPerMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKelvinPerMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KelvinPerMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKelvinPerMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KelvinPerMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKelvinPerMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function WattPerMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerMeter then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsWattPerMeterSymbol, cWattPerMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsWattPerMeterSymbol, cWattPerMeterPrefixes);
{$ENDIF}
end;

function WattPerMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerMeter then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cWattPerMeterPrefixes, cWattPerMeterExponents, cWattPerMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cWattPerMeterPrefixes, cWattPerMeterExponents, cWattPerMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattPerMeterSymbol, cWattPerMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattPerMeterSymbol, APrefixes);
end;

function WattPerMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function WattPerMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function WattPerMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function KilogramMeterPerCubicSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramMeterPerCubicSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerMeter then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cKilogramMeterPerCubicSecondPrefixes, cKilogramMeterPerCubicSecondExponents, cKilogramMeterPerCubicSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cKilogramMeterPerCubicSecondPrefixes, cKilogramMeterPerCubicSecondExponents, cKilogramMeterPerCubicSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramMeterPerCubicSecondSymbol, cKilogramMeterPerCubicSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramMeterPerCubicSecondSymbol, APrefixes);
end;

function KilogramMeterPerCubicSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramMeterPerCubicSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramMeterPerCubicSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function WattPerSquareMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsWattPerSquareMeterSymbol, cWattPerSquareMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsWattPerSquareMeterSymbol, cWattPerSquareMeterPrefixes);
{$ENDIF}
end;

function WattPerSquareMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cWattPerSquareMeterPrefixes, cWattPerSquareMeterExponents, cWattPerSquareMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cWattPerSquareMeterPrefixes, cWattPerSquareMeterExponents, cWattPerSquareMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattPerSquareMeterSymbol, cWattPerSquareMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattPerSquareMeterSymbol, APrefixes);
end;

function WattPerSquareMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function WattPerSquareMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function WattPerSquareMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function KilogramPerCubicSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramPerCubicSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cKilogramPerCubicSecondPrefixes, cKilogramPerCubicSecondExponents, cKilogramPerCubicSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cKilogramPerCubicSecondPrefixes, cKilogramPerCubicSecondExponents, cKilogramPerCubicSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramPerCubicSecondSymbol, cKilogramPerCubicSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramPerCubicSecondSymbol, APrefixes);
end;

function KilogramPerCubicSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramPerCubicSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramPerCubicSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function WattPerCubicMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsWattPerCubicMeterSymbol, cWattPerCubicMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsWattPerCubicMeterSymbol, cWattPerCubicMeterPrefixes);
{$ENDIF}
end;

function WattPerCubicMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cWattPerCubicMeterPrefixes, cWattPerCubicMeterExponents, cWattPerCubicMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cWattPerCubicMeterPrefixes, cWattPerCubicMeterExponents, cWattPerCubicMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattPerCubicMeterSymbol, cWattPerCubicMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattPerCubicMeterSymbol, APrefixes);
end;

function WattPerCubicMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function WattPerCubicMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function WattPerCubicMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function WattPerKelvinToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerKelvin then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsWattPerKelvinSymbol, cWattPerKelvinPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsWattPerKelvinSymbol, cWattPerKelvinPrefixes);
{$ENDIF}
end;

function WattPerKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerKelvin then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cWattPerKelvinPrefixes, cWattPerKelvinExponents, cWattPerKelvinExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cWattPerKelvinPrefixes, cWattPerKelvinExponents, cWattPerKelvinExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattPerKelvinSymbol, cWattPerKelvinPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattPerKelvinSymbol, APrefixes);
end;

function WattPerKelvinToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerKelvin then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function WattPerKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerKelvin then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function WattPerKelvinToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerKelvin then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function KilogramSquareMeterPerCubicSecondPerKelvinToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerKelvin then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramSquareMeterPerCubicSecondPerKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerKelvin then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cKilogramSquareMeterPerCubicSecondPerKelvinPrefixes, cKilogramSquareMeterPerCubicSecondPerKelvinExponents, cKilogramSquareMeterPerCubicSecondPerKelvinExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cKilogramSquareMeterPerCubicSecondPerKelvinPrefixes, cKilogramSquareMeterPerCubicSecondPerKelvinExponents, cKilogramSquareMeterPerCubicSecondPerKelvinExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramSquareMeterPerCubicSecondPerKelvinSymbol, cKilogramSquareMeterPerCubicSecondPerKelvinPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramSquareMeterPerCubicSecondPerKelvinSymbol, APrefixes);
end;

function KilogramSquareMeterPerCubicSecondPerKelvinToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerKelvin then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramSquareMeterPerCubicSecondPerKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerKelvin then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramSquareMeterPerCubicSecondPerKelvinToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerKelvin then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function WattPerMeterPerKelvinToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerMeterPerKelvin then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsWattPerMeterPerKelvinSymbol, cWattPerMeterPerKelvinPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsWattPerMeterPerKelvinSymbol, cWattPerMeterPerKelvinPrefixes);
{$ENDIF}
end;

function WattPerMeterPerKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerMeterPerKelvin then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cWattPerMeterPerKelvinPrefixes, cWattPerMeterPerKelvinExponents, cWattPerMeterPerKelvinExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cWattPerMeterPerKelvinPrefixes, cWattPerMeterPerKelvinExponents, cWattPerMeterPerKelvinExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattPerMeterPerKelvinSymbol, cWattPerMeterPerKelvinPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattPerMeterPerKelvinSymbol, APrefixes);
end;

function WattPerMeterPerKelvinToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerMeterPerKelvin then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function WattPerMeterPerKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerMeterPerKelvin then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function WattPerMeterPerKelvinToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerMeterPerKelvin then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function KilogramMeterPerCubicSecondPerKelvinToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerMeterPerKelvin then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramMeterPerCubicSecondPerKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerMeterPerKelvin then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cKilogramMeterPerCubicSecondPerKelvinPrefixes, cKilogramMeterPerCubicSecondPerKelvinExponents, cKilogramMeterPerCubicSecondPerKelvinExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cKilogramMeterPerCubicSecondPerKelvinPrefixes, cKilogramMeterPerCubicSecondPerKelvinExponents, cKilogramMeterPerCubicSecondPerKelvinExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramMeterPerCubicSecondPerKelvinSymbol, cKilogramMeterPerCubicSecondPerKelvinPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramMeterPerCubicSecondPerKelvinSymbol, APrefixes);
end;

function KilogramMeterPerCubicSecondPerKelvinToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerMeterPerKelvin then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramMeterPerCubicSecondPerKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerMeterPerKelvin then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramMeterPerCubicSecondPerKelvinToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerMeterPerKelvin then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function KelvinPerWattToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKelvinPerWatt then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsKelvinPerWattSymbol, cKelvinPerWattPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsKelvinPerWattSymbol, cKelvinPerWattPrefixes);
{$ENDIF}
end;

function KelvinPerWattToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKelvinPerWatt then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cKelvinPerWattPrefixes, cKelvinPerWattExponents, cKelvinPerWattExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cKelvinPerWattPrefixes, cKelvinPerWattExponents, cKelvinPerWattExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKelvinPerWattSymbol, cKelvinPerWattPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKelvinPerWattSymbol, APrefixes);
end;

function KelvinPerWattToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKelvinPerWatt then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KelvinPerWattToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKelvinPerWatt then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KelvinPerWattToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKelvinPerWatt then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function MeterPerWattToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerWatt then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsMeterPerWattSymbol, cMeterPerWattPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsMeterPerWattSymbol, cMeterPerWattPrefixes);
{$ENDIF}
end;

function MeterPerWattToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerWatt then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cMeterPerWattPrefixes, cMeterPerWattExponents, cMeterPerWattExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cMeterPerWattPrefixes, cMeterPerWattExponents, cMeterPerWattExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterPerWattSymbol, cMeterPerWattPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterPerWattSymbol, APrefixes);
end;

function MeterPerWattToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerWatt then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function MeterPerWattToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerWatt then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function MeterPerWattToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerWatt then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function MeterKelvinPerWattToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterKelvinPerWatt then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsMeterKelvinPerWattSymbol, cMeterKelvinPerWattPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsMeterKelvinPerWattSymbol, cMeterKelvinPerWattPrefixes);
{$ENDIF}
end;

function MeterKelvinPerWattToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterKelvinPerWatt then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cMeterKelvinPerWattPrefixes, cMeterKelvinPerWattExponents, cMeterKelvinPerWattExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cMeterKelvinPerWattPrefixes, cMeterKelvinPerWattExponents, cMeterKelvinPerWattExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterKelvinPerWattSymbol, cMeterKelvinPerWattPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterKelvinPerWattSymbol, APrefixes);
end;

function MeterKelvinPerWattToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterKelvinPerWatt then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function MeterKelvinPerWattToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterKelvinPerWatt then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function MeterKelvinPerWattToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterKelvinPerWatt then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function SquareMeterKelvinToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterKelvin then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsSquareMeterKelvinSymbol, cSquareMeterKelvinPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsSquareMeterKelvinSymbol, cSquareMeterKelvinPrefixes);
{$ENDIF}
end;

function SquareMeterKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterKelvin then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSquareMeterKelvinPrefixes, cSquareMeterKelvinExponents, cSquareMeterKelvinExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSquareMeterKelvinPrefixes, cSquareMeterKelvinExponents, cSquareMeterKelvinExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareMeterKelvinSymbol, cSquareMeterKelvinPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareMeterKelvinSymbol, APrefixes);
end;

function SquareMeterKelvinToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterKelvin then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareMeterKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterKelvin then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareMeterKelvinToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterKelvin then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function WattPerSquareMeterPerKelvinToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSquareMeterPerKelvin then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsWattPerSquareMeterPerKelvinSymbol, cWattPerSquareMeterPerKelvinPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsWattPerSquareMeterPerKelvinSymbol, cWattPerSquareMeterPerKelvinPrefixes);
{$ENDIF}
end;

function WattPerSquareMeterPerKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSquareMeterPerKelvin then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cWattPerSquareMeterPerKelvinPrefixes, cWattPerSquareMeterPerKelvinExponents, cWattPerSquareMeterPerKelvinExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cWattPerSquareMeterPerKelvinPrefixes, cWattPerSquareMeterPerKelvinExponents, cWattPerSquareMeterPerKelvinExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattPerSquareMeterPerKelvinSymbol, cWattPerSquareMeterPerKelvinPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattPerSquareMeterPerKelvinSymbol, APrefixes);
end;

function WattPerSquareMeterPerKelvinToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSquareMeterPerKelvin then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function WattPerSquareMeterPerKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSquareMeterPerKelvin then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function WattPerSquareMeterPerKelvinToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSquareMeterPerKelvin then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function KilogramPerCubicSecondPerKelvinToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSquareMeterPerKelvin then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramPerCubicSecondPerKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSquareMeterPerKelvin then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cKilogramPerCubicSecondPerKelvinPrefixes, cKilogramPerCubicSecondPerKelvinExponents, cKilogramPerCubicSecondPerKelvinExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cKilogramPerCubicSecondPerKelvinPrefixes, cKilogramPerCubicSecondPerKelvinExponents, cKilogramPerCubicSecondPerKelvinExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramPerCubicSecondPerKelvinSymbol, cKilogramPerCubicSecondPerKelvinPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKilogramPerCubicSecondPerKelvinSymbol, APrefixes);
end;

function KilogramPerCubicSecondPerKelvinToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSquareMeterPerKelvin then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramPerCubicSecondPerKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSquareMeterPerKelvin then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KilogramPerCubicSecondPerKelvinToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSquareMeterPerKelvin then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function SquareMeterQuarticKelvinToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterQuarticKelvin then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsSquareMeterQuarticKelvinSymbol, cSquareMeterQuarticKelvinPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsSquareMeterQuarticKelvinSymbol, cSquareMeterQuarticKelvinPrefixes);
{$ENDIF}
end;

function SquareMeterQuarticKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterQuarticKelvin then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSquareMeterQuarticKelvinPrefixes, cSquareMeterQuarticKelvinExponents, cSquareMeterQuarticKelvinExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSquareMeterQuarticKelvinPrefixes, cSquareMeterQuarticKelvinExponents, cSquareMeterQuarticKelvinExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareMeterQuarticKelvinSymbol, cSquareMeterQuarticKelvinPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareMeterQuarticKelvinSymbol, APrefixes);
end;

function SquareMeterQuarticKelvinToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterQuarticKelvin then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareMeterQuarticKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterQuarticKelvin then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareMeterQuarticKelvinToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterQuarticKelvin then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function WattPerQuarticKelvinToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerQuarticKelvin then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsWattPerQuarticKelvinSymbol, cWattPerQuarticKelvinPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsWattPerQuarticKelvinSymbol, cWattPerQuarticKelvinPrefixes);
{$ENDIF}
end;

function WattPerQuarticKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerQuarticKelvin then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cWattPerQuarticKelvinPrefixes, cWattPerQuarticKelvinExponents, cWattPerQuarticKelvinExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cWattPerQuarticKelvinPrefixes, cWattPerQuarticKelvinExponents, cWattPerQuarticKelvinExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattPerQuarticKelvinSymbol, cWattPerQuarticKelvinPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattPerQuarticKelvinSymbol, APrefixes);
end;

function WattPerQuarticKelvinToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerQuarticKelvin then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function WattPerQuarticKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerQuarticKelvin then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function WattPerQuarticKelvinToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerQuarticKelvin then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function WattPerSquareMeterPerQuarticKelvinToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSquareMeterPerQuarticKelvin then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsWattPerSquareMeterPerQuarticKelvinSymbol, cWattPerSquareMeterPerQuarticKelvinPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsWattPerSquareMeterPerQuarticKelvinSymbol, cWattPerSquareMeterPerQuarticKelvinPrefixes);
{$ENDIF}
end;

function WattPerSquareMeterPerQuarticKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSquareMeterPerQuarticKelvin then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cWattPerSquareMeterPerQuarticKelvinPrefixes, cWattPerSquareMeterPerQuarticKelvinExponents, cWattPerSquareMeterPerQuarticKelvinExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cWattPerSquareMeterPerQuarticKelvinPrefixes, cWattPerSquareMeterPerQuarticKelvinExponents, cWattPerSquareMeterPerQuarticKelvinExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattPerSquareMeterPerQuarticKelvinSymbol, cWattPerSquareMeterPerQuarticKelvinPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattPerSquareMeterPerQuarticKelvinSymbol, APrefixes);
end;

function WattPerSquareMeterPerQuarticKelvinToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSquareMeterPerQuarticKelvin then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function WattPerSquareMeterPerQuarticKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSquareMeterPerQuarticKelvin then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function WattPerSquareMeterPerQuarticKelvinToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSquareMeterPerQuarticKelvin then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function JoulePerMoleToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerMole then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsJoulePerMoleSymbol, cJoulePerMolePrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsJoulePerMoleSymbol, cJoulePerMolePrefixes);
{$ENDIF}
end;

function JoulePerMoleToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerMole then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cJoulePerMolePrefixes, cJoulePerMoleExponents, cJoulePerMoleExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cJoulePerMolePrefixes, cJoulePerMoleExponents, cJoulePerMoleExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsJoulePerMoleSymbol, cJoulePerMolePrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsJoulePerMoleSymbol, APrefixes);
end;

function JoulePerMoleToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerMole then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function JoulePerMoleToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerMole then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function JoulePerMoleToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerMole then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function MoleKelvinToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMoleKelvin then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsMoleKelvinSymbol, cMoleKelvinPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsMoleKelvinSymbol, cMoleKelvinPrefixes);
{$ENDIF}
end;

function MoleKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMoleKelvin then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cMoleKelvinPrefixes, cMoleKelvinExponents, cMoleKelvinExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cMoleKelvinPrefixes, cMoleKelvinExponents, cMoleKelvinExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMoleKelvinSymbol, cMoleKelvinPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMoleKelvinSymbol, APrefixes);
end;

function MoleKelvinToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMoleKelvin then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function MoleKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMoleKelvin then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function MoleKelvinToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMoleKelvin then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function JoulePerMolePerKelvinToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerMolePerKelvin then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsJoulePerMolePerKelvinSymbol, cJoulePerMolePerKelvinPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsJoulePerMolePerKelvinSymbol, cJoulePerMolePerKelvinPrefixes);
{$ENDIF}
end;

function JoulePerMolePerKelvinToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerMolePerKelvin then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cJoulePerMolePerKelvinPrefixes, cJoulePerMolePerKelvinExponents, cJoulePerMolePerKelvinExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cJoulePerMolePerKelvinPrefixes, cJoulePerMolePerKelvinExponents, cJoulePerMolePerKelvinExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsJoulePerMolePerKelvinSymbol, cJoulePerMolePerKelvinPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsJoulePerMolePerKelvinSymbol, APrefixes);
end;

function JoulePerMolePerKelvinToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerMolePerKelvin then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function JoulePerMolePerKelvinToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerMolePerKelvin then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function JoulePerMolePerKelvinToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cJoulePerMolePerKelvin then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function OhmMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cOhmMeter then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsOhmMeterSymbol, cOhmMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsOhmMeterSymbol, cOhmMeterPrefixes);
{$ENDIF}
end;

function OhmMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cOhmMeter then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cOhmMeterPrefixes, cOhmMeterExponents, cOhmMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cOhmMeterPrefixes, cOhmMeterExponents, cOhmMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsOhmMeterSymbol, cOhmMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsOhmMeterSymbol, APrefixes);
end;

function OhmMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cOhmMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function OhmMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cOhmMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function OhmMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cOhmMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function VoltPerMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVoltPerMeter then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsVoltPerMeterSymbol, cVoltPerMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsVoltPerMeterSymbol, cVoltPerMeterPrefixes);
{$ENDIF}
end;

function VoltPerMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVoltPerMeter then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cVoltPerMeterPrefixes, cVoltPerMeterExponents, cVoltPerMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cVoltPerMeterPrefixes, cVoltPerMeterExponents, cVoltPerMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsVoltPerMeterSymbol, cVoltPerMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsVoltPerMeterSymbol, APrefixes);
end;

function VoltPerMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVoltPerMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function VoltPerMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVoltPerMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function VoltPerMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVoltPerMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function NewtonPerCoulombToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVoltPerMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function NewtonPerCoulombToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVoltPerMeter then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cNewtonPerCoulombPrefixes, cNewtonPerCoulombExponents, cNewtonPerCoulombExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cNewtonPerCoulombPrefixes, cNewtonPerCoulombExponents, cNewtonPerCoulombExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonPerCoulombSymbol, cNewtonPerCoulombPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonPerCoulombSymbol, APrefixes);
end;

function NewtonPerCoulombToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVoltPerMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function NewtonPerCoulombToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVoltPerMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function NewtonPerCoulombToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVoltPerMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function CoulombPerMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulombPerMeter then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsCoulombPerMeterSymbol, cCoulombPerMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsCoulombPerMeterSymbol, cCoulombPerMeterPrefixes);
{$ENDIF}
end;

function CoulombPerMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulombPerMeter then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cCoulombPerMeterPrefixes, cCoulombPerMeterExponents, cCoulombPerMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cCoulombPerMeterPrefixes, cCoulombPerMeterExponents, cCoulombPerMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCoulombPerMeterSymbol, cCoulombPerMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCoulombPerMeterSymbol, APrefixes);
end;

function CoulombPerMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulombPerMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function CoulombPerMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulombPerMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function CoulombPerMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulombPerMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function SquareCoulombPerMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareCoulombPerMeter then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsSquareCoulombPerMeterSymbol, cSquareCoulombPerMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsSquareCoulombPerMeterSymbol, cSquareCoulombPerMeterPrefixes);
{$ENDIF}
end;

function SquareCoulombPerMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareCoulombPerMeter then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSquareCoulombPerMeterPrefixes, cSquareCoulombPerMeterExponents, cSquareCoulombPerMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSquareCoulombPerMeterPrefixes, cSquareCoulombPerMeterExponents, cSquareCoulombPerMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareCoulombPerMeterSymbol, cSquareCoulombPerMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareCoulombPerMeterSymbol, APrefixes);
end;

function SquareCoulombPerMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareCoulombPerMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareCoulombPerMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareCoulombPerMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareCoulombPerMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareCoulombPerMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function CoulombPerSquareMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulombPerSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsCoulombPerSquareMeterSymbol, cCoulombPerSquareMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsCoulombPerSquareMeterSymbol, cCoulombPerSquareMeterPrefixes);
{$ENDIF}
end;

function CoulombPerSquareMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulombPerSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cCoulombPerSquareMeterPrefixes, cCoulombPerSquareMeterExponents, cCoulombPerSquareMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cCoulombPerSquareMeterPrefixes, cCoulombPerSquareMeterExponents, cCoulombPerSquareMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCoulombPerSquareMeterSymbol, cCoulombPerSquareMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCoulombPerSquareMeterSymbol, APrefixes);
end;

function CoulombPerSquareMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulombPerSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function CoulombPerSquareMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulombPerSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function CoulombPerSquareMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulombPerSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function SquareMeterPerSquareCoulombToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterPerSquareCoulomb then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsSquareMeterPerSquareCoulombSymbol, cSquareMeterPerSquareCoulombPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsSquareMeterPerSquareCoulombSymbol, cSquareMeterPerSquareCoulombPrefixes);
{$ENDIF}
end;

function SquareMeterPerSquareCoulombToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterPerSquareCoulomb then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSquareMeterPerSquareCoulombPrefixes, cSquareMeterPerSquareCoulombExponents, cSquareMeterPerSquareCoulombExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSquareMeterPerSquareCoulombPrefixes, cSquareMeterPerSquareCoulombExponents, cSquareMeterPerSquareCoulombExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareMeterPerSquareCoulombSymbol, cSquareMeterPerSquareCoulombPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareMeterPerSquareCoulombSymbol, APrefixes);
end;

function SquareMeterPerSquareCoulombToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterPerSquareCoulomb then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareMeterPerSquareCoulombToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterPerSquareCoulomb then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareMeterPerSquareCoulombToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterPerSquareCoulomb then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function NewtonPerSquareCoulombToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerSquareCoulomb then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsNewtonPerSquareCoulombSymbol, cNewtonPerSquareCoulombPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsNewtonPerSquareCoulombSymbol, cNewtonPerSquareCoulombPrefixes);
{$ENDIF}
end;

function NewtonPerSquareCoulombToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerSquareCoulomb then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cNewtonPerSquareCoulombPrefixes, cNewtonPerSquareCoulombExponents, cNewtonPerSquareCoulombExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cNewtonPerSquareCoulombPrefixes, cNewtonPerSquareCoulombExponents, cNewtonPerSquareCoulombExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonPerSquareCoulombSymbol, cNewtonPerSquareCoulombPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonPerSquareCoulombSymbol, APrefixes);
end;

function NewtonPerSquareCoulombToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerSquareCoulomb then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function NewtonPerSquareCoulombToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerSquareCoulomb then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function NewtonPerSquareCoulombToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonPerSquareCoulomb then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function NewtonSquareMeterPerSquareCoulombToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonSquareMeterPerSquareCoulomb then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsNewtonSquareMeterPerSquareCoulombSymbol, cNewtonSquareMeterPerSquareCoulombPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsNewtonSquareMeterPerSquareCoulombSymbol, cNewtonSquareMeterPerSquareCoulombPrefixes);
{$ENDIF}
end;

function NewtonSquareMeterPerSquareCoulombToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonSquareMeterPerSquareCoulomb then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cNewtonSquareMeterPerSquareCoulombPrefixes, cNewtonSquareMeterPerSquareCoulombExponents, cNewtonSquareMeterPerSquareCoulombExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cNewtonSquareMeterPerSquareCoulombPrefixes, cNewtonSquareMeterPerSquareCoulombExponents, cNewtonSquareMeterPerSquareCoulombExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonSquareMeterPerSquareCoulombSymbol, cNewtonSquareMeterPerSquareCoulombPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonSquareMeterPerSquareCoulombSymbol, APrefixes);
end;

function NewtonSquareMeterPerSquareCoulombToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonSquareMeterPerSquareCoulomb then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function NewtonSquareMeterPerSquareCoulombToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonSquareMeterPerSquareCoulomb then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function NewtonSquareMeterPerSquareCoulombToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cNewtonSquareMeterPerSquareCoulomb then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function VoltMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVoltMeter then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsVoltMeterSymbol, cVoltMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsVoltMeterSymbol, cVoltMeterPrefixes);
{$ENDIF}
end;

function VoltMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVoltMeter then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cVoltMeterPrefixes, cVoltMeterExponents, cVoltMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cVoltMeterPrefixes, cVoltMeterExponents, cVoltMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsVoltMeterSymbol, cVoltMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsVoltMeterSymbol, APrefixes);
end;

function VoltMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVoltMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function VoltMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVoltMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function VoltMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVoltMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function NewtonSquareMeterPerCoulombToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVoltMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function NewtonSquareMeterPerCoulombToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVoltMeter then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cNewtonSquareMeterPerCoulombPrefixes, cNewtonSquareMeterPerCoulombExponents, cNewtonSquareMeterPerCoulombExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cNewtonSquareMeterPerCoulombPrefixes, cNewtonSquareMeterPerCoulombExponents, cNewtonSquareMeterPerCoulombExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonSquareMeterPerCoulombSymbol, cNewtonSquareMeterPerCoulombPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonSquareMeterPerCoulombSymbol, APrefixes);
end;

function NewtonSquareMeterPerCoulombToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVoltMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function NewtonSquareMeterPerCoulombToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVoltMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function NewtonSquareMeterPerCoulombToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVoltMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function VoltMeterPerSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVoltMeterPerSecond then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsVoltMeterPerSecondSymbol, cVoltMeterPerSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsVoltMeterPerSecondSymbol, cVoltMeterPerSecondPrefixes);
{$ENDIF}
end;

function VoltMeterPerSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVoltMeterPerSecond then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cVoltMeterPerSecondPrefixes, cVoltMeterPerSecondExponents, cVoltMeterPerSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cVoltMeterPerSecondPrefixes, cVoltMeterPerSecondExponents, cVoltMeterPerSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsVoltMeterPerSecondSymbol, cVoltMeterPerSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsVoltMeterPerSecondSymbol, APrefixes);
end;

function VoltMeterPerSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVoltMeterPerSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function VoltMeterPerSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVoltMeterPerSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function VoltMeterPerSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cVoltMeterPerSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function FaradPerMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cFaradPerMeter then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsFaradPerMeterSymbol, cFaradPerMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsFaradPerMeterSymbol, cFaradPerMeterPrefixes);
{$ENDIF}
end;

function FaradPerMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cFaradPerMeter then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cFaradPerMeterPrefixes, cFaradPerMeterExponents, cFaradPerMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cFaradPerMeterPrefixes, cFaradPerMeterExponents, cFaradPerMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsFaradPerMeterSymbol, cFaradPerMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsFaradPerMeterSymbol, APrefixes);
end;

function FaradPerMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cFaradPerMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function FaradPerMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cFaradPerMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function FaradPerMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cFaradPerMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function AmperePerMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cAmperePerMeter then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsAmperePerMeterSymbol, cAmperePerMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsAmperePerMeterSymbol, cAmperePerMeterPrefixes);
{$ENDIF}
end;

function AmperePerMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cAmperePerMeter then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cAmperePerMeterPrefixes, cAmperePerMeterExponents, cAmperePerMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cAmperePerMeterPrefixes, cAmperePerMeterExponents, cAmperePerMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsAmperePerMeterSymbol, cAmperePerMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsAmperePerMeterSymbol, APrefixes);
end;

function AmperePerMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cAmperePerMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function AmperePerMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cAmperePerMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function AmperePerMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cAmperePerMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function MeterPerAmpereToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerAmpere then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsMeterPerAmpereSymbol, cMeterPerAmperePrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsMeterPerAmpereSymbol, cMeterPerAmperePrefixes);
{$ENDIF}
end;

function MeterPerAmpereToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerAmpere then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cMeterPerAmperePrefixes, cMeterPerAmpereExponents, cMeterPerAmpereExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cMeterPerAmperePrefixes, cMeterPerAmpereExponents, cMeterPerAmpereExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterPerAmpereSymbol, cMeterPerAmperePrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterPerAmpereSymbol, APrefixes);
end;

function MeterPerAmpereToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerAmpere then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function MeterPerAmpereToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerAmpere then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function MeterPerAmpereToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterPerAmpere then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function TeslaMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cTeslaMeter then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsTeslaMeterSymbol, cTeslaMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsTeslaMeterSymbol, cTeslaMeterPrefixes);
{$ENDIF}
end;

function TeslaMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cTeslaMeter then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cTeslaMeterPrefixes, cTeslaMeterExponents, cTeslaMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cTeslaMeterPrefixes, cTeslaMeterExponents, cTeslaMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsTeslaMeterSymbol, cTeslaMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsTeslaMeterSymbol, APrefixes);
end;

function TeslaMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cTeslaMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function TeslaMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cTeslaMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function TeslaMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cTeslaMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function NewtonPerAmpereToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cTeslaMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function NewtonPerAmpereToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cTeslaMeter then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cNewtonPerAmperePrefixes, cNewtonPerAmpereExponents, cNewtonPerAmpereExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cNewtonPerAmperePrefixes, cNewtonPerAmpereExponents, cNewtonPerAmpereExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonPerAmpereSymbol, cNewtonPerAmperePrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonPerAmpereSymbol, APrefixes);
end;

function NewtonPerAmpereToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cTeslaMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function NewtonPerAmpereToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cTeslaMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function NewtonPerAmpereToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cTeslaMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function TeslaPerAmpereToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cTeslaPerAmpere then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsTeslaPerAmpereSymbol, cTeslaPerAmperePrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsTeslaPerAmpereSymbol, cTeslaPerAmperePrefixes);
{$ENDIF}
end;

function TeslaPerAmpereToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cTeslaPerAmpere then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cTeslaPerAmperePrefixes, cTeslaPerAmpereExponents, cTeslaPerAmpereExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cTeslaPerAmperePrefixes, cTeslaPerAmpereExponents, cTeslaPerAmpereExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsTeslaPerAmpereSymbol, cTeslaPerAmperePrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsTeslaPerAmpereSymbol, APrefixes);
end;

function TeslaPerAmpereToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cTeslaPerAmpere then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function TeslaPerAmpereToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cTeslaPerAmpere then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function TeslaPerAmpereToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cTeslaPerAmpere then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function HenryPerMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHenryPerMeter then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsHenryPerMeterSymbol, cHenryPerMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsHenryPerMeterSymbol, cHenryPerMeterPrefixes);
{$ENDIF}
end;

function HenryPerMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHenryPerMeter then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cHenryPerMeterPrefixes, cHenryPerMeterExponents, cHenryPerMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cHenryPerMeterPrefixes, cHenryPerMeterExponents, cHenryPerMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsHenryPerMeterSymbol, cHenryPerMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsHenryPerMeterSymbol, APrefixes);
end;

function HenryPerMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHenryPerMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function HenryPerMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHenryPerMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function HenryPerMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHenryPerMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function TeslaMeterPerAmpereToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHenryPerMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function TeslaMeterPerAmpereToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHenryPerMeter then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cTeslaMeterPerAmperePrefixes, cTeslaMeterPerAmpereExponents, cTeslaMeterPerAmpereExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cTeslaMeterPerAmperePrefixes, cTeslaMeterPerAmpereExponents, cTeslaMeterPerAmpereExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsTeslaMeterPerAmpereSymbol, cTeslaMeterPerAmperePrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsTeslaMeterPerAmpereSymbol, APrefixes);
end;

function TeslaMeterPerAmpereToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHenryPerMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function TeslaMeterPerAmpereToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHenryPerMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function TeslaMeterPerAmpereToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHenryPerMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function NewtonPerSquareAmpereToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHenryPerMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function NewtonPerSquareAmpereToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHenryPerMeter then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cNewtonPerSquareAmperePrefixes, cNewtonPerSquareAmpereExponents, cNewtonPerSquareAmpereExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cNewtonPerSquareAmperePrefixes, cNewtonPerSquareAmpereExponents, cNewtonPerSquareAmpereExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonPerSquareAmpereSymbol, cNewtonPerSquareAmperePrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsNewtonPerSquareAmpereSymbol, APrefixes);
end;

function NewtonPerSquareAmpereToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHenryPerMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function NewtonPerSquareAmpereToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHenryPerMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function NewtonPerSquareAmpereToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cHenryPerMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function RadianPerMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cRadianPerMeter then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsRadianPerMeterSymbol, cRadianPerMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsRadianPerMeterSymbol, cRadianPerMeterPrefixes);
{$ENDIF}
end;

function RadianPerMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cRadianPerMeter then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cRadianPerMeterPrefixes, cRadianPerMeterExponents, cRadianPerMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cRadianPerMeterPrefixes, cRadianPerMeterExponents, cRadianPerMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsRadianPerMeterSymbol, cRadianPerMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsRadianPerMeterSymbol, APrefixes);
end;

function RadianPerMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cRadianPerMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function RadianPerMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cRadianPerMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function RadianPerMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cRadianPerMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function SquareKilogramPerSquareSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareKilogramPerSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsSquareKilogramPerSquareSecondSymbol, cSquareKilogramPerSquareSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsSquareKilogramPerSquareSecondSymbol, cSquareKilogramPerSquareSecondPrefixes);
{$ENDIF}
end;

function SquareKilogramPerSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareKilogramPerSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSquareKilogramPerSquareSecondPrefixes, cSquareKilogramPerSquareSecondExponents, cSquareKilogramPerSquareSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSquareKilogramPerSquareSecondPrefixes, cSquareKilogramPerSquareSecondExponents, cSquareKilogramPerSquareSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareKilogramPerSquareSecondSymbol, cSquareKilogramPerSquareSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareKilogramPerSquareSecondSymbol, APrefixes);
end;

function SquareKilogramPerSquareSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareKilogramPerSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareKilogramPerSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareKilogramPerSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareKilogramPerSquareSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareKilogramPerSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function SquareSecondPerSquareMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareSecondPerSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsSquareSecondPerSquareMeterSymbol, cSquareSecondPerSquareMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsSquareSecondPerSquareMeterSymbol, cSquareSecondPerSquareMeterPrefixes);
{$ENDIF}
end;

function SquareSecondPerSquareMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareSecondPerSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSquareSecondPerSquareMeterPrefixes, cSquareSecondPerSquareMeterExponents, cSquareSecondPerSquareMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSquareSecondPerSquareMeterPrefixes, cSquareSecondPerSquareMeterExponents, cSquareSecondPerSquareMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareSecondPerSquareMeterSymbol, cSquareSecondPerSquareMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareSecondPerSquareMeterSymbol, APrefixes);
end;

function SquareSecondPerSquareMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareSecondPerSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareSecondPerSquareMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareSecondPerSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareSecondPerSquareMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareSecondPerSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function SquareJouleToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareJoule then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsSquareJouleSymbol, cSquareJoulePrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsSquareJouleSymbol, cSquareJoulePrefixes);
{$ENDIF}
end;

function SquareJouleToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareJoule then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSquareJoulePrefixes, cSquareJouleExponents, cSquareJouleExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSquareJoulePrefixes, cSquareJouleExponents, cSquareJouleExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareJouleSymbol, cSquareJoulePrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareJouleSymbol, APrefixes);
end;

function SquareJouleToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareJoule then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareJouleToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareJoule then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareJouleToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareJoule then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function JouleSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareMeterPerSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function JouleSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareMeterPerSecond then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cJouleSecondPrefixes, cJouleSecondExponents, cJouleSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cJouleSecondPrefixes, cJouleSecondExponents, cJouleSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsJouleSecondSymbol, cJouleSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsJouleSecondSymbol, APrefixes);
end;

function JouleSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareMeterPerSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function JouleSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareMeterPerSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function JouleSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareMeterPerSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function JoulePerHertzToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareMeterPerSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function JoulePerHertzToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareMeterPerSecond then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cJoulePerHertzPrefixes, cJoulePerHertzExponents, cJoulePerHertzExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cJoulePerHertzPrefixes, cJoulePerHertzExponents, cJoulePerHertzExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsJoulePerHertzSymbol, cJoulePerHertzPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsJoulePerHertzSymbol, APrefixes);
end;

function JoulePerHertzToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareMeterPerSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function JoulePerHertzToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareMeterPerSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function JoulePerHertzToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareMeterPerSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function ElectronvoltSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareMeterPerSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function ElectronvoltSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareMeterPerSecond then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cElectronvoltSecondPrefixes, cElectronvoltSecondExponents, cElectronvoltSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cElectronvoltSecondPrefixes, cElectronvoltSecondExponents, cElectronvoltSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsElectronvoltSecondSymbol, cElectronvoltSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsElectronvoltSecondSymbol, APrefixes);
end;

function ElectronvoltSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareMeterPerSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function ElectronvoltSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareMeterPerSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function ElectronvoltSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareMeterPerSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function ElectronvoltMeterPerSpeedOfLightToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareMeterPerSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function ElectronvoltMeterPerSpeedOfLightToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareMeterPerSecond then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cElectronvoltMeterPerSpeedOfLightPrefixes, cElectronvoltMeterPerSpeedOfLightExponents, cElectronvoltMeterPerSpeedOfLightExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cElectronvoltMeterPerSpeedOfLightPrefixes, cElectronvoltMeterPerSpeedOfLightExponents, cElectronvoltMeterPerSpeedOfLightExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsElectronvoltMeterPerSpeedOfLightSymbol, cElectronvoltMeterPerSpeedOfLightPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsElectronvoltMeterPerSpeedOfLightSymbol, APrefixes);
end;

function ElectronvoltMeterPerSpeedOfLightToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareMeterPerSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function ElectronvoltMeterPerSpeedOfLightToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareMeterPerSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function ElectronvoltMeterPerSpeedOfLightToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKilogramSquareMeterPerSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function SquareJouleSquareSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareJouleSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsSquareJouleSquareSecondSymbol, cSquareJouleSquareSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsSquareJouleSquareSecondSymbol, cSquareJouleSquareSecondPrefixes);
{$ENDIF}
end;

function SquareJouleSquareSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareJouleSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSquareJouleSquareSecondPrefixes, cSquareJouleSquareSecondExponents, cSquareJouleSquareSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSquareJouleSquareSecondPrefixes, cSquareJouleSquareSecondExponents, cSquareJouleSquareSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareJouleSquareSecondSymbol, cSquareJouleSquareSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareJouleSquareSecondSymbol, APrefixes);
end;

function SquareJouleSquareSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareJouleSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareJouleSquareSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareJouleSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareJouleSquareSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareJouleSquareSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function CoulombPerKilogramToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulombPerKilogram then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsCoulombPerKilogramSymbol, cCoulombPerKilogramPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsCoulombPerKilogramSymbol, cCoulombPerKilogramPrefixes);
{$ENDIF}
end;

function CoulombPerKilogramToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulombPerKilogram then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cCoulombPerKilogramPrefixes, cCoulombPerKilogramExponents, cCoulombPerKilogramExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cCoulombPerKilogramPrefixes, cCoulombPerKilogramExponents, cCoulombPerKilogramExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCoulombPerKilogramSymbol, cCoulombPerKilogramPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCoulombPerKilogramSymbol, APrefixes);
end;

function CoulombPerKilogramToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulombPerKilogram then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function CoulombPerKilogramToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulombPerKilogram then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function CoulombPerKilogramToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulombPerKilogram then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function SquareMeterAmpereToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterAmpere then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsSquareMeterAmpereSymbol, cSquareMeterAmperePrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsSquareMeterAmpereSymbol, cSquareMeterAmperePrefixes);
{$ENDIF}
end;

function SquareMeterAmpereToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterAmpere then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSquareMeterAmperePrefixes, cSquareMeterAmpereExponents, cSquareMeterAmpereExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSquareMeterAmperePrefixes, cSquareMeterAmpereExponents, cSquareMeterAmpereExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareMeterAmpereSymbol, cSquareMeterAmperePrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareMeterAmpereSymbol, APrefixes);
end;

function SquareMeterAmpereToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterAmpere then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareMeterAmpereToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterAmpere then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareMeterAmpereToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterAmpere then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function JoulePerTeslaToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterAmpere then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function JoulePerTeslaToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterAmpere then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cJoulePerTeslaPrefixes, cJoulePerTeslaExponents, cJoulePerTeslaExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cJoulePerTeslaPrefixes, cJoulePerTeslaExponents, cJoulePerTeslaExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsJoulePerTeslaSymbol, cJoulePerTeslaPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsJoulePerTeslaSymbol, APrefixes);
end;

function JoulePerTeslaToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterAmpere then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function JoulePerTeslaToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterAmpere then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function JoulePerTeslaToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterAmpere then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function LumenPerWattToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLumenPerWatt then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsLumenPerWattSymbol, cLumenPerWattPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsLumenPerWattSymbol, cLumenPerWattPrefixes);
{$ENDIF}
end;

function LumenPerWattToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLumenPerWatt then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cLumenPerWattPrefixes, cLumenPerWattExponents, cLumenPerWattExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cLumenPerWattPrefixes, cLumenPerWattExponents, cLumenPerWattExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsLumenPerWattSymbol, cLumenPerWattPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsLumenPerWattSymbol, APrefixes);
end;

function LumenPerWattToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLumenPerWatt then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function LumenPerWattToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLumenPerWatt then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function LumenPerWattToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cLumenPerWatt then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function ReciprocalMoleToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalMole then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsReciprocalMoleSymbol, cReciprocalMolePrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsReciprocalMoleSymbol, cReciprocalMolePrefixes);
{$ENDIF}
end;

function ReciprocalMoleToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalMole then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cReciprocalMolePrefixes, cReciprocalMoleExponents, cReciprocalMoleExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cReciprocalMolePrefixes, cReciprocalMoleExponents, cReciprocalMoleExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsReciprocalMoleSymbol, cReciprocalMolePrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsReciprocalMoleSymbol, APrefixes);
end;

function ReciprocalMoleToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalMole then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function ReciprocalMoleToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalMole then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function ReciprocalMoleToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cReciprocalMole then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function AmperePerSquareMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cAmperePerSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsAmperePerSquareMeterSymbol, cAmperePerSquareMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsAmperePerSquareMeterSymbol, cAmperePerSquareMeterPrefixes);
{$ENDIF}
end;

function AmperePerSquareMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cAmperePerSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cAmperePerSquareMeterPrefixes, cAmperePerSquareMeterExponents, cAmperePerSquareMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cAmperePerSquareMeterPrefixes, cAmperePerSquareMeterExponents, cAmperePerSquareMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsAmperePerSquareMeterSymbol, cAmperePerSquareMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsAmperePerSquareMeterSymbol, APrefixes);
end;

function AmperePerSquareMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cAmperePerSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function AmperePerSquareMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cAmperePerSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function AmperePerSquareMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cAmperePerSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function MolePerCubicMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMolePerCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsMolePerCubicMeterSymbol, cMolePerCubicMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsMolePerCubicMeterSymbol, cMolePerCubicMeterPrefixes);
{$ENDIF}
end;

function MolePerCubicMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMolePerCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cMolePerCubicMeterPrefixes, cMolePerCubicMeterExponents, cMolePerCubicMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cMolePerCubicMeterPrefixes, cMolePerCubicMeterExponents, cMolePerCubicMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMolePerCubicMeterSymbol, cMolePerCubicMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMolePerCubicMeterSymbol, APrefixes);
end;

function MolePerCubicMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMolePerCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function MolePerCubicMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMolePerCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function MolePerCubicMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMolePerCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function CandelaPerSquareMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCandelaPerSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsCandelaPerSquareMeterSymbol, cCandelaPerSquareMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsCandelaPerSquareMeterSymbol, cCandelaPerSquareMeterPrefixes);
{$ENDIF}
end;

function CandelaPerSquareMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCandelaPerSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cCandelaPerSquareMeterPrefixes, cCandelaPerSquareMeterExponents, cCandelaPerSquareMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cCandelaPerSquareMeterPrefixes, cCandelaPerSquareMeterExponents, cCandelaPerSquareMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCandelaPerSquareMeterSymbol, cCandelaPerSquareMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCandelaPerSquareMeterSymbol, APrefixes);
end;

function CandelaPerSquareMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCandelaPerSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function CandelaPerSquareMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCandelaPerSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function CandelaPerSquareMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCandelaPerSquareMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function CoulombPerCubicMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulombPerCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsCoulombPerCubicMeterSymbol, cCoulombPerCubicMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsCoulombPerCubicMeterSymbol, cCoulombPerCubicMeterPrefixes);
{$ENDIF}
end;

function CoulombPerCubicMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulombPerCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cCoulombPerCubicMeterPrefixes, cCoulombPerCubicMeterExponents, cCoulombPerCubicMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cCoulombPerCubicMeterPrefixes, cCoulombPerCubicMeterExponents, cCoulombPerCubicMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCoulombPerCubicMeterSymbol, cCoulombPerCubicMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCoulombPerCubicMeterSymbol, APrefixes);
end;

function CoulombPerCubicMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulombPerCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function CoulombPerCubicMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulombPerCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function CoulombPerCubicMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulombPerCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function GrayPerSecondToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cGrayPerSecond then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsGrayPerSecondSymbol, cGrayPerSecondPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsGrayPerSecondSymbol, cGrayPerSecondPrefixes);
{$ENDIF}
end;

function GrayPerSecondToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cGrayPerSecond then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cGrayPerSecondPrefixes, cGrayPerSecondExponents, cGrayPerSecondExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cGrayPerSecondPrefixes, cGrayPerSecondExponents, cGrayPerSecondExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsGrayPerSecondSymbol, cGrayPerSecondPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsGrayPerSecondSymbol, APrefixes);
end;

function GrayPerSecondToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cGrayPerSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function GrayPerSecondToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cGrayPerSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function GrayPerSecondToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cGrayPerSecond then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function SteradianHertzToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSteradianHertz then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsSteradianHertzSymbol, cSteradianHertzPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsSteradianHertzSymbol, cSteradianHertzPrefixes);
{$ENDIF}
end;

function SteradianHertzToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSteradianHertz then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSteradianHertzPrefixes, cSteradianHertzExponents, cSteradianHertzExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSteradianHertzPrefixes, cSteradianHertzExponents, cSteradianHertzExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSteradianHertzSymbol, cSteradianHertzPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSteradianHertzSymbol, APrefixes);
end;

function SteradianHertzToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSteradianHertz then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SteradianHertzToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSteradianHertz then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SteradianHertzToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSteradianHertz then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function MeterSteradianToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterSteradian then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsMeterSteradianSymbol, cMeterSteradianPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsMeterSteradianSymbol, cMeterSteradianPrefixes);
{$ENDIF}
end;

function MeterSteradianToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterSteradian then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cMeterSteradianPrefixes, cMeterSteradianExponents, cMeterSteradianExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cMeterSteradianPrefixes, cMeterSteradianExponents, cMeterSteradianExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterSteradianSymbol, cMeterSteradianPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsMeterSteradianSymbol, APrefixes);
end;

function MeterSteradianToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterSteradian then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function MeterSteradianToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterSteradian then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function MeterSteradianToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cMeterSteradian then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function SquareMeterSteradianToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterSteradian then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsSquareMeterSteradianSymbol, cSquareMeterSteradianPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsSquareMeterSteradianSymbol, cSquareMeterSteradianPrefixes);
{$ENDIF}
end;

function SquareMeterSteradianToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterSteradian then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSquareMeterSteradianPrefixes, cSquareMeterSteradianExponents, cSquareMeterSteradianExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSquareMeterSteradianPrefixes, cSquareMeterSteradianExponents, cSquareMeterSteradianExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareMeterSteradianSymbol, cSquareMeterSteradianPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareMeterSteradianSymbol, APrefixes);
end;

function SquareMeterSteradianToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterSteradian then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareMeterSteradianToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterSteradian then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareMeterSteradianToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterSteradian then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function CubicMeterSteradianToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeterSteradian then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsCubicMeterSteradianSymbol, cCubicMeterSteradianPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsCubicMeterSteradianSymbol, cCubicMeterSteradianPrefixes);
{$ENDIF}
end;

function CubicMeterSteradianToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeterSteradian then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cCubicMeterSteradianPrefixes, cCubicMeterSteradianExponents, cCubicMeterSteradianExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cCubicMeterSteradianPrefixes, cCubicMeterSteradianExponents, cCubicMeterSteradianExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCubicMeterSteradianSymbol, cCubicMeterSteradianPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCubicMeterSteradianSymbol, APrefixes);
end;

function CubicMeterSteradianToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeterSteradian then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function CubicMeterSteradianToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeterSteradian then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function CubicMeterSteradianToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCubicMeterSteradian then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function SquareMeterSteradianHertzToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterSteradianHertz then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsSquareMeterSteradianHertzSymbol, cSquareMeterSteradianHertzPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsSquareMeterSteradianHertzSymbol, cSquareMeterSteradianHertzPrefixes);
{$ENDIF}
end;

function SquareMeterSteradianHertzToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterSteradianHertz then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cSquareMeterSteradianHertzPrefixes, cSquareMeterSteradianHertzExponents, cSquareMeterSteradianHertzExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cSquareMeterSteradianHertzPrefixes, cSquareMeterSteradianHertzExponents, cSquareMeterSteradianHertzExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareMeterSteradianHertzSymbol, cSquareMeterSteradianHertzPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsSquareMeterSteradianHertzSymbol, APrefixes);
end;

function SquareMeterSteradianHertzToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterSteradianHertz then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareMeterSteradianHertzToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterSteradianHertz then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function SquareMeterSteradianHertzToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cSquareMeterSteradianHertz then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function WattPerSteradianToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSteradian then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsWattPerSteradianSymbol, cWattPerSteradianPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsWattPerSteradianSymbol, cWattPerSteradianPrefixes);
{$ENDIF}
end;

function WattPerSteradianToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSteradian then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cWattPerSteradianPrefixes, cWattPerSteradianExponents, cWattPerSteradianExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cWattPerSteradianPrefixes, cWattPerSteradianExponents, cWattPerSteradianExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattPerSteradianSymbol, cWattPerSteradianPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattPerSteradianSymbol, APrefixes);
end;

function WattPerSteradianToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSteradian then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function WattPerSteradianToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSteradian then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function WattPerSteradianToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSteradian then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function WattPerSteradianPerHertzToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSteradianPerHertz then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsWattPerSteradianPerHertzSymbol, cWattPerSteradianPerHertzPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsWattPerSteradianPerHertzSymbol, cWattPerSteradianPerHertzPrefixes);
{$ENDIF}
end;

function WattPerSteradianPerHertzToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSteradianPerHertz then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cWattPerSteradianPerHertzPrefixes, cWattPerSteradianPerHertzExponents, cWattPerSteradianPerHertzExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cWattPerSteradianPerHertzPrefixes, cWattPerSteradianPerHertzExponents, cWattPerSteradianPerHertzExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattPerSteradianPerHertzSymbol, cWattPerSteradianPerHertzPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattPerSteradianPerHertzSymbol, APrefixes);
end;

function WattPerSteradianPerHertzToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSteradianPerHertz then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function WattPerSteradianPerHertzToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSteradianPerHertz then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function WattPerSteradianPerHertzToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSteradianPerHertz then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function WattPerMeterPerSteradianToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerMeterPerSteradian then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsWattPerMeterPerSteradianSymbol, cWattPerMeterPerSteradianPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsWattPerMeterPerSteradianSymbol, cWattPerMeterPerSteradianPrefixes);
{$ENDIF}
end;

function WattPerMeterPerSteradianToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerMeterPerSteradian then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cWattPerMeterPerSteradianPrefixes, cWattPerMeterPerSteradianExponents, cWattPerMeterPerSteradianExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cWattPerMeterPerSteradianPrefixes, cWattPerMeterPerSteradianExponents, cWattPerMeterPerSteradianExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattPerMeterPerSteradianSymbol, cWattPerMeterPerSteradianPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattPerMeterPerSteradianSymbol, APrefixes);
end;

function WattPerMeterPerSteradianToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerMeterPerSteradian then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function WattPerMeterPerSteradianToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerMeterPerSteradian then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function WattPerMeterPerSteradianToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerMeterPerSteradian then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function WattPerSquareMeterPerSteradianToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSquareMeterPerSteradian then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsWattPerSquareMeterPerSteradianSymbol, cWattPerSquareMeterPerSteradianPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsWattPerSquareMeterPerSteradianSymbol, cWattPerSquareMeterPerSteradianPrefixes);
{$ENDIF}
end;

function WattPerSquareMeterPerSteradianToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSquareMeterPerSteradian then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cWattPerSquareMeterPerSteradianPrefixes, cWattPerSquareMeterPerSteradianExponents, cWattPerSquareMeterPerSteradianExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cWattPerSquareMeterPerSteradianPrefixes, cWattPerSquareMeterPerSteradianExponents, cWattPerSquareMeterPerSteradianExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattPerSquareMeterPerSteradianSymbol, cWattPerSquareMeterPerSteradianPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattPerSquareMeterPerSteradianSymbol, APrefixes);
end;

function WattPerSquareMeterPerSteradianToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSquareMeterPerSteradian then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function WattPerSquareMeterPerSteradianToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSquareMeterPerSteradian then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function WattPerSquareMeterPerSteradianToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSquareMeterPerSteradian then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function WattPerCubicMeterPerSteradianToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerCubicMeterPerSteradian then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsWattPerCubicMeterPerSteradianSymbol, cWattPerCubicMeterPerSteradianPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsWattPerCubicMeterPerSteradianSymbol, cWattPerCubicMeterPerSteradianPrefixes);
{$ENDIF}
end;

function WattPerCubicMeterPerSteradianToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerCubicMeterPerSteradian then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cWattPerCubicMeterPerSteradianPrefixes, cWattPerCubicMeterPerSteradianExponents, cWattPerCubicMeterPerSteradianExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cWattPerCubicMeterPerSteradianPrefixes, cWattPerCubicMeterPerSteradianExponents, cWattPerCubicMeterPerSteradianExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattPerCubicMeterPerSteradianSymbol, cWattPerCubicMeterPerSteradianPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattPerCubicMeterPerSteradianSymbol, APrefixes);
end;

function WattPerCubicMeterPerSteradianToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerCubicMeterPerSteradian then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function WattPerCubicMeterPerSteradianToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerCubicMeterPerSteradian then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function WattPerCubicMeterPerSteradianToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerCubicMeterPerSteradian then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function WattPerSquareMeterPerSteradianPerHertzToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSquareMeterPerSteradianPerHertz then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsWattPerSquareMeterPerSteradianPerHertzSymbol, cWattPerSquareMeterPerSteradianPerHertzPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsWattPerSquareMeterPerSteradianPerHertzSymbol, cWattPerSquareMeterPerSteradianPerHertzPrefixes);
{$ENDIF}
end;

function WattPerSquareMeterPerSteradianPerHertzToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSquareMeterPerSteradianPerHertz then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cWattPerSquareMeterPerSteradianPerHertzPrefixes, cWattPerSquareMeterPerSteradianPerHertzExponents, cWattPerSquareMeterPerSteradianPerHertzExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cWattPerSquareMeterPerSteradianPerHertzPrefixes, cWattPerSquareMeterPerSteradianPerHertzExponents, cWattPerSquareMeterPerSteradianPerHertzExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattPerSquareMeterPerSteradianPerHertzSymbol, cWattPerSquareMeterPerSteradianPerHertzPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsWattPerSquareMeterPerSteradianPerHertzSymbol, APrefixes);
end;

function WattPerSquareMeterPerSteradianPerHertzToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSquareMeterPerSteradianPerHertz then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function WattPerSquareMeterPerSteradianPerHertzToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSquareMeterPerSteradianPerHertz then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function WattPerSquareMeterPerSteradianPerHertzToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cWattPerSquareMeterPerSteradianPerHertz then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function KatalPerCubicMeterToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKatalPerCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsKatalPerCubicMeterSymbol, cKatalPerCubicMeterPrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsKatalPerCubicMeterSymbol, cKatalPerCubicMeterPrefixes);
{$ENDIF}
end;

function KatalPerCubicMeterToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKatalPerCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cKatalPerCubicMeterPrefixes, cKatalPerCubicMeterExponents, cKatalPerCubicMeterExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cKatalPerCubicMeterPrefixes, cKatalPerCubicMeterExponents, cKatalPerCubicMeterExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKatalPerCubicMeterSymbol, cKatalPerCubicMeterPrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsKatalPerCubicMeterSymbol, APrefixes);
end;

function KatalPerCubicMeterToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKatalPerCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KatalPerCubicMeterToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKatalPerCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function KatalPerCubicMeterToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cKatalPerCubicMeter then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

function CoulombPerMoleToString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulombPerMole then;
    raise Exception.Create('Wrong units of measurements');
  result := FloatToStr(AValue.FValue) + ' ' + GetSymbol(rsCoulombPerMoleSymbol, cCoulombPerMolePrefixes);
{$ELSE}
  result := FloatToStr(AValue) + ' ' + GetSymbol(rsCoulombPerMoleSymbol, cCoulombPerMolePrefixes);
{$ENDIF}
end;

function CoulombPerMoleToString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
var
  FactoredValue: double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulombPerMole then;
    raise Exception.Create('Wrong units of measurements');
  FactoredValue := GetValue(AValue.FValue, APrefixes, cCoulombPerMolePrefixes, cCoulombPerMoleExponents, cCoulombPerMoleExponents);
{$ELSE}
  FactoredValue := GetValue(AValue, APrefixes, cCoulombPerMolePrefixes, cCoulombPerMoleExponents, cCoulombPerMoleExponents);
{$ENDIF}
  if Length(APrefixes) = 0 then
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCoulombPerMoleSymbol, cCoulombPerMolePrefixes)
  else
    result := FloatToStrF(FactoredValue, ffGeneral, APrecision, ADigits) + ' ' + GetSymbol(rsCoulombPerMoleSymbol, APrefixes);
end;

function CoulombPerMoleToVerboseString(const AValue: TQuantity): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulombPerMole then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function CoulombPerMoleToVerboseString(const AValue: TQuantity; APrecision, ADigits: longint; const APrefixes: TPrefixes): string;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulombPerMole then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := '';
end;

function CoulombPerMoleToFloat(const AValue: TQuantity): double;
begin
{$IFOPT D+}
  if AValue.FUnitOfMeasurement <> cCoulombPerMole then;
    raise Exception.Create('Wrong units of measurements');
{$ENDIF}
  result := 0;
end;

{ Helpers }

{ Power functions }

end.
